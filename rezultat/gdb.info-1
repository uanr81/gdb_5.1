This is gdb.info, produced by texi2any version 6.7 from gdb.texinfo.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* Gdb-ru: (gdb-ru).                  Отладчик GNU.
END-INFO-DIR-ENTRY

Этот файл описывает отладчик GNU GDB.

   'Отладка с помощью GDB: отладчик GNU уровня исходного кода', Восьмая
Редакция, Март 2000, для GDB версии 5.0.

   Copyright (C) 1988-2000 Free Software Foundation, Inc.
Перевод Copyright (C) 1999-2001 Дмитрий Сиваченко.  Под редакцией Олега
Тихонова.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: gdb.info,  Node: Top,  Next: Обзор,  Prev: (dir),  Up: (dir)

Отладка с помощью GDB
*********************

Этот файл описывает GDB, символьный отладчик GNU.

   Восьмая редакция, Март 2000, для GDB версии 5.0.

   Copyright (C) 1988-2000 Free Software Foundation, Inc.

* Menu:

* Обзор::                       Обзор GDB
* Пример сеанса::               Пример сеанса GDB

* Вызов::                       Вход и выход из GDB
* Команды::                     Команды GDB
* Выполнение::                  Выполнение программ под управлением GDB
* Остановка::                   Остановка и продолжение
* Стек::                        Исследование стека
* Исходные файлы::              Исследование исходных файлов
* Данные::                      Исследование данных

* Языки::                       Использование GDB с различными языками

* Символы::                     Исследование таблицы символов
* Изменения::                   Изменение выполнения
* Файлы GDB::                   Файлы GDB
* Отладочные цели::             Определение отладочной цели
* Конфигурации::                Информация о конфигурации
* Управление GDB::              Управление GDB
* Последовательности::          Фиксированные последовательности команд
* Emacs::                       Использование GDB под управлением GNU Emacs
* Примечания::                  Интерфейс примечаний GDB
* GDB/MI::                      Машинный интерфейс GDB

* Ошибки в GDB::                Отчеты об ошибках в GDB
* Редактирование командной строки::
                                Редактирование командной строки
* Интерактивное использование истории::
                                Интерактивное использование истории
* Форматирование документации:: Как отформатировать и распечатать
                                документацию по GDB
* Установка GDB::               Установка GDB
* Алфавитный указатель::        Алфавитный указатель


Обзор GDB

* Свободные программы::         Свободно распространяемые программы
* Выражение признательности::   Кто внес вклад в развитие GDB

Вход и выход из GDB

* Вызов GDB::
* Выход из GDB::
* Команды оболочки::

Вызов GDB

* Параметры файлов::
* Параметры режима::

Команды GDB

* Синтаксис команд::
* Завершение::
* Справка::

Выполнение программ под управлением GDB

* Компиляция::
* Начало выполнения::
* Аргументы::
* Среда::
* Рабочий каталог::
* Ввод-вывод::
* Присоединение::
* Уничтожение процесса::
* Нити::
* Процессы::

Остановка и продолжение исполнения

* Точки останова::
* Продолжение и пошаговое выполнение::
* Сигналы::
* Остановка нитей::

Точки останова, точки наблюдения и точки перехвата

* Установка точек останова::
* Установка точек наблюдения::
* Установка точек перехвата::
* Удаление точек останова::
* Отключение::
* Условия::
* Команды останова::
* Меню точки останова::
* Ошибки в точках останова::

Исследование стека

* Кадры::
* Цепочки вызовов::
* Выбор::
* Информация о кадре::

Исследование исходных файлов

* Вывод строк::
* Поиск::
* Пути для исходных файлов::
* Машинный код::

Исследование данных

* Выражения::
* Переменные::
* Массивы::
* Форматы вывода::
* Память::
* Автоматическое отображение::
* Параметры вывода::
* История значений::
* Вспомогательные переменные::
* Регистры::
* Вычисления с плавающей точкой::

Использование GDB с различными языками программирования

* Переход от одного языка к другому::
* Отображение языка::
* Проверка::
* Поддержка::

Переход от одного языка к другому

* Имена файлов::
* Установка рабочего языка::
* Автоматическое::

Проверка диапазона принадлежности типу

* Проверка типов::
* Проверка диапазона::

Поддерживаемые языки

* Си::
* Модула-2::
* Chill::

Си и Си++

* Операторы Си::
* Константы Си::
* Выражения Си++::
* Значения Си по умолчанию::
* Проверки в Си::
* Отладка Си::
* Отладка Си++::

Модула-2

* Операторы Модулы-2::
* Встроенные функции/процедуры::
* Константы Модулы-2::
* Установки по умолчанию М-2::
* Отклонения::
* Проверки Модулы-2::
* Область видимости в Модуле-2::
* GDB и Модула-2::

Chill

* Как отображаются режимы::
* Местоположения::
* Значения и операции с ними::
* Проверка диапазона и типов в Chill::
* Установки по умолчанию Chill::

Изменение выполнения

* Присваивание::
* Переходы::
* Подача сигналов::
* Возврат::
* Вызовы::
* Внесение изменений::

Файлы GDB

* Файлы::
* Ошибки с символами::

Определение отладочной цели

* Активные цели::
* Команды для целей::
* Порядок байтов::
* Удаленная отладка::
* Отображение объектов ядра::

Удаленная отладка

* Удаленный::

Удаленный последовательный протокол GDB

* Содержимое заглушки::
* Начальная загрузка::
* Сеанс отладки::
* Протокол::
* Сервер::
* NetWare::

Информация о конфигурации

* Чистая::
* Встроенная ОС::
* Встроенные процессоры::
* Архитектуры::

Чистая

* HP-UX::
* Информация о процессах SVR4::

Встроенные операционные системы

* VxWorks::

Использование GDB с VxWorks

* Соединение к VxWorks::
* Загрузка на VxWorks::
* Присоединение к VxWorks::

Встроенные процессоры

* Встроенный A29K::
* ARM::
* H8/300::
* H8/500::
* i960::
* M32R/D::
* M68K::
* M88K::
* Встроенный MIPS::
* PowerPC::
* PA::
* SH::
* Sparclet::
* Sparclite::
* ST2000::
* Z8000::

Встроенный AMD A29K

* A29K UDI::
* A29K EB29K::
* Коммуникации (EB29K)::
* gdb-EB29K::
* Удаленный журнал::

Hitachi H8/300

* Платы Hitachi::
* Hitachi ICE::
* Специально для Hitachi::

Intel i960

* Вызов Nindy::
* Параметры Nindy::
* Сброс Nindy::

Tsqware Sparclet

* Файл Sparclet::
* Соединение к Sparclet::
* Загрузка на Sparclet::
* Выполнение Sparclet::

Архитектуры

* A29K::
* Alpha::
* MIPS::

Управление GDB

* Приглашение::
* Редактирование::
* История::
* Размер экрана::
* Числа::
* Сообщения/предупреждения::
* Отладочный вывод::

Фиксированные последовательности команд

* Определяемые пользователем команды::
* Ловушки::
* Командные файлы::
* Вывод::

Сообщение об ошибках в GDB

* Критерий ошибки::
* Отчеты об ошибках::

Установка GDB

* Отдельный объектный каталог::
* Имена конфигураций::
* Ключи configure::



File: gdb.info,  Node: Обзор,  Next: Пример сеанса,  Up: Top

Обзор GDB
*********

Назначение отладчика, такого как GDB -- позволить вам увидеть, что
происходит "внутри" другой программы во время ее выполнения, или что
делала другая программа в момент краха.

   GDB может выполнять действия четырех основных типов (а также другие,
дополняющие эти основные), чтобы помочь вам выявить ошибку:

   * Начать выполнение вашей программы, задав все, что может повлиять на
     ее поведение.

   * Остановить вашу программу при указанных условиях.

   * Исследовать, что случилось, когда ваша программа остановилась.

   * Изменить вашу программу, чтобы вы могли поэкспериментировать с
     устранением эффектов одной ошибки и продолжить выявление других.

   Вы можете использовать GDB для отладки программ, написанных на Си и
Си++.  Для получения более подробной информации, смотрите *note
Поддерживаемые языки: Поддержка.  Для дополнительной информации,
смотрите *note Си и Си++: Си.

   GDB частично поддерживает языки Модула-2 и Chill.  Для получения
информации о Модуле-2, смотрите *note Модула-2: Модула-2.  Для получения
информации о Chill, см.  *note Chill::

   Отладка программ на Паскале, которые используют множества,
поддиапазоны, файловые переменные или вложенные функции, в настоящее
время не работает.  GDB не поддерживает ввод выражений, вывод значений,
и аналогичные возможности, использующие синтаксис Паскаля.

   GDB можно использовать для отладки программ, написанных на Фортране,
хотя может возникнуть необходимость ссылаться на некоторые переменные,
добавляя в конец имени знак подчеркивания.

* Menu:

* Свободные программы::         Свободно распространяемые программы
* Выражение признательности::   Кто внес вклад в развитие GDB


File: gdb.info,  Node: Свободные программы,  Next: Выражение признательности,  Up: Обзор

Свободно распространяемые программы
===================================

GDB -- "свободная программа", защищенная Универсальной Общественной
Лицензией GNU (GPL). GPL предоставляет вам свободу копировать или
изменять программу, но каждый человек, получая копию, также получает
свободу изменять эту копию (это означает, что у него должен быть доступ
к исходному коду), и свободу распространять последующие копии.  Обычные
компании, разрабатывающие программы, используют авторские права для
ограничения ваших свобод; Фонд Свободного Программного Обеспечения
использует GPL для сохранения этих свобод.

   Главное, Универсальная Общественная Лицензия -- это лицензия,
говорящая, что вы имеете эти свободы и что вы не можете их у кого-либо
отнять.


File: gdb.info,  Node: Выражение признательности,  Prev: Свободные программы,  Up: Обзор

Кто внес вклад в развитие GDB
=============================

Первоначальным автором GDB, как и многих других программ GNU, был Ричард
Столмен.  Многие другие люди внесли вклад в его разработку.  Этот раздел
пытается отдать должное основным участникам разработки.  Одним из
достоинств свободных программ является то, что каждый может внести свой
вклад в их развитие; к сожалению, мы не можем в действительности
поблагодарить здесь всех.  Файл 'ChangeLog' в поставке GDB представляет
детальнейший отчет.

   Изменения, сделанные задолго до версии 2.0, потеряны в тумане времен.

     _Оправдание:_ Дополнения к этому разделу особенно приветствуются.
     Если вы или ваши друзья (или враги, чтобы соблюдать справедливость)
     были незаслуженно пропущены в этом списке, мы будем рады добавить
     ваши имена!

   Особенно мы хотим сказать спасибо тем, кто присматривал за GDB между
основными выпусками, чтобы они не сочли свои многочисленные заслуги
оставленными без благодарности: Эндрю Кагни (выпуск 5.0); Джим Бленди
(выпуск 4.18); Джесон Моленда (выпуск 4.17); Стан Шебс (выпуск 4.14);
Фред Фиш (выпуски 4.16, 4.15, 4.13, 4.12, 4.11, 4.10, и 4.9); Сту
Гроссман и Джон Гилмор (выпуски 4.8, 4.7, 4.6, 4.5, и 4.4); Джон Гилмор
(выпуски 4.3, 4.2, 4.1, 4.0, и 3.9); Джим Кингдон (выпуски 3.5, 3.4, и
3.3) и Ренди Смит (выпуски 3.2, 3.1, и 3.0).

   Ричард Столмен, которому в различные времена помогали Петер ТерМаат,
Крис Хенсон и Ричард Млинарик, занимался выпусками до 2.8.

   Михаэль Тиманн является автором большей части поддержки GNU Си++ в
GDB, со значительным дополнительным вкладом от Пера Бозера.  Джеймс
Кларк написал дешифровщик(1) имен GNU Си++.  Ранняя работа по Си++ была
сделана Петером ТерМаатом (который также сделал много общей работы по
обновлению, приведшей к выпуску 3.0).

   Для исследования многих форматов объектных файлов GDB 4 использует
библиотеку подпрограмм BFD. BFD был совместным проектом Дэвида
В. Хенкел-Волласа, Рича Пиксли, Стива Чемберлена и Джона Гилмора.

   Дэвид Джонсон первоначально написал поддержку COFF; Пейс Виллисон
первоначально сделал поддержку инкапсулированного COFF.

   Брент Бенсон из Harris Computer Systems сделал поддержку DWARF2.

   Адам ДеБур и Брэндли Дэвис сделали поддержку ISI Optimum V. Пер
Бозер, Нобоюки Хикичи, и Алессандро Форин сделали поддержку MIPS.
Жан-Даниэль Фекет сделал поддержку Sun 386i.  Крис Хенсон улучшил
поддержку HP9000.  Нобоюки Хикичи и Томоюки Хаси сделали поддержку
Sony/News OS 3.  Дэвид Джонсон сделал поддержку Encore Umax.  Юрки
Куоппала сделал поддержку Altos 3068.  Джефф Ло сделал поддержку HP PA и
SOM. Кейс Паккард сделал поддержку NS32K. Доуг Ребсон сделал поддержку
Acorn Risc Machine.  Боб Раск сделал поддержку Harris Nighthawk CX-UX.
Крис Смит сделал поддержку Convex (и отладку программ на Фортране).
Джонатан Стоун сделал поддержку Pyramid.  Михаэль Тиманн сделал
поддержку SPARC. Тим Такер сделал поддержку для Gould NP1 и Gould
Powernode.  Пейс Виллисон сделал поддержку Intel 386.  Джей Восбург
сделал поддержку Symmetry.

   Андреас Шваб сделал поддержку M68K Linux.

   Рич Шаефер и Петер Шауер помогли реализовать поддержку разделяемых
библиотек SunOS.

   Джей Фенласон и Роланд МакГрес проверили совместимость GDB и GAS по
нескольким наборам машинных инструкций.

   Патрик Дювал, Тед Голдстейн, Викрам Кока и Гленн Инжел помогли
разработать удаленную отладку.  Корпорации Intel, Wind River Systems,
AMD и ARM сделали модули удаленной отладки для целей i960, VxWorks, A29K
UDI, и RDI соответственно.

   Брайан Фокс является автором библиотек Readline, предоставляющих
историю команд и возможность редактирования командной строки.

   Эндрю Бирс из SUNY Buffalo написал код для переключения языков,
поддержку Модулы-2, главу 'Языки' этого руководства.

   Фред Фиш написал большую часть поддержки Unix System Vr4.  Он также
улучшил поддержку завершения команд для поддержки перегруженных символов
Си++.

   Hitachi America, Ltd.  спонсировала поддержку для процессоров H8/300,
H8/500 и Super-H.

   NEC спонсировала поддержку процессоров v850, Vr4xxx и Vr5xxx.

   Mitsubishi спонсировала поддержку процессоров D10V, D30V и M32R/D.

   Toshiba спонсировала поддержку процессора TX39 Mips.

   Matsushita спонсировала поддержку процессоров MN10200 и MN10300.

   Fujitsu спонсировала поддержку процессоров SPARClite и FR30.

   Кунг Шу, Джефф Ло и Рик Слэдки добавили поддержку аппаратных точек
наблюдения.

   Михаэль Снайдер добавил поддержку точек трассировки.

   Сту Гроссман написал gdbserver.

   Джим Кингдон, Петер Шауер, Ян Тейлор и Сту Гроссман сделали почти
бесчисленное количество исправлений и улучшений во всем GDB.

   Следующие люди из Hewlett-Packard Company сделали поддержку
архитектуры PA-RISC 2.0, HP-UX 10.20, 10.30 и 11.0 (усеченный режим),
реализации нитей HP в ядре, компилятора HP aC++, и конечного интерфейса
пользователя: Бен Крепп, Ричард Тайтл, Джон Бишоп, Сюзан Макчиа, Кэси
Манн, Сэтиш Пай, Индиа Поул, Стив Рейраур и Елена Заннони.  Ким Хаас
предоставил специфичную для HP информацию для этого руководства.

   Cygnus Solutions спонсировала поддержку GDB и большую часть его
развития с 1991 года.  Среди инженеров Cygnus, работавших над GDB на
постоянной основе, Марк Александер, Джим Бленди, Пер Бозер, Кевин
Беттнер, Эдит Эпштейн, Крис Фейлор, Фред Фиш, Мартин Хант, Джим Ингам,
Джон Гилмор, Сту Гроссман, Кунг Шу, Джим Кингдон, Джон Мецлер, Фернандо
Нассер, Джеффри Ноер, Дон Перчик, Рич Пиксли, Зденек Радуч, Кейс Сейц,
Стан Шебс, Дэвид Тейлор и Елена Заннони.  Кроме того, Дейв Бролли, Ян
Кармихаэль, Стив Чемберлен, Ник Клифтон, Джэй Ти Конклин, Стен Кокс, Ди
Джей Делори, Ульрих Дреппер, Фрэнк Эйглер, Дуг Эванс, Син Фаган, Дэвид
Хенкель-Воллас, Ричард Хендерсон, Джефф Холком, Джефф Ло, Джим Лемке,
Том Лорд, Боб Мансон, Михаэль Мейсснер, Джейсон Меррилл, Кэтрин Мур, Дрю
Мосли, Кен Робурн, Гавин Ромиг-Кох, Роб Савой, Джейми Смит, Майк Стамп,
Ян Тейлор, Анжела Томас, Михаэль Тиманн, Том Тромей, Рон Унро, Джим
Вилсон и Дэвид Зун также внесли свой вклад в большей или меньшей
степени.

   ---------- Footnotes ----------

   (1) В Си++ и других объектно-ориентированных языках программирования,
у вас может быть несколько функций с одним именем, но с аргументами
разных типов.  Например:

     int add_two(int a, int b);
     double add_two(double a, double b);
     double add_two(double a, int b);

Компилятор генерирует код для вызова верной функции по заданным
аргументам.  Это называется "перегрузкой функций".

   Однако, компоновщик требует, чтобы все символы имели недвусмысленные
имена.  Поэтому компилятор _шифрует_ (от английского "mangle") имена
перегруженных функций так, чтобы они включали типы аргументов и
возвращаемые значения.  К примеру, приведенные выше функции могут быть
зашифрованы примерно так:

     add_two_Ret_int_int_int
     add_two_Ret_double_double_double
     add_two_Ret_double_double_int

(в действительности шифрованные имена выглядят безобразнее).  В
результате компоновщик может правильно обработать перегруженные функции.
_Дешифровщик_ (от английского "demangler") -- это программа (или
функция), которая выполняет обратную операцию: анализируя зашифрованные
имена, она выдает исходную сигнатуру функции.  Это необходимо, чтобы
отобразить то, что программист сможет понять и связать с исходным
текстом своей программы.  Для этого любому средству отладки,
поддерживающему Си++, обычно требуется дешифровщик.  (Прим. переводчика)


File: gdb.info,  Node: Пример сеанса,  Next: Вызов,  Prev: Обзор,  Up: Top

1 Пример сеанса GDB
*******************

Вы можете пользоваться этим руководством в свое удовольствие, чтобы
прочитать о GDB все.  Однако, достаточно небольшого количества команд,
чтобы начать пользоваться отладчиком.  Эта глава иллюстрирует эти
команды.

   В одной из предварительных версий программы GNU 'm4' (настраиваемый
макропроцессор), была допущена следующая ошибка: иногда, при замене
строк, определяющих кавычки, со значений по умолчанию, команды,
использовавшиеся для поиска одного макроопределения внутри другого,
прекращали работать.  В следующем коротком сеансе 'm4' мы определим
макрос 'foo', который раскрывается в '0000'; затем мы используем
встроенную процедуру 'm4' 'defn', чтобы определить точно такой же макрос
'bar'.  Однако, если мы изменим открывающую кавычку на '<QUOTE>', а
закрывающую на '<UNQUOTE>', та же самая процедура не сможет определить
новый синоним 'baz':

     $ cd gnu/m4
     $ ./m4
     define(foo,0000)

     foo
     0000
     define(bar,defn('foo'))

     bar
     0000
     changequote(<QUOTE>,<UNQUOTE>)

     define(baz,defn(<QUOTE>foo<UNQUOTE>))
     baz
     C-d
     m4: End of input: 0: fatal error: EOF in string(1)

Попытаемся с помощью GDB понять, что же происходит.

     $ gdb m4
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty"
      for details.

     GDB 5.0, Copyright 1999 Free Software Foundation, Inc...
     (gdb)

GDB читает только минимум символьных данных, достаточный для того, чтобы
знать, где в случае необходимости искать остальные; в результате первое
приглашение появляется очень быстро.  Теперь мы велим GDB использовать
меньшую чем обычно ширину экрана, чтобы примеры умещались на страницах
этого руководства.

     (gdb) set width 70

Нам необходимо увидеть, как работает встроенная процедура 'm4'
'changequote'.  Посмотрев исходный текст, мы знаем, что соответствующей
подпрограммой является 'm4_changequote', так что мы устанавливаем на ней
точку останова с помощью команды GDB 'break'.

     (gdb) break m4_changequote
     Breakpoint 1 at 0x62f4: file builtin.c, line 879.

Используя команду 'run', мы запускаем 'm4' под управлением GDB; до тех
пор, пока управление не достигло подпрограммы 'm4_changequote',
программа выполняется как обычно:

     (gdb) run
     Starting program: /work/Editorial/gdb/gnu/m4/m4
     define(foo,0000)

     foo
     0000

Чтобы активировать точку останова, мы вызываем 'changequote'.  GDB
приостанавливает выполнение 'm4', выводя на экран информацию о том
месте, где он остановился.

     changequote(<QUOTE>,<UNQUOTE>)

     Breakpoint 1, m4_changequote (argc=3, argv=0x33c70)
         at builtin.c:879
     879         if (bad_argc(TOKEN_DATA_TEXT(argv[0]),argc,1,3))

Теперь мы используем команду 'n' ('next'), чтобы продолжить выполнение
до следующей строки текущей функции.

     (gdb) n
     882         set_quotes((argc >= 2) ? TOKEN_DATA_TEXT(argv[1])\
      : nil,

'set_quotes' выглядит как нужная нам подпрограмма.  Мы можем войти в
нее, используя команду 's' ('step') вместо 'next'.  'step' переходит на
следующую исполняемую строку _любой_ подпрограммы, так что она входит в
'set_quotes'.

     (gdb) s
     set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     530         if (lquote != def_lquote)

Отображение, показывающее подпрограмму (и ее параметры), где 'm4' сейчас
приостановлен, называется отображением кадра стека.  Оно показывает
обзор стека.  Мы можем использовать команду 'backtrace' (которую можно
сокращать как 'bt'), чтобы посмотреть, в каком месте стека мы находимся:
команда 'backtrace' выводит кадр стека для каждой активной подпрограммы.

     (gdb) bt
     #0  set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     #1  0x6344 in m4_changequote (argc=3, argv=0x33c70)
         at builtin.c:882
     #2  0x8174 in expand_macro (sym=0x33320) at macro.c:242
     #3  0x7a88 in expand_token (obs=0x0, t=209696, td=0xf7fffa30)
         at macro.c:71
     #4  0x79dc in expand_input () at macro.c:40
     #5  0x2930 in main (argc=0, argv=0xf7fffb20) at m4.c:195

Пройдем по шагам еще несколько строк, чтобы понять, что же происходит.
Первые два раза мы можем использовать 's'; следующие два раза мы
пользуемся командой 'n', чтобы избежать вхождения в подпрограмму
'xstrdup'.

     (gdb) s
     0x3b5c  532         if (rquote != def_rquote)
     (gdb) s
     0x3b80  535         lquote = (lq == nil || *lq == '\0') ?  \
     def_lquote : xstrdup(lq);
     (gdb) n
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup(rq);
     (gdb) n
     538         len_lquote = strlen(rquote);

Последняя выведенная строка выглядит несколько странно; мы можем
исследовать переменные 'lquote' и 'rquote', чтобы понять, действительно
ли это определенные нами новые левая и правая кавычки.  Мы используем
команду 'p' ('print'), чтобы посмотреть их значения.

     (gdb) p lquote
     $1 = 0x35d40 "<QUOTE>"
     (gdb) p rquote
     $2 = 0x35d50 "<UNQUOTE>"

Действительно, 'lquote' и 'rquote' являются новыми кавычками.  Для
просмотра контекста, мы можем вывести десять строк исходного текста,
окружающих текущую строку, используя команду 'l' ('list').

     (gdb) l
     533             xfree(rquote);
     534
     535         lquote = (lq == nil || *lq == '\0') ? def_lquote\
      : xstrdup (lq);
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup (rq);
     537
     538         len_lquote = strlen(rquote);
     539         len_rquote = strlen(lquote);
     540     }
     541
     542     void

   Давайте пройдем еще две строки, которые устанавливают 'len_lquote' и
'len_rquote', и затем исследуем значения этих переменных.

     (gdb) n
     539         len_rquote = strlen(lquote);
     (gdb) n
     540     }
     (gdb) p len_lquote
     $3 = 9
     (gdb) p len_rquote
     $4 = 7

Это, очевидно, неправильно, так как 'len_lquote' и 'len_rquote'
обозначают длины переменных 'lquote' и 'rquote' соответственно.  Мы
можем присвоить им лучшие значения, используя команду 'p', так как она
может выводить значение любого выражения, а выражение может содержать
вызовы подпрограмм и присваивания.

     (gdb) p len_lquote=strlen(lquote)
     $5 = 7
     (gdb) p len_rquote=strlen(rquote)
     $6 = 9

Достаточно ли этого, чтобы решить проблему использования новых кавычек
во встроенной процедуре 'm4' 'defn'?  Мы можем продолжить выполнение
'm4' командой 'c' ('continue'), и затем попробовать пример,
первоначально вызывавший ошибку:

     (gdb) c
     Continuing.

     define(baz,defn(<QUOTE>foo<UNQUOTE>))

     baz
     0000

Получилось!  Теперь новые кавычки работают так же хорошо, как и
стандартные.  Кажется, проблема заключалась лишь в двух опечатках,
приводивших к неправильному определению длин.  Мы позволим 'm4' выйти,
подавая ему на вход EOF:

     C-d
     Program exited normally.(2)

Сообщение 'Program exited normally.' исходит от GDB; оно показывает, что
'm4' закончила выполнение.  Мы можем завершить наш сеанс работы с GDB
командой 'quit'.

     (gdb) quit

   ---------- Footnotes ----------

   (1) m4: Конец ввода: 0: фатальная ошибка: EOF в строке (Прим.
переводчика)

   (2) Программа завершилась нормально.  (Прим. переводчика)


File: gdb.info,  Node: Вызов,  Next: Команды,  Prev: Пример сеанса,  Up: Top

2 Вход и выход из GDB
*********************

Эта глава посвящена тому, как запустить GDB и как из него выйти.
Основные принципы:
   * введите 'gdb' для вызова GDB.
   * введите 'quit' или 'C-d' для выхода из него.

* Menu:

* Вызов GDB::                   Как начать работу с GDB
* Выход из GDB::                Как выйти из GDB
* Команды оболочки::            Как использовать команды оболочки из GDB


File: gdb.info,  Node: Вызов GDB,  Next: Выход из GDB,  Up: Вызов

2.1 Вызов GDB
=============

Вызывайте GDB путем запуска программы 'gdb'.  Начав работу, GDB
считывает команды с терминала до тех пор, пока вы не скажете ему выйти.

   Вы также можете запустить 'gdb' с различными аргументами и ключами,
чтобы с самого начала более детально задать среду отладки.

   Ключи командной строки, описанные здесь, предназначены для охвата
различных ситуаций; в действительности, в некоторых средах часть этих
ключей может быть недоступна.

   Чаще всего GDB вызывается с одним аргументом, который определяет
исполняемую программу:

     gdb ПРОГРАММА

Вы также можете указать при старте как исполняемую программу, так и файл
дампа памяти:

     gdb ПРОГРАММА ДАМП

   Если вы хотите отладить выполняющийся в данный момент процесс, то
вместо этого, вы можете указать вторым аргументом идентификатор этого
процесса:

     gdb ПРОГРАММА 1234

присоединит GDB к процессу '1234' (если, конечно, у вас нет файла с
именем '1234', GDB сначала проверяет наличие файла дампа памяти).

   Преимущества, которые можно получить при использовании второго
аргумента командной строки, требуют наличия достаточно полной
операционной системы; если вы используете GDB как удаленный отладчик,
присоединенный к компьютеру без операционной системы, там вообще может
не быть понятия "процесса", и часто нет никакого способа получить дамп.
GDB предупредит вас, если ему не удается присоединиться к процессу или
считать файл дампа памяти.

   Вы можете запустить 'gdb' без вывода начального сообщения,
описывающего отсутствие гарантии, задав ключ '-silent':

     gdb -silent

Кроме того, вы можете контролировать процесс запуска GDB с помощью
ключей командной строки.  GDB может сам напомнить вам о доступных
ключах.

Введите

     gdb -help

чтобы вывести на экран все доступные ключи с кратким описанием их
использования (сокращенный эквивалент -- 'gdb -h').

   Все заданные вами ключи и параметры командной строки обрабатываются
последовательно.  Порядок становится важным при использовании ключа
'-x'.

* Menu:

* Параметры файлов::            Выбор файлов
* Параметры режима::            Выбор режимов


File: gdb.info,  Node: Параметры файлов,  Next: Параметры режима,  Up: Вызов GDB

2.1.1 Выбор файлов
------------------

При запуске, GDB считывает параметры, отличные от ключей, как указатели
на исполняемую программу и файл дампа (или идентификатор процесса),
точно так же, как если бы эти параметры задавались ключами '-se' и '-c'
соответственно.  (GDB считает первый параметр, не имеющий
соответствующего флага ключа, эквивалентом ключа '-se', за которым
следует этот параметр; а второй такой параметр, если он есть, --
эквивалентом ключа '-c', за которым следует этот параметр.)

   Если GDB был сконфигурирован без включения поддержки файлов дампа,
что имеет место для большинства встроенных целей, то он выразит
недовольство вторым аргументом и проигнорирует его.

   Многие ключи имеют как длинную, так и краткую формы; в следующем
списке приводятся обе.  GDB также распознает недвусмысленные сокращения
длинных форм.  (Вы можете, по желанию, обозначать ключи с помощью '--',
а не '-', хотя мы показываем наиболее употребляемый формат.)

'-symbols ФАЙЛ'
'-s ФАЙЛ'
     Читать таблицу символов из файла ФАЙЛ.

'-exec ФАЙЛ'
'-e ФАЙЛ'
     Использовать ФАЙЛ как исполняемый для выполнения и исследования
     данных вместе с дампом памяти, когда это необходимо.

'-se ФАЙЛ'
     Читать таблицу символов из файла ФАЙЛ и использовать его как
     исполняемый файл.

'-core ФАЙЛ'
'-c ФАЙЛ'
     Использовать ФАЙЛ как дамп памяти для исследования.

'-c НОМЕР'
     Присоединиться к процессу с идентификатором НОМЕР, также, как по
     команде 'attach' (при условии, что нет файла в формате дампа памяти
     с именем НОМЕР; в этом случае '-c' определяет этот файл как дамп
     для считывания).

'-command ФАЙЛ'
'-x ФАЙЛ'
     Выполнить команды GDB из файла ФАЙЛ.  *Note Командные файлы:
     Командные файлы.

'-directory КАТАЛОГ'
'-d КАТАЛОГ'
     Добавить КАТАЛОГ к путям поиска файлов с исходными текстами.

'-m'
'-mapped'
     _Предупреждение: этот ключ зависит от возможностей операционной
     системы, которые реализованы не везде._
     Если отображаемые в память файлы поддерживаются в вашей системе
     через системный вызов 'mmap', вы можете использовать этот ключ,
     чтобы GDB записывал символы из вашей программы в файл в текущем
     каталоге, допускающий повторное использование.  Если программа,
     которую вы отлаживаете, называется '/tmp/fred', то отображаемым
     символьным файлом будет '/tmp/fred.syms'.  Последующие отладочные
     сеансы GDB замечают наличие этого файла и могут быстро отобразить в
     память символьную информацию из него, а не читать таблицу символов
     из выполняемого файла.

     Файл '.syms' специфичен для рабочей машины, на которой запускается
     GDB. Он содержит точный образ внутренней символьной таблицы GDB. Он
     не может быть разделен между несколькими рабочими платформами.

'-r'
'-readnow'
     Читать символьную таблицу каждого файла, содержащего таблицу
     символов, сразу целиком, а не стандартным образом, при котором она
     считывается постепенно по мере необходимости.  Эта команда
     замедляет запуск, но дальнейшие операции производятся быстрее.

   Ключи '-mapped' и '-readnow' обычно используются вместе, чтобы
построить файл '.syms', который содержит полную информацию о символах.
(*Note Команды для задания файлов: Файлы, для информации о файлах
'.syms'.)  Вот простой вызов GDB, не делающий ничего, кроме построения
файла '.syms' для использования в будущем:

     gdb -batch -nx -mapped -readnow имя-программы


File: gdb.info,  Node: Параметры режима,  Prev: Параметры файлов,  Up: Вызов GDB

2.1.2 Выбор режимов
-------------------

Вы можете вызывать GDB в различных альтернативных режимах -- например, в
пакетном или в "тихом" режиме.

'-nx'
'-n'
     Не выполнять команды ни из каких файлов инициализации (обычно
     называемых '.gdbinit', или 'gdb.ini' на PC). В нормальном режиме,
     GDB выполняет команды из этих файлов после обработки всех командных
     ключей и параметров.  *Note Командные файлы: Командные файлы.

'-quiet'
'-silent'
'-q'
     "Тихий".  Не печатать вводное сообщение и информацию об авторских
     правах.  Эти сообщения также подавляются в пакетном режиме.

'-batch'
     Выполняться в пакетном режиме.  Выйти со значением '0' после
     обработки всех командных файлов, заданных ключом '-x' (и всех
     команд из инициализационных файлов, если это не запрещено ключом
     '-n').  Выйти с ненулевым значением, если во время выполнения
     команд GDB из командных файлов произойдет ошибка.

     Пакетный режим может быть полезен при вызове GDB как фильтра;
     например, чтобы загрузить программу и запустить ее на другом
     компьютере; чтобы это было более удобно, сообщение

          Program exited normally.

     (которое обычно выдается при завершении программы, выполняемой под
     управлением GDB) при выполнении в пакетном режиме не выдается.

'-nowindows'
'-nw'
     "Без окон".  Если GDB имеет встроенный графический интерфейс
     пользователя (GUI), то этот ключ велит GDB использовать только
     интерфейс командной строки.  Если GUI недоступен, этот ключ не
     оказывает никакого действия.

'-windows'
'-w'
     Если GDB включает GUI, этот ключ требует использовать его, если
     только возможно.

'-cd КАТАЛОГ'
     Запустить GDB, используя в качестве рабочего каталога КАТАЛОГ,
     вместо текущего.

'-fullname'
'-f'
     GNU Emacs устанавливает этот ключ, когда вызывает GDB как
     подпроцесс.  Это велит GDB выводить полное имя файла и номер строки
     в стандартном, распознаваемом стиле всякий раз, когда отображается
     кадр стека (что включает каждую остановку вашей программы).  Этот
     распознаваемый формат выглядит как два знака '\032', за которыми
     следует имя файла, номер строки и символьная позиция, разделенные
     двоеточиями, и знак новой строки.  Программа интерфейса Emacs-GDB
     использует два знака '\032' как сигнал для отображения исходного
     текста для кадра.

'-epoch'
     Интерфейс Epoch Emacs-GDB устанавливает этот ключ, когда вызывает
     GDB как подпроцесс.  Это велит GDB изменить свои подпрограммы
     печати так, чтобы позволить Epoch отображать значения выражений в
     отдельном окне.

'-annotate УРОВЕНЬ'
     Этот ключ устанавливает "уровень примечаний" внутри GDB. Его эффект
     аналогичен использованию 'set annotate УРОВЕНЬ' (*note
     Примечания::).  Уровень примечаний контролирует, какое количество
     информации GDB выводит вместе с приглашением, значениями выражений,
     строками исходного текста и другими типами вывода.  Уровень 0
     является обычным, уровень 1 используется, когда GDB выполняется как
     подпроцесс GNU Emacs, уровень 2 выводит максимальное количество
     примечаний и подходит для программ, которые управляют GDB.

'-async'
     Использовать асинхронный цикл событий для интерфейса командной
     строки.  GDB обрабатывает все события, такие как ввод пользователя
     с клавиатуры, через специальный цикл событий.  Это позволяет GDB
     принимать и обрабатывать команды пользователя параллельно с
     выполнением отлаживаемого процесса(1), так что вы не должны ждать
     возвращения управления GDB, прежде чем ввести следующую команду.
     (_Замечание:_ в версии 5.0, асинхронное выполнение на целевой
     системе еще не поддерживается, так что режим '-async' еще не
     полностью реализован.)

     Когда стандартный ввод соединен с терминальным устройством, GDB по
     умолчанию использует асинхронный цикл событий, если это не
     отключено ключом '-noasync'.

'-noasync'
     Отключить асинхронный цикл событий для интерфейса командной строки.

'-baud БОД-В-СЕК'
'-b БОД-В-СЕК'
     Устанавливает скорость линии (скорость в бодах, или в битах в
     секунду) любого последовательного интерфейса, используемого GDB для
     удаленной отладки.

'-tty УСТРОЙСТВО'
'-t УСТРОЙСТВО'
     Запуститься, используя УСТРОЙСТВО для стандартного ввода и вывода
     вашей программы.

'-interpreter ИНТЕРП'
     Использовать интерпретатор ИНТЕРП к качестве интерфейса с
     управляющей программой или устройством.  Подразумевается, что этот
     ключ должен устанавливаться программами, которые взаимодействуют с
     GDB, используя его как выходной буфер.  Например,
     '--interpreter=mi' велит GDB использовать "интерфейс gdbmi" (*note
     Интерфейс GDB/MI: GDB/MI.).

'-write'
     Открыть выполняемый файл и файл дампа памяти как для чтения, так и
     для записи.  Это эквивалентно команде GDB 'set write on' (*note
     Внесение изменений::).

'-statistics'
     Этот ключ велит GDB печатать статистику о времени и использовании
     памяти после завершения каждой команды и возврата к приглашению.

'-version'
     Этот ключ велит GDB напечатать номер своей версии и объявление об
     отсутствии гарантий и затем завершиться.

   ---------- Footnotes ----------

   (1) GDB, собранный средствами DJGPP для MS-DOS/MS-Windows,
поддерживает этот режим функционирования, но цикл событий
приостанавливается, когда выполняется отлаживаемая программа.


File: gdb.info,  Node: Выход из GDB,  Next: Команды оболочки,  Prev: Вызов GDB,  Up: Вызов

2.2 Выход из GDB
================

'quit [ВЫРАЖЕНИЕ]'
'q'
     Чтобы выйти из GDB, используйте команду 'quit' (сокращенно 'q') или
     введите знак конца файла (обычно 'C-d').  Если вы не укажете
     ВЫРАЖЕНИЕ, GDB закончит работу нормально; в противном случае, он
     использует результат ВЫРАЖЕНИЯ как код ошибки.

   Прерывание (часто 'C-c') не приводит к выходу из GDB, а завершает
любую выполняющуюся команду и возвращает вас на командный уровень.  Вы
можете безопасно пользоваться прерыванием в любое время, потому что GDB
не позволяет ему вступить в силу до того, как это станет безопасным.

   Если вы использовали GDB для управления присоединенным процессом или
устройством, вы можете освободить его командой 'detach' (*note Отладка
запущенного ранее процесса: Присоединение.).


File: gdb.info,  Node: Команды оболочки,  Prev: Выход из GDB,  Up: Вызов

2.3 Команды оболочки
====================

Если вам потребовалось выполнить команды оболочки во время сеанса
отладки, нет смысла приостанавливать или покидать GDB; вам достаточно
воспользоваться командой 'shell'.

'shell КОМАНДНАЯ СТРОКА'
     Вызвать стандартную оболочку для выполнения КОМАНДНОЙ СТРОКИ.
     Переменная среды 'SHELL', если она существует, определяет, какую
     оболочку запустить.  В противном случае, GDB использует оболочку по
     умолчанию ('/bin/sh' в системах Unix, 'COMMAND.COM' в MS-DOS, и так
     далее).

   В средах разработки часто бывает необходимо воспользоваться утилитой
'make'.  Для этой цели вам не обязательно пользоваться командой 'shell'
в GDB:

'make MAKE-АРГ'
     Выполнить программу 'make' с указанными аргументами.  Это
     эквивалентно 'shell make MAKE-АРГ'.


File: gdb.info,  Node: Команды,  Next: Выполнение,  Prev: Вызов,  Up: Top

3 Команды GDB
*************

Вы можете сокращать команды GDB по нескольким первым знакам имени
команды, если это сокращение однозначно; и вы можете повторять
определенные команды GDB простым нажатием <RET>.  Вы также можете
использовать клавишу <TAB> для того, чтобы GDB сам дополнил остаток
слова в команде (или показал вам возможные альтернативы, если существует
несколько вариантов).

* Menu:

* Синтаксис команд::            Как давать команды GDB
* Завершение::                  Завершение команд
* Справка::                     Как запросить помощь у GDB


File: gdb.info,  Node: Синтаксис команд,  Next: Завершение,  Up: Команды

3.1 Синтаксис команд
====================

Команда GDB представляет собой одну строку ввода.  Никаких ограничений
на ее длину нет.  Она начинается именем команды, за которым следуют
параметры, значение которых определяется ее названием.  Например,
команда 'step' допускает в качестве параметра число шагов, как в 'step
5'.  Вы также можете использовать команду 'step' и без параметров.
Некоторые команды не допускают никаких параметров.

   Названия команд GDB всегда могут быть сокращены, если это сокращение
однозначно.  Другие возможные сокращения команд перечислены в
документации по отдельным командам.  В некоторых случаях допускаются
даже неоднозначные сокращения; например, 's' специально определено как
эквивалент 'step', хотя существуют другие команды, чьи названия
начинаются на 's'.  Вы можете проверить сокращения, задавая их как
параметр для команды 'help'.

   Введенная пустая строка (просто нажатие <RET>), означает повтор
предыдущей команды.  Определенные команды (например, 'run') не
повторяются таким способом; это те команды, непреднамеренное повторение
которых может вызвать проблемы, и которые вы вряд ли захотите повторять.

   Команды 'list' и 'x', при их повторе нажатием <RET>, вместо точного
повтора создают новые параметры.  Это позволяет легко просматривать
исходный текст или память.

   GDB может также использовать <RET> по-другому: для разделения
длинного вывода, аналогично обычной утилите 'more' (*note Размер экрана:
Размер экрана.).  Так как в такой ситуации легко нажать <RET> слишком
много раз, GDB блокирует повтор после любой команды, генерирующей такой
тип вывода.

   Любой текст, расположенный от знака '#' до конца строки является
комментарием; он ничего не делает.  В основном, это полезно в командных
файлах (*note Командные файлы: Командные файлы.).


File: gdb.info,  Node: Завершение,  Next: Справка,  Prev: Синтаксис команд,  Up: Команды

3.2 Завершение команд
=====================

GDB может дополнить за вас окончание слова в команде, если существует
только один вариант; он также может в любой момент показать, какие
завершения возможны для следующего слова в команде.  Это работает для
команд и подкоманд GDB, а также для имен символов в вашей программе.

   Нажмите <TAB> в любой момент, когда захотите, чтобы GDB дополнил
оставшуюся часть слова.  Если существует только одна возможность, GDB
дополняет слово и ждет, пока вы закончите команду (или нажмете <RET>,
чтобы ввести ее).  Например, если вы введете

     (gdb) info bre <TAB>

GDB дополнит остаток слова 'breakpoints', так как у команды 'info' есть
единственная подкоманда, начинающаяся с 'bre':

     (gdb) info breakpoints

Теперь вы можете нажать либо <RET>, чтобы выполнить команду 'info
breakpoints', либо удалить часть знаков и ввести что-то другое, если
'breakpoints' не является той командой, которую вы ожидали.  (Если вы с
самого начала были уверены, что хотите 'info breakpoints', вы также
могли просто нажать <RET> сразу после 'info bre', использовав сокращение
команды вместо завершения).

   Если при нажатии <TAB> существует несколько вариантов для следующего
слова, GDB издает звук.  Вы можете либо ввести больше знаков и
попробовать снова, либо нажать <TAB> второй раз; GDB выведет все
возможные завершения для этого слова.  Например, вы можете захотеть
установить точку останова на подпрограмме, чье имя начинается с 'make_',
но когда вы вводите 'b make_<TAB>', GDB лишь издает звук.  Повторное
нажатие <TAB> отображает все имена функций в вашей программе,
начинающиеся с этих знаков.  Например:

     (gdb) b make_ <TAB>
GDB издает звук; нажав <TAB> еще раз, видим:
     make_a_section_from_file     make_environ
     make_abs_section             make_function_type
     make_blockvector             make_pointer_type
     make_cleanup                 make_reference_type
     make_command                 make_symbol_completion_list
     (gdb) b make_

После отображения возможных вариантов, GDB копирует ваш частичный ввод
('b make_' в этом примере), так что вы можете закончить команду.

   Если вы сначала хотите только увидеть список альтернатив, вы можете
нажать 'M-?', а не нажимать <TAB> дважды.  'M-?' означает '<META> ?'.
Вы можете ввести это, либо нажав '?', удерживая клавишу, обозначенную на
вашей клавиатуре как <META> (если такая есть), либо как <ESC>, за
которой следует '?'.

   Иногда нужная вам строка, являясь логически "словом", может содержать
скобки или другие знаки, которые GDB обычно исключает из своего понятия
о слове.  Чтобы позволить завершению слов работать в такой ситуации, вы
можете заключить слова в командах GDB в ''' (знаки одинарных кавычек).

   Наиболее вероятная ситуация, где вам это может потребоваться, -- это
при вводе имени функции в Си++.  Это происходит потому, что Си++
допускает перегрузку функций (множественные определения одной и той же
функции, различающиеся типом параметров).  Например, когда вы хотите
установить точку останова, вам может потребоваться различать, имеете вы
в виду версию 'name' с параметром целого типа, 'name(int)', или же
версию с параметром вещественного типа, 'name(float)'.  Для
использования возможностей завершения слов в такой ситуации, введите
одинарную кавычку ''' в начале имени функции.  Это предупреждает GDB,
что ему может потребоваться принять во внимание больше информации, чем
обычно, когда вы нажимаете <TAB> или 'M-?' для запроса завершения слова:

     (gdb) b 'bubble( M-?
     bubble(double,double)    bubble(int,int)
     (gdb) b 'bubble(

   В некоторых случаях GDB может сам определить, что завершение имени
требует использования кавычек.  Когда это происходит, GDB вставляет
кавычку за вас (выполняя завершение настолько, на сколько это возможно),
если вы не ввели ее в первой позиции:

     (gdb) b bub <TAB>
GDB изменяет вашу строку ввода на следующую, и издает звук:
     (gdb) b 'bubble(

Вообще, GDB может определить, что кавычка нужна (и вставляет ее), если
вы запрашиваете завершение перегруженного символа до того, как начали
вводить список параметров.

   Для получения большей информации о перегруженных функциях, смотрите
*note Выражения Си++: Выражения Си++.  Вы можете использовать команду
'set overload-resolution off' для отключения распознавания перегруженных
символов; смотрите *note Возможности GDB для Си++: Отладка Си++.


File: gdb.info,  Node: Справка,  Prev: Завершение,  Up: Команды

3.3 Получение справки
=====================

Используя команду 'help', вы всегда можете запросить информацию о
командах у самого GDB.

'help'
'h'
     Вы можете использовать 'help' (сокращенно 'h') без параметров для
     отображения короткого списка именованных классов команд:

          (gdb) help
          List of classes of commands:

          aliases -- Aliases of other commands
          breakpoints -- Making program stop at certain points
          data -- Examining data
          files -- Specifying and examining files
          internals -- Maintenance commands
          obscure -- Obscure features
          running -- Running the program
          stack -- Examining the stack
          status -- Status inquiries
          support -- Support facilities
          tracepoints -- Tracing of program execution without
                         stopping the program
          user-defined -- User-defined commands

          Type "help" followed by a class name for a list of
          commands in that class.
          Type "help" followed by command name for full
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

'help КЛАСС'
     Используя один из общих классов справки как параметр, вы можете
     получить список отдельных команд этого класса.  Вот, например,
     отображение справки для класса 'status':

          (gdb) help status
          Status inquiries.

          List of commands:

          info -- Generic command for showing things
           about the program being debugged
          show -- Generic command for showing things
           about the debugger

          Type "help" followed by command name for full
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

'help КОМАНДА'
     Если указать имя команды в качестве параметра 'help', GDB выведет
     короткую справку о том, как ей пользоваться.

'apropos АРГ'
     Команда 'apropos АРГ' производит поиск по регулярному выражению,
     заданному в АРГ, во всех командах GDB и их документации.  Она
     выводит все найденные совпадения.  Например:

          apropos reload

     выводит:

          set symbol-reloading -- Set dynamic symbol table reloading
                                           multiple times in one run
          show symbol-reloading -- Show dynamic symbol table reloading
                                           multiple times in one run

'complete АРГ'
     Команда 'complete АРГ' перечисляет все возможные завершения для
     начала команды.  Используйте АРГ для задания начала команды,
     которую вы хотите завершить.  Например,

          complete i

     приводит к:

          if
          ignore
          info
          inspect

     Это предназначено для использования GNU Emacs.

   В дополнение к 'help', вы можете использовать команды GDB 'info' и
'show' для получения информации о состоянии вашей программы, или о
состоянии самого GDB. Каждая команда поддерживает много тем запросов;
это руководство описывает каждую тему в соответствующем месте.  Списки в
разделах 'info' и 'show' в Алфавитном указателе указывают на все
подкоманды.  *Note Алфавитный указатель::.

'info'
     Эта команда (сокращенно 'i') предназначена для описания состояния
     вашей программы.  Например, вы можете с помощью 'info args'
     просмотреть аргументы, переданные вашей программе, с помощью 'info
     registers' перечислить используемые в настоящий момент регистры или
     используя 'info breakpoints' вывести установленные вами точки
     останова.  Вы можете получить полный список подкоманд команды
     'info' с помощью 'help info'.

'set'
     Вы можете присвоить переменной среды результат выражения с помощью
     'set'.  Например, вы можете сделать приглашением GDB знак $
     используя 'set prompt $'.

'show'
     В отличие от 'info', команда 'show' предназначена для описания
     состояния самого GDB. Вы можете изменить почти все, что показывает
     'show', используя соответствующую команду 'set'.  Например,
     командой 'set radix' вы можете указать, какую систему счисления
     использовать для вывода, или просто узнать, какая система
     используется в данный момент с помощью команды 'show radix'.

     Для отображения всех устанавливаемых параметров и их текущих
     значений вы можете использовать 'show' без аргументов; также можно
     использовать 'info set'.  Обе команды приводят к одинаковому
     результату.

   Вот три еще подкоманды 'show'; они отличаются от остальных тем, не
имеют соответствующих 'set'-команд:

'show version'
     Показывает, какая версия GDB запущена.  Вам следует включать эту
     информацию в отчеты об ошибках в GDB. Если вы используете несколько
     версий GDB, вам может потребоваться определить, какая из них
     запущена; по мере развития отладчика появляются новые команды, а
     старые могут исчезнуть.  Кроме того, многие распространители
     операционных систем поставляют модифицированные версии GDB, также
     существуют модифицированные версии GDB в GNU/Linux.  Номер версии
     -- это номер, появляющийся при старте.

'show copying'
     Выводит информацию о правах на распространение GDB.

'show warranty'
     Отображает заявление GNU об отсутствии гарантий, или заявление о
     гарантиях, если ваша версия GDB поставляется с гарантиями.


File: gdb.info,  Node: Выполнение,  Next: Остановка,  Prev: Команды,  Up: Top

4 Выполнение программ под управлением GDB
*****************************************

Прежде чем выполнять программу под управлением GDB, при компиляции вы
должны сгенерировать отладочную информацию.

   Вы можете запустить GDB с параметрами или без, в любой среде по
вашему выбору.  Если вы отлаживаете программу на той же машине, на
которой выполняется GDB, вы можете перенаправлять ввод и вывод вашей
программы, отлаживать уже выполняющийся процесс или убить дочерний
процесс.

* Menu:

* Компиляция::                  Компиляция для отладки
* Начало выполнения::           Запуск вашей программы
* Аргументы::                   Аргументы вашей программы
* Среда::                       Среда вашей программы

* Рабочий каталог::             Рабочий каталог вашей программы
* Ввод-вывод::                  Ввод и вывод вашей программы
* Присоединение::               Отладка запущенного ранее процесса
* Уничтожение процесса::        Уничтожение дочернего процесса

* Нити::                        Отладка программ с несколькими нитями
* Процессы::                    Отладка программ с несколькими процессами


File: gdb.info,  Node: Компиляция,  Next: Начало выполнения,  Up: Выполнение

4.1 Компиляция для отладки
==========================

Для эффективной отладки программы, при компиляции вы должны
сгенерировать отладочную информацию.  Эта отладочная информация
сохраняется в объектном файле; она описывает тип данных каждой
переменной или функции и соответствие между номерами строк исходного
текста и адресами в выполняемом коде.

   Чтобы запросить генерацию отладочной информации, укажите ключ '-g'
при вызове компилятора.

   Многие компиляторы Си не могут обрабатывать ключи '-g' и '-O' вместе.
Используя такие компиляторы, вы не можете создавать оптимизированные
выполняемые файлы, содержащие отладочную информацию.

   GCC, GNU компилятор Си, поддерживает '-g' вместе с ключом '-O' или
без него, что делает возможной отладку оптимизированного кода.  Мы
рекомендуем вам _всегда_ использовать '-g' при компиляции программ.  Вы
можете думать, что ваша программа правильная, но нет никакого смысла
испытывать удачу.

   Когда вы отлаживаете программу, откомпилированную с '-g -O', помните,
что оптимизатор перестраивает ваш код; отладчик же показывает то, что
там находится в действительности.  Не удивляйтесь, если порядок
выполнения не будет в точности соответствовать вашему исходному файлу!
Крайний пример: если вы определяете переменную, но нигде ее не
используете, GDB никогда не увидит этой переменной, потому что при
оптимизации компилятор ее исключит.

   Некоторые вещи не работают с '-g -O' так же хорошо, как с одним '-g',
в частности, на машинах с планированием инструкций.  Если сомневаетесь,
перекомпилируйте с одним ключом '-g', и если это устранит проблему,
пожалуйста, сообщите нам об этом как об ошибке (включите тестовый
пример!).

   Ранние версии компилятора GNU Си допускали вариант ключа для
отладочной информации '-gg'.  GDB больше не поддерживает этот формат;
если этот ключ есть у вашего компилятора GNU Си, не используйте его.


File: gdb.info,  Node: Начало выполнения,  Next: Аргументы,  Prev: Компиляция,  Up: Выполнение

4.2 Начало выполнения вашей программы
=====================================

'run'
'r'
     Используйте команду 'run' для запуска вашей программы под
     управлением GDB. Сначала вы должны задать имя программы (кроме как
     на VxWorks) с параметрами GDB (*note Вход и выход из GDB: Вызов.),
     или используя команды 'file' или 'exec-file' (*note Команды для
     задания файлов: Файлы.).

   Если вы запускаете вашу программу в среде выполнения, поддерживающей
процессы, 'run' создает подчиненный процесс, и этот процесс выполняет
вашу программу.  (В средах, не поддерживающих процессы, 'run' выполняет
переход на начало вашей программы.)

   Выполнение программы зависит от определенной информации, которую она
получает от породившего ее процесса.  GDB предоставляет способы задать
эту информацию, что вы должны сделать _до_ запуска программы.  (Вы
можете изменить ее после старта, но такие изменения воздействуют на вашу
программу только при следующем запуске.)  Эта информация может быть
разделена на четыре категории:

_Параметры._
     Задайте параметры, которые нужно передать вашей программе, в
     качестве параметров команды 'run'.  Если на вашей системе доступна
     оболочка, она используется для передачи параметров, так что при их
     описании вы можете использовать обычные соглашения (такие как
     раскрывание шаблонов или подстановка переменных).  В системах Unix,
     вы можете контролировать, какая оболочка используется, с помощью
     переменной среды 'SHELL'.  *Note Аргументы вашей программы:
     Аргументы.

_Среда._
     Обычно ваша программа наследует свою среду от GDB, но вы можете
     использовать команды GDB 'set environment' и 'unset environment',
     чтобы изменить часть настроек среды, влияющих на нее.  *Note
     Рабочая среда вашей программы: Среда.

_Рабочий каталог._
     Ваша программа наследует свой рабочий каталог от GDB. Вы можете
     установить рабочий каталог GDB командой 'cd'.  *Note Рабочий
     каталог вашей программы: Рабочий каталог.

_Стандартный ввод и вывод._
     Обычно ваша программа использует те же устройства для стандартного
     ввода и вывода, что и GDB. Вы можете перенаправить ввод и вывод в
     строке команды 'run' или использовать команду 'tty', чтобы
     установить другое устройство для вашей программы.  *Note Ввод и
     вывод вашей программы: Ввод-вывод.

     _Предупреждение:_ Хотя перенаправление ввода и вывода работает, вы
     не можете использовать каналы для передачи выходных данных
     отлаживаемой программы другой программе; если вы попытаетесь это
     сделать, скорее всего GDB перейдет к отладке не той программы.

   Когда вы подаете команду 'run', ваша программа начинает выполняться
немедленно.  *Note Остановка и продолжение: Остановка, для обсуждения
того, как остановить вашу программу.  Как только программа остановилась,
вы можете вызывать функции вашей программы, используя команды 'print'
или 'call'.  *Note Исследование данных: Данные.

   Если время модификации символьного файла изменилось с того момента,
когда GDB последний раз считывал символы, он уничтожает свою символьную
таблицу и считывает ее заново.  При этом GDB старается сохранить ваши
текущие точки останова.


File: gdb.info,  Node: Аргументы,  Next: Среда,  Prev: Начало выполнения,  Up: Выполнение

4.3 Аргументы вашей программы
=============================

Аргументы к вашей программе могут быть заданы как аргументы к команде
'run'.  Они передаются оболочке, которая раскрывает символы шаблонов и
выполняет перенаправление ввода-вывода, и с того момента попадают в вашу
программу.  Переменная среды 'SHELL' (если она существует) определяет,
какую оболочку использует GDB. Если вы не определите 'SHELL', он
использует оболочку по умолчанию ('/bin/sh' в Unix).

   В не-Unix-системах, программу обычно запускает непосредственно GDB,
который эмулирует перенаправление ввода-вывода через соответствующие
системные вызовы, и символы шаблонов раскрываются кодом запуска, а не
оболочкой.

   'run' без аргументов использует те же аргументы, которые
использовались предыдущей командой 'run', или которые установлены
командой 'set args'.

'set args'
     Задает аргументы, которые будут использоваться при следующем
     запуске вашей программы.  Если у 'set args' нет аргументов, 'run'
     выполняет вашу программу без аргументов.  Если вы запустили
     программу с аргументами, то единственный способ запустить ее снова
     без аргументов -- это использовать 'set args' до следующего запуска
     командой 'run'.

'show args'
     Показать аргументы, которые будут переданы вашей программе при ее
     вызове.


File: gdb.info,  Node: Среда,  Next: Рабочий каталог,  Prev: Аргументы,  Up: Выполнение

4.4 Рабочая среда вашей программы
=================================

"Среда" состоит из набора переменных среды и их значений.  Переменные
среды обычно хранят такие данные, как ваше имя пользователя, домашний
каталог, тип терминала и путь поиска для запуска программ.  Как правило,
вы устанавливаете переменные среды с помощью оболочки, и они наследуются
всеми другими программами, которые вы вызываете.  При отладке может
оказаться полезным попробовать запустить программу в измененной среде,
не перезапуская GDB.

'path КАТАЛОГ'
     Добавить КАТАЛОГ в начало переменной среды 'PATH' (пути поиска
     выполняемых файлов), как для GDB, так и для вашей программы.  Вы
     можете указать названия нескольких каталогов, разделив их пробелом
     или системно-зависимым разделителем (':' в Unix, ';' в MS-DOS и
     MS-Windows).  Если КАТАЛОГ уже находится в списке путей, он
     переносится в начало, так что поиск в нем будет производиться
     раньше.

     Вы можете использовать строку 'cwd', чтобы сослаться на рабочий
     каталог, который является текущим в тот момент, когда GDB
     производит поиск.  Если вместо этого вы используете '.', то она
     будет указывать на тот каталог, в котором вы выполнили команду
     'path'.  GDB заменяет '.' в аргументе КАТАЛОГ (на текущий путь) до
     добавления КАТАЛОГА к списку путей поиска.

'show paths'
     Отобразить список путей для поиска выполняемых файлов (переменную
     среды 'PATH').

'show environment [ИМЯ-ПЕРЕМ]'
     Вывести значение переменной среды ИМЯ-ПЕРЕМ, которое будет передано
     вашей программе при ее старте.  Если вы не указываете ИМЯ-ПЕРЕМ,
     вывести названия и значения всех переменных среды, передаваемых
     вашей программе.  Вы можете сократить 'environment' как 'env'.

'set environment ИМЯ-ПЕРЕМ [=ЗНАЧЕНИЕ]'
     Присваивает ЗНАЧЕНИЕ переменной среды ИМЯ-ПЕРЕМ.  Значение меняется
     только для вашей программы, но не для самого GDB. ЗНАЧЕНИЕ может
     быть любой строкой; значениями переменных среды являются просто
     строки, а их интерпретацию обеспечивает ваша программа.  Параметр
     ЗНАЧЕНИЕ является необязательным; если он опущен, переменная
     устанавливается в пустое значение.

     Например, эта команда:

          set env USER = foo

     говорит отлаживаемой программе, что при последующих запусках именем
     пользователя является 'foo'.  (Пробелы, окружающие '=',
     использованы здесь для ясности; в действительности, они не
     обязательны.)

'unset environment ИМЯ-ПЕРЕМ'
     Удалить переменную ИМЯ-ПЕРЕМ из среды, передаваемой вашей
     программе.  Это отличается от 'set env ИМЯ-ПЕРЕМ ='; 'unset
     environment' удаляет переменную из среды, а не присваивает ей
     пустое значение.

   _Предупреждение:_ В системах Unix, GDB вызывает вашу программу,
используя оболочку, указанную вашей переменной среды 'SHELL', если она
определена (или '/bin/sh', если не определена).  Если переменная 'SHELL'
указывает на оболочку, которая выполняет файл инициализации -- такой как
'.cshrc' для оболочки C-shell, или '.bashrc' для BASH -- любая
переменная, которую вы установите в этом файле, воздействует на вашу
программу.  В этой связи, вы можете захотеть перенести установку
переменных среды в файлы, которые выполняются только при входе в
систему, такие как '.login' или '.profile'.


File: gdb.info,  Node: Рабочий каталог,  Next: Ввод-вывод,  Prev: Среда,  Up: Выполнение

4.5 Рабочий каталог вашей программы
===================================

Каждый раз, когда вы запускаете свою программу командой 'run', она
наследует рабочий каталог от текущего рабочего каталога GDB. В начальный
момент, рабочий каталог GDB наследуется от его родительского процесса
(обычно оболочки), но вы можете задать новый рабочий каталог командой
'cd' из GDB.

   Рабочий каталог GDB также служит каталогом по умолчанию для команд
отладчика, определяющих действия с файлами.  *Note Команды для задания
файлов: Файлы.

'cd КАТАЛОГ'
     Установить рабочий каталог GDB в КАТАЛОГ.

'pwd'
     Вывести рабочий каталог GDB.


File: gdb.info,  Node: Ввод-вывод,  Next: Присоединение,  Prev: Рабочий каталог,  Up: Выполнение

4.6 Ввод и вывод вашей программы
================================

По умолчанию, программа, которую вы запускаете под управлением GDB,
осуществляет ввод и вывод на тот же терминал, что и GDB. Для
взаимодействия с вами, GDB переключает терминал в свой собственный
терминальный режим, но он записывает терминальные режимы, которые
использовала ваша программа, и переключается назад к ним, когда вы
продолжаете выполнение программы.

'info terminal'
     Отображает информацию, записанную GDB о терминальных режимах,
     которые использует ваша программа.

   Вы можете перенаправить ввод и/или вывод вашей программы, используя
перенаправление оболочки с помощью команды 'run'.  Например,

     run > выходной-файл

запускает вашу программу, перенаправляя ее вывод в 'выходной-файл'.

   Другой способ задать, как ваша программа должна осуществлять ввод и
вывод, -- использовать команду 'tty'.  Эта команда принимает в качестве
аргумента имя файла, который будет использоваться по умолчанию для
будущих команд 'run'.  Она также сбрасывает управляющий терминал для
дочернего процесса для будущих команд 'run'.  Например,

     tty /dev/ttyb

указывает, что процессы, запущенные последующими командами 'run', для
ввода и вывода используют по умолчанию терминал '/dev/ttyb', и что он
будет их управляющим терминалом.

   Явное перенаправление в 'run' замещает эффект команды 'tty' для
устройств ввода-вывода, но не ее воздействие на управляющий терминал.

   Когда вы используете команду 'tty' или перенаправляете ввод в команде
'run', изменяется только ввод _для вашей программы_.  Ввод для GDB по
прежнему происходит через ваш терминал.


File: gdb.info,  Node: Присоединение,  Next: Уничтожение процесса,  Prev: Ввод-вывод,  Up: Выполнение

4.7 Отладка запущенного ранее процесса
======================================

'attach ИДЕНТ-ПРОЦЕССА'
     Эта команда присоединяется к выполняющемуся процессу -- процессу,
     который был запущен вне GDB. (Команда 'info files' показывает ваши
     активные цели.)  В качестве аргумента эта команда получает
     идентификатор процесса.  Обычный способ узнать идентификатор
     Unix-процесса -- воспользоваться утилитой 'ps' или командой
     оболочки 'jobs -l'.

     'attach' не повторяется, если вы нажмете <RET> второй раз после
     выполнения команды.

   Чтобы использовать 'attach', ваша программа должна выполняться в
среде, поддерживающей процессы; например, 'attach' не работает на
специальных машинах, не имеющих операционной системы.  Вы также должны
обладать полномочиями для посылки сигнала процессу.

   Когда вы используете 'attach', отладчик находит программу
выполняющегося процесса, производя поиск сперва в текущем рабочем
каталоге, а затем (если программа не найдена), используя пути поиска
исходных файлов (*note Определение каталогов с исходными файлами: Пути
для исходных файлов.).  Также, для загрузки программы вы можете
использовать команду 'file'.  *Note Команды для задания файлов: Файлы.

   Первое, что GDB делает после подготовки указанного процесса к отладке
-- останавливает его.  Вы можете исследовать и изменять присоединенный
процесс всеми командами GDB, которые обычно доступны, когда вы
запускаете процессы с помощью 'run'.  Вы можете устанавливать точки
останова; вы можете пошагово выполнять программу и продолжить ее обычное
выполнение, вы можете изменять области данных.  Если вы решите
продолжить выполнение процесса после присоединения к нему GDB, вы можете
использовать команду 'continue'.

'detach'
     Когда вы закончили отлаживать присоединенный процесс, для его
     освобождения из-под управления GDB вы можете использовать команду
     'detach'.  Отсоединение процесса продолжает его выполнение.  После
     команды 'detach', этот процесс и GDB снова становятся совершенно
     независимыми, и вы готовы присоединить или запустить с помощью
     'run' другой процесс.  'detach' не повторяется, если вы нажмете
     <RET> еще раз.

   Если вы выйдете из GDB или используете команду 'run', пока у вас есть
присоединенный процесс, вы убьете этот процесс.  По умолчанию, GDB
запрашивает подтверждение, если вы пытаетесь сделать одну из этих вещей;
вы можете контролировать, нужно вам это подтверждение или нет, используя
команду 'set confirm' (*note Необязательные предупреждения и сообщения:
Сообщения/предупреждения.).


File: gdb.info,  Node: Уничтожение процесса,  Next: Нити,  Prev: Присоединение,  Up: Выполнение

4.8 Уничтожение дочернего процесса
==================================

'kill'
     Уничтожить дочерний процесс, в котором ваша программа выполняется
     под управлением GDB.

   Эта команда полезна, если вы хотите отладить дамп памяти, а не
выполняющийся процесс.  GDB игнорирует любые дампы памяти, пока ваша
программа выполняется.

   В некоторых операционных системах программа не может быть выполнена
вне GDB, пока в ней есть точки останова, установленные отладчиком.  В
этой ситуации вы можете использовать команду 'kill', чтобы разрешить
выполнение вашей программы вне отладчика.

   Команда 'kill' также полезна, если вы хотите перекомпилировать и
перекомпоновать вашу программу, так как во многих системах невозможно
модифицировать исполняемый файл во время выполнения процесса.  В этом
случае, когда вы в следующий раз введете 'run', GDB заметит, что файл
изменился, и заново прочитает символьную таблицу (стараясь при этом
сохранить ваши точки останова).


File: gdb.info,  Node: Нити,  Next: Процессы,  Prev: Уничтожение процесса,  Up: Выполнение

4.9 Отладка программ с несколькими нитями
=========================================

В некоторых операционных системах, таких как HP-UX и Solaris, одна
программа может иметь несколько "нитей" выполнения.  Точная семантика
нитей меняется от одной операционной системы к другой, но в общем, нити
одной программы сродни нескольким процессам -- за исключением того, что
они разделяют одно адресное пространство (то есть, все они могут
исследовать и модифицировать одни и те же переменные).  С другой
стороны, каждая нить имеет свои собственные регистры и стек выполнения,
и, возможно, свои собственные участки памяти.

   GDB предоставляет следующие возможности для отладки многонитевых
программ:

   * автоматическое уведомление о новых нитях
   * 'thread НОМЕР-НИТИ', команда для переключения между нитями
   * 'info threads', команда для запроса информации о существующих нитях
   * 'thread apply [НОМЕР-НИТИ] [ALL] АРГ', команда для применения
     некоторой команды к списку нитей
   * точки останова, определяемые отдельно для каждой нити

     _Предупреждение:_ Пока эти возможности доступны не в любой
     конфигурации GDB, где операционная система поддерживает нити.  Если
     ваш GDB не поддерживает нити, эти команды не имеют эффекта.
     Например, в системах без поддержки нитей GDB ничего не выводит на
     команду 'info threads' и всегда отвергает команду 'thread', как в
     этом примере:

          (gdb) info threads
          (gdb) thread 1
          Thread ID 1 not known.  Use the "info threads" command to
          see the IDs of currently known threads.(1)

   Возможности GDB для отладки нитей позволяют вам наблюдать все нити во
время выполнения вашей программы, но когда управление переходит к GDB,
одна конкретная нить выделяется для отладки.  Она называется "текущей
нитью".  Отладочные команды показывают информацию о программе с точки
зрения текущей нити.

   Когда GDB обнаруживает новую нить в вашей программе, он выводит для
нее идентификатор на целевой системе с сообщением в форме '[New
СИСТ-ТЕГ]'.  СИСТ-ТЕГ является идентификатором нити, чья форма
различается в зависимости от конкретной системы.  Например, в LynxOS вы
можете увидеть

     [New process 35 thread 27]

когда GDB замечает новую нить.  Напротив, в системе SGI, СИСТ-ТЕГ
выглядит просто как 'process 368', без дополнительных спецификаций.

   Для отладочных целей, GDB присваивает свои собственные номера нитей
-- всегда в виде одного целого числа -- каждой нити в вашей программе.

'info threads'
     Вывести краткую информацию обо всех имеющихся в данный момент в
     вашей программе нитях.  Для каждой нити, GDB отображает (в этом
     порядке):

       1. номер нити, назначенный GDB

       2. идентификатор нити на целевой системе (СИСТ-ТЕГ)

       3. краткие сведения о текущем кадре стека для этой нити

     Звездочка '*' слева от номера нити GDB обозначает текущую нить.

     Например,

     (gdb) info threads
       3 process 35 thread 27  0x34e5 in sigpause ()
       2 process 35 thread 23  0x34e5 in sigpause ()
     * 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
         at threadtest.c:68

   В системах HP-UX:

   Для отладочных целей, GDB присваивает свои собственные номера нитей
-- небольшие целые, присваиваемые в порядке создания нитей -- каждой
нити в вашей программе.

   Когда GDB обнаруживает новую нить в вашей программе, он выводит как
номер нити, присвоенный GDB, так и идентификатор на целевой системе для
нити с сообщением в форме '[New СИСТ-ТЕГ]'.  СИСТ-ТЕГ является
идентификатором нити, чья форма различается в зависимости от конкретной
системы.  Например, в HP-UX, когда GDB замечает новую нить, вы увидите

     [New thread 2 (system thread 26594)]

'info threads'
     Вывести краткую информацию обо всех имеющихся в данный момент в
     вашей программе нитях.  Для каждой нити, GDB отображает (в этом
     порядке):

       1. номер нити, назначенный GDB

       2. идентификатор нити на целевой системе (СИСТ-ТЕГ)

       3. краткие сведения о текущем кадре стека для этой нити

     Звездочка '*' слева от номера нити GDB означает текущую нить.

     Например,

     (gdb) info threads
         * 3 system thread 26607  worker (wptr=0x7b09c318 "@") \

                                    at quicksort.c:137
           2 system thread 26606  0x7b0030d8 in __ksleep () \

                                    from /usr/lib/libc.2
           1 system thread 27905  0x7b003498 in _brk () \

                                    from /usr/lib/libc.2

'thread НОМЕР-НИТИ'
     Сделать нить с номером НОМЕР-НИТИ текущей.  Аргумент команды,
     НОМЕР-НИТИ, является внутренним номером нити GDB, который показан в
     первом поле 'info threads'.  GDB отвечает, выводя системный
     идентификатор выбранной вами нити и обзор ее кадра стека:

          (gdb) thread 2
          [Switching to process 35 thread 23]
          0x34e5 in sigpause ()

     Также как и с сообщением '[New ...]', форма текста после 'Switching
     to' зависит от соглашений для идентификации нитей в вашей системе.

'threads apply [НОМЕР-НИТИ] [ALL] АРГ'
     Команда 'thread apply' позволяет вам применить команду к одной или
     нескольким нитям.  Задайте номера нитей, на которые вы хотите
     воздействовать, в аргументе НОМЕР-НИТИ.  НОМЕР-НИТИ -- это
     внутренний номер нити GDB, который показан в первом поле 'info
     threads'.  Чтобы применить команду ко всем нитям, используйте
     'thread apply all' АРГ.

   Когда GDB останавливает вашу программу, вследствие точки останова или
по сигналу, он автоматически выбирает нить, в которой появилась эта
точка останова или сигнал.  GDB предупреждает вас о переключении
контекста сообщением в форме '[Switching to СИСТ-ТЕГ]' для идентификации
нити.

   *Note Остановка и запуск многонитевых программ: Остановка нитей, для
дополнительной информации о поведении GDB, когда вы останавливаете и
запускаете многонитевую программу.

   *Note Установка точек наблюдения: Установка точек наблюдения, для
информации о точках наблюдения в многонитевых программах.

   ---------- Footnotes ----------

   (1) Нить с идентификатором 1 неизвестна.  Используйте команду "info
threads", чтобы получить идентификаторы известных нитей.  (Прим.
переводчика)


File: gdb.info,  Node: Процессы,  Prev: Нити,  Up: Выполнение

4.10 Отладка многонитевых программ
==================================

В большинстве систем GDB не имеет специальной поддержки для отладки
программ, создающих дополнительные процессы с помощью функции 'fork'.
Когда программа вызывает 'fork', GDB будет продолжать отладку
родительского процесса, а дочерний процесс будет выполняться
беспрепятственно.  Если выполнение дочернего процесса дойдет до места,
где вы установили точку останова, дочерний процесс получит сигнал
'SIGTRAP', который приведет к остановке процесса (если он не
перехватывает этот сигнал).

   Однако, если вы хотите отладить дочерний процесс, существует
достаточно простое решение.  Поместите вызов 'sleep' в код программы,
который дочерний процесс выполнит после 'fork'.  Может быть удобным
вызывать 'sleep', только если установлена определенная переменная среды,
или если существует определенный файл, так что задержка не будет
происходить, если вы не захотите отлаживать дочерний процесс.  Пока
дочерний процесс спит, используйте программу 'ps' для получения его
идентификатора.  Затем укажите GDB (новому экземпляру GDB, если вы
отлаживаете также и родительский процесс) присоединиться к дочернему
процессу (*note Присоединение::).  Начиная с этого момента, вы можете
отлаживать дочерний процесс точно так же, как любой другой процесс, к
которому вы присоединились.

   В системе HP-UX (только в версиях 11.x и более поздних?)  GDB
предоставляет средства для отладки программ, которые создают
дополнительные процессы, используя функции 'fork' или 'vfork'.

   По умолчанию, когда программа ветвится, GDB будет продолжать отладку
родительского процесса, а дочерний процесс будет выполняться
беспрепятственно.

   Если вы хотите отлаживать дочерний процесс вместо родительского,
используйте команду 'set follow-fork-mode'.

'set follow-fork-mode РЕЖИМ'
     Устанавливает реакцию отладчика на вызов 'fork' или 'vfork' в
     программе.  Вызов 'fork' или 'vfork' создает новый процесс.  РЕЖИМ
     может быть:

     'parent'
          После ветвления отлаживается исходный процесс.  Дочерний
          процесс выполняется беспрепятственно.  Это поведение по
          умолчанию.

     'child'
          После ветвления отлаживается новый процесс.  Родительский
          процесс выполняется беспрепятственно.

     'ask'
          Отладчик будет запрашивать один из этих вариантов.

'show follow-fork-mode'
     Отображает текущую реакцию отладчика на вызов 'fork' или 'vfork'.

   Если вы запрашиваете отладку дочернего процесса, и за 'vfork' следует
'exec', GDB выполняет новую программу до первой установленной в ней
точки останова.  Если в вашей исходной программе была установлена точка
останова на функции 'main', она будет также установлена на 'main' в
дочернем процессе.

   Когда дочерний процесс порождается вызовом 'vfork', вы не можете
отлаживать дочерний или родительский процесс до тех пор, пока не
завершится вызов 'exec'.

   Если вы даете GDB команду 'run' после выполнения 'exec', новая
программа стартует заново.  Чтобы перезапустить родительский процесс,
используйте команду 'file' с именем выполняемого файла родительской
программы в качестве аргумента.

   Вы можете использовать команду 'catch', чтобы остановить GDB, когда
сделан вызов 'fork', 'vfork' или 'exec'.  *Note Установка точек
перехвата: Установка точек перехвата.


File: gdb.info,  Node: Остановка,  Next: Стек,  Prev: Выполнение,  Up: Top

5 Остановка и продолжение исполнения
************************************

Основные цели применения отладчика -- позволить вам остановить программу
до ее завершения или, в случае нарушений в работе программы, исследовать
программу и выяснить причину неполадок.

   Внутри GDB ваша программа может остановиться по нескольким причинам,
таким как сигнал, точка останова или достижение новой строки после
команды GDB, такой как 'step'.  Затем вы можете исследовать и изменять
значения переменных, устанавливать новые точки останова и удалять старые
и затем продолжить выполнение.  Обычно выводимые GDB сообщения
предоставляют достаточную информацию о состоянии вашей программы, но вы
также можете запросить эту информацию явно в любое время.

'info program'
     Отобразить информацию о состоянии вашей программы: выполняется она
     или нет, каким процессом она является, и почему остановлена.

* Menu:

* Точки останова::              Точки останова, наблюдения и перехвата
* Продолжение и пошаговое выполнение::
                                Возобновление выполнения
* Сигналы::                     Сигналы
* Остановка нитей::             Остановка и запуск многонитевых программ


File: gdb.info,  Node: Точки останова,  Next: Продолжение и пошаговое выполнение,  Up: Остановка

5.1 Точки останова, точки наблюдения и точки перехвата
======================================================

"Точка останова" останавливает вашу программу всякий раз, когда ее
выполнение достигает определенного места.  Для каждой точки останова вы
можете добавлять условия для лучшего управления условиями остановки.  Вы
можете устанавливать точки останова командой 'break' и ее вариантами
(*note Установка точек останова: Установка точек останова.), чтобы
задать место, где должна остановиться ваша программа, по номеру строки,
имени функции или точному адресу.

   В конфигурациях HP-UX, SunOS 4.x, SVR4 и Alpha OSF/1, вы можете
устанавливать точки останова в разделяемых библиотеках до запуска
выполняемого файла.  В системах HP-UX существует небольшое ограничение:
вы должны подождать, пока программа не перестанет выполняться, для
установки точек останова в подпрограммах из разделяемой библиотеки,
которые не вызываются напрямую из программы (например, подпрограммах,
являющихся аргументами вызова 'pthread_create').

   "Точка наблюдения" -- это специальная точка останова, которая
останавливает вашу программу при изменении значения выражения.  Вы
должны использовать другую команду для установки точки наблюдения (*note
Установка точек наблюдения: Установка точек наблюдения.), но помимо
этого, вы можете обращаться с ней так же, как с любой другой точкой
останова: вы включаете, отключаете и удаляете точки останова и точки
наблюдения при помощи одних и тех же команд.

   Вы можете сделать так, чтобы при каждой остановке в точке останова
автоматически отображались некоторые значения из вашей программы.  *Note
Автоматическое отображение: Автоматическое отображение.

   "Точка перехвата" -- это другая специализированная точка останова,
которая останавливает вашу программу при возникновении события
определенного типа, такого как выбрасывание исключения в Си++ или
загрузка библиотеки.  Так же, как с точками наблюдения, вы используете
другую команду для установки точки перехвата, (*note Установка точек
перехвата: Установка точек перехвата.), но помимо этого, вы можете
обращаться с ней так же, как с любой другой точкой останова.  (Для
остановки, когда ваша программа получает сигнал, используйте команду
'handle'; смотрите *note Сигналы: Сигналы.)

   Когда вы создаете точку останова, наблюдения или перехвата, GDB
присваивает ей номер; эти номера являются последовательными целыми
числами, начинающимися с единицы.  Во многих командах для управления
различными возможностями точек останова вы используете эти номера для
указания точки останова, которую вы хотите изменить.  Каждая точка
останова может быть "включена" или "отключена"; если точка останова
отключена, она не оказывает никакого влияния на вашу программу, пока вы
снова не включите ее.

   Некоторые команды GDB допускают в качестве указания точек останова,
на которые они действуют, их диапазоны.  Диапазон точек останова -- это
или номер одной точки, например '5', или два таких номера, в порядке
увеличения, разделенные дефисом, например '5-7'.  Когда команде задается
диапазон точек останова, она действует на все точки останова в этом
диапазоне.

* Menu:

* Установка точек останова::    Установка точек останова
* Установка точек наблюдения::  Установка точек наблюдения
* Установка точек перехвата::   Установка точек перехвата
* Удаление точек останова::     Удаление точек останова
* Отключение::                  Отключение точек останова
* Условия::                     Условия останова
* Команды останова::            Команды точки останова
* Меню точки останова::         Меню точки останова
* Ошибки в точках останова::    "Не удается поместить точки останова"


File: gdb.info,  Node: Установка точек останова,  Next: Установка точек наблюдения,  Up: Точки останова

5.1.1 Установка точек останова
------------------------------

Точки останова устанавливаются командой 'break' (сокращенно 'b').
Вспомогательная переменная отладчика '$bpnum' хранит номер последней
установленной вами точки останова; смотрите *note Вспомогательные
переменные: Вспомогательные переменные, для обсуждения того, что вы
можете делать со вспомогательными переменными.

   Вы можете задавать место для установки новой точки останова
несколькими способами.

'break ФУНКЦИЯ'
     Установить точку останова на входе в функцию ФУНКЦИЯ.  При
     использовании языков, допускающих перегрузку символов, таких как
     Си++, ФУНКЦИЯ может ссылаться более чем на одно возможное место
     останова.  *Note Меню точки останова: Меню точки останова, для
     обсуждения такой ситуации.

'break +СМЕЩЕНИЕ'
'break -СМЕЩЕНИЕ'
     Установить точку останова через несколько строк впереди или сзади
     от позиции, на которой выполнение остановилось в текущем выбранном
     "кадре стека".  (*Note Кадры стека: Кадры, для описания кадров
     стека.)

'break НОМЕР-СТРОКИ'
     Установить точку останова на строке НОМЕР-СТРОКИ в текущем исходном
     файле.  Текущий исходный файл -- это файл, исходный текст которого
     отображался последним.  Точка останова остановит вашу программу
     сразу перед выполнением какого-либо кода на этой строке.

'break ИМЯ-ФАЙЛА:НОМЕР-СТРОКИ'
     Установить точку останова на строке НОМЕР-СТРОКИ в исходном файле
     ИМЯ-ФАЙЛА.

'break ИМЯ-ФАЙЛА:ФУНКЦИЯ'
     Установить точку останова на входе в ФУНКЦИЮ, находящуюся в файле
     ИМЯ-ФАЙЛА.  Указание имени файла вместе с именем функции является
     излишним, за исключением ситуаций, когда несколько файлов содержат
     одинаково названные функции.

'break *АДРЕС'
     Установить точку останова по адресу АДРЕС.  Вы можете использовать
     это для установки точек останова в тех частях вашей программы,
     которые не имеют отладочной информации или исходных файлов.

'break'
     При вызове без аргументов, 'break' устанавливает точку останова на
     инструкции, которая должна быть выполнена следующей в выбранном
     кадре стека (*note Исследование стека: Стек.).  В любом выбранном
     кадре, кроме самого внутреннего, это останавливает вашу программу,
     как только управление возвращается в этот кадр.  Это похоже на
     результат команды 'finish' в кадре внутри выбранного кадра -- за
     исключением того, что 'finish' не оставляет активной точки
     останова.  Если вы используете 'break' без аргументов в самом
     внутреннем кадре, GDB останавливается, когда в следующий раз
     достигает текущего места; это может быть полезно внутри циклов.

     Обычно GDB игнорирует точки останова, когда он возобновляет
     выполнение, пока не будет выполнена хотя бы одна инструкция.  Если
     бы он этого не делал, вы не могли бы продолжать выполнение после
     точки останова, не отключив сперва ее.  Это правило применяется вне
     зависимости от того, существовала или нет точка останова, когда
     ваша программа остановилась.

'break ... if УСЛ'
     Установить точку останова с условием УСЛ; каждый раз, когда
     достигается эта точка останова, происходит вычисление выражения
     УСЛ, и остановка происходит, только если эта величина не равна нулю
     -- то есть, если УСЛ истинно.  '...' означает один из возможных
     аргументов, перечисленных выше (или отсутствие аргументов),
     описывающих место остановки.  *Note Условия остановки: Условия, для
     большей информации об условных точках останова.

'tbreak АРГ'
     Установить точку останова только до первой активизации.  Аргументы
     АРГ такие же, как для команды 'break', и точка останова
     устанавливается аналогичным образом, но она автоматически
     уничтожается после того, как ваша программа первый раз на ней
     остановится.  *Note Отключение точек останова: Отключение.

'hbreak АРГ'
     Установить аппаратно-поддерживаемую точку останова.  Аргументы АРГ
     такие же, как и для команды 'break', и точка останова
     устанавливается аналогичным образом, но она требует аппаратной
     поддержки, и некоторые целевые платформы могут ее не иметь.
     Основной целью этого является отладка кода EPROM/ROM, так что вы
     можете установить точку останова на инструкции без изменения
     инструкции.  Это может быть использовано с новой генерацией
     ловушек, предоставляемой SPARClite DSU и некоторыми машинами на
     базе x86.  Эти платформы будут генерировать ловушки, когда
     программа обращается к некоторым данным или адресу инструкции,
     которые назначены регистрам отладки.  Однако, регистры аппаратных
     точек останова могут хранить ограниченное число точек останова.
     Например, на DSU, только две точки останова могут быть установлены
     одновременно, и GDB будет отвергать эту команду, если используется
     больше.  Удалите или отключите неиспользуемые аппаратные точки
     останова перед установкой новых (*note Отключение точек останова:
     Отключение.).  *Note Условия останова: Условия.

'thbreak АРГ'
     Установить аппаратно-поддерживаемую точку останова, включенную
     только до первой активизации.  Аргументы АРГ такие же, как и для
     команды 'hbreak', и точка останова устанавливается аналогичным
     образом.  Однако, как в случае команды 'tbreak', точка останова
     автоматически уничтожается после того, как программа первый раз на
     ней остановится.  Также, как и в случае команды 'hbreak', точка
     останова требует аппаратной поддержки и некоторые аппаратные
     платформы могут ее не иметь.  *Note Отключение точек останова:
     Отключение.  Смотрите также *note Условия остановки: Условия.

'rbreak РЕГ-ВЫР'
     Установить точки останова на всех функциях, удовлетворяющих
     регулярному выражению РЕГ-ВЫР.  Эта команда устанавливает
     безусловные точки останова при всех совпадениях, выводя список всех
     установленных точек останова.  После установки, они рассматриваются
     точно так же, как точки останова, установленные командой 'break'.
     Вы можете удалять их, отключать или делать их условными таким же
     способом, как любые другие точки останова.

     Регулярные выражения имеют стандартный синтаксис, используемый
     такими средствами, как 'grep'.  Заметьте, что это отличается от
     синтаксиса, используемого оболочками; так, например, 'foo*'
     подходит для всех функций, которые включают 'fo', за которым
     следует любое число букв 'o'.  Существует неявное '.*' в начале и в
     конце введенного вами регулярного выражения, так что для нахождения
     только тех функций, которые начинаются на 'foo', используйте
     '^foo'.

     При отладке программ, написанных на Си++, 'rbreak' полезна для
     установки точек останова на перегруженных функциях, не являющихся
     членами никакого специального класса.

'info breakpoints [N]'
'info break [N]'
'info watchpoints [N]'
     Вывести таблицу всех установленных и не удаленных точек останова,
     наблюдения и перехвата, со следующими колонками для каждой точки:

     _Номер точки останова_
     _Тип_
          Точка останова, наблюдения или перехвата.
     _План_
          Помечена ли точка останова для отключения или удаления после
          активации.
     _Включена или отключена_
          Включенные точки останова помечаются как 'y'.  'n' отмечает
          отключенные точки.
     _Адрес_
          Адрес памяти, где расположена точка останова в вашей
          программе.
     _Где_
          Файл и номер строки, где расположена точка останова в исходном
          файле.

     Если точка останова условная, 'info break' показывает условие на
     строке, следующей за этой точкой; команды точки останова, если они
     есть, перечисляются после этого.

     'info break' с номером точки останова N в качестве аргумента
     отображает только эту точку.  Вспомогательная переменная '$_' и
     адрес по умолчанию для исследования для команды 'x' устанавливаются
     равными адресу последней из перечисленных точек останова (*note
     Исследование памяти: Память.).

     'info break' отображает то число раз, которое точка останова была
     активирована.  Это особенно полезно при использовании вместе с
     командой 'ignore'.  Вы можете игнорировать большое число активаций
     точки останова, посмотреть информацию о точке останова, чтобы
     узнать, сколько раз она активировалась, и затем запустить заново,
     игнорируя на единицу меньше, чем это число.  Это быстро приведет
     вас к последней активации этой точки останова.

   GDB позволяет вам установить любое число точек останова в одном и том
же месте вашей программы.  В этом нет ничего глупого или бессмысленного.
Когда точки останова являются условными, это даже полезно (*note Условия
останова: Условия.).

   GDB иногда сам устанавливает точки останова в вашей программе для
специальных целей, таких как правильная обработка 'longjmp' (в
программах на Си).  Этим внутренним точкам останова присваиваются
отрицательные номера, начиная с '-1'; 'info breakpoints' не отображает
их.

   Вы можете увидеть эти точки останова с помощью служебной команды GDB
'maint info breakpoints'.

'maint info breakpoints'
     Используя тот же формат, что и 'info breakpoints', отобразить как
     точки останова, установленные вами явно, так и те, которые GDB
     использует для внутренних целей.  Внутренние точки останова
     показываются с отрицательными номерами.  Колонка типа определяет,
     какого типа точка останова показана:

     'breakpoint'
          Обычная, явно установленная точка останова.

     'watchpoint'
          Обычная, явно установленная точка наблюдения.

     'longjmp'
          Внутренняя точка останова, используемая для корректной
          обработки пошагового выполнения вызовов 'longjmp'.

     'longjmp resume'
          Внутренняя точка останова на цели 'longjmp'.

     'until'
          Временная внутренняя точка останова, используемая командой GDB
          'until'.

     'finish'
          Временная внутренняя точка останова, используемая командой GDB
          'finish'.

     'shlib events'
          События в разделяемых библиотеках.


File: gdb.info,  Node: Установка точек наблюдения,  Next: Установка точек перехвата,  Prev: Установка точек останова,  Up: Точки останова

5.1.2 Установка точек наблюдения
--------------------------------

Вы можете использовать точку наблюдения для остановки выполнения, как
только изменится значение какого-либо выражения, не предсказывая
конкретное место, где это может произойти.

   В зависимости от вашей системы, точки наблюдения могут быть
реализованы программно или аппаратно.  GDB осуществляет программную
реализацию точек наблюдения путем пошагового выполнения вашей программы
и проверки значения переменной на каждом шаге, что в сотни раз медленнее
нормального выполнения.  (Но, тем не менее, это того стоит, если нужно
найти ошибку в программе, когда вы не представляете, в какой части она
находится.)

   В некоторых системах, таких как HP-UX, Linux и некоторых других
платформах, базирующихся на x86, GDB включает поддержку для аппаратных
точек наблюдения, которые не замедляют выполнение вашей программы.

'watch ВЫРАЖ'
     Устанавливает точку наблюдения за выражением.  GDB остановит
     программу, когда ВЫРАЖ сохраняется программой, и его значение
     изменяется.

'rwatch ВЫРАЖ'
     Устанавливает точку наблюдения, которая остановит программу, когда
     наблюдаемое ВЫРАЖ считывается программой.

'awatch ВЫРАЖ'
     Устанавливает точку наблюдения, которая остановит программу, когда
     ВЫРАЖ либо считывается, либо сохраняется программой.

'info watchpoints'
     Эта команда печатает список точек наблюдения, останова и перехвата;
     это то же самое, что и 'info break'.

   Когда это возможно, GDB устанавливает "аппаратную точку наблюдения".
Аппаратные точки наблюдения выполняются очень быстро, и отладчик
сообщает об изменении значения точно в месте инструкции, где это
изменение произошло.  Если GDB не может установить аппаратную точку
наблюдения, он устанавливает программную точку наблюдения, которая
выполняется намного медленнее и сообщает об изменении значения на
следующем операторе, а не инструкции, после появления изменения.

   Когда вы даете команду 'watch', GDB сообщает

     Hardware watchpoint НОМЕР: ВЫРАЖ

если ему удалось установить аппаратную точку наблюдения.

   В настоящее время, команды 'awatch' и 'rwatch' могут устанавливать
только аппаратные точки наблюдения, так как доступы к данным, которые не
изменяют величины наблюдаемого выражения, не могут быть замечены без
исследования каждой инструкции во время ее выполнения, а GDB пока этого
не делает.  Если GDB обнаруживает, что не может установить аппаратную
точку останова командами 'awatch' или 'rwatch', он напечатает сообщение,
аналогичное этому:

     Expression cannot be implemented with read/access watchpoint.(1)

   Иногда GDB не может установить аппаратную точку наблюдения из-за
того, что тип данных наблюдаемого выражения занимает больше места, чем
допускает аппаратная точка наблюдения на целевой платформе.  Например,
некоторые системы позволяют наблюдать за областями, занимающими до 4
байт; на таких системах вы не можете устанавливать аппаратные точки
наблюдения за выражениями, которые в результате дают число с плавающей
точкой двойной точности (которое обычно занимает 8 байт).  В качестве
одного из решений, можно разбить большую область на несколько меньших
областей, и затем наблюдать за каждой из них с помощью отдельной точки
наблюдения.

   Если вы установите слишком много аппаратных точек наблюдения, GDB
может быть не в состоянии задействовать их все, когда вы возобновите
выполнение вашей программы.  Так как точное количество активных точек
наблюдения неизвестно до того момента, как ваша программа должна
возобновить выполнение, GDB может быть не в состоянии предупредить вас
об этом, когда вы устанавливаете точку наблюдения, и предупреждение
будет напечатано, только когда программа возобновит выполнение:

     Hardware watchpoint НОМЕР: Could not insert watchpoint(2)

Если это происходит, удалите или отключите некоторые точки наблюдения.

   SPARClite DSU будет генерировать ловушки, когда программа обращается
к некоторым данным или адресу инструкции, которые отведены для
отладочных регистров.  Для адресов данных, DSU упрощает команду 'watch'.
Однако, аппаратные регистры точек останова могут принять только две
точки наблюдения за данными, и обе точки наблюдения должны быть одного
типа.  Например, вы можете установить две точки наблюдения с помощью
команды 'watch', две с помощью команды 'rwatch', *или* две с помощью
команды 'awatch', но вы не можете установить одну точку наблюдения с
помощью одной команды, а другую с помощью другой.  GDB не примет
команду, если вы попытаетесь совместить различные точки наблюдения.
Удалите или отключите неиспользуемые точки наблюдения перед установкой
новых.

   Если вы вызываете функцию интерактивно, используя 'print' или 'call',
все установленные вами точки наблюдения будут неактивными до тех, пор
пока GDB не достигнет точки останова другого типа, или пока вызов не
завершится.

   GDB автоматически удаляет точки наблюдения, которые наблюдают за
локальными переменными или за выражениями, которые используют такие
переменные, когда они выходят из области видимости, то есть когда
выполнение покидает блок, в котором эти переменные были определены.  В
частности, когда отлаживаемая программа завершается, _все_ локальные
переменные выходят из области видимости, и таким образом остаются
установленными только те точки наблюдения, которые наблюдают за
глобальными переменными.  Если вы снова запустите программу, вы должны
будете заново установить все такие точки наблюдения.  Одним из способов
сделать это будет установить точку останова на входе в функцию 'main',
и, когда программа остановится, установить все остальные точки
наблюдения.

     _Предупреждение:_ В многонитевых программах точки наблюдения
     являются лишь частично полезными.  С текущей реализацией точек
     наблюдения, GDB может наблюдать за величиной выражения только _в
     одной нити_.  Если вы уверены, что выражение может измениться
     только вследствие действий внутри текущей нити (и если вы также
     уверены, что никакая другая нить не может стать текущей), то вы
     можете использовать точки наблюдения как обычно.  Однако, GDB может
     не заметить, когда действия в другой нити изменяют выражение.

     _Предупреждение для HP-UX:_ В многонитевых программах программные
     точки наблюдения являются лишь частично полезными.  Если GDB
     создает программную точку наблюдения, она может наблюдать за
     величиной выражения только _в одной нити_.  Если вы уверены, что
     выражение может измениться только вследствие действий внутри
     текущей нити (и если вы также уверены, что никакая другая нить не
     может стать текущей), то вы можете использовать программные точки
     наблюдения как обычно.  Однако, GDB может не заметить, когда
     действия в другой нити изменяют выражение.  (Аппаратные же точки
     наблюдения напротив, наблюдают за выражением во всех нитях.)

   ---------- Footnotes ----------

   (1) Выражение не может быть реализовано с помощью точки наблюдения
чтения/доступа.  (Прим. переводчика)

   (2) Аппаратная точка наблюдения НОМЕР: Не удается поместить точку
наблюдения (Прим. переводчика)


File: gdb.info,  Node: Установка точек перехвата,  Next: Удаление точек останова,  Prev: Установка точек наблюдения,  Up: Точки останова

5.1.3 Установка точек перехвата
-------------------------------

Вы можете использовать "точки перехвата", чтобы вызвать остановку
отладчика в ответ на определенные типы событий в программе, такие как
исключения в Си++ или загрузка разделяемой библиотеки.  Для установки
точки перехвата используйте команду 'catch'.

'catch СОБЫТИЕ'
     Остановиться, когда происходит СОБЫТИЕ.  СОБЫТИЕ может быть одним
     из:
     'throw'
          Выбрасывание исключения Си++.

     'catch'
          Перехват исключения Си++.

     'exec'
          Вызов 'exec'.  В настоящее время это доступно только на HP-UX.

     'fork'
          Вызов 'fork'.  В настоящее время это доступно только на HP-UX.

     'vfork'
          Вызов 'vfork'.  В настоящее время это доступно только на
          HP-UX.

     'load'
     'load ИМЯ-БИБЛ'
          Динамическая загрузка любой разделяемой библиотеки или
          загрузка библиотеки ИМЯ-БИБЛ.  В настоящее время это доступно
          только на HP-UX.

     'unload'
     'unload ИМЯ-БИБЛ'
          Выгрузка любой динамически загруженной разделяемой библиотеки
          или выгрузка библиотеки ИМЯ-БИБЛ.  В настоящее время это
          доступно только на HP-UX.

'tcatch СОБЫТИЕ'
     Установить точку перехвата, которая включена только до первой
     активации.  Точка перехвата автоматически уничтожается после того,
     как событие перехвачено первый раз.

   Используйте команду 'info break' для получения списка текущих точек
перехвата.

   В настоящее время, в GDB существуют некоторые ограничения на
обработку исключений Си++ ('catch throw' и 'catch catch'):

   * Если вы вызываете функцию интерактивно, GDB обычно возвращает вам
     управление после того, как функция закончила выполнение.  Однако,
     если вызов возбуждает исключение, он может обойти механизм,
     возвращающий вам управление, и заставить вашу программу либо
     остановиться, либо просто продолжить выполнение до тех пор, пока
     она не активирует точку останова, получит сигнал, который ждет GDB,
     или выйдет.  Это имеет место, даже если вы установите точку
     перехвата для исключения; точки перехвата для исключений отключены
     при интерактивных вызовах.

   * Вы не можете возбуждать исключения интерактивно.

   * Вы не можете интерактивно установить обработчик исключения.

   Иногда 'catch' не является лучшим способом отладки обработки
исключений: если вам необходимо точно знать, где исключение возбуждено,
то лучше остановиться _до_ того, как вызван обработчик исключения, так
как в этом случае вы можете увидеть стек до того, как произойдет
какое-либо развертывание.  Если вместо этого вы установите точку
останова в обработчике исключений, то может быть нелегко определить, где
исключение было возбуждено.

   Для остановки сразу перед вызовом обработчика исключений, вам
необходимы некоторые знания о реализации.  В случае GNU Си++, исключения
возбуждаются путем вызова библиотечной функции '__raise_exception',
которая имеет следующий интерфейс ANSI Си:

         /* ADDR -- где хранится идентификатор исключения.
            ID -- идентификатор исключения.  */
         void __raise_exception (void **addr, void *id);

Для того, чтобы отладчик перехватывал все исключения до того, как
произойдет развертывание стека, установите точку останова на
'__raise_exception' (*note Точки останова: (точки наблюдения и точки
перехвата)Точки останова.).

   С помощью условных точек останова (*note Условия останова: Условия.),
зависящих от значения ID, вы можете остановить вашу программу, когда
возбуждается определенное исключение.  Вы можете использовать несколько
условных точек останова, чтобы остановить программу, когда возбуждается
любое из нескольких исключений.


File: gdb.info,  Node: Удаление точек останова,  Next: Отключение,  Prev: Установка точек перехвата,  Up: Точки останова

5.1.4 Удаление точек останова
-----------------------------

Часто бывает необходимо уничтожить точку останова, наблюдения или
перехвата, когда она сделала свое дело, и вы больше не хотите
останавливать там свою программу.  Это называется "уничтожением" точки
останова.  Точка останова, которая была уничтожена, более не существует;
она забыта.

   С помощью команды 'clear' вы можете удалять точки останова в
соответствии с тем, где они находятся в вашей программе.  С помощью
команды 'delete' вы можете удалять отдельные точки останова, наблюдения
или перехвата, указывая их номера.

   Не обязательно удалять точку останова, чтобы продолжить выполнение
после нее.  GDB автоматически игнорирует точки останова на первой
инструкции, которая должна быть выполнена, когда вы продолжаете
исполнение без изменения адреса выполнения.

'clear'
     Удаляет любые точки останова, установленные на следующей
     инструкции, которая должна быть выполнена в выбранном кадре стека
     (*note Выбор кадра: Выбор.).  Когда выбран самый внутренний кадр,
     это хороший способ удалить ту точку останова, на которой ваша
     программа только что остановилась.

'clear ФУНКЦИЯ'
'clear ИМЯ-ФАЙЛА:ФУНКЦИЯ'
     Удалить любые точки останова, установленные на входе в ФУНКЦИЮ.

'clear НОМЕР-СТРОКИ'
'clear ИМЯ-ФАЙЛА:НОМЕР-СТРОКИ'
     Удалить все точки останова, установленные на или внутри кода на
     указанной строке.

'delete [breakpoints] [ДИАПАЗОН...]'
     Удалить точки останова, наблюдения или перехвата из диапазона,
     указанного в качестве аргумента.  Если аргумент не задан, удалить
     все точки останова (GDB запрашивает подтверждение, если у вас не
     установлено 'set confirm off').  Вы можете сократить это команду
     как 'd'.


File: gdb.info,  Node: Отключение,  Next: Условия,  Prev: Удаление точек останова,  Up: Точки останова

5.1.5 Отключение точек останова
-------------------------------

Вместо того, чтобы удалять точку останова, наблюдения или перехвата, вам
может быть удобнее "отключить" ее.  Это делает точку останова
бездействующей, как если бы она была удалена, но информация о ней
запоминается, так что вы можете позже "включить" ее снова.

   Вы отключаете и включаете точки останова, наблюдения и перехвата
командами 'enable' и 'disable', возможно, указывая один или более
номеров точек останова в качестве аргументов.  Используйте 'info break'
или 'info watch' для распечатки списка точек останова, наблюдения и
перехвата, если вы не знаете, какие номера использовать.

   Точка останова, наблюдения или перехвата может находиться в одном из
четырех состояний:

   * Включена.  Точка останова останавливает вашу программу.  Точка
     останова, установленная командой 'break', изначально находится в
     таком состоянии.
   * Отключена.  Точка останова не оказывает воздействия на вашу
     программу.
   * Включена до первого срабатывания.  Точка останова останавливает
     вашу программу, но потом становится отключенной.
   * Включена для удаления.  Точка останова останавливает вашу
     программу, но сразу после этого она удаляется навсегда.  Точка
     останова, установленная командой 'tbreak', изначально находится в
     этом состоянии.

   Вы можете использовать следующие команды для включения или отключения
точек останова, наблюдения и перехвата:

'disable [breakpoints] [ДИАПАЗОН...]'
     Отключить указанные точки останова или все точки останова, если ни
     одна не перечислена.  Отключенная точка останова не оказывает
     никакого действия, но она не забывается.  Все параметры, такие как
     счетчик игнорирований, условия и команды запоминаются на случай,
     если точка останова позже будет снова включена.  Вы можете
     сокращать 'disable' как 'dis'.

'enable [breakpoints] [ДИАПАЗОН...]'
     Включает указанные (или все определенные) точки останова.  Они
     снова становятся значимыми для остановки вашей программы.

'enable [breakpoints] once ДИАПАЗОН...'
     Временно включить указанные точки останова.  GDB отключает любую из
     этих точек останова немедленно после срабатывания.

'enable [breakpoints] delete ДИАПАЗОН...'
     Включить указанные точки останова до первого срабатывания, затем
     уничтожить.  GDB удаляет любую из этих точек останова, как только
     ваша программа останавливается на ней.

   Кроме точек останова, установленных командой 'tbreak' (*note
Установка точек останова: Установка точек останова.), установленные вами
точки останова изначально включены; следовательно, они становятся
отключенными или включенными, только когда вы используете одну из
вышеперечисленных команд.  (Команда 'until' может устанавливать и
удалять свою собственную точку останова, но она не изменяет состояние
других точек останова; см.  *note Продолжение и выполнение по шагам:
Продолжение и пошаговое выполнение.)


File: gdb.info,  Node: Условия,  Next: Команды останова,  Prev: Отключение,  Up: Точки останова

5.1.6 Условия останова
----------------------

Простейшая точка останова останавливает вашу программу каждый раз, когда
управление достигает заданного места.  Вы можете также указать "условие"
для точки останова.  Условие является просто булевым выражением в вашем
языке программирования (*note Выражения: Выражения.).  Точка останова с
условием вычисляет выражение каждый раз, когда ваша программа достигает
ее, и ваша программа остановится только в том случае, если условие
_истинно_.

   Это противоположно использованию утверждений для проверки
правильности программы; в этом случае, вы хотите остановиться, когда
утверждение нарушается -- то есть, когда условие ложно.  В Си, если вы
хотите проверить утверждение, выраженное условием ASSERT, вы должны
установить условие '! ASSERT' на соответствующей точке останова.

   Условия также допускаются для точек наблюдения; вам они могут не
понадобиться, так как точка наблюдения так или иначе контролирует
значение выражения -- но может оказаться проще, скажем, просто
установить точку наблюдения на имя переменной и указать условие,
проверяющее, является ли новое значение тем, которое нас интересует.

   Условия останова могут иметь побочные эффекты и даже могут вызывать
функции в вашей программе.  Это может быть полезным, например, для
активации функций, которые запоминают продвижение выполнения вашей
программы, или для использования ваших собственных функций печати для
форматирования специальных структур данных.  Результаты полностью
предсказуемы, если нет другой включенной точки останова по тому же
адресу.  (В этом случае, GDB может сначала увидеть другую точку останова
и остановить вашу программу программу без проверки условия первой точки
останова.)  Заметьте, что для выполнения побочных эффектов при
достижении точки останова обычно более удобны и гибки команды точек
останова, а не условия останова (*note Команды точки останова: Команды
останова.).

   Условия останова можно задать в момент установки точки останова,
используя 'if' в аргументах команды 'break'.  *Note Установка точек
останова: Установка точек останова.  Они могут быть также изменены в
любой момент с помощью команды 'condition'.

   Вы также можете использовать ключевое слово 'if' с командой 'watch'.
Команда 'catch' не распознает ключевое слово 'if'; 'condition' является
единственным способом наложить дальнейшие условия на точку перехвата.

'condition НОМЕР ВЫРАЖЕНИЕ'
     Задайте ВЫРАЖЕНИЕ как условие остановки для точки останова,
     наблюдения или перехвата с номером НОМЕР.  После того, как вы
     установили условие, данная точка останова остановит вашу программу,
     только если значение ВЫРАЖЕНИЯ будет истинным (ненулевым, в Си).
     Когда вы используете 'condition', GDB немедленно проверяет
     ВЫРАЖЕНИЕ на синтаксическую корректность и на тот факт, что символы
     в нем ссылаются на реальные объекты в контексте данной точки
     останова.  Если ВЫРАЖЕНИЕ использует символы, не существующие в
     контексте точки останова, GDB выведет сообщение об ошибке:

          No symbol "foo" in current context.(1)

     Однако, GDB в действительности не вычисляет ВЫРАЖЕНИЕ в момент
     подачи команды 'condition' (или команды, устанавливающей точку
     останова с условием, такой как 'break if ...').  *Note Выражения:
     Выражения.

'condition НОМЕР'
     Снимает условие с точки останова с номером НОМЕР.  Она становится
     обычной безусловной точкой останова.

   Специальным случаем условия для точки останова является остановка
только тогда, когда точка останова была достигнута определенное число
раз.  Это настолько полезно, что существует специальный способ сделать
это, используя "счетчик игнорирования".  Каждая точка останова имеет
счетчик игнорирования, являющийся целым числом.  Как правило, счетчик
игнорирования равен нулю и, следовательно, не производит никакого
действия.  Но если ваша программа достигает точки останова, чей счетчик
игнорирования положителен, тогда вместо того чтобы остановиться, она
лишь уменьшит его на единицу и продолжит выполнение.  В результате, если
величина счетчика игнорирования равна N, точка останова не остановит
программу следующие N раз, когда программа его достигнет.

'ignore НОМЕР ЗНАЧЕНИЕ'
     Устанавливает счетчик игнорирований точки останова с номером НОМЕР
     в ЗНАЧЕНИЕ.  Следующие ЗНАЧЕНИЕ раз, когда точка останова будет
     достигнута, выполнение вашей программы не будет остановлено; GDB не
     производит никаких действий, только уменьшает счетчик
     игнорирований.

     Чтобы точка останова сработала при следующем достижении, установите
     счетчик в ноль.

     Когда вы используете 'continue' для возобновления выполнения вашей
     программы от точки останова, вы можете установить счетчик
     игнорирований непосредственно как аргумент к 'continue', а не
     использовать 'ignore'.  *Note Продолжение и выполнение по шагам:
     Продолжение и пошаговое выполнение.

     Если точка останова имеет положительный счетчик игнорирований и
     условие, то условие не проверяется.  Как только счетчик
     игнорирований достигнет нуля, GDB возобновит проверку условия.

     Вы можете достигнуть эффекта счетчика игнорирований с помощью
     такого условия, как '$foo-- <= 0', используя вспомогательную
     переменную отладчика, которая уменьшается каждый раз.  *Note
     Вспомогательные переменные: Вспомогательные переменные.

   Счетчики игнорирований можно использовать с точками останова, точками
наблюдения и точками перехвата.

   ---------- Footnotes ----------

   (1) В текущем контексте нет символа "foo".  (Прим. переводчика)


File: gdb.info,  Node: Команды останова,  Next: Меню точки останова,  Prev: Условия,  Up: Точки останова

5.1.7 Команды точки останова
----------------------------

Вы можете подать любой точке останова (наблюдения или перехвата) ряд
команд, которые будут выполняться при остановке вашей программы на этой
точке останова.  Например, вы можете захотеть вывести значения
определенных выражений, или включить другие точки останова.

'commands [НОМЕР]'
'... СПИСОК-КОМАНД ...'
'end'
     Определяет список команд для точки останова с номером НОМЕР.  Сами
     команды указываются в следующих строках.  Для завершения списка
     команд, введите строку, содержащую только 'end'.

     Чтобы удалить все команды точки останова, введите 'commands' и
     потом сразу 'end', то есть задайте пустой список команд.

     Без аргумента НОМЕР, 'commands' относится к последней установленной
     точке останова, наблюдения или перехвата (но не к последней
     встреченной).

   Нажатие <RET>, как средство повторения последней команды GDB,
отключено внутри СПИСКА-КОМАНД.

   Вы можете использовать команды для точки останова, чтобы снова
запустить вашу программу на выполнение.  Просто используйте команду
'continue', или 'step', или любую другую команду, возобновляющую
выполнение.

   После команды, возобновляющей выполнение, любые другие команды в
списке игнорируются.  Так сделано потому, что каждый раз, когда вы
возобновляете выполнение (даже просто с помощью 'next' или 'step'), вы
можете встретить другую точку останова -- которая может иметь свой
собственный список команд, что приведет к неоднозначности, какой из
списков выполнять.

   Если в качестве первой команды в списке вы укажете 'silent', обычное
сообщение об остановке на точке останова не будет выводиться.  Это может
быть желательно для точек останова, которые должны вывести определенное
сообщение и затем продолжить выполнение.  Если никакая из оставшихся
команд ничего не выводит, вы не увидите никакого знака о том, что точка
останова была достигнута.  'silent' имеет смысл только в начале списка
команд точки останова.

   Команды 'echo', 'output' и 'printf' позволяют вам более точно
контролировать выводимый текст, и часто полезны в "тихих" точках
останова.  *Note Команды управления выводом: Вывод.

   Например, вот как вы можете использовать команды точки останова для
вывода величины 'x' на входе в 'foo', когда 'x' положительна.

     break foo if x>0
     commands
     silent
     printf "x is %d\n",x
     cont
     end

   Одним из применений команд точки останова является компенсация одной
ошибки, так, чтобы вы могли искать другую.  Поместите точку останова
сразу после строки кода, содержащей ошибку, задайте ей условие для
определения случая, в котором было сделано что-то ошибочное, и
определите команды для присвоения правильных значений тем переменным,
для которых это требуется.  Закончите командой 'continue', чтобы ваша
программа не останавливалась, а начните с команды 'silent', чтобы не
было никакого вывода.  Вот пример:

     break 403
     commands
     silent
     set x = y + 4
     cont
     end


File: gdb.info,  Node: Меню точки останова,  Next: Ошибки в точках останова,  Prev: Команды останова,  Up: Точки останова

5.1.8 Меню точки останова
-------------------------

Некоторые языки программирования (особенно Си++) допускают, чтобы одно и
то же имя функции было определено несколько раз, для применения в
различных контекстах.  Это называется "перегрузкой".  Когда имя функции
перегружается, простой записи 'break ФУНКЦИЯ' недостаточно, чтобы
указать GDB, где вы хотите установить точку останова.  Если вы
столкнулись с этой проблемой, вы можете использовать что-то вроде 'break
ФУНКЦИЯ(ТИПЫ)' для указания, какую конкретную версию функции вы имеете в
виду.  В противном случае, GDB предлагает вам выбор из пронумерованных
вариантов для различных возможных точек останова и ждет вашего выбора с
приглашением '>'.  Первыми двумя вариантами всегда являются '[0] cancel'
и '[1] all'.  Ввод '1' устанавливает точку останова на каждом
определении ФУНКЦИИ, а ввод '0' прерывает команду 'break' без установки
новых точек останова.

   Например, следующая выдержка из сеанса иллюстрирует попытку
установить точку останова на перегруженном символе 'String::after'.  Мы
выбрали три конкретных определения имени функции:

     (gdb) b String::after
     [0] cancel
     [1] all
     [2] file:String.cc; line number:867
     [3] file:String.cc; line number:860
     [4] file:String.cc; line number:875
     [5] file:String.cc; line number:853
     [6] file:String.cc; line number:846
     [7] file:String.cc; line number:735
     > 2 4 6
     Breakpoint 1 at 0xb26c: file String.cc, line 867.
     Breakpoint 2 at 0xb344: file String.cc, line 875.
     Breakpoint 3 at 0xafcc: file String.cc, line 846.
     Multiple breakpoints were set.
     Use the "delete" command to delete unwanted
      breakpoints.
     (gdb)


File: gdb.info,  Node: Ошибки в точках останова,  Prev: Меню точки останова,  Up: Точки останова

5.1.9 "Не удается поместить точки останова"
-------------------------------------------

В некоторых операционных системах точки останова не могут быть
использованы в программе, если какой-либо другой процесс выполняет эту
программу.  В этом случае, попытка выполнить или продолжить выполнение
программы с точкой останова приводит к тому, что GDB печатает сообщение
об ошибке:

     Cannot insert breakpoints.
     The same program may be running in another process.(1)

   Когда это происходит, у вас есть три варианта дальнейших действий:

  1. Удалить или отключить точки останова и затем продолжить.

  2. Приостановить GDB и скопировать файл, содержащий вашу программу,
     под другим именем.  Возобновить работу GDB и использовать команду
     'exec-file' для указания, что GDB должен выполнять вашу программу
     под этим именем.  Затем запустите программу снова.

  3. Скомпоновать заново вашу программу так, чтобы сегмент текста был
     неразделяемым, используя ключ компоновщика '-N'.  Ограничения
     операционной системы могут не распространяться на неразделяемые
     выполняемые файлы.

   Аналогичное сообщение может выводиться, если вы запрашиваете слишком
много активных аппаратно-поддерживаемых точек останова и наблюдения:

     Stopped; cannot insert breakpoints.
     You may have requested too many hardware breakpoints and watchpoints.(2)

Это сообщение выводится, когда вы пытаетесь возобновить выполнение
программы, так как только тогда GDB знает точно, сколько аппаратных
точек останова и наблюдения ему нужно установить.

   Когда вы видите это сообщение, вам необходимо отключить или удалить
некоторые аппаратно-поддерживаемые точки останова и наблюдения и затем
продолжить.

   ---------- Footnotes ----------

   (1) Не удается поместить точки останова.  Возможно, эта программа
выполняется в другом процессе.  (Прим. переводчика)

   (2) Остановлено; не удается поместить точки останова.  Возможно, вы
запросили слишком много аппаратно-поддерживаемых точек останова и
наблюдения.  (Прим. переводчика)


File: gdb.info,  Node: Продолжение и пошаговое выполнение,  Next: Сигналы,  Prev: Точки останова,  Up: Остановка

5.2 Продолжение и выполнение по шагам
=====================================

"Продолжение" означает возобновление выполнения программы до ее
нормального завершения.  Напротив, "пошаговое выполнение" означает
выполнение еще одного "шага" вашей программы, где "шаг" быть либо одной
строкой исходного кода, либо одной машинной инструкцией (в зависимости
от того, какую именно команду вы используете).  И в случае продолжения,
и в случае выполнения по шагам, ваша программа может остановиться и
раньше, вследствие точки останова или сигнала.  (Если она
останавливается по сигналу, вы можете использовать 'handle', или 'signal
0' для возобновления выполнения.  *Note Сигналы: Сигналы.)

'continue [СЧЕТЧИК-ИГНОР]'
'c [СЧЕТЧИК-ИГНОР]'
'fg [СЧЕТЧИК-ИГНОР]'
     Возобновить выполнение программы с того адреса, где она
     остановилась последний раз; все точки останова, установленные по
     этому адресу, пропускаются.  Необязательный аргумент СЧЕТЧИК-ИГНОР
     позволяет вам задать количество последующих игнорирований точки
     останова в этом месте; его действие совпадает с действием 'ignore'
     (*note Условия останова: Условия.).

     Аргумент СЧЕТЧИК-ИГНОР имеет смысл, только если ваша программа
     остановилась в точке останова.  В остальных случаях аргумент к
     'continue' игнорируется.

     Синонимы 'c' и 'fg' (от "foreground", так как отлаживаемая
     программа считается фоновой), предоставляются исключительно для
     удобства и имеют в точности тот же смысл, что и 'continue'.

   Чтобы возобновить выполнение с другого места, вы можете использовать
'return' (*note Возврат из функции: Возврат.) чтобы вернуться назад к
вызывающей функции; или 'jump' (*note Продолжение с другого адреса:
Переходы.) для перехода к произвольному месту в вашей программе.

   Типичная техника для использования пошагового выполнения заключается
в установке точки останова (*note Точки останова: (точки наблюдения и
точки перехвата)Точки останова.) на начале функции или раздела вашей
программы, где предположительно находится ошибка, выполнении вашей
программы до остановки на этой точке останова, и затем пошаговом
выполнении подозреваемого участка, с исследованием интересуемых
переменных, пока вы не увидите, что случилась ошибка.

'step'
     Продолжить выполнение вашей программы, пока управление не достигнет
     другой строки исходного текста, затем остановить ее и вернуть
     управление GDB. Эту команду можно сокращать как 's'.

          _Предупреждение:_ Если вы используете команду 'step', когда
          управление находится внутри функции, которая была
          скомпилирована без отладочной информации, выполнение
          продолжается, пока управление не достигнет функции, которая
          _имеет_ ее.  Аналогично, пошаговое выполнение не будет
          заходить в функцию, скомпилированную без отладочной
          информации.  Для пошагового выполнения таких функций
          используйте команду 'stepi', описанную ниже.

     Команда 'step' останавливается только на первой инструкции строки
     исходного текста.  Это предотвращает множественные остановки,
     которые в противном случае могут возникнуть в операторе 'switch',
     цикле 'for', и так далее.  'step' продолжает останавливаться, если
     функция, имеющая отладочную информацию, вызывается внутри строки.
     Другими словами, 'step' _заходит внутрь_ функций, вызываемых в
     данной строке.

     Также, команда 'step' входит в функцию, только если для нее
     существует информация о номерах строк.  Иначе она действует, как
     команда 'next'.  Это позволяет избежать проблем, появляющихся при
     использовании 'cc -gl' на машинах MIPS. Раньше 'step' заходила в
     подпрограмму, если о ней существовала хоть какая-нибудь отладочная
     информация.

'step число'
     Продолжает выполнение, как по команде 'step', но делает это
     указанное ЧИСЛО раз.  Если до завершения указанного ЧИСЛА шагов
     достигается точка останова, или приходит сигнал, не связанный с
     пошаговым выполнением, пошаговое выполнение сразу останавливается.

'next [ЧИСЛО]'
     Продолжает выполнение до следующей строки исходного текста в
     текущем (внутреннем) кадре стека.  Это аналогично 'step', но вызовы
     функций, которые появляются внутри строки кода, выполняются без
     остановки.  Выполнение останавливается, когда управление достигает
     другой строки кода в исходном уровне стека, который выполнялся,
     когда вы дали команду 'next'.  Эта команда сокращается как 'n'.

     Аргумент ЧИСЛО является счетчиком повторений, как для 'step'.

     Команда 'next' останавливается только на первой инструкции исходной
     строки.  Это предотвращает множественные остановки, которые иначе
     могут возникнуть в операторах 'switch', циклах 'for' и так далее.

'set step-mode'
'set step-mode on'
     Команда 'set step-mode on' велит команде 'step' останавливаться на
     первой инструкции в функции, не содержащей отладочной информации о
     строках, а не выполнять ее без остановки.

     Это полезно в случаях, когда вы можете быть заинтересованы в
     изучении машинных инструкций функции, не имеющей символьной
     информации, и не хотите, чтобы GDB автоматически ее проскочил.

'set step-mode off'
     Велит команде 'step' выполнять все функции, не содержащие
     отладочной информации, без остановки.  Это значение используется по
     умолчанию.

'finish'
     Продолжить выполнение до возврата из функции в выбранном кадре
     стека.  Напечатать возвращенное значение (если таковое существует).

     Сравните это с командой 'return' (*note Возврат из функции:
     Возврат.).

'until'
'u'
     Продолжить выполнение до достижения строки исходного текста,
     следующей за текущей, в текущем кадре стека.  Эта команда
     используется для избежания выполнения цикла по шагам больше одного
     раза.  Она похожа на команду 'next', за исключением того, что когда
     'until' встречает переход, она автоматически продолжает выполнение,
     пока счетчик выполнения программы не станет больше, чем адрес
     перехода.

     Это означает, что когда вы достигаете конца цикла после его
     выполнения по шагам, 'until' продолжает выполнение вашей программы,
     пока она не выйдет из цикла.  Напротив, команда 'next' в конце
     цикла просто переходит назад в начало цикла, что заставляет вас
     выполнять по шагам следующую итерацию.

     'until' всегда останавливает вашу программу, если она пытается
     выйти из текущего кадра стека.

     'until' может привести к несколько неожиданным результатам, если
     порядок машинных кодов не совпадает с порядком строк исходного
     текста.  Например, в следующем отрывке сеанса отладки, команда 'f'
     ('frame') показывает, что выполнение остановилось на строке '206';
     хотя, когда мы используем 'until', мы переходим к строке '195':

          (gdb) f
          #0  main (argc=4, argv=0xf7fffae8) at m4.c:206
          206                 expand_input();
          (gdb) until
          195             for ( ; argc > 0; NEXTARG) {

     Это произошло потому, что для эффективности выполнения компилятор
     сгенерировал код для проверки окончания цикла в конце, а не в
     начале цикла -- даже если проверка в цикле 'for' Си написана до
     тела цикла.  Кажется, что команда 'until' переместилась назад к
     началу цикла, когда двигалась к этому выражению; однако, в
     действительности она не переходила к более раннему оператору -- в
     терминах фактического машинного кода.

     'until' без аргументов работает посредством пошагового выполнения
     отдельных инструкций, и, следовательно, является более медленной,
     чем 'until' с аргументом.

'until ПОЛОЖЕНИЕ'
'u ПОЛОЖЕНИЕ'
     Продолжить выполнение вашей программы, пока либо указанное место не
     будет достигнуто, либо не произойдет возврат из текущего кадра
     стека.  ПОЛОЖЕНИЕ может быть любой из доступных форм аргумента для
     'break' (*note Установка точек останова: Установка точек
     останова.).  Эта форма команды использует точки останова и,
     следовательно, является более быстрой, чем 'until' без аргумента.

'stepi'
'stepi АРГ'
'si'
     Выполнить одну машинную инструкцию, затем остановиться и вернуться
     в отладчик.

     При пошаговом выполнении машинных инструкций, часто бывает полезным
     сделать 'display/i $pc'.  Это велит GDB автоматически отображать
     инструкцию, которая будет выполняться следующей, каждый раз, когда
     ваша программа останавливается.  *Note Автоматическое отображение:
     Автоматическое отображение.

     Аргумент является счетчиком повторений, как для 'step'.

'nexti'
'nexti АРГ'
'ni'
     Выполнить одну машинную инструкцию, но если это вызов функции,
     продолжать до возврата из нее.

     Аргумент является счетчиком повторений, как для 'next'.


File: gdb.info,  Node: Сигналы,  Next: Остановка нитей,  Prev: Продолжение и пошаговое выполнение,  Up: Остановка

5.3 Сигналы
===========

Сигнал -- это асинхронное событие, которое может произойти в программе.
Операционная система определяет возможные типы сигналов и дает каждому
типу имя и номер.  В Unix, например, 'SIGINT' -- это сигнал, получаемый
программой, когда вы вводите знак прерывания (часто 'C-c'); 'SIGSEGV' --
сигнал, получаемый программой при ссылке на область памяти, отличную от
всех используемых областей; 'SIGALRM' появляется при срабатывании
интервального таймера (возникает, только если ваша программа запросила
временной сигнал).

   Некоторые сигналы, такие как 'SIGALRM', являются обычной частью
функционирования вашей программы.  Другие, такие как 'SIGSEGV',
обозначают ошибки; эти сигналы являются "фатальными" (они немедленно
убивают вашу программу), если программа не определила заранее другой
способ их обработки.  'SIGINT' не указывает на ошибку в вашей программе,
но обычно является фатальным, так что он может выполнять функцию
прерывания: убить программу.

   GDB способен обнаружить любое появление сигнала в вашей программе.
Вы можете заранее сообщить GDB, что делать для каждого типа сигнала.

   Обычно, GDB установлен так, чтобы игнорировать неошибочные сигналы,
такие как 'SIGALRM' (чтобы не мешать их действию при исполнении вашей
программы), но немедленно останавливать вашу программу всякий раз, когда
возникает сигнал об ошибке.  Вы можете изменить эти установки командой
'handle'.

'info signals'
'info handle'
     Напечатать таблицу всех типов сигналов и описания, как GDB будет
     обрабатывать каждый из них.  Вы можете использовать эту команду,
     чтобы посмотреть номера всех определенных типов сигналов.

     'info handle' является синонимом для 'info signals'.

'handle СИГНАЛ КЛЮЧЕВЫЕ-СЛОВА...'
     Изменить способ, которым GDB обрабатывает СИГНАЛ.  СИГНАЛ может
     быть номером сигнала или его именем (с 'SIG' или без него в
     начале).  КЛЮЧЕВЫЕ-СЛОВА определяют, какие сделать изменения.

   Ключевые слова, допускаемые командой 'handle', могут быть сокращены.
Вот их полные имена:

'nostop'
     GDB не должен останавливать вашу программу при получении этого
     сигнала.  Все же он может вывести сообщение, уведомляющее о
     получении сигнала.

'stop'
     GDB должен остановить вашу программу при получении этого сигнала.
     Это также подразумевает ключевое слово 'print'.

'print'
     GDB должен вывести сообщение при возникновении данного сигнала.

'noprint'
     GDB вообще не должен замечать возникновение сигнала.  Это также
     подразумевает ключевое слово 'nostop'.

'pass'
     GDB должен позволить вашей программе увидеть этот сигнал; программа
     может обработать сигнал, или же она может завершиться, если сигнал
     фатальный и не обработан.

'nopass'
     GDB не должен позволять вашей программе видеть этот сигнал.

   Когда сигнал останавливает вашу программу, он невидим для нее, пока
вы не продолжите выполнение.  Затем ваша программа видит сигнал, если _в
данный момент_ на рассматриваемый сигнал распространяется действие
команды 'pass'.  Другими словами, после того, как GDB сообщит о сигнале,
вы можете использовать команду 'handle' c 'pass' или 'nopass', чтобы
указать, должна ли ваша программа увидеть этот сигнал при продолжении.

   Вы также можете использовать команду 'signal' для того, чтобы
помешать вашей программе увидеть сигнал или, наоборот, заставить ее
заметить обычно игнорируемый сигнал, или чтобы подать ей произвольный
сигнал в любое время.  Например, если ваша программа остановилась
вследствие какой-либо ошибки обращения к памяти, вы можете записать
правильные значения в ошибочные переменные и продолжить выполнение в
надежде посмотреть на дальнейшее выполнение, но ваша программа,
вероятно, немедленно остановилась бы из-за фатального сигнала, как
только она его заметила бы.  Чтобы помешать этому, вы можете продолжить
выполнение с 'signal 0'.  *Note Подача сигнала вашей программе: Подача
сигналов.


File: gdb.info,  Node: Остановка нитей,  Prev: Сигналы,  Up: Остановка

5.4 Остановка и запуск многонитевых программ
============================================

Когда ваша программа имеет несколько нитей выполнения (*note Отладка
многонитевых программ: Нити.), вы можете выбрать, установить точки
останова либо во всех, либо в каких-то отдельных нитях.

'break НОМ-СТРОКИ thread НОМЕР-НИТИ'
'break НОМ-СТРОКИ thread НОМЕР-НИТИ if ...'
     НОМ-СТРОКИ определяет строки исходного текста; существует несколько
     способов их задания, но результат всегда один и тот же -- указание
     строки исходного текста.

     Используйте классификатор 'thread НОМЕР-НИТИ' с командой точки
     останова, чтобы указать GDB, что вы хотите остановить программу,
     только когда определенная нить достигнет этой точки.  НОМЕР-НИТИ --
     это один из числовых идентификаторов нити, присвоенный GDB,
     показываемый в первой колонке при выводе 'info threads'.

     Если при установке точки останова вы не укажете 'thread
     НОМЕР-НИТИ', точка останова будет действовать для _всех_ нитей
     вашей программы.

     Вы также можете использовать классификатор 'thread' для условных
     точек останова; в этом случае, поместите 'thread НОМЕР-НИТИ' перед
     условием точки останова, вот так:

          (gdb) break frik.c:13 thread 28 if bartab > lim

   При любой остановке вашей программы под управлением GDB прекращается
выполнение _всех_ нитей, а не только текущей.  Это позволяет вам
исследовать полное состояние программы, включая переключение между
нитями, не опасаясь, что это может изменить что-либо в дальнейшем.

   Наоборот, когда вы снова запускаете программу, _все_ нити начинают
выполняться.  _Это верно даже при пошаговом выполнении_ такими
командами, как 'step' или 'next'.

   В частности, GDB не может пошагово выполнять все нити параллельно.
Так как планированием выполнения нити занимается операционная система
отлаживаемой цели (не контролируемая GDB), то пока в текущей нити
выполняется один шаг, в других может выполниться несколько.  Более того,
когда выполнение программы останавливается, другие потоки вообще могут
остановиться в середине операторов, а не на границе между ними.

   Вы даже можете обнаружить, что после продолжения исполнения или после
пошагового выполнения ваша программа остановилась в другой нити.  Это
случается всякий раз, когда другая нить достигает точки останова,
получает сигнал, или в ней возникает исключительная ситуация, прежде чем
первая нить завершает выполнение того, что вы запросили.

   В некоторых операционных системах вы можете заблокировать планировщик
заданий и тем самым позволить выполняться только одной нити.

'set scheduler-locking РЕЖИМ'
     Устанавливает режим блокировки планировщика заданий.  Если он
     установлен в 'off', то блокировки нет и любая нить может
     выполняться в любое время.  Если этот режим установлен в 'on', то
     только текущая нить может выполняться, когда выполнение
     продолжается.  Режим 'step' производит оптимизацию для пошагового
     выполнения.  Он не дает другим нитям "захватывать приглашение"
     путем приоритетного прерывания обслуживания текущей нити во время
     пошагового выполнения.  Другие нити едва ли получат возможность
     начать выполнение, когда вы выполняете очередной шаг.  С большей
     вероятностью они начнут выполняться, когда вы выполняете команду
     'next' на вызове функции, и им ничто не помешает выполняться, когда
     вы используете такие команды, как 'continue', 'until' или 'finish'.
     Однако, если другие нити не достигнут точки останова в течение
     отведенного им для выполнения времени, они никогда не перехватят
     приглашение GDB у отлаживаемой вами нити.

'show scheduler-locking'
     Отобразить текущий режим блокировки.


File: gdb.info,  Node: Стек,  Next: Исходные файлы,  Prev: Остановка,  Up: Top

6 Исследование стека
********************

Когда ваша программа остановилась, первое, что вам нужно знать -- где
она остановилась, и как она туда попала.

   Каждый раз, когда ваша программа производит вызов функции, о нем
создается определенная информация.  Она включает положение вызова в
вашей программе, параметры вызова и локальные переменные вызываемой
функции.  Информация сохраняется в блоке данных, называемом "кадром
стека".  Кадры стека размещаются в области памяти, называемой "стеком
вызовов".

   Команды GDB для исследования стека позволяют вам увидеть всю эту
информацию при остановке вашей программы.

   Один из кадров стека является "выбранным", и многие команды GDB
неявно относятся к нему.  В частности, когда вы запрашиваете у GDB
значение переменной вашей программы, это значение находится в выбранном
кадре.  Для выбора интересующего вас кадра существуют специальные
команды GDB. *Note Выбор кадра: Выбор.

   Когда ваша программа останавливается, GDB автоматически выбирает
текущий выполняющийся кадр и выдает его краткое описание, аналогично
команде 'frame' (*note Информация о кадре стека: Информация о кадре.).

* Menu:

* Кадры::                       Кадры стека
* Цепочки вызовов::             Цепочки вызовов
* Выбор::                       Выбор кадра
* Информация о кадре::          Информация о кадре


File: gdb.info,  Node: Кадры,  Next: Цепочки вызовов,  Up: Стек

6.1 Кадры стека
===============

Cтек вызовов разделен на непрерывные участки, называемые "кадрами
стека", или "кадрами" для краткости; каждый кадр является данными,
связанными с одним вызовом одной функции.  Кадр содержит аргументы,
переданные функции, ее локальные переменные и адрес, с которого она
выполняется.

   Когда ваша программа стартует, стек содержит только один кадр -- для
функции 'main'.  Он называется "начальным" или "внешним" кадром.  Каждый
раз при вызове функции создается новый кадр.  При каждом выходе из
функции кадр вызова этой функции уничтожается.  Если функция является
рекурсивной, для нее может существовать множество кадров.  Кадр для
функции, исполняемой в данный момент, называется "внутренним" кадром.
Это кадр, созданный самым последним из всех существующих кадров стека.

   Внутри вашей программы кадры стека идентифицируются своим адресом.
Кадр стека состоит из множества байт, каждый из которых имеет свой
собственный адрес; каждый тип компьютеров имеет свой способ для выбора
одного байта, чей адрес служит адресом кадра.  Обычно, пока выполнение
происходит в данном кадре, этот адрес содержится в регистре, называемом
"регистром указателя кадра".

   GDB присваивает номера всем существующим кадрам стека, начиная с нуля
для внутреннего кадра, единицу -- вызвавшему его кадру, и так далее.  В
действительности, эти номера не существуют в вашей программе; они
назначаются GDB, чтобы предоставить вам способ различать кадры стека в
командах GDB.

   Некоторые компиляторы позволяют компилировать функции так, чтобы они
выполнялись без создания кадров стека.  (Например, ключ gcc
'-fomit-frame-pointer' создает функции без кадра.)  Это иногда делается
с часто используемыми библиотечными функциями, чтобы сэкономить время,
требуемое для установки кадра.  GDB имеет ограниченные возможности для
обработки таких вызовов.  Если вызов внутренней функции происходит без
создания кадра стека, GDB, тем не менее, описывает его так, как если бы
он имел отдельный кадр, который имеет, как обычно, номер 0, позволяя
корректно трассировать цепочку вызовов функций.  Однако, GDB не имеет
средств для работы с функциями без кадра в другом месте стека.

'frame АРГ'
     Команда 'frame' позволяет вам перемещаться от одного кадра стека к
     другому и распечатывать выбранный вами кадр.  АРГ может быть либо
     адресом кадра, либо его номером.  Без аргумента, 'frame' выводит
     текущий кадр стека.

'select-frame'
     Команда 'select-frame' позволяет вам перемещаться от одного кадра
     стека к другому без его распечатки.  Это "тихая" версия 'frame'.


File: gdb.info,  Node: Цепочки вызовов,  Next: Выбор,  Prev: Кадры,  Up: Стек

6.2 Цепочки вызовов
===================

Цепочка вызовов предоставляет собой информацию о том, как ваша программа
оказалась там, где она есть.  Она отображает по одной строке для каждого
кадра, начиная с текущего выполняющегося кадра (кадра 0), за которым
следует кадр, из которого он был вызван (кадр 1), и далее вверх по
стеку.

'backtrace'
'bt'
     Вывести цепочку вызовов всего стека: по одной строке на кадр, для
     всех кадров в стеке.

     Вы можете прервать цепочку вызовов в любое время, введя знак
     системного прерывания, обычно 'C-c'.

'backtrace N'
'bt N'
     То же самое, но выводятся только N внутренних кадров.

'backtrace -N'
'bt -N'
     То же самое, но выводятся только N внешних кадров.

   'where' и 'info stack' (сокращенно 'info s') -- дополнительные
синонимы для 'backtrace'.

   Каждая строка в цепочке вызовов показывает номер кадра и имя функции.
Счетчик команд также показывается, если только вы не используете 'set
print address off'.  Цепочка вызовов также показывает имя исходного
файла, номер строки и аргументы функции.  Значение счетчика команд
опускается, если он указывает на начало кода для данной строки.

   Ниже приведен пример цепочки вызовов.  Она была получена командой 'bt
3', так что она показывает три внутренних кадра.

     #0  m4_traceon (obs=0x24eb0, argc=1, argv=0x2b8c8)
         at builtin.c:993
     #1  0x6e38 in expand_macro (sym=0x2b600) at macro.c:242
     #2  0x6840 in expand_token (obs=0x0, t=177664, td=0xf7fffb08)
         at macro.c:71
     (More stack frames follow...)

Информация о нулевом кадре не начинается со значения счетчика команд,
что указывает на то, что ваша программа остановилась в начале кода для
строки '993' файла 'builtin.c'.


File: gdb.info,  Node: Выбор,  Next: Информация о кадре,  Prev: Цепочки вызовов,  Up: Стек

6.3 Выбор кадра
===============

Большинство команд для исследования стека и других данных в вашей
программе применяются выбранному в данный момент кадру.  Здесь приведены
команды для выбора кадра стека; все они завершаются выводом краткого
описания выбранного кадра стека.

'frame N'
'f N'
     Выбрать кадр номер N.  Напоминаем, что нулевой кадр -- это
     внутренний (исполняемый в данный момент) кадр, первый кадр -- тот,
     из которого вызван нулевой, и так далее.  Кадр с наибольшим номером
     -- это кадр для функции 'main'.

'frame АДРЕС'
'f АДРЕС'
     Выбрать кадр, расположенный по адресу АДРЕС.  В основном это
     полезно, если формирование цепочки кадров стека было нарушено из-за
     ошибки, сделавшей невозможным для GDB правильное присвоение номеров
     всем кадрам.  Кроме того, это может быть полезным, когда у вашей
     программы есть несколько стеков и происходит переключение от одного
     к другому.

     В архитектуре SPARC, команде 'frame' для выбора произвольного кадра
     необходимо указать два адреса: указатель кадра и указатель вершины
     стека.

     В архитектурах MIPS и Alpha требуется два адреса: указатель вершины
     стека и указатель команд.

     В архитектуре 29k требуется три адреса: указатель вершины стека
     регистров, указатель команд и указатель вершины стека памяти.

'up N'
     Переместиться вверх по стеку на N кадров.  Для положительных
     значений N, это перемещение происходит по направлению к внешнему
     кадру, к кадрам с большими номерами, к кадрам, которые существуют
     дольше.  По умолчанию N принимается равным единице.

'down N'
     Передвинуться вниз по стеку на N кадров.  Для положительных
     значений N, это продвижение происходит по направлению к внутреннему
     кадру, к кадру с меньшим номером, к кадрам, которые были созданы
     позже.  По умолчанию, значение N принимается равным единице.  Вы
     можете сокращать 'down' как 'do'.

   Все эти команды заканчиваются выводом двух строк, описывающих кадр.
Первая строка показывает номер кадра, имя функции, аргументы, имя
исходного файла и номер выполняемой строки в этом кадре.  Вторая строка
показывает содержимое этой строки исходного текста.

   Например:

     (gdb) up
     #1  0x22f0 in main (argc=1, argv=0xf7fffbf4, env=0xf7fffbfc)
         at env.c:10
     10              read_input_file (argv[i]);

   После такого вывода, команда 'list' без аргументов выводит десять
строк, расположенных вокруг точки выполнения в кадре.  *Note Вывод строк
исходного текста: Вывод строк.

'up-silently N'
'down-silently N'
     Эти две команды являются вариантами 'up' и 'down' соответственно,
     отличаясь от них тем, что делают свою работу "тихо", не отображая
     новый кадр.  Они предназначены для использования в основном в
     командных сценариях GDB, где вывод может быть ненужным и
     отвлекающим.


File: gdb.info,  Node: Информация о кадре,  Prev: Выбор,  Up: Стек

6.4 Информация о кадре стека
============================

Существуют несколько других команд для вывода информации о выбранном
кадре стека.

'frame'
'f'
     При использовании без аргументов, эта команда не выбирает новый
     кадр, а выводит краткое описание текущего выбранного кадра стека.
     Эту команду можно сокращать как 'f'.  С аргументом, эта команда
     используется для выбора кадра стека.  *Note Выбор кадра стека:
     Выбор.

'info frame'
'info f'
     Эта команда выводит подробное описание выбранного кадра стека,
     включающее:

        * адрес кадра
        * адрес следующего вниз по стеку кадра (вызываемого из данного)
        * адрес следующего вверх по стеку кадра (того, из которого был
          вызван данный)
        * язык, на котором написан исходный код, соответствующий этому
          кадру
        * адрес аргументов кадра
        * адрес локальных переменных кадра
        * сохраненный в кадре счетчик команд (адрес выполнения в кадре,
          вызвавшем данный)
        * регистры, которые были сохранены в кадре

     Подробное описание полезно, если из-за какой-либо ошибки формат
     стека не соответствует обычным соглашениям.

'info frame АДРЕС'
'info f АДРЕС'
     Вывести подробное описание кадра стека, расположенного по адресу
     АДРЕС, не выбирая этот кадр.  Выбранный кадр этой командой не
     изменяется.  Она требует параметр АДРЕС того же типа, что и команда
     'frame' (для некоторых архитектур не один, а несколько).  *Note
     Выбор кадра стека: Выбор.

'info args'
     Вывести аргументы выбранного кадра, каждый на отдельной строке.

'info locals'
     Вывести локальные переменные выбранного кадра, каждую на отдельной
     строке.  Выводятся все переменные (объявленные как статические или
     как автоматические), доступные в точке выполнения выбранного кадра
     стека.

'info catch'
     Выводит список всех обработчиков исключительных ситуаций,
     являющихся активными в текущей точке выполнения текущего кадра
     стека.  Чтобы увидеть другие обработчики исключительных ситуаций,
     перейдите в соответствующую секцию (используя команды 'up', 'down'
     или 'frame'); затем наберите 'info catch'.  *Note Установка точек
     перехвата: Установка точек перехвата.


File: gdb.info,  Node: Исходные файлы,  Next: Данные,  Prev: Стек,  Up: Top

7 Исследование исходных файлов
******************************

GDB может выводить части исходных текстов вашей программы, так как
отладочная информация, записанная в ней, сообщает GDB, какие исходные
файлы использовались при создании программы.  Когда ваша программа
останавливается, GDB сам выводит строку, на которой она остановилась.
Аналогично, когда вы выбираете кадр стека (*note Выбор кадра стека:
Выбор.), GDB выводит строку, на которой остановилось выполнение в этом
кадре.  Вы можете выводить другие части исходных файлов с помощью явных
команд.

   Если вы используете GDB через интерфейс к GNU Emacs, вы можете
предпочесть воспользоваться средствами Emacs для просмотра исходных
текстов; смотрите *note Использование GDB под управлением GNU Emacs:
Emacs.

* Menu:

* Вывод строк::                 Вывод строк исходного текста
* Поиск::                       Поиск в исходных файлах
* Пути для исходных файлов::    Определение каталогов для исходных файлов
* Машинный код::                Исходный текст и машинный код


File: gdb.info,  Node: Вывод строк,  Next: Поиск,  Up: Исходные файлы

7.1 Вывод строк исходного текста
================================

Чтобы вывести строки файла с исходным текстом, используйте команду
'list' (сокращенно 'l').  По умолчанию выводятся десять строк.
Существует несколько способов определения того, какую часть файла вы
хотите вывести.

   Здесь представлены наиболее употребительные формы команды 'list':

'list НОМЕР-СТРОКИ'
     Вывести строки, расположенные вокруг строки с номером НОМЕР-СТРОКИ
     в текущем исходном файле.

'list ФУНКЦИЯ'
     Вывести строки, расположенные вокруг начала функции ФУНКЦИЯ.

'list'
     Вывести еще определенное количество строк.  Если последние
     выведенные строки выводились с помощью команды 'list', то выводятся
     строки, следующие за последними выведенными; если, однако,
     последней выведенной строкой была одиночная строка, выведенная как
     часть отображения кадра стека (*note Исследование стека: Стек.), то
     выводятся строки, расположенные вокруг нее.

'list -'
     Вывести строки, расположенные непосредственно перед последними
     выведенными.

   По умолчанию, для любой из этих форм команды 'list' GDB выводит
десять строк исходного текста.  Вы можете изменить это командой 'set
listsize':

'set listsize ЧИСЛО'
     Установить количество выводимых командой 'list' строк в ЧИСЛО (если
     аргумент команды 'list' не задает явно какое-нибудь другое число).

'show listsize'
     Отобразить количество строк, выводимых по команде 'list'.

   Повторение команды 'list' нажатием <RET> отбрасывает аргумент, так
что это эквивалентно вводу просто 'list'.  Это полезнее, чем вывод тех
же самых строк снова.  Исключение сделано для параметра '-'; этот
параметр сохраняется при повторе команды, так что каждое повторение
приводит к перемещению вверх по исходному файлу.

   Обычно команда 'list' ожидает от вас ноль, один или два "указателя
строк".  Указатели строк определяют строки исходного текста; существует
несколько способов их задания, но результат всегда заключается в задании
строки исходного текста.  Вот полное описание возможных параметров
команды 'list':

'list УКАЗ-СТР'
     Вывести строки, расположенные вокруг строки, определяемой УКАЗ-СТР.

'list ПЕРВ,ПОСЛ'
     Вывести строки с ПЕРВ до ПОСЛ.  Оба параметра являются указателями
     строк.

'list ,ПОСЛ'
     Вывести строки, расположенные перед ПОСЛ.

'list ПЕРВ,'
     Вывести строки, начиная с ПЕРВ.

'list +'
     Вывести строки, расположенные сразу за последними выведенными.

'list -'
     Вывести строки, расположенные непосредственно перед последними
     выведенными.

'list'
     Описано в предыдущей таблице.

   Ниже перечислены способы указания одиночной строки исходного текста
-- все виды указателей строк.

'НОМЕР'
     Определяет строку с номером НОМЕР из текущего исходного файла.
     Если в качестве параметров к команде 'list' задано два указателя
     строк, это относится к тому же исходному файлу, что и первый
     указатель строки.

'+СМЕЩЕНИЕ'
     Указывает на строку, смещенную вперед на СМЕЩЕНИЕ строк
     относительно последней выведенной строки.  Когда используется в
     качестве второго указателя строки для команды 'list', имеющей два
     указателя, задает строку, смещенную на СМЕЩЕНИЕ строк вниз
     относительно строки, определенной первым указателем.

'-СМЕЩЕНИЕ'
     Указывает на строку, расположенную на СМЕЩЕНИЕ строк раньше
     последней выведенной строки.

'ИМЯ-ФАЙЛА:НОМЕР'
     Задает строку НОМЕР из исходного файла ИМЯ-ФАЙЛА.

'ФУНКЦИЯ'
     Определяет строку, с которой начинается тело функции ФУНКЦИЯ.
     Например, в Си это строка с открывающейся фигурной скобкой.

'ИМЯ-ФАЙЛА:ФУНКЦИЯ'
     Определяет строку с открывающейся фигурной скобкой, с которой
     начинается тело функции ФУНКЦИЯ в файле ИМЯ-ФАЙЛА.  Имя файла
     необходимо лишь для того, чтобы избежать неоднозначности, когда в
     различных исходных файлах есть одинаково названные функции.

'*АДРЕС'
     Определяет строку, соответствующую адресу АДРЕС программы.  АДРЕС
     может быть любым выражением.


File: gdb.info,  Node: Поиск,  Next: Пути для исходных файлов,  Prev: Вывод строк,  Up: Исходные файлы

7.2 Поиск в исходных файлах
===========================

Существуют две команды для поиска по регулярному выражению в текущем
исходном файле.

'forward-search РЕГ-ВЫРАЖ'
'search РЕГ-ВЫРАЖ'
     Команда 'forward-search РЕГ-ВЫРАЖ' проверяет на соответствие
     регулярному выражению РЕГ-ВЫРАЖ каждую строку, начиная со строки,
     следующей за последней выведенной.  Найденная строка выводится.  Вы
     можете использовать синоним 'search РЕГ-ВЫРАЖ' или сокращать имя
     команды как 'fo'.

'reverse-search РЕГ-ВЫРАЖ'
     Команда 'reverse-search РЕГ-ВЫРАЖ', двигаясь назад, проверяет на
     соответствие регулярному выражению РЕГ-ВЫРАЖ каждую строку, начиная
     с предшествующей последней выведенной.  Найденная строка выводится.
     Вы можете сокращать эту команду как 'rev'.


File: gdb.info,  Node: Пути для исходных файлов,  Next: Машинный код,  Prev: Поиск,  Up: Исходные файлы

7.3 Определение каталогов с исходными файлами
=============================================

Исполняемые программы иногда не сохраняют имена каталогов, в которых
находились исходные файлы, из которых они скомпилированы, а хранят лишь
имена файлов.  Даже если они их сохранили, каталоги могли быть
перемещены в период между компиляцией и сеансом отладки.  У GDB есть
список каталогов для поиска исходных файлов; он называется "путь для
исходных файлов".  Каждый раз, когда GDB требуется исходный файл, он
перебирает по порядку все каталоги из этого списка, пока не находит файл
с требуемым именем.  Заметьте, что пути поиска исполняемых файлов для
этой цели _не_ используются, как не используется и текущий рабочий
каталог, если только он не присутствует в пути для исходных файлов.

   Если GDB не может найти исходный файл, используя путь для исходных
файлов, а в объектном файле программы указан какой-либо каталог, GDB
просматривает также и его.  В последнюю очередь, если путь для исходных
файлов пуст и запись о каталоге компиляции отсутствует, GDB
просматривает текущий каталог.

   При переустановке или переупорядочивании пути для исходных файлов,
GDB очищает любую запомненную им информацию о том, где исходные файлы
были найдены и о расположении строк в них.

   Когда вы вызываете GDB, путь для исходных файлов содержит только
'cdir' и 'cwd', в этом порядке.  Для добавления других каталогов,
используйте команду 'directory'.

'directory ИМЯ-КАТАЛОГА ...'
'dir ИМЯ-КАТАЛОГА ...'
     Добавить каталог ИМЯ-КАТАЛОГА в начало пути для исходных файлов.
     Этой команде могут быть заданы несколько имен, разделенные ':' (';'
     в MS-DOS и MS-Windows, где ':' обычно является частью абсолютного
     имени файла) или пробелом.  Вы можете указать каталог, который уже
     содержится в пути для исходных файлов; это переместит его в начало,
     так что GDB будет просматривать его раньше.

     Вы можете использовать строку '$cdir' для ссылки на каталог
     компиляции (если информация о нем сохранена), и '$cwd' для ссылки
     на текущий рабочий каталог.  '$cwd' -- это не то же самое, что '.'.
     Первая отслеживает текущий рабочий каталог, который может меняться
     во время вашего сеанса работы с GDB, тогда как вторая сразу
     преобразовывается в текущий каталог в момент его добавления в путь
     для исходных файлов.

'directory'
     Очистить путь для файлов с исходными текстами.  Эта команда требует
     подтверждения.

'show directories'
     Вывести путь поиска исходных файлов: показать, какие каталоги он
     содержит.

   Если ваш путь для исходных файлов перемешан с уже неиспользуемыми
каталогами, GDB может иногда вызвать недоумение, найдя неправильный
вариант исходного файла.  Вы можете исправить ситуацию следующим
образом:

  1. Использовать 'directory' без параметров, чтобы очистить путь поиска
     исходных файлов.

  2. Использовать 'directory' с подходящими аргументами, чтобы
     переустановить каталоги, которые вы хотите видеть в пути для
     исходных файлов.  Вы можете добавить все каталоги одной командой.


File: gdb.info,  Node: Машинный код,  Prev: Пути для исходных файлов,  Up: Исходные файлы

7.4 Исходный текст и машинный код
=================================

Вы можете использовать команду 'info line', чтобы отобразить строки
исходного текста в программные адреса (и наоборот), и команду
'disassemble', чтобы вывести диапазон адресов в виде машинных
инструкций.  При запуске в режиме GNU Emacs, команда 'info line' выводит
стрелку, указывающую на заданную строку.  Также 'info line' выводит
адреса как в символьной форме, так и в шестнадцатеричной.

'info line УКАЗ-СТР'
     Выводит начальный и конечный адреса скомпилированного кода,
     соответствующего строке исходного текста УКАЗ-СТР.  Вы можете
     определить строки исходного текста любым способом, воспринимаемым
     командой 'list' (*note Вывод строк исходного текста: Вывод строк.).

   Например, мы можем использовать 'info line' для определения положения
объектного кода первой строки функции 'm4_changequote':

     (gdb) info line m4_changequote
     Line 895 of "builtin.c" starts at pc 0x634c and ends at 0x6350.

Мы также можем запросить (используя '*АДРЕС' как форму задания
УКАЗ-СТР), какая строка исходного текста соответствует определенному
адресу:

     (gdb) info line *0x63ff
     Line 926 of "builtin.c" starts at pc 0x63e4 and ends at 0x6404.

   После 'info line', адрес, используемый по умолчанию для команды 'x',
меняется на начальный адрес строки, так что 'x/i' достаточно для начала
исследования машинного кода (*note Исследование памяти: Память.).  Этот
адрес также сохраняется как значение вспомогательной переменной '$_'
(*note Вспомогательные переменные: Вспомогательные переменные.).

'disassemble'
     Эта специализированная команда служит для дампа диапазона памяти в
     виде машинных инструкций.  Диапазоном памяти по умолчанию является
     функция, в которой находится счетчик программы в выбранном кадре.
     Одиночным параметром этой команды является значение счетчика
     программы; GDB выводит дамп функции, которой принадлежит указанный
     адрес.  Два параметра определяют диапазон адресов для дампа (первый
     включается, второй исключается).

   Следующий пример показывает результат дисассемблирования диапазона
адресов кода HP PA-RISC 2.0:

     (gdb) disas 0x32c4 0x32e4
     Dump of assembler code from 0x32c4 to 0x32e4:
     0x32c4 <main+204>:      addil 0,dp
     0x32c8 <main+208>:      ldw 0x22c(sr0,r1),r26
     0x32cc <main+212>:      ldil 0x3000,r31
     0x32d0 <main+216>:      ble 0x3f8(sr4,r31)
     0x32d4 <main+220>:      ldo 0(r31),rp
     0x32d8 <main+224>:      addil -0x800,dp
     0x32dc <main+228>:      ldo 0x588(r1),r26
     0x32e0 <main+232>:      ldil 0x3000,r31
     End of assembler dump.

   Некоторые архитектуры имеют несколько широко используемых наборов
мнемоник инструкций или другой синтаксис.

'set disassembly-flavor НАБОР-ИНСТРУКЦИЙ'
     Выбрать набор инструкций для использования при дисассемблировании
     программы командами 'disassemble' и 'x/i'.

     В настоящее время эта команда определена только для Intel x86.  Вы
     можете установить НАБОР-ИНСТРУКЦИЙ в 'intel' или 'att'.  По
     умолчанию установлено 'att', диалект AT&T используется по умолчанию
     ассемблерами Unix на архитектурах, базирующихся на x86.


File: gdb.info,  Node: Данные,  Next: Языки,  Prev: Исходные файлы,  Up: Top

8 Исследование данных
*********************

Для исследования данных в вашей программе обычно используется команда
'print' (сокращенно 'p') или ее синоним 'inspect'.  Она вычисляет и
выводит значение выражения, записанного на том же языке, что и ваша
программа (*note Использование GDB с различными языками: Языки.).

'print ВЫРАЖ'
'print /F ВЫРАЖ'
     ВЫРАЖ является выражением (на исходном языке).  По умолчанию,
     значение ВЫРАЖ выводится в формате, соответствующем его типу
     данных; вы можете выбрать другой формат, указав '/F', где F --
     буква, определяющая формат; смотрите *note Форматы вывода: Форматы
     вывода.

'print'
'print /F'
     Если вы опустите ВЫРАЖ, GDB отображает последнее значение снова (из
     "истории значений"; *note История значений: История значений.).
     Это предоставляет вам удобный способ изучить то же самое значение в
     другом формате.

   Команда 'x' позволяет исследовать данные на более низком уровне.  Она
исследует данные в памяти по указанному адресу и выводит их в указанном
формате.  *Note Исследование памяти: Память.

   Если вас интересует информация о типах или о том, как объявлены поля
структуры или класса, используйте команду 'ptype ВЫРАЖ' вместо 'print'.
*Note Исследование таблицы символов: Символы.

* Menu:

* Выражения::                   Выражения
* Переменные::                  Переменные программы
* Массивы::                     Искусственные массивы
* Форматы вывода::              Форматы вывода
* Память::                      Исследование памяти
* Автоматическое отображение::  Автоматическое отображение
* Параметры вывода::            Параметры вывода
* История значений::            История значений
* Вспомогательные переменные::  Вспомогательные переменные
* Регистры::                    Регистры
* Вычисления с плавающей точкой::
                                Аппаратные средства поддержки вычислений
                                с плавающей точкой


File: gdb.info,  Node: Выражения,  Next: Переменные,  Up: Данные

8.1 Выражения
=============

'print' и многие другие команды GDB принимают в качестве параметра
выражение и вычисляют его значение.  В выражении GDB допустимо
использование любого типа констант, переменных или операторов,
определенных в используемом вами языке программирования, включая
условные выражения, вызовы функций, приведение типов и строковые
постоянные.  К сожалению, исключением являются символы, определенные
командами препроцессора '#define'.

   GDB поддерживает константы-массивы в выражениях, введенных
пользователем.  Синтаксис следующий: {ЭЛЕМЕНТ, ЭЛЕМЕНТ...}.  Например,
вы можете использовать команду 'print {1, 2, 3}', чтобы создать в памяти
массив, который будет доступен в программе так же, как выделенный
функцией 'malloc'.

   По причине широкого распространения Си, большинство выражений в
примерах этого руководства написаны на Си.  *Note Использование GDB с
различными языками: Языки, для информации об использовании выражений в
других языках.

   В этом разделе мы обсуждаем операторы, которые вы можете использовать
в выражениях GDB независимо от используемого вами языка
программирования.

   Приведения типов поддерживается во всех языках, а не только в Си, так
как бывает очень полезно преобразовать число в указатель, чтобы
исследовать структуру, расположенную по этому адресу в памяти.

   GDB поддерживает эти операторы, в дополнении к следующим, являющимися
общими для языков программирования:

'@'
     '@' является бинарным оператором, позволяющим рассматривать области
     памяти как массивы.  *Note Исскуственные массивы: Массивы, для
     дополнительной информации.

'::'
     '::' позволяет вам указывать переменную в терминах файла или
     функции, где она определена.  *Note Переменные программы:
     Переменные.

'{ТИП} АДРЕС'
     Ссылается на объект типа ТИП, хранящийся в памяти по адресу АДРЕС.
     АДРЕС может быть любым выражением, значением которого является
     целое число или указатель (но вокруг бинарных операторов, также как
     и вокруг оператора приведения типа, требуются скобки).  Эта
     конструкция допустима вне зависимости от того, какого типа данные
     предположительно расположены по АДРЕСУ.


File: gdb.info,  Node: Переменные,  Next: Массивы,  Prev: Выражения,  Up: Данные

8.2 Переменные программы
========================

Чаще всего в качестве выражения используется имя переменной вашей
программы.

   Переменные в выражениях трактуются в контексте выбранного кадра стека
(*note Выбор кадра стека: Выбор.); они могут быть либо

   * глобальными (или статическими)

либо

   * видимыми из точки выполнения в данном кадре, в соответствии с
     правилами определения области видимости языка программирования.

Это означает, что в функции

     foo (a)
          int a;
     {
       bar (a);
       {
         int b = test ();
         bar (b);
       }
     }

вы можете исследовать и использовать переменную 'a' всякий раз, когда
ваша программа выполняется в пределах функции 'foo', но переменную 'b'
можно использовать или исследовать только тогда, когда ваша программа
выполняется внутри блока, в котором она объявлена.

   Есть исключение: вы можете ссылаться на переменную или функцию,
областью видимости которой является единственный исходный файл, даже
если точка текущего выполнения в нем не находится.  Допускается
существование нескольких переменных или функций с одинаковым именем (в
различных исходных файлах).  Если это так, обращение к этому имени
приводит к непредсказуемым результатам.  Если хотите, вы можете указать
статическую переменную в конкретной функции или в файле, используя
двойное двоеточие:

     ФАЙЛ::ПЕРЕМЕННАЯ
     ФУНКЦИЯ::ПЕРЕМЕННАЯ

Здесь ФАЙЛ или ФУНКЦИЯ -- название контекста для статической ПЕРЕМЕННОЙ.
В первом случае вы можете использовать кавычки, чтобы GDB рассматривал
имя файла как одно слово; например, чтобы вывести глобальное значение
переменной 'x', определенной в 'f2.c':

     (gdb) p 'f2.c'::x

   Такое использование '::' крайне редко конфликтует с похожим
использованием той же записи в Си++.  GDB также поддерживает
использование оператора определения области видимости Си++ в выражениях.

     _Предупреждение:_ В некоторых случаях, в определенной точке функции
     (сразу после входа в новую область видимости и непосредственно
     перед выходом из нее) может показаться, что локальная переменная
     имеет неверное значение.

   Вы можете столкнуться с этой проблемой при пошаговом выполнении по
одной машинной инструкции.  Она возникает из-за того, что на большинстве
машин процедура установки кадра стека (включая определения локальных
переменных) занимает более одной инструкции; если вы производите
пошаговое выполнение по одной машинной инструкции, может показаться, что
переменная имеет неверное значение, пока кадр стека не будет полностью
построен.  При выходе, для уничтожения кадра стека обычно также
требуется более одной инструкции; после начала пошагового выполнения
этой группы инструкций определения локальных переменных могут пропасть.

   Это также может случиться, когда компилятор делает значительную
оптимизацию.  Чтобы быть уверенным, что вы всегда видите точные
значения, отключите всю оптимизацию при компиляции.

   Другой возможный эффект оптимизации компилятора заключается в
уничтожении неиспользуемых переменных или в присвоении переменных
регистрам (а не адресам памяти).  В зависимости от поддержки таких
ситуаций, предоставляемой форматом отладочной информации, который
использует компилятор, GDB может не вывести значения таких локальных
переменных.  Если это происходит, GDB выведет сообщение, подобное этому:

     No symbol "foo" in current context.

   Для решения таких проблем или перекомпилируйте программу без
оптимизации, или используйте другой формат отладочной информации, если
компилятор поддерживает несколько таких форматов.  Например GCC,
компилятор GNU Си/Си++, обычно поддерживает ключ '-gstabs'.  '-gstabs'
создает отладочную информацию в формате, являющимся развитием таких
форматов, как COFF. У вас может быть возможность использовать DWARF2
('-gdwarf-2'), который тоже является эффективной формой представления
отладочной информации.  Смотрите *note Ключи для отладки вашей программы
или GNU CC: (gcc.info)Ключи для отладки, для дополнительной информации.


File: gdb.info,  Node: Массивы,  Next: Форматы вывода,  Prev: Переменные,  Up: Данные

8.3 Искусственные массивы
=========================

Часто бывает полезным вывести несколько объектов одного типа,
расположенных в памяти последовательно; часть массива или динамический
массив, для которого в программе существует только указатель.

   Вы можете это сделать, обращаясь к непрерывному участку памяти как к
"искусственному массиву", используя бинарный оператор '@'.  Левым
операндом для '@' должен быть первый элемент желаемого массива, и он
должен быть индивидуальным объектом.  Правым операндом должна быть длина
массива.  Результатом операции будет массив, все элементы которого имеют
тот же тип, что и левый аргумент.  Первым элементом массива является
левый аргумент; второй элемент формируется из байтов памяти,
непосредственно следующих за байтами, содержащими первый элемент, и так
далее.  Например, если в программе есть строка

     int *array = (int *) malloc (len * sizeof (int));

то вы можете вывести содержимое 'array' с помощью

     p *array@len

   Левый операнд операции '@' должен находиться в памяти.  Значения
массивов, полученных операцией '@', при индексации ведут себя точно так
же, как и другие массивы, и приводятся к указателям при использовании в
выражениях.  Искусственные массивы чаще всего появляются в выражениях
через историю значений (*note История значений: История значений.),
после вывода одного из них.

   Другой способ создания искусственного массива -- использование
приведения типов.  Оно заново интерпретирует значение так, как если бы
оно было массивом.  Значение не обязано находиться в памяти.

     (gdb) p/x (short[2])0x12345678
     $1 = {0x1234, 0x5678}

   Если вы опускаете длину массива (как в '(ТИП[])ЗНАЧЕНИЕ'), GDB для
удобства вычисляет его размер для заполнения значениями (как
'sizeof(ЗНАЧЕНИЕ)/sizeof(ТИП)':

     (gdb) p/x (short[])0x12345678
     $2 = {0x1234, 0x5678}

   Иногда механизма искусственных массивов бывает недостаточно; в
сравнительно сложных структурах данных интересующие нас элементы могут
не быть смежными -- например, если вас интересуют значения указателей в
массиве.  Одно из удачных решений этой проблемы -- использование
вспомогательной переменной (*note Вспомогательные переменные:
Вспомогательные переменные.) в качестве счетчика в выражении, выводящем
первое интересующее нас значение, а затем повторять это выражение
нажатием <RET>.  Предположим, например, у вас есть массив 'dtab'
указателей на структуры, и вас интересуют значения полей 'fv' в каждой
структуре.  Ниже приведен пример ваших возможных действий:

     set $i = 0
     p dtab[$i++]->fv
     <RET>
     <RET>
     ...


File: gdb.info,  Node: Форматы вывода,  Next: Память,  Prev: Массивы,  Up: Данные

8.4 Форматы вывода
==================

По умолчанию, GDB печатает значение в соответствии с его типом.  Это не
всегда отвечает вашему желанию.  Например, вы можете захотеть вывести
число в шестнадцатеричной записи или указатель в десятичной.  Или вы
можете захотеть просмотреть данные по некоторому адресу в памяти в виде
строки знаков или в виде инструкций.  Для этого при выводе значения
задайте "формат вывода".

   Простейшим применением форматов вывода является форматирование вывода
уже вычисленного выражения.  Чтобы сделать это, начните параметры
команды 'print' с косой черты и символа формата.  Поддерживаются
следующие символы формата:

'x'
     Рассматривать биты значения как целое и вывести целое в
     шестнадцатеричном виде.

'd'
     Вывести как десятичное целое со знаком.

'u'
     Вывести как десятичное целое без знака.

'o'
     Вывести как восьмеричное целое.

't'
     Вывести как целое в двоичном виде.  Буква 't' означает "two".  (1)

'a'
     Вывести в виде адреса, как абсолютного в шестнадцатеричной записи,
     так и в виде смещения от ближайшего предшествующего символа.  Вы
     можете использовать этот формат, чтобы определить, где (в какой
     функции) расположен какой-либо неизвестный адрес:

          (gdb) p/a 0x54320
          $3 = 0x54320 <_initialize_vx+396>

'c'
     Рассматривать как целое и вывести в виде строковой постоянной.

'f'
     Рассматривать биты значения как число с плавающей точкой и вывести
     с использованием обычного синтаксиса для этих чисел.

   Например, чтобы вывести счетчик программы в шестнадцатеричном виде
(*note Регистры::), введите

     p/x $pc

Обратите внимание, что перед косой чертой не требуется пробела, потому
что имена команд в GDB не могут содержать косую черту.

   Чтобы вывести последнее значение из истории значений в другом
формате, вы можете воспользоваться командой 'print' лишь с указанием
формата и без выражения.  Например, 'p/x' выведет последнее значение в
шестнадцатеричной форме.

   ---------- Footnotes ----------

   (1) 'b' не может быть использовано, потому что эти символы формата
также используются с командой 'x', где 'b' означает "byte"; смотрите
*note Исследование памяти: Память.


File: gdb.info,  Node: Память,  Next: Автоматическое отображение,  Prev: Форматы вывода,  Up: Данные

8.5 Исследование памяти
=======================

Вы можете использовать команду 'x' (от слова "examine") для исследования
памяти в одном из нескольких форматов, независимо от типов данных вашей
программы.

'x/NFU АДРЕС'
'x АДРЕС'
'x'
     Для исследования памяти используйте команду 'x'.

   N, F и U -- необязательные параметры, определяющие, сколько памяти
отобразить и в каком формате; АДРЕС -- это выражение, задающее адрес, с
которого вы хотите начать отображение памяти.  Если вы используете
значения по умолчанию для NFU, то вам не нужно вводить косую черту '/'.
Некоторые команды устанавливают удобные значения по умолчанию для
АДРЕСА.

N, счетчик повторений
     Счетчик повторений является десятичным целым числом; по умолчанию
     1.  Он определяет, сколько памяти отобразить (считая в единицах U).

F, формат отображения
     Формат отображения -- это один из форматов, используемых командой
     'print', 's' (строка, оканчивающаяся нулем), или 'i' (машинная
     инструкция).  Первоначально, значением по умолчанию установлено 'x'
     (шестнадцатеричная форма).  Значение по умолчанию изменяется каждый
     раз, когда вы используете либо 'x', либо 'print'.

U, размер единицы измерений
     Размер единицы измерений может быть одним из

     'b'
          Байты.
     'h'
          Полуслова (два байта).
     'w'
          Слова (четыре байта).  Это первоначальное значение по
          умолчанию.
     'g'
          Длинные слова (восемь байт).

     Каждый раз, когда вы определяете размер единицы измерений командой
     'x', этот размер становится размером по умолчанию при последующем
     использовании 'x'.  (Для форматов 's' и 'i' размер единицы
     измерений игнорируется и обычно не пишется.)

АДРЕС, начальный адрес отображения
     АДРЕС -- это адрес, с которого вы хотите, чтобы GDB начинал
     отображение памяти.  Значение выражения не обязано должно быть
     указателем (хотя может им быть); оно всегда интерпретируется как
     целый адрес байта в памяти.  *Note Выражения: Выражения, для
     дополнительной информации о выражениях.  Значением по умолчанию для
     АДРЕСА обычно является адрес, следующий за последним изученным
     адресом, но некоторые другие команды также устанавливают это
     значение: 'info breakpoints' (в адрес последней выведенной точки
     останова), 'info line' (в начальный адрес строки) и 'print' (если
     вы используете эту команду для отображения значения из памяти).

   Например, 'x/3uh 0x54320' -- запрос на вывод трех полуслов ('h')
памяти в формате беззнаковых десятичных целых ('u'), начиная с адреса
'0x54320'.  'x/4xw $sp' выводит четыре слова ('w') памяти, расположенные
над указателем стека (здесь '$sp'; *note Регистры: Регистры.), в
шестнадцатеричном виде ('x').

   Так как все буквы, обозначающие размер единиц измерения, отличаются
от букв, определяющих форматы вывода, вы не должны запоминать, формат
или размер единиц измерений указывается раньше; это можно делать в любом
порядке.  Спецификации вывода '4xw' и '4wx' означают в точности одно и
то же.  (Однако, число N должно быть первым; 'wx4' не сработает.)

   Хотя размер единицы измерения U игнорируется для форматов 's' и 'i',
вы, тем не менее, можете воспользоваться счетчиком повторений N;
например, '3i' указывает, что вы хотите вывести три машинные инструкции,
включая любые операнды.  Команда 'disassemble' предоставляет
альтернативный способ исследования машинных инструкций; смотрите *note
Исходный и машинный код: Машинный код.

   Все значения по умолчанию для аргументов команды 'x' разработаны
таким образом, чтобы облегчить продолжение сканирования памяти с
минимальными конкретизациями при очередном использовании 'x'.  Например,
после того, как вы просмотрели три машинные инструкции с помощью 'x/3i
АДРЕС', вы можете просмотреть следующие семь, используя просто 'x/7'.
Если вы повторяете команду 'x' нажатием <RET>, число повторений N
остается прежним; другие параметры берутся по умолчанию, как для
последовательных использований 'x'.

   Адреса и их содержимое, выводимые командой 'x', не сохраняются в
истории значений, так как они мешали бы.  Вместо этого, GDB делает их
доступными для последующего использования в выражениях как значения
вспомогательных переменных '$_' и '$__'.  После команды 'x', последний
исследованный адрес доступен для использования в выражениях во
вспомогательной переменной '$_'.  Содержимое этого адреса, исследованное
только что, доступно во вспомогательной переменной '$__'.

   Если команде 'x' задан счетчик повторений, адрес и его содержимое
сохраняются из последнего выведенного элемента памяти; это не то же
самое, что последний выведенный адрес, если в последней строке вывода
были отображены несколько элементов.


File: gdb.info,  Node: Автоматическое отображение,  Next: Параметры вывода,  Prev: Память,  Up: Данные

8.6 Автоматическое отображение
==============================

Если вам необходимо часто выводить значение какого-либо выражения (чтобы
увидеть, как оно меняется), вы можете добавить его в "список
автоматического отображения", чтобы GDB выводил его значение каждый раз
при остановке вашей программы.  Каждому выражению, добавленному в
список, присваивается идентификационный номер; чтобы удалить выражение
из списка, вы указываете этот номер.  Автоматическое отображение
выглядит следующим образом:

     2: foo = 38
     3: bar[5] = (struct hack *) 0x3804

Это отображение показывает номера элементов, выражения и их текущие
значения.  Как и при отображении, запрашиваемом вручную с помощью 'x'
или 'print', вы можете указать предпочитаемый формат вывода; фактически,
'display' выбирает между 'print' и 'x' в зависимости от того, насколько
детально задана спецификация формата: 'x' используется, если вы
указываете размер элемента или один из двух форматов ('i' и 's'),
которые поддерживаются только 'x'; в остальных случаях применяется
'print'.

'display выраж'
     Добавляет выражение ВЫРАЖ к списку выражений, отображаемых каждый
     раз, когда ваша программа останавливается.  *Note Выражения:
     Выражения.

     'display' не повторяется, если вы повторно нажимаете <RET> после ее
     использования.

'display/ФОРМАТ ВЫРАЖ'
     Если ФОРМАТ определяет только формат вывода, а не размер или
     счетчик повторений, выражение ВЫРАЖ добавляется в список
     автоматического отображения, но его отображение осуществляется в
     указанном формате ФОРМАТ.  *Note Форматы вывода: Форматы вывода.

'display/ФОРМАТ АДРЕС'
     Если ФОРМАТОМ является 'i' или 's', или он включает в себя размер
     элементов или их число, выражение АДРЕС добавляется как адрес
     памяти для исследования при каждой остановке вашей программы.  Под
     исследованием в данном случае подразумевается выполнение 'x/ФОРМАТ
     АДРЕС'.  *Note Исследование памяти: Память.

   Например, команда 'display/i $pc' может быть полезна, чтобы при
каждой остановке видеть машинную инструкцию, которая будет выполняться
следующей ('$pc' -- это общее обозначение счетчика программы; *note
Регистры: Регистры.).

'undisplay НОМЕРА...'
'delete display НОМЕРА...'
     Удалить элементы с номерами НОМЕРА из списка выражений, подлежащих
     отображению.

     'undisplay' не повторяется при последующем нажатии <RET>.  (Иначе
     вы сразу получили бы сообщение об ошибке 'No display number ...'.)

'disable display НОМЕРА...'
     Отключить отображение элементов с номерами НОМЕРА.  Отключенные
     элементы не выводятся автоматически, но и не забываются.
     Впоследствии их можно снова включить.

'enable display НОМЕРА...'
     Включить отображение элементов с номерами НОМЕРА.  Выражения,
     соответствующие этим номерам, снова будут выводиться автоматически,
     пока вы не укажете обратное.

'display'
     Отобразить текущие значения выражений из списка, точно так же, как
     это происходит при остановке вашей программы.

'info display'
     Вывести список выражений, ранее установленных для автоматического
     отображения, каждое с его номером элемента, но не показывая
     значений.  Список включает отключенные выражения, с соответствующей
     пометкой.  Он также включает в себя выражения, которые не могут
     быть показаны прямо сейчас, потому что обращаются к автоматическим
     переменным, недоступным в данный момент.

   Если отображаемое выражение обращается к локальным переменным, оно не
имеет смысла вне того лексического контекста, для которого оно
устанавливалось.  Такое выражения отключается, как только выполнение
входит в контекст, где одна из его переменных становится неопределенной.
Например, если вы дадите команду 'display last_char', находясь внутри
функции с аргументом 'last_char', GDB будет отображать этот аргумент,
пока программа останавливается внутри этой функции.  Как только она
остановится где-то еще -- где нет переменной 'last_char' -- отображение
будет отключено автоматически.  Вы можете снова включить его при
следующей остановке программы там, где 'last_char' будет вновь иметь
смысл.


File: gdb.info,  Node: Параметры вывода,  Next: История значений,  Prev: Автоматическое отображение,  Up: Данные

8.7 Параметры вывода
====================

GDB предоставляет следующие способы управления выводом массивов,
структур и символов.

Данные параметры полезны при отладке программ на любом языке:

'set print address'
'set print address on'
     GDB выводит адреса памяти, показывающие положение стека, структур,
     указателей, точек останова и так далее, даже когда он отображает
     также содержимое этих адресов.  Значение по умолчанию установлено в
     'on'.  Например, вот как выглядит отображение кадра стека с
     установленным 'set print address on':

          (gdb) f
          #0  set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
              at input.c:530
          530         if (lquote != def_lquote)

'set print address off'
     Не выводить адреса при отображении их содержимого.  Вот, например,
     тот же кадр стека, отображенный с установкой 'set print address
     off':

          (gdb) set print addr off
          (gdb) f
          #0  set_quotes (lq="<<", rq=">>") at input.c:530
          530         if (lquote != def_lquote)

     Вы можете использовать 'set print address off', чтобы удалить все
     машинно-зависимые отображения из интерфейса GDB. Например, с 'print
     address off', вы должны получить одинаковый текст для цепочек
     вызовов на всех машинах, независимо от того, включают они указатели
     в качестве аргументов или нет.

'show print address'
     Показать, должны выводиться адреса или нет.

   При выводе адреса в символьной форме, GDB обычно выводит ближайший
предшествующий символ плюс смещение.  Если этот символ не определяет
адрес однозначно (например, это имя, областью действия которого является
один исходный файл), вам может потребоваться дать пояснения.  Один из
способов это сделать -- с помощью 'info line'; например, 'info line
*0x4537'.  Альтернативный способ заключается в том, чтобы GDB выводил
имя исходного файла и номер строки при выводе символьного адреса:

'set print symbol-filename on'
     Велит GDB выводить имя исходного файла и номер строки символа в
     символьной форме адреса.

'set print symbol-filename off'
     Не выводить имя исходного файла и номер строки символа.
     Принимается по умолчанию.

'show print symbol-filename'
     Показать, будет GDB выводить имя исходного файла и номер строки в
     символьной форме адреса или нет.

   Другая ситуация, в которой полезно показывать имена файлов и номера
строк, возникает при дисассемблировании кода; GDB показывает вам номер
строки и исходный файл, которые соответствуют каждой инструкции.

   Вы также можете захотеть видеть символьную форму только в том случае,
если выводимый адрес достаточно близок к ближайшему предшествующему
символу:

'set print max-symbolic-offset МАКС-СМЕЩЕНИЕ'
     Велит GDB выводить символьные формы только тех адресов, для которых
     смещение между ближайшим предшествующим символом и адресом меньше,
     чем МАКС-СМЕЩЕНИЕ.  По умолчанию значение МАКС-СМЕЩЕНИЕ равно 0; в
     этом случае GDB всегда выводит адрес в символьной форме, если ему
     предшествует хоть какой-нибудь символ.

'show print max-symbolic-offset'
     Запрашивает информацию о максимальном смещении, для которого GDB
     выводит символьную форму адреса.

   Если у вас есть указатель, и вы не знаете, на что он указывает,
попробуйте 'set print symbol-filename on'.  Затем вы можете определить
название и исходный файл переменной, на которую он указывает, используя
'p/a УКАЗАТЕЛЬ'.  Это интерпретирует адрес в символьной форме.
Например, здесь GDB показывает, что переменная 'ptt' указывает на другую
переменную 't', определенную в файле 'hi2.c':

     (gdb) set print symbol-filename on
     (gdb) p/a ptt
     $4 = 0xe008 <t in hi2.c>

     _Предупреждение:_ Для указателей, ссылающихся на локальные
     переменные, 'p/a' не показывает символьное имя и имя файла,
     которому принадлежит объект ссылки, даже если установлен
     соответствующий параметр 'set print'.

   Другие установки управляют выводом объектов различных типов:

'set print array'
'set print array on'
     Структурный вывод массивов.  Этот формат удобнее для чтения, но
     занимает больше места.  По умолчанию отключено.

'set print array off'
     Вернуться к сжатому формату вывода массивов.

'show print array'
     Показать, какой формат (сжатый или структурный) выбран для
     отображения массивов.

'set print elements ЧИСЛО-ЭЛЕМЕНТОВ'
     Установить ограничение на количество выводимых GDB элементов
     массива.  Если GDB выводит большой массив, вывод прерывается после
     того, как будет выведено установленное командой 'set print
     elements' число элементов.  Это ограничение также действует при
     отображении строк.  Когда GDB стартует, этот предел принимается
     равным 200.  Установка ЧИСЛО-ЭЛЕМЕНТОВ в ноль означает, что вывод
     не ограничен.

'show print elements'
     Показать количество элементов большого массива, которые будут
     выведены GDB. Если это число равно 0, вывод не ограничивается.

'set print null-stop'
     Указывает GDB прекращать вывод знаков массива, как только
     встретится первый NULL.  Это полезно, когда большие массивы
     фактически содержат только короткие строки.  По умолчанию
     отключено.

'set print pretty on'
     Велит GDB выводить структуры в формате с отступами, по одному
     элементу в строке, например:

          $1 = {
            next = 0x0,
            flags = {
              sweet = 1,
              sour = 1
            },
            meat = 0x54 "Pork"
          }

'set print pretty off'
     Указывает GDB выводить структуры в компактном формате, как здесь:

          $1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
          meat = 0x54 "Pork"}

     Этот формат устанавливается по умолчанию.

'show print pretty'
     Показать, какой формат GDB использует для вывода структур.

'set print sevenbit-strings on'
     Осуществлять вывод, используя только семибитные знаки; если этот
     параметр установлен, GDB отображает любые восьмибитные знаки (в
     строках или знаковых значениях), используя запись '\'NNN.  Эта
     установка очень удобна, если вы работаете на английском (ASCII) и
     используете старший бит знаков как маркер или "мета"-бит.

'set print sevenbit-strings off'
     Выводить восьмибитные знаки полностью.  Это позволяет использовать
     большее количество международных наборов знаков; устанавливается по
     умолчанию.

'show print sevenbit-strings'
     Показать, выводит GDB только семибитные литеры или нет.

'set print union on'
     Велит GDB выводить объединения, содержащиеся в структурах.
     Устанавливается по умолчанию.

'set print union off'
     Указывает GDB не выводить объединения, содержащиеся в структурах.

'show print union'
     Запросить GDB, будет ли он выводить объединения, содержащиеся в
     структурах.

     Например, пусть даны описания

          typedef enum {Tree, Bug} Species;
          typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
          typedef enum {Caterpillar, Cocoon, Butterfly}
                        Bug_forms;

          struct thing {
            Species it;
            union {
              Tree_forms tree;
              Bug_forms bug;
            } form;
          };

          struct thing foo = {Tree, {Acorn}};

     с установленным 'set print union on', команда 'p foo' выведет

          $1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}

     а с установленным 'set print union off', эта же команда выведет

          $1 = {it = Tree, form = {...}}

Следующие установки представляют интерес при отладке программ на Си++:

'set print demangle'
'set print demangle on'
     Печатать идентификаторы Си++ в их изначальной, а не в
     закодированной ("искаженной") форме, передаваемой ассемблеру и
     компоновщику для сборки с контролем типа.  Установлено по
     умолчанию.

'show print demangle'
     Показать, в искаженной или восстановленной форме выводятся
     идентификаторы Си++.

'set print asm-demangle'
'set print asm-demangle on'
     Выводить идентификаторы Си++ в их исходной форме, а не в
     искаженной, даже при выводе ассемблерного кода, например при
     дисассемблировании инструкций.  По умолчанию отключено.

'show print asm-demangle'
     Показать, в закодированной или восстановленной форме выводятся
     имена Си++ при выводе кода ассемблера.

'set demangle-style СТИЛЬ'
     Выбрать одну из нескольких схем кодирования, используемых
     различными компиляторами для представления имен Си++.  Параметр
     СТИЛЬ может быть следующим:

     'auto'
          Позволить GDB выбрать стиль декодирования посредством изучения
          вашей программы.

     'gnu'
          Декодирование основывается на алгоритме кодирования
          компилятора GNU Си++ ('g++').  Устанавливается по умолчанию.

     'hp'
          Декодирование основывается на алгоритме кодирования HP ANSI
          Си++ ('aCC').

     'lucid'
          Декодирование основывается на алгоритме кодирования
          компилятора Lucid Си++ ('lcc').

     'arm'
          Декодировать, используя алгоритм из 'C++ Annotated Reference
          Manual'.  *Предупреждение:* одной этой установки недостаточно,
          чтобы производить отладку исполняемых программ,
          сгенерированных 'cfront'.  Чтобы реализовать это, GDB требует
          дальнейших усовершенствований.

     Если вы опустите СТИЛЬ, то увидите список возможных форматов.

'show demangle-style'
     Отобразить текущий стиль кодирования, используемый для
     декодирования символов Си++.

'set print object'
'set print object on'
     При отображении указателя на объект, идентифицировать _фактический_
     (производный), а не _объявленный_ тип объекта, используя таблицу
     виртуальных функций.

'set print object off'
     Отображать только объявленный тип объекта, не ссылаясь на таблицу
     виртуальных функций.  Устанавливается по умолчанию.

'show print object'
     Показать, какой из типов объекта выводится.

'set print static-members'
'set print static-members on'
     Выводить статические члены при отображении объекта Си++.
     Установлено по умолчанию.

'set print static-members off'
     Не выводить статические члены при отображении объекта Си++.

'show print static-members'
     Показать, выводятся статические члены Си++ или нет.

'set print vtbl'
'set print vtbl on'
     Осуществлять структурный вывод таблиц виртуальных функций Си++.  По
     умолчанию отключено.  (Команды 'vtbl' не работают для программ,
     скомпилированных компилятором HP ANSI Си++ ('aCC').)

'set print vtbl off'
     Не производить структурного вывода таблиц виртуальных функций Си++.

'show print vtbl'
     Показать, производится структурный вывод таблиц виртуальных функций
     Си++ или нет.


File: gdb.info,  Node: История значений,  Next: Вспомогательные переменные,  Prev: Параметры вывода,  Up: Данные

8.8 История значений
====================

Значения, выведенные командой 'print', сохраняются в "истории значений"
GDB. Это позволяет вам обращаться к ним в других выражениях.  Значения
сохраняются, пока таблица символов не будет заново считана или
уничтожена (например, командами 'file' или 'symbol-file').  При
изменении таблицы символов история значений уничтожается, так как
значения могут содержать указатели на типы, определенные в таблице
символов.

   Выведенным значениям присваиваются "номера в истории", по которым вы
можете на них ссылаться.  Эти номера являются последовательными целыми
числами, начинающимися с единицы.  Команда 'print' показывает номер в
истории, присвоенный значению, выводя перед ним '$НОМЕР = ', где НОМЕР
-- это номер в истории.

   Для обращения к какому-либо предшествующему значению, используйте
'$', за которым следует номер в истории.  Способ, которым 'print'
маркирует вывод, продуман так, чтобы напоминать вам об этом.  Просто '$'
ссылается на самое последнее значение в истории, а '$$' -- на
предпоследнее.  '$$N' ссылается на N-е с конца значение; '$$2' --
значение, находящееся перед '$$', '$$1' эквивалентно '$$', а '$$0'
эквивалентно '$'.

   Предположим, например, вы только что вывели указатель на структуру и
хотите посмотреть ее содержимое.  Для этого достаточно ввести

     p *$

   Если у вас есть цепочка структур, где компонента 'next' указывает на
следующую, вы можете вывести содержимое следующей структуры так:

     p *$.next

Вы можете выводить последовательные звенья в цепочке повторяя эту
команду.  Это можно сделать простым нажатием <RET>.

   Обратите внимание на то, что в историю записываются значения, а не
выражения.  Если значение 'x' равно 4, и вы наберете:

     print x
     set x=5

то значение, записанное в историю значений командой 'print', будет
по-прежнему равно 4, хотя значение 'x' изменилось.

'show values'
     Вывести из истории последние десять значений с их номерами.  Это
     похоже на команду 'p $$9', повторенную десять раз, за исключением
     того, что 'show values' не изменяет историю.

'show values N'
     Вывести десять значений из истории, расположенных вокруг элемента с
     номером N.

'show values +'
     Вывести десять значений из истории, следующих сразу после
     последнего выведенного значения.  Если доступных значений больше
     нет, 'show values +' не выводит ничего.

   Нажатие <RET> для повтора 'show values N' действует точно так же, как
'show values +'.


File: gdb.info,  Node: Вспомогательные переменные,  Next: Регистры,  Prev: История значений,  Up: Данные

8.9 Вспомогательные переменные
==============================

GDB предоставляет "вспомогательные переменные", которые вы можете в нем
использовать, чтобы сохранить значение и обратиться к нему позже.  Эти
переменные существуют только в GDB; они не являются частью вашей
программы, и установка вспомогательной переменной не оказывает
непосредственного влияния на ее дальшейшее выполнение.  Поэтому вы
можете пользоваться ими совершенно свободно.

   Имена вспомогательных переменных начинаются с '$'.  Любое имя с
приставкой '$' может использоваться для вспомогательной переменной, если
только оно не является предопределенным машинно-зависимым именем
регистра, (*note Регистры: Регистры.).  (Ссылки на историю значений,
напротив, есть _числа_, которым предшествует '$'.  *Note История
значений: История значений.)

   Вы можете сохранить значение во вспомогательной переменной с помощью
выражения присваивания, как если бы вы устанавливали переменную в вашей
программе.  Например:

     set $foo = *object_ptr

сохранит в '$foo' значение объекта, на который указывает 'object_ptr'.

   Первое использование вспомогательной переменной создает ее, но
значением переменной будет 'void', пока вы не присвоите ей новое.  С
помощью другого присваивания вы можете в любое время изменить значение.

   Вспомогательные переменные не имеют фиксированного типа.  Вы можете
присваивать вспомогательной переменной значение любого типа, включая
структуры и массивы, даже если у этой переменной уже было значение
другого типа.  Будучи использованной в выражении, вспомогательная
переменная имеет тип своего текущего значения.

'show convenience'
     Вывести список используемых вспомогательных переменных с их
     значениями.  Сокращается как 'show conv'.

   Один из способов использования вспомогательных переменных -- в
качестве увеличивающегося счетчика или продвигающегося указателя.
Например, чтобы напечатать поле из последовательных элементов массива
структур:

     set $i = 0
     print bar[$i++]->contents

Повторяйте эту команду нажатием <RET>.

   Некоторые вспомогательные переменные создаются GDB автоматически, и
им присваиваются значения, которые вероятно могут оказаться полезными.

'$_'
     Переменная '$_' устанавливается автоматически командой 'x' в
     последний исследованный адрес (*note Исследование памяти: Память.).
     Другие команды, которые устанавливают адрес по умолчанию для
     исследования командой 'x', также присваивают '$_' упомянутый адрес;
     эти команды включают 'info line' и 'info breakpoint'.  Переменная
     '$_' имеет тип 'void *', если только она не установлена командой
     'x'; в этом случае она является указателем на тип переменной '$__'.

'$__'
     Переменная '$__' устанавливается автоматически командой 'x' в
     значение, находящееся по последнему исследованному адресу.  Ее тип
     выбирается соответствующим формату, в котором это значение было
     выведено.

'$_exitcode'
     Переменной '$_exitcode' автоматически присваивается код завершения,
     когда отлаживаемая программа завершается.

   В системах HP-UX, если вы ссылаетесь на функцию или переменную, чье
имя начинается со знака доллара, GDB сначала производит поиск
пользовательского или системного имени, перед поиском вспомогательной
переменной.


File: gdb.info,  Node: Регистры,  Next: Вычисления с плавающей точкой,  Prev: Вспомогательные переменные,  Up: Данные

8.10 Регистры
=============

В выражениях, вы можете обращаться к содержимому машинных регистров,
обозначая их как переменные с именами, начинающимся с '$'.  Имена
регистров различаются от машины к машине; для вывода имен регистров,
используемых на вашей машине, воспользуйтесь командой 'info registers'.

'info registers'
     Вывести имена и содержимое всех регистров, кроме регистров с
     плавающей точкой (в выбранном кадре стека).

'info all-registers'
     Вывести имена и содержимое всех регистров, включая регистры с
     плавающей точкой.

'info registers ИМЯ-РЕГ ...'
     Выводит "относительное" значение каждого из указанных в ИМЯ-РЕГ
     регистров.  Как подробно обсуждается ниже, значения регистров
     обычно относятся к выбранному кадру стека.  ИМЯ-РЕГ может быть
     любым допустимым на вашей машине именем регистра, с '$' в начале
     имени или без.

   GDB распознает четыре "стандартных" имени регистров, которые доступны
(в выражениях) на большинстве машин -- если только они не конфликтуют с
каноническим для архитектуры обозначением регистров.  Названия регистров
'$pc' и '$sp' используются для регистра счетчика программы и указателя
вершины стека.  '$fp' используется как имя регистра, содержащего
указатель на текущий кадр стека, а '$ps' -- как имя регистра,
содержащего состояние процессора.  Например, вы можете вывести счетчик
программы в шестнадцатеричной записи с помощью

     p/x $pc

или вывести следующую исполняемую инструкцию, используя

     x/i $pc

или увеличить указатель вершины стека на четыре(1) с помощью

     set $sp += 4

   Когда возможно, эти четыре стандартных имени регистров доступны на
вашей машине, даже если она имеет другую каноническую мнемонику, если не
возникает конфликта.  Команда 'info registers' показывает канонические
имена.  В SPARC, например, 'info registers' отображает регистр состояния
процессора как '$psr', но вы также можете называть его '$ps'; а на
машинах, базирующихся на платформе x86, '$ps' является синонимом для
регистра EFLAGS.

   Когда регистр изучается таким образом, GDB всегда рассматривает
содержимое обычного регистра как целое.  Некоторые машины имеют
специальные регистры, которые могут содержать только значение с
плавающей точкой; их значения трактуются как величины с плавающей
точкой.  Не существует способа сослаться на содержимое обычного регистра
как на величину с плавающей точкой (хотя вы можете распечатать его
значение командой _print_ как величину с плавающей точкой, используя
'print/f $ИМЯ-РЕГ').

   Некоторые регистры имеют различные "необработанные" и "виртуальные"
форматы данных.  Это означает, что формат данных, в котором операционная
система сохраняет содержимое регистра, не совпадает с тем, который
обычно воспринимается вашей программой.  Например, регистры сопроцессора
с плавающей точкой 68881 всегда сохраняются в "расширенном"
(необработанном) формате, но все программы на Си работают с "двойным"
(виртуальным) форматом.  В подобных случаях, GDB обычно работает только
с виртуальным форматом (форматом, имеющим смысл в вашей программе), но
команда 'info registers' выводит данные в обоих форматах.

   Обычно значения регистров относятся к выбранному кадру стека (*note
Выбор кадра: Выбор.).  Это значит, что вы получаете значение, которое
содержалось бы в регистре, если бы произошел выход из всех внутренних
кадров стека, и их сохраненные регистры были бы восстановлены.  Для
того, чтобы увидеть истинное содержимое аппаратных регистров, вы должны
выбрать самый внутренний кадр (с помощью 'frame 0').

   Однако, GDB, исходя из машинного кода, сгенерированного вашим
компилятором, должен установить, где сохранены регистры.  Если некоторые
регистры не сохранены, или если GDB не в состоянии найти сохраненные
регистры, выбранный кадр стека не имеет значения.

   ---------- Footnotes ----------

   (1) На машинах, где стек растет вниз в памяти (в наши дни, на
большинстве машин), это способ удалить одно слово из стека.  Это
подразумевает, что выбран самый внутренний кадр; когда выбраны другие
кадры стека, установка '$sp' не разрешена.  Используйте 'return' для
извлечения целого кадра из стека, вне зависимости от архитектуры машины;
смотрите *note Возврат из функции: Возврат.


File: gdb.info,  Node: Вычисления с плавающей точкой,  Prev: Регистры,  Up: Данные

8.11 Аппаратные средства поддержки вычислений с плавающей точкой
================================================================

В зависимости от конфигурации, GDB может выдать вам больше информации о
состоянии аппаратных средств поддержки вычислений с плавающей точкой.

'info float'
     Отобразить аппаратно-зависимую информацию о модуле поддержки
     вычислений с плавающей точкой.  Ее точное содержание и размещение
     зависит от микросхемы поддержки вычислений с плавающей точкой.  В
     настоящее время, 'info float' поддерживается на машинах ARM и x86.


File: gdb.info,  Node: Языки,  Next: Символы,  Prev: Данные,  Up: Top

9 Использование GDB с различными языками программирования
*********************************************************

Хотя языки программирования обычно имеют общие аспекты, их выражения
редко выглядят одинаково.  Например, в ANSI Си, разыменование указателя
'p' осуществляется операцией '*p', а в Модуле-2 это выполняется как
'p^'.  Представление (и отображение) значений также может быть
различным.  Шестнадцатеричные числа в Си отображаются как '0x1ae', в то
время как в Модуле-2 они отображаются как '1AEH'.

   В GDB встроена специальная информация о некоторых языках, которая
позволяет описывать действия, подобные упомянутым, на языке вашей
программы, и позволяет GDB выводить значения в виде, принятом в языке,
на котором написана ваша программа.  Язык, которым вы пользуетесь для
построения выражений, называется "рабочим языком".

* Menu:

* Переход от одного языка к другому::
                                Переход от одного языка к другому
* Отображение языка::           Отображение языка
* Проверка::                    Проверки диапазона и соответствия типов
* Поддержка::                   Поддерживаемые языки


File: gdb.info,  Node: Переход от одного языка к другому,  Next: Отображение языка,  Up: Языки

9.1 Переход от одного языка к другому
=====================================

Существует два способа управления рабочим языком: либо GDB устанавливает
его автоматически, либо вы можете сделать это самостоятельно.  Для этих
целей вы можете воспользоваться командой 'set language'.  По умолчанию,
при старте GDB устанавливает язык автоматически.  Рабочий язык
используется, чтобы определить, как интерпретируются вводимые вами
выражения, как выводятся значения, и так далее.

   В дополнение к рабочему языку, каждый исходный файл, с которым
работает GDB, имеет свой собственный рабочий язык.  Для некоторых
форматов объектных файлов компилятор может указывать, на каком языке
написан конкретный исходный файл.  Однако, чаще всего GDB распознает
язык по имени файла.  Язык исходного файла определяет, будут ли
восстанавливаться имена Си++; таким образом, 'backtrace' может
показывать каждый кадр в соответствии с исходным языком.  Не существует
способа установить язык исходного файла из GDB, но вы можете установить
язык, ассоциированный с расширением файла.  *Note Отображение языка
программирования: Отображение языка.

   Наиболее часто эта проблема возникает, когда вы используете
программу, такую как 'cfront' или 'f2c', которая создает текст на Си, но
написана на другом языке.  В этом случае нужно сделать, чтобы программа
использовала директивы '#line' в выводе текста Си; тогда GDB будет знать
правильный язык исходного текста первоначальной программы, и выведет
этот исходный код, а не сгенерированный код Си.

* Menu:

* Имена файлов::                Расширения имен файлов и языки
* Установка рабочего языка::    Установки рабочего языка вручную
* Автоматическое::              Распознавание GDB исходного языка


File: gdb.info,  Node: Имена файлов,  Next: Установка рабочего языка,  Up: Переход от одного языка к другому

9.1.1 Соответствие расширений файлов и языков
---------------------------------------------

Если имя исходного файла заканчивается одним из следующих расширений, то
GDB воспринимает это как указание на обозначенный язык.

'.c'
     Исходный файл Си

'.C'
'.cc'
'.cp'
'.cpp'
'.cxx'
'.c++'
     Исходный файл Си++

'.f'
'.F'
     Исходный файл Фортрана

'.ch'
'.c186'
'.c286'
     Исходный файл CHILL

'.mod'
     Исходный файл Модулы-2

'.s'
'.S'
     Исходный файл Ассемблера.  В действительности, воспринимается почти
     также, как Си, но GDB не пропускает вводные части функций при
     пошаговом выполнении.

   В дополнение к этому, вы можете установить язык, ассоциированный с
расширением имени файла.  *Note Отображение языка программирования:
Отображение языка.


File: gdb.info,  Node: Установка рабочего языка,  Next: Автоматическое,  Prev: Имена файлов,  Up: Переход от одного языка к другому

9.1.2 Установка рабочего языка
------------------------------

Если вы позволяете GDB устанавливать язык автоматически, выражения в
сеансе отладки и в вашей программе интерпретируются одинаково.

   По желанию, вы можете установить язык сами.  Для этого воспользуйтесь
командой 'set language ЯЗЫК', где ЯЗЫК -- название языка, например, 'c'
или 'modula-2'.  Чтобы получить перечень поддерживаемых языков, наберите
'set language'.

   Установка языка вручную запрещает GDB автоматически переключать
рабочий язык.  Это может привести к неприятным последствиям, если вы
попытаетесь отладить программу, когда рабочий язык не совпадает с
исходным языком, а выражение допустимо в обоих языках, но означает
разные вещи.  Например, если текущий исходный файл написан на Си, а в
GDB выбрана Модула-2, команда

     print a = b + c

может не привести к ожидаемому результату.  В Си это означает сложить
'b' и 'c' и поместить результат в 'a'.  Выведенным результатом будет
значение 'a'.  В Модуле-2 это означает сравнение 'a' с результатом
'b+c', выдающее значение типа 'BOOLEAN'.


File: gdb.info,  Node: Автоматическое,  Prev: Установка рабочего языка,  Up: Переход от одного языка к другому

9.1.3 Распознавание GDB исходного языка
---------------------------------------

Для автоматической установки рабочего языка, используйте 'set language
local' или 'set language auto'.  Тогда GDB будет определять рабочий язык
автоматически.  То есть при остановке вашей программы в кадре стека
(обычно, в точке останова), GDB устанавливает рабочий язык в тот,
который записан для функции в этом кадре.  Если язык для кадра
неизвестен (то есть, если функция или блок, соответствующие кадру, были
определены в исходном файле, не имевшем распознаваемого расширения),
текущий рабочий язык не изменяется, а GDB выдает предупреждающее
сообщение.

   Для большинства программ, которые написаны целиком на одном языке,
автоматическая установка языка может показаться ненужной.  Однако, в
основной программе, написанной на одном исходном языке, могут
использоваться программные модули и библиотеки, написанные на другом
исходном языке.  Использование в этом случае 'set language auto'
освобождает вас от установки рабочего языка вручную.


File: gdb.info,  Node: Отображение языка,  Next: Проверка,  Prev: Переход от одного языка к другому,  Up: Языки

9.2 Отображение языка программирования
======================================

Следующие команды помогают вам определить, какой язык является рабочим,
а также на каком языке были написаны исходные файлы.

'show language'
     Отобразить текущий рабочий язык.  Это тот язык, который вы можете
     использовать в командах типа 'print' для построения и вычисления
     выражений, в которые могут входить переменные вашей программы.

'info frame'
     Отобразить исходный язык для данного кадра стека.  Этот язык
     становится рабочим, если используется идентификатор из этого кадра.
     *Note Информация о кадре стека: Информация о кадре, для
     дополнительной информации.

'info source'
     Отобразить исходный язык данного исходного файла.  *Note
     Исследование таблицы символов: Символы, для получения
     дополнительной информации.

   При необычных обстоятельствах, у вас могут быть исходные файлы с
расширениями, не входящими в стандартный список.  Вы можете явно
установить расширение, ассоциированное с языком:

'set extension-language .РАСШ ЯЗЫК'
     Установить соответствие исходных файлов с расширением .РАСШ с
     исходным языком ЯЗЫК.

'info extensions'
     Перечислить все расширения имен файлов и соответствующие им языки.


File: gdb.info,  Node: Проверка,  Next: Поддержка,  Prev: Отображение языка,  Up: Языки

9.3 Проверка диапазона и принадлежности типу
============================================

     _Предупреждение:_ В этот выпуск включены команды GDB для проверки
     диапазона и соответствия типов, но они пока не оказывают никакого
     действия.  Этот раздел описывает их предполагаемые возможности.

   Некоторые языки обеспечивают защиту от достаточно общих ошибок с
помощью набора проверок времени компиляции и времени выполнения.  Это
включает проверку типов аргументов функций и операторов и обеспечивает
проверку математического переполнения во время выполнения.  Проверки
такого рода помогают убедиться в корректности программы после ее
компиляции путем устранения несоответствия типов, и предоставляя
активную проверку ошибок выхода за пределы диапазона во время
выполнения.

   По вашему желанию, GDB может проводить подобные проверки.  Хотя GDB
не проверяет операторы вашей программы, он может, например, проверять
выражения, введенные непосредственно в GDB для вычисления командой
'print'.  Как и в случае рабочего языка, GDB может также автоматически
решить, выполнять проверку или нет, основываясь на исходном языке вашей
программы.  *Note Поддерживаемые языки: Поддержка, для информации об
установках по умолчанию для поддерживаемых языков.

* Menu:

* Проверка типов::              Обзор проверки типов
* Проверка диапазона::          Обзор проверки диапазона


File: gdb.info,  Node: Проверка типов,  Next: Проверка диапазона,  Up: Проверка

9.3.1 Краткий обзор проверки соответствия типов
-----------------------------------------------

Некоторые языки, такие как Модула-2, должны иметь жесткое соответствие
типов, то есть аргументы операторов и функций должны иметь правильный
тип, в противном случае возникает ошибка.  Описанные здесь проверки
предотвращают ошибки несоответствия типов, которые могут вызвать ошибки
времени выполнения.  Например,

     1 + 2 => 3
но
     error-> 1 + 2.3

   Во втором примере ошибка, потому что 'CARDINAL' 1 не совместим по
типу с 'REAL' 2.3.

   Для выражений, используемых вами в командах GDB, вы можете указать
GDB не производить проверку; или же рассматривать любое несоответствие
как ошибку и прекращать обработку выражения; или только выводить
предупреждение в случае возникновения несоответствия, но вычислять
выражение в любом случае.  В последнем случае, GDB вычисляет выражения,
подобные второму примеру, но также выводит предупреждающее сообщение.

   Даже если вы отключили проверку типов, GDB может прекратить обработку
выражения по другим причинам, связанным с типами.  Например, GDB не
знает, как сложить 'int' и 'struct foo'.  Такие типы ошибок не имеют
ничего общего с используемым языком и обычно возникают из выражений,
подобных описанному выше, которые нет смысла вычислять.

   Каждый язык определяет степень строгости контроля типов.  Например,
как Модула-2, так и Си требуют, чтобы аргументы арифметических операций
были числами.  В Си, перечисляемые типы и указатели могут быть
представлены в виде чисел, так что они допустимы в качестве аргументов
математических операторов.  *Note Поддерживаемые языки: Поддержка, для
более подробного обсуждения конкретных языков.

   GDB предоставляет некоторые дополнительные команды для контроля
проверки типов:

'set check type auto'
     Включить или отключить контроль типов, в зависимости от текущего
     рабочего языка.  *Note Поддерживаемые языки: Поддержка, для
     установок по умолчанию для каждого языка.

'set check type on'
'set check type off'
     Включить или отключить контроль типов, пренебрегая установкой по
     умолчанию для текущего рабочего языка.  Вывести предупреждающее
     сообщение, если установка не соответствует используемой по
     умолчанию.  Если возникает несоответствие типов во время вычисления
     выражения при включенном контроле типов, GDB выводит сообщение и
     прерывает вычисление выражения.

'set check type warn'
     При возникновении несоответствия типов вывести предупреждающее
     сообщение, но попытаться вычислить выражение.  Вычисление выражения
     все же может быть невозможным по другим причинам.  Например, GDB не
     может складывать числа со структурами.

'show type'
     Показать текущую установку проверки типов, а также была ли она
     установлена GDB автоматически.


File: gdb.info,  Node: Проверка диапазона,  Prev: Проверка типов,  Up: Проверка

9.3.2 Краткий обзор проверки диапазона
--------------------------------------

В некоторых языках (например, в Модуле-2), выход за границы диапазона
типа считается ошибкой; эти ошибки отслеживаются с помощью контроля
времени выполнения.  Эти проверки диапазона служат для того, чтобы
избежать переполнения при вычислениях и не допустить превышения
индексами элементов массива границ индексации.

   В выражениях, используемых вами в командах GDB, вы можете указать GDB
обрабатывать ошибки диапазона одним из трех способов: игнорировать их,
всегда рассматривать как ошибки и прерывать обработку выражения, или
выводить предупреждение и продолжать вычисление выражения.

   Ошибки диапазона могут возникать при числовом переполнении, при
превышении границы индексации массива или при использовании константы,
не принадлежащей ни одному типу.  Однако, некоторые языки не считают
переполнение ошибкой.  Во многих реализациях Си математическое
переполнение вызывает "циклический переход" к меньшему значению.
Например, если M -- наибольшее целое значение, а S -- наименьшее, то

     M + 1 => S

   Это также является специфичным для конкретных языков, а в некоторых
случаях -- для отдельного компилятора или машины.  Для дальнейших
сведений по отдельным языкам, *Note Поддерживаемые языки: Поддержка.

   GDB обеспечивает некоторые дополнительные команды для контроля
проверки диапазона:

'set check range auto'
     Включить или отключить контроль диапазона, в зависимости от
     текущего рабочего языка.  *Note Поддерживаемые языки: Поддержка,
     для получения информации об установках по умолчанию для каждого
     языка.

'set check range on'
'set check range off'
     Включить или отключить контроль типов, пренебрегая установкой по
     умолчанию для текущего рабочего языка.  Если установка не
     соответствует используемой по умолчанию, выводится предупреждающее
     сообщение.  Если происходит ошибка диапазона и контроль включен,
     выводится сообщение и вычисление выражения прерывается.

'set check range warn'
     При выявлении ошибки диапазона GDB выведет предупреждающее
     сообщение, но попытается вычислить выражение.  Тем не менее,
     вычисление выражения может быть невозможным по другим причинам,
     таким как обращение к памяти, которой процесс не владеет (типичный
     пример для многих систем Unix).

'show range'
     Показать текущую установку проверки диапазона, и была ли она
     установлена GDB автоматически.


File: gdb.info,  Node: Поддержка,  Prev: Проверка,  Up: Языки

9.4 Поддерживаемые языки
========================

GDB поддерживает Си, Си++, Фортран, Java, Chill, Ассемблер и Модулу-2.
Некоторые возможности GDB могут быть задействованы в выражениях
независимо от используемого языка: операторы GDB '@' и '::' и
конструкция '{тип}адрес' (*note Выражения: Выражения.) могут быть
использованы в конструкциях любого поддерживаемого языка.

   Следующие разделы подробно описывают, до какой степени каждый из
исходных языков поддерживается GDB. Эти разделы не задумывались как
учебники или руководства по языкам; они лишь служат справочным
руководством по тому, что допускает анализатор выражений GDB, и как
должны выглядеть входные и выходные форматы в различных языках.
Существует много хороших книг по каждому из этих языков; пожалуйста,
загляните в них, если вам нужен учебник или справочник по языку.

* Menu:

* Си::          Си и Си++
* Модула-2::    Модула-2
* Chill::       Chill


File: gdb.info,  Node: Си,  Next: Модула-2,  Up: Поддержка

9.4.1 Си и Си++
---------------

Поскольку Си и Си++ тесно связаны, многие возможности GDB применимы к
ним обоим.  Когда это имеет место, мы обсуждаем эти языки вместе.

   Средства отладки Си++ обеспечиваются совместно компилятором Си++ и
GDB. Следовательно, для эффективной отладки программы на Си++, вам
следует пользоваться одним из поддерживаемых компиляторов, например GNU
'g++', или компилятором HP ANSI Си++ ('aCC').

   При использовании GNU Си++, для получения наилучших результатов
используйте формат отладочной информации stabs.  Вы можете выбрать его
явно с помощью ключа командной строки '-gstabs' или '-gstabs+'.
Смотрите *note Ключи для отладки вашей программы или GNU CC:
(gcc.info)Отладочные ключи, для дополнительной информации.

* Menu:

* Операторы Си::                Операторы Си и Си++
* Константы Си::                Константы Си и Си++
* Выражения Си++::              Выражения Си++
* Значения Си по умолчанию::    Значения по умолчанию Си и Си++
* Проверки в Си::               Проверки диапазона и типов Си и Си++
* Отладка Си::                  GDB и Си
* Отладка Си++::                Возможности GDB для Си++


File: gdb.info,  Node: Операторы Си,  Next: Константы Си,  Up: Си

9.4.1.1 Операторы Си и Си++
...........................

Операторы должны быть определены на значениях определенных типов.
Например, '+' определен на числах, но не на структурах.  Операторы часто
определяются на группах типов.

   Для целей Си и Си++, имеют место следующие определения:

   * _Целые типы_ включают 'int' с любыми спецификаторами класса памяти;
     'char'; 'enum'; и, для Си++, 'bool'.

   * _Типы с плавающей точкой_ включают 'float', 'double' и 'long
     double' (если поддерживается целевой платформой).

   * _Типы указателей_ включают все типы, определенные как '(ТИП *)'.

   * _Скалярные типы_ включают все вышеперечисленные типы.

Поддерживаются следующие операторы, перечисленные здесь в порядке
возрастания приоритета:

','
     Запятая, или оператор последовательного выполнения.  Выражения,
     разделенные в списке запятыми, вычисляются слева направо;
     результатом всего выражения является результат, полученный
     последним.

'='
     Присваивание.  Значение выражения присваивания -- присвоенное
     значение.  Определено на скалярных типах.

'ОПЕР='
     Используется в выражениях в форме 'A ОПЕР= B' и преобразовывается в
     'A = A ОПЕР B'. 'ОПЕР=' и '=' имеют одинаковый приоритет.  ОПЕР
     может быть одним из операторов '|', '^', '&', '<<', '>>', '+', '-',
     '*', '/', '%'.

'?:'
     Тернарный оператор.  'A ? B : C' истолковывается так: если A, то B,
     иначе C.  A должно быть целого типа.

'||'
     Логическое ИЛИ.  Определено на целых типах.

'&&'
     Логическое И.  Определено на целых типах.

'|'
     Побитовое ИЛИ.  Определено на целых типах.

'^'
     Побитовое исключающее ИЛИ.  Определено на целых типах.

'&'
     Побитовое И.  Определено на целых типах.

'==, !='
     Равенство и неравенство.  Определено на скалярных типах.  Значение
     этих выражений отлично от нуля для истины и 0 для лжи.

'<, >, <=, >='
     Меньше чем, больше чем, меньше или равно, больше или равно.
     Определено на скалярных типах.  Значение этих выражений равно 0 для
     лжи и отлично от нуля для истины.

'<<, >>'
     Левый сдвиг и правый сдвиг.  Определено на целых типах.

'@'
     Оператор GDB создания "искусственного массива" (*note Выражения:
     Выражения.).

'+, -'
     Сложение и вычитание.  Определено на целочисленных типах, типах с
     плавающей точкой и указателях.

'*, /, %'
     Умножение, деление и остаток.  Умножение и деление определены на
     целочисленных типах и типах с плавающей точкой.  Остаток определен
     на целочисленных типах.

'++, --'
     Инкремент и декремент.  При появлении перед переменной, операция
     выполняется прежде, чем переменная используется в выражении; при
     появлении после переменной, значение переменной используется до
     выполнения операции.

'*'
     Разыменование указателя.  Определено для указателей.  Имеет тот же
     приоритет, что и '++'.

'&'
     Оператор получения адреса.  Определен на переменных.  Имеет тот же
     приоритет, что и '++'.

     Для отладки Си++, GDB реализует использование '&' независимо от
     того, что позволяет сам язык Си++: вы можете использовать
     '&(&ССЫЛКА)' (или просто '&&ССЫЛКА'), чтобы исследовать адрес, по
     которому хранится переменная-ссылка Си++ (объявленная с помощью
     '&ССЫЛКА').

'-'
     Унарный минус.  Определен на целочисленных типах и типах с
     плавающей точкой.  Имеет тот же приоритет, что и '++'.

'!'
     Логическое отрицание.  Определено на целочисленных типах.  Имеет
     тот же приоритет, что и '++'.

'~'
     Оператор побитового дополнения.  Определен на целочисленных типах.
     Имеет тот же приоритет, что и '++'.

'., ->'
     Элемент структуры и указатель на элемент структуры.  Для удобства,
     GDB считает их эквивалентными, определяя, следует ли разыменовывать
     указатель, основываясь на сохраненной информации о типах.
     Определен на данных структуры ('struct') и объединения ('union').

'.*, ->*'
     Разыменовывание указателя на элемент.

'[]'
     Индексация массива.  'A[I]' определяется как '*(A+I)'.  Имеет тот
     же приоритет, что и '->'.

'()'
     Список параметров функции.  Имеет тот же приоритет, что и '->'.

'::'
     Оператор Си++ определения области видимости.  Определен на типах
     'struct', 'union' и 'class'.

'::'
     Двойное двоеточие также представляет оператор GDB области видимости
     (*note Выражения: Выражения.).  Имеет тот же приоритет, что и '::',
     описанный выше.

   Если оператор переопределен в пользовательском коде, GDB обычно
пытается выполнить переопределенную версию, а не использовать
предопределенное значение оператора.


File: gdb.info,  Node: Константы Си,  Next: Выражения Си++,  Prev: Операторы Си,  Up: Си

9.4.1.2 Константы Си и Си++
...........................

GDB позволяет вам выражать константы Си и Си++ следующими способами:

   * Целочисленные константы -- это последовательности цифр.
     Восьмеричные константы начинаются с '0' (с нуля), а
     шестнадцатеричные константы -- с '0x' или '0X'.  Константы также
     могут заканчиваться буквой 'l', указывая, что значение константы
     должно рассматриваться как длинное ('long').

   * Константы с плавающей точкой -- это последовательность цифр, за
     которой следует десятичная точка, другая последовательность цифр,
     и, возможно, порядок.  Порядок указывается в форме 'e[[+]|-]NNN',
     где NNN -- другая последовательность цифр.  Для положительных
     порядков '+' является необязательным.  Константа с плавающей точкой
     может также заканчиваться буквой 'f' или 'F', это указывает на то,
     что константа должна рассматриваться как 'float' (в отличие от
     'double' по умолчанию), или буквой 'l' или 'L', что указывает на
     константу типа 'long double'.

   * Перечисляемые константы состоят из перечисляемых идентификаторов,
     или их целочисленных эквивалентов.

   * Знаковые константы -- это одиночный знак, заключенный в одиночные
     кавычки ('''), или число -- порядковое значение соответствующего
     знака (обычно его значение ASCII).  Внутри кавычек, одиночный знак
     может быть представлен либо буквой, либо "экранирующей
     последовательностью", которая имеет форму '\NNN', где NNN является
     восьмеричным представлением порядкового значения знака; или форму
     '\X', где 'X' -- специальный предопределенный знак, например, '\n'
     для знака новой строки.

   * Строковые константы -- последовательность знаковых констант (без
     одиночных кавычек), заключенная в двойные кавычки ('"').  Туда
     могут входить любые допустимые знаковые константы (как описано
     выше).  Двойным кавычкам внутри строки должна предшествовать
     обратная косая черта, так что '"a\"b'c"', например, является
     строкой из пяти знаков.

   * Константы-указатели представляют собой целочисленные значения.  Вы
     можете также записывать указатели на константы, используя оператор
     Cи '&'.

   * Константы-массивы -- заключенные в фигурные скобки ('{' и '}')
     списки элементов, разделенные запятыми.  Например, '{1,2,3}'
     является массивом с тремя целочисленными элементами, '{{1,2},
     {3,4}, {5,6}}' является массивом размерности три на два, а '{&"hi",
     &"there", &"fred"}' является трехэлементным массивом указателей.


File: gdb.info,  Node: Выражения Си++,  Next: Значения Си по умолчанию,  Prev: Константы Си,  Up: Си

9.4.1.3 Выражения Си++
......................

Обработчик выражений GDB может интерпретировать большинство выражений
Си++.

     _Предупреждение:_ GDB может отлаживать программы на Си++, только
     если вы используете подходящий компилятор.  Обычно отладка Си++
     зависит от использования дополнительной отладочной информации в
     таблице символов и, таким образом, требует специальной поддержки.
     В частности, если ваш компилятор генерирует a.out, MIPS ECOFF,
     RS/6000 XCOFF или ELF с расширениями stabs к таблице символов, все
     эти средства доступны.  (С GNU CC вы можете использовать ключ
     '-gstabs', чтобы явно запросить расширения отладки stabs).  С
     другой стороны, если формат объектного кода -- стандартный COFF или
     DWARF в ELF, значительная часть поддержки Си++ в GDB _не_ работает.

  1. Допускаются вызовы функций-членов; вы можете использовать выражения
     типа

          count = aml->GetOriginal(x, y)

  2. Пока функция-член активна (в выбранном кадре стека), вашим
     выражениям доступно то же пространство имен, что и функции-члену;
     то есть GDB допускает неявные ссылки на указатель экземпляра класса
     'this' по тем же правилам, что и Си++.

  3. Вы можете вызывать перегруженные функции; GDB производит вызов
     функции с правильным определением, но с некоторыми ограничениями.
     GDB не совершает преобразования, для выполнения которых требуются
     преобразования типов, определенные пользователем, вызовы
     конструкторов или конкретизации не существующих в программе
     шаблонов.  Он также не может обрабатывать списки с неопределенным
     числом аргументов или аргументы со значениями по умолчанию.

     Он производит преобразования и расширения целочисленных типов,
     расширения типов с плавающей точкой, арифметические преобразования,
     преобразования указателей, преобразования класса объекта в базовые
     классы и стандартные преобразования, например функции или массива к
     указателю; это требует точного совпадения числа аргументов функции.

     Разрешение перегруженных имен производится всегда, если не указано
     'set overload-resolution off'.  *Note Возможности GDB для Си++:
     Отладка Си++.

     Вы должны указать 'set overload-resolution off', чтобы задать
     функцию явно при вызове перегруженной функции, как в примере

          p 'foo(char,int)'('x', 13)

     Возможности GDB для завершения команд могут упростить это; смотрите
     *note Завершение команд: Завершение.

  4. GDB понимает переменные, объявленные как ссылки Си++; вы можете
     использовать их в выражениях, точно как вы делаете в исходном
     тексте Си++ -- они автоматически разыменовываются.

     В списке параметров, показываемом GDB при отображении кадра стека,
     значения переменных-ссылок не отображаются (в отличие от других
     переменных); это позволяет избежать неудобств из-за того, что
     ссылки часто используются для больших структур.  _Адрес_
     переменной-ссылки всегда выводится, если только вы не установили
     'set print address off'.

  5. GDB поддерживает оператор Си++ определения области видимости имени
     '::' -- ваши выражения могут использовать его так же, как в вашей
     программе.  Так как одна область видимости может быть определена
     внутри другой, вы можете при необходимости неоднократно
     использовать '::', например, в выражении типа 'ОБЛ1::ОБЛ2::ИМЯ'.
     GDB также позволяет определить область видимости имени путем ссылки
     на исходный файл, при отладке как Си, так и Си++ (*note Переменные
     программы: Переменные.).

   Кроме того, при использовании с компилятором HP Си++, GDB правильно
поддерживает вызов виртуальных функций, вывод виртуальных баз объектов,
вызов функций в базовом подобъекте, приведение объектов и выполнение
операторов, определенных пользователем.


File: gdb.info,  Node: Значения Си по умолчанию,  Next: Проверки в Си,  Prev: Выражения Си++,  Up: Си

9.4.1.4 Значения Си и Си++ по умолчанию
.......................................

Если вы разрешаете GDB устанавливать проверки диапазона и принадлежности
типу автоматически, обе они по умолчанию _отключены_, если рабочий язык
изменяется на Си или Си++.  Это происходит независимо от того, выбираете
рабочий язык вы или GDB.

   Если вы разрешаете GDB устанавливать язык автоматически, он
распознает исходные файлы, чьи имена заканчиваются расширением '.c',
'.C' или '.cc' и так далее, и когда GDB начинает обработку кода,
скомпилированного из одного из этих файлов, он устанавливает рабочий
язык в Си или Си++.  *Note Распознавание GDB рабочего языка:
Автоматическое, для более подробного обсуждения.


File: gdb.info,  Node: Проверки в Си,  Next: Отладка Си,  Prev: Значения Си по умолчанию,  Up: Си

9.4.1.5 Проверки диапазона и принадлежности типу в Си и Си++
............................................................

Когда GDB производит разбор выражений Си или Си++, по умолчанию проверки
соответствия типов не проводятся.  Однако, если вы их включите, GDB
считает типы двух переменных эквивалентными, если:

   * Обе переменные структурированы и имеют один и тот же тег структуры,
     объединения или перечисления.

   * Имена типов обеих переменных совпадают или были объявлены
     эквивалентными через 'typedef'.

   Проверка диапазона, если она включена, выполняется для математических
операций.  Индексы массивов не проверяются, так как они часто
применяются для индексирования указателей, которые сами по себе
массивами не являются.


File: gdb.info,  Node: Отладка Си,  Next: Отладка Си++,  Prev: Проверки в Си,  Up: Си

9.4.1.6 GDB и Си
................

Команды 'set print union' и 'show print union' применимы к типу 'union'.
При установке в 'on', любые объединения, находящиеся внутри структуры
или класса, также выводятся.  В противном случае, они отображаются как
'{...}'.

   Оператор '@' помогает при отладке динамических массивов,
сформированных с помощью указателей и функции выделения памяти.  *Note
Выражения: Выражения.


File: gdb.info,  Node: Отладка Си++,  Prev: Отладка Си,  Up: Си

9.4.1.7 Возможности GDB для Си++
................................

Некоторые команды GDB особенно полезны при использовании с Си++, а
некоторые разработаны специально для него.  Ниже приведено их краткое
описание:

'меню точки останова'
     Когда вы хотите установить точку останова в перегруженной функции,
     меню точки останова GDB помогает вам указать, какое определение
     функции вам нужно.  *Note Меню точки останова: Меню точки останова.

'rbreak РЕГ-ВЫР'
     Установка точек останова при помощи регулярных выражений полезна
     при использовании перегруженных функций, не являющихся членами
     специальных классов.  *Note Установка точек останова: Установка
     точек останова.

'catch throw'
'catch catch'
     Отлаживайте обработку исключений Си++ с помощью этих команд.  *Note
     Установка точек перехвата: Установка точек перехвата.

'ptype ИМЯ-ТИПА'
     Вывести отношения наследования вместе с другой информацией для типа
     ИМЯ-ТИПА.  *Note Исследование таблицы символов: Символы.

'set print demangle'
'show print demangle'
'set print asm-demangle'
'show print asm-demangle'
     Управляет отображением символов Си++ в их исходной форме, как при
     выводе кода в виде исходного текста Си++, так и при выводе
     результата дисассемблирования.  *Note Параметры вывода: Параметры
     вывода.

'set print object'
'show print object'
     Выбрать, выводить производные (реальные) или описанные типы
     объектов.  *Note Параметры вывода: Параметры вывода.

'set print vtbl'
'show print vtbl'
     Управляет форматом вывода таблиц виртуальных функций.  *Note
     Параметры вывода: Параметры вывода.  (Команды 'vtbl' не работают
     для программ, скомпилированных компилятором HP ANSI Си++ ('aCC').)

'set overload-resolution on'
     Включить разрешение перегруженных символов при вычислении выражений
     Си++.  Значение по умолчанию 'on'.  Для перегруженных функций, GDB
     вычисляет аргументы и ищет функции, чьи сигнатуры удовлетворяют
     типам аргументов, используя стандартные правила преобразования Си++
     (смотрите *note Выражения Си++: Выражения Си++, для дополнительной
     информации).  Если GDB не может найти такие функции, он выводит
     сообщение.

'set overload-resolution off'
     Отключить разрешение перегруженных символов при вычислении
     выражений Си++.  Для перегруженных функций, не являющихся
     функциями-членами класса, GDB выбирает функцию с указанным именем,
     которую он первой находит в таблице символов, вне зависимости от
     того, правильного типа ее аргументы или нет.  Для перегруженных
     функций, являющихся функциями-членами класса, GDB ищет функцию, чья
     сигнатура _точно_ совпадает с типами аргументов.

'Перегруженные имена символов'
     Вы можете указать конкретное определение перегруженного символа,
     используя ту же запись, что и для объявления таких символов в Си++:
     введите 'СИМВОЛ(ТИПЫ)' вместо просто СИМВОЛ.  Вы также можете
     воспользоваться средствами завершения слова командной строки GDB,
     чтобы вывести список возможных вариантов, или чтобы завершить набор
     за вас.  *Note Завершение команд: Завершение, для подробного
     обсуждения, как это сделать.


File: gdb.info,  Node: Модула-2,  Next: Chill,  Prev: Си,  Up: Поддержка

9.4.2 Модула-2
--------------

Расширения, сделанные в GDB для поддержки Модулы-2, поддерживаются
только для программ, скомпилированных компилятором Модулы-2 GNU (который
сейчас разрабатывается).  Другие компиляторы Модулы-2 в настоящее время
не поддерживаются, и попытка отладки исполняемых программ, полученных
ими, скорее всего приведет к ошибке при считывании GDB таблицы символов
этой программы.

* Menu:

* Операторы Модулы-2::           Встроенные операторы
* Встроенные функции/процедуры:: Встроенные функции и процедуры
* Константы Модулы-2::           Константы Модулы-2
* Установки по умолчанию М-2::   Установки по умолчанию для Модулы-2
* Отклонения::                   Отклонения от стандарта Модулы-2
* Проверки Модулы-2::            Проверки диапазона и типа в Модулы-2
* Область видимости в Модуле-2:: Операторы определения области видимости
                                 '::' и '.'
* GDB и Модула-2::               GDB и Модула-2


File: gdb.info,  Node: Операторы Модулы-2,  Next: Встроенные функции/процедуры,  Up: Модула-2

9.4.2.1 Операторы Модулы-2
..........................

Операторы должны быть определены на значениях определенных типов.
Например, '+' определен на числах, но не на структурах.  Операторы часто
определяются на группах типов.  Для целей Модулы-2, имеют место
следующие определения:

   * _Целые типы_ состоят из 'INTEGER', 'CARDINAL' и их поддиапазонов.

   * _Знаковые типы_ состоят из 'CHAR' и его поддиапазонов.

   * _Типы с плавающей точкой_ состоят из 'REAL'.

   * _Типы-указатели_ состоят из всего, объявленного как 'POINTER TO
     ТИП'.

   * _Скалярные типы_ включают все вышеперечисленное.

   * _Типы-множества_ состоят из типов 'SET' и 'BITSET'.

   * _Булевый тип_ состоит из 'BOOLEAN'.

Поддерживаются следующие операторы; они представлены в порядке
возрастания приоритета:

','
     Разделитель аргументов функции или индексов массива.

':='
     Присваивание.  Значением 'ПЕРЕМ := ЗНАЧ' является ЗНАЧ.

'<, >'
     Меньше чем, больше чем для целочисленных типов, типов с плавающей
     точкой и перечислимых типов.

'<=, >='
     Меньше или равно, больше или равно.  Определено на целочисленных
     типах, типах с плавающей точкой и перечислимых типах.  Включение
     для множеств.  Такой же приоритет, как у '<'.

'=, <>, #'
     Равенство и два способа выражения неравенства; допустимо на
     скалярных типах.  Такой же приоритет, как у '<'.  В сценариях GDB,
     для неравенства допустимо только '<>', так как '#' конфликтует со
     знаком комментария.

'IN'
     Установка принадлежности.  Определено на множествах и типах их
     элементов.  Такой же приоритет, как у '<'.

'OR'
     Дизъюнкция (логическое ИЛИ). Определена на булевых типах.

'AND, &'
     Конъюнкция (логическое И). Определена на булевых типах.

'@'
     Оператор "искусственного массива" GDB (*note Выражения:
     Выражения.).

'+, -'
     Сложение и вычитание на целочисленных типах и типах с плавающей
     точкой или объединение и разность на множественных типах.

'*'
     Умножение на целочисленных типах и типах с плавающей точкой или
     пересечение на типах-множествах.

'/'
     Деление на типах с плавающей точкой.  Симметрическая разность
     множеств на типах-множествах.  Такой же приоритет, как у '*'.

'DIV, MOD'
     Целочисленное деление и остаток.  Определены на целочисленных
     типах.  Такой же приоритет, как у '*'.

'-'
     Отрицание.  Определено на данных типов 'INTEGER' и 'REAL'.

'^'
     Разыменовывание указателя.  Определено на типах-указателях.

'NOT'
     Булево отрицание.  Определено на булевых типах.  Такой же
     приоритет, как у '^'.

'.'
     Селектор полей 'RECORD'.  Определен для данных типа 'RECORD'.
     Такое же приоритет, как у '^'.

'[]'
     Индексация массива.  Определена для данных типа 'ARRAY'.  Такой же
     приоритет, как у '^'.

'()'
     Список параметров процедуры.  Определен на объектах 'PROCEDURE'.
     Такой же приоритет, как у '^'.

'::, .'
     Операторы GDB и Модулы-2 определения области видимости.

     _Предупреждение:_ Множества и операции над ними еще не
     поддерживаются, так что GDB трактует использование оператора 'IN'
     или операторов '+', '-', '*', '/', '=', , '<>', '#', '<=', и '>='
     на множествах как ошибку.


File: gdb.info,  Node: Встроенные функции/процедуры,  Next: Константы Модулы-2,  Prev: Операторы Модулы-2,  Up: Модула-2

9.4.2.2 Встроенные функции и процедуры
......................................

Модула-2 также делает доступными несколько встроенных процедур и
функций.  При их описании используются следующие метапеременные:

A
     представляет переменную типа 'ARRAY'.

C
     представляет константу или переменную типа 'CHAR'.

I
     представляет переменную или константу целого типа.

M
     представляет идентификатор, принадлежащий множеству.  Обычно
     используется в одной функции с метапеременной S.  Тип S должен быть
     'SET OF МЕТАТИП' (где МЕТАТИП -- тип M).

N
     представляет переменную или константу целого типа или типа с
     плавающей точкой.

R
     представляет переменную или константу типа с плавающей точкой.

T
     представляет тип.

V
     представляет переменную.

X
     представляет переменную или константу одного из нескольких типов.
     Смотрите пояснение к функции для дополнительной информации.

   Ниже описаны все встроенные процедуры Модулы-2, возвращающие
результат.

'ABS(N)'
     Возвращает абсолютное значение N.

'CAP(C)'
     Если C -- строчная буква, процедура возвращает ее эквивалент в
     верхнем регистре, иначе возвращает сам аргумент.

'CHR(I)'
     Возвращает знак, порядковое значение которого есть I.

'DEC(V)'
     Уменьшает значение переменной V на единицу.  Возвращает новое
     значение.

'DEC(V,I)'
     Уменьшает значение переменной V на I.  Возвращает новое значение.

'EXCL(M,S)'
     Удаляет элемент M из множества S.  Возвращает новое множество.

'FLOAT(I)'
     Возвращает эквивалент целого числа I в формате с плавающей точкой.

'HIGH(A)'
     Возвращает индекс последнего элемента A.

'INC(V)'
     Увеличивает значение переменной V на единицу.  Возвращает новое
     значение.

'INC(V,I)'
     Увеличивает значение переменной V на I.  Возвращает новое значение.

'INCL(M,S)'
     Добавляет элемент M в множество S, если его там еще нет.
     Возвращает новое множество.

'MAX(T)'
     Возвращает максимальное значение типа T.

'MIN(T)'
     Возвращает минимальное значение типа T.

'ODD(I)'
     Возвращает булево значение TRUE, если число I нечетно.

'ORD(X)'
     Возвращает порядковое значение своего аргумента.  Например,
     порядковое значение знака -- его ASCII-значение (на машинах,
     поддерживающих набор знаков ASCII).  X должна принадлежать
     упорядоченному типу, что включает целочисленные, знаковый и
     перечислимый типы.

'SIZE(X)'
     Возвращает размер аргумента.  X может быть переменной или типом.

'TRUNC(R)'
     Возвращает целую часть R.

'VAL(T,I)'
     Возвращает элемент типа T, порядковое значение которого есть I.

     _Предупреждение:_ Множества и операции над ними еще не
     поддерживаются, так что GDB рассматривает использование процедур
     'INCL' и 'EXCL' как ошибку.


File: gdb.info,  Node: Константы Модулы-2,  Next: Установки по умолчанию М-2,  Prev: Встроенные функции/процедуры,  Up: Модула-2

9.4.2.3 Константы
.................

GDB позволяет вам выражать константы Модулы-2 следующими способами:

   * Целые константы являются просто последовательностью цифр.  При
     использовании в выражении, константа интерпретируется так, чтобы
     быть совместимой по типу с остальной частью выражения.
     Шестнадцатеричные целые числа определяются окончанием 'H', а
     восьмеричные -- окончанием 'B'.

   * Константы с плавающей точкой задаются как последовательность цифр,
     за которой следует десятичная точка и другая последовательность
     цифр.  Необязательный порядок может быть задан в форме 'E[+|-]NNN',
     где '[+|-]NNN' и есть желаемый порядок.  Все цифры константы с
     плавающей точкой должны быть десятичными (по основанию 10).

   * Знаковые константы состоят из одиночных знаков, заключенных в пару
     одинаковых кавычек: либо одиночных ('''), либо двойных ('"').  Они
     также могут быть заданы своим порядковым значением (обычно
     ASCII-значением), за которым следует 'C'.

   * Строковые константы состоят из последовательности знаков,
     окруженных парой одинаковых кавычек: либо одиночных ('''), либо
     двойных ('"').  Также допускаются экранирующие последовательности в
     стиле Си.  *Note Константы Си и Си++: Константы Си, для краткого
     объяснения экранирующих последовательностей.

   * Перечислимые константы состоят из перечислимого идентификатора.

   * Булевы константы состоят из идентификаторов 'TRUE' и 'FALSE'.

   * Константы-указатели состоят только из целочисленных значений.

   * Константы-множества пока не поддерживаются.


File: gdb.info,  Node: Установки по умолчанию М-2,  Next: Отклонения,  Prev: Константы Модулы-2,  Up: Модула-2

9.4.2.4 Установки по умолчанию Модулы-2
.......................................

Если проверка диапазона или принадлежности типу устанавливается GDB
автоматически, то по умолчанию обе они устанавливаются в 'on', если
рабочим языком становится Модула-2.  Это происходит независимо от того,
кто выбрал рабочий язык -- вы или GDB.

   Если вы разрешаете GDB выбирать язык автоматически, то при анализе
кода, скомпилированного из файла, чье имя оканчивается на '.mod', GDB
установит рабочим языком Модулу-2.  *Note Распознавание GDB исходного
языка: Автоматическое, для дополнительной информации.


File: gdb.info,  Node: Отклонения,  Next: Проверки Модулы-2,  Prev: Установки по умолчанию М-2,  Up: Модула-2

9.4.2.5 Отклонения от стандарта Модулы-2
........................................

Для упрощения отладки программ на Модуле-2 было сделано несколько
изменений.  В основном, это сделано путем ослабления строгости контроля
типов:

   * В отличие от стандарта Модулы-2, константы-указатели могут быть
     сформированы целыми числами.  Это позволяет вам изменять
     переменные-указатели в процессе отладки.  (В стандарте Модулы-2,
     реальный адрес, содержащийся в переменной-указателе, скрыт от вас;
     его можно изменить лишь прямым присваиванием значения другой
     переменной-указателя или выражения, возвращающего указатель.)

   * Для представления непечатаемых знаков можно использовать в строках
     и знаковых константах экранирующие последовательности Си.  GDB
     выводит строки со встроенными экранирующими последовательностями.
     Одиночные непечатаемые знаки выводятся с помощью формата
     'CHR(NNN)'.

   * Оператор присваивания (':=') возвращает значение своего правого
     аргумента.

   * Все встроенные процедуры как изменяют, так _и_ возвращают свой
     аргумент.


File: gdb.info,  Node: Проверки Модулы-2,  Next: Область видимости в Модуле-2,  Prev: Отклонения,  Up: Модула-2

9.4.2.6 Проверки диапазона и принадлежности типу Модулы-2
.........................................................

     _Предупреждение:_ в этом выпуске, GDB еще не выполняет проверки
     диапазона и принадлежности типу.

   GDB считает две переменные Модулы-2 эквивалентными по типу, если:

   * Их типы были объявлены эквивалентными посредством оператора 'TYPE
     T1 = T2'

   * Они были объявлены на одной и той же строке.  (Примечание: Это
     верно для компилятора GNU Модула-2, но это может не выполняться для
     других компиляторов.)

   Пока проверка соответствия типов включена, любая попытка
скомбинировать переменные неэквивалентных типов является ошибкой.

   Проверка диапазона выполняется во всех математических операциях,
присваиваниях, при индексации массивов и во всех встроенных функциях и
процедурах.


File: gdb.info,  Node: Область видимости в Модуле-2,  Next: GDB и Модула-2,  Prev: Проверки Модулы-2,  Up: Модула-2

9.4.2.7 Операторы определения области видимости '::' и '.'
..........................................................

Существует несколько тонких различий между операторами области видимости
Модулы-2 ('.') и GDB ('::').  Оба имеют похожий синтаксис:


     МОДУЛЬ . ИДЕНТ
     ОБЛАСТЬ :: ИДЕНТ

где ОБЛАСТЬ -- имя модуля или процедуры, МОДУЛЬ -- имя модуля, а ИДЕНТ
-- любой идентификатор, описанный в пределах вашей программы, за
исключением другого модуля.

   Использование оператора '::' заставляет GDB искать идентификатор
ИДЕНТ в ОБЛАСТИ.  Если он в ней не найден, GDB ищет его во всех
областях, содержащих ОБЛАСТЬ.

   Использование оператора '.' заставляет GDB искать идентификатор
ИДЕНТ, который был импортирован из модуля определения МОДУЛЬ, в текущей
области видимости.  В этом операторе cчитается ошибкой, если
идентификатор ИДЕНТ не был импортирован из модуля определения МОДУЛЬ,
или если ИДЕНТ не является в нем идентификатором.


File: gdb.info,  Node: GDB и Модула-2,  Prev: Область видимости в Модуле-2,  Up: Модула-2

9.4.2.8 GDB и Модула-2
......................

Некоторые команды GDB имеют мало смысла при отладке программ на
Модуле-2.  Пять подкоманд из команд 'set print' и 'show print' применимы
исключительно к Си и Си++: 'vtbl', 'demangle', 'asm-demangle', 'object'
и 'union'.  Первые четыре применимы к Си++, а последняя к типу Си
'union', который не имеет прямого аналога в Модуле-2.

   Оператор '@' (*note Выражения: Выражения.), хоть и доступен при
использовании любого языка, бесполезен при работе с Модулой-2.  Его цель
состоит в том, чтобы помочь при отладке "динамических массивов", которые
не могут быть созданы в Модуле-2 в отличие от Си или Си++.  Однако,
конструкция '{ТИП}АДР-ВЫР' все же полезна, так как адрес может быть
определен целочисленной константой.

   В сценариях GDB, оператор неравенства Модулы-2 '#' интерпретируется
как начало комментария.  Используйте вместо него '<>'.


File: gdb.info,  Node: Chill,  Prev: Модула-2,  Up: Поддержка

9.4.3 Chill
-----------

Расширения, сделанные в GDB для поддержки Chill, работают только с
программами, созданными компилятором GNU Chill.  Другие компиляторы
Chill в настоящее время не поддерживаются, и попытка отладить программы,
полученные с их помощью, скорее всего приведет к ошибке в тот момент,
когда GDB будет считывать таблицу символов выполняемого файла.

   Этот раздел охватывает темы, связанные с Chill, и возможности GDB для
их поддержки.

* Menu:

* Как отображаются режимы::     Как отображаются режимы
* Местоположения::              Местоположения и доступ к ним
* Значения и операции с ними::  Значения и операции с ними
* Проверка диапазона и типов в Chill::
* Установки по умолчанию Chill::


File: gdb.info,  Node: Как отображаются режимы,  Next: Местоположения,  Up: Chill

9.4.3.1 Как отображаются режимы
...............................

Поддержка GDB типов данных (режимов) Chill непосредственно связана с
возможностями компилятора GNU Chill и, следовательно, слегка отличается
от стандартной спецификации языка.  Вот предоставляемые режимы:

'_Дискретные режимы:_'
        * _Целочисленные режимы_, которые предопределены как 'BYTE,
          UBYTE, INT, UINT, LONG, ULONG',
        * _Булевский режим_, который предопределен как 'BOOL',
        * _Знаковый режим_, который предопределен как 'CHAR',
        * _Режим-множество_, который отображается ключевым словом 'SET'.
               (gdb) ptype x
               type = SET (karli = 10, susi = 20, fritzi = 100)
          Если тип является ненумерованным множеством, значения
          элементов множества опускаются.
        * _Режим-диапазон_, который отображается как
               тип = <базовый-режим>(<нижняя граница> : <верхняя граница>)
          где '<нижняя граница>, <верхняя граница>' может быть любым
          дискретным буквенным выражением (например, имена элементов
          множества).

'_Режим powerset:_'
     Режим Powerset отображается ключевым словом 'POWERSET', за которым
     следует режим элемента.
          (gdb) ptype x
          type = POWERSET SET (egon, hugo, otto)

'_Режимы-ссылки:_'
        * _Режим привязанной ссылки_, который отображается ключевым
          словом 'REF', за которым следует название режима, к которому
          ссылка привязана.
        * _Режим свободной ссылки_, который отображается ключевым словом
          'PTR'.

'_Процедурный режим_'
     Процедурный режим отображается в виде 'тип = PROC(<список
     параметров>) <возвращаемый режим> EXCEPTIONS (<список
     исключений>)'.  '<список параметров>' представляет собой список
     режимов параметров.  '<возвращаемый режим>' указывает режим
     результата процедуры, если она возвращает результат.  '<список
     исключений>' перечисляет все возможные исключения, которые могут
     быть возбуждены процедурой.

'_Синхронизационные режимы:_'
        * _Режим события_, который отображается как
               EVENT (<длина события>)
          где '<длина события>' является необязательной.
        * _Буферный режим_, который отображается как
               BUFFER (<длина буфера>)<режим элементов буфера>
          где '(<длина буфера>)' является необязательной.

'_Режимы времени:_'
        * _Режим длительности_, который предопределен как 'DURATION'
        * _Режим абсолютного времени_, который предопределен как 'TIME'

'_Вещественные режимы:_'
     Вещественные режимы предопределены как 'REAL' и 'LONG_REAL'.

'_Строковые режимы:_'
        * _Режим строки знаков_, который отображается как
               CHARS(<длина строки>)
          за которым следует ключевое слово 'VARYING', если строковый
          режим является изменяющимся режимом
        * _Режим строки битов_, который отображается как
               BOOLS(<длина строки>)

'_Режим массива:_'
     Режим массива отображается ключевым словом 'ARRAY(<диапазон>)', за
     которым следует режим элементов (который, в свою очередь, может
     быть режимом массива).
          (gdb) ptype x
          type = ARRAY (1:42)
                    ARRAY (1:20)
                       SET (karli = 10, susi = 20, fritzi = 100)

'_Структурный режим_'
     Структурный режим отображается ключевым словом 'STRUCT(<список
     полей>)'.  '<список полей>' состоит из имен и режимов полей
     структуры.  Структуры с вариантами имеют ключевое слово 'CASE
     <поле> OF <варианты поля> ESAC' в их списке полей.  Так как текущая
     версия компилятора GNU Chill не реализует обработку тегов (нет
     проверок времени выполнения вариантных полей и, следовательно, нет
     отладочной информации), вывод всегда содержит все вариантные поля.
          (gdb) ptype str
          type = STRUCT (
              as x,
              bs x,
              CASE bs OF
              (karli):
                  cs a
              (ott):
                  ds x
              ESAC
          )


File: gdb.info,  Node: Местоположения,  Next: Значения и операции с ними,  Prev: Как отображаются режимы,  Up: Chill

9.4.3.2 Местоположения и доступ к ним
.....................................

Местоположением в Chill является объект, который может содержать
значения.

   Доступ к значению местоположения обычно производится посредством
(описанного) имени местоположения.  Вывод удовлетворяет спецификации
значений в программах на Chill.  То, как значения задаются, является
темой следующего раздела, смотрите *note Значения и операции с ними::.

   Псевдоместоположение 'RESULT' (или 'result') может использоваться для
отображения или изменения результата процедуры, активной в настоящий
момент:

     set result := EXPR

Это делает то же самое, что и действие Chill 'RESULT EXPR' (которое в
GDB недоступно).

   Значения местоположений режима ссылок выводятся, в случае режима
свободной ссылки, посредством 'PTR(<шестнадцатеричное значение>)', и с
помощью '(REF <режим ссылки>) (<шестнадцатеричное значение>)' в случае
привязанной ссылки.  '<шестнадцатеричное значение>' представляет адрес,
на который указывает ссылка.  Для доступа к значению местоположения,
указываемого ссылкой, используйте оператор разыменовывания '->'.

   Значения местоположений процедурного режима отображаются как
     { PROC
     (<режимы аргументов> ) <возвращаемый режим> } <адрес> <имя
     местоположения процедуры>
   '<режимы аргументов>' -- это список режимов, в соответствии со
спецификацией параметров процедуры, а '<адрес>' указывает адрес точки
входа.

   Подструктуры значений строковых режимов, режимов массивов или
структур (например, срезы массивов, поля структурных местоположений)
доступны при использовании определенных операторов, которые описаны в
следующем разделе, смотрите *note Значения и операции с ними::.

   Значение местоположения может быть интерпретировано как имеющее
другой режим посредством преобразования местоположений.  Это
преобразование режимов записывается как '<имя
режима>(<местоположение>)'.  Пользователь должен учесть, что размеры
режимов должны быть равными, в противном случае возникает ошибка.  Более
того, не производится никаких проверок диапазона местоположения по
сравнению с режимом назначения, и, следовательно, результат может быть
достаточно обескураживающим.

     (gdb) print int (s(3 up 4)) XXX TO be filled in !! XXX


File: gdb.info,  Node: Значения и операции с ними,  Next: Проверка диапазона и типов в Chill,  Prev: Местоположения,  Up: Chill

9.4.3.3 Значения и операции с ними
..................................

Значения используются для изменения местоположений, для более подробного
изучения сложных структур и для отфильтровывания значимой информации из
большого объема данных.  Определено несколько операций (зависящих от
режима), которые позволяют проводить подобные изучения.  Эти операции
применимы не только к значениям-константам, но также и к
местоположениям, что может оказаться достаточно полезным при отладке
сложных структур.  Во время разбора командной строки (например, вычисляя
выражение), GDB рассматривает имена местоположений как значения этих
местоположений.

   Этот раздел описывает, как должны задаваться значения, и какие
операции допустимо использовать с этими значениями.

'Буквенные значения'
     Буквенные значения определяются также, как в программах GNU Chill.
     Для подробной спецификации, смотрите главу 1.5 Руководства по
     реализации GNU Chill.

'Значения-наборы'
     Набор может быть задан как '<имя режима>[<набор>]', где '<имя
     режима>' может быть опущено, если режим набора определяется
     однозначно.  Эта однозначность определяется из контекста
     вычисляемого выражения.  '<набор>' может быть одним из:

        * _Набор powerset_
        * _Набор массивов_
        * _Набор структур_

     Наборы-powerset, наборы массивов и наборы структур определяются так
     же, как в программах на Chill.

'Значение элемента строки'
     Значение элемента строки задается как
          <строковое значение>(<индекс>)
     где '<индекс>' является целочисленным выражением.  Это дает
     знаковое значение, которое эквивалентно знаку, указываемому в
     строке индексом '<индекс>'.

'Значение среза строки'
     Значение среза строки задается как '<значение строки>(<спецификация
     среза>)', где '<спецификация среза>' может быть либо диапазоном
     целых выражений, либо задаваться в виде '<начальное выражение> up
     <размер>'.  '<размер>' обозначает число элементов, которое содержит
     срез.  Полученная величина является строкой, которая является
     частью указанной строки.

'Значения элементов массива'
     Значение элемента массива указывается в виде '<величина
     массива>(<выр>)' и дает величину элемента массива с режимом как у
     указанного массива.

'Значение среза массива'
     Срез массива задается как '<значение массива>(<спецификация
     среза>)', где '<спецификация среза>' может быть диапазоном,
     определенным либо выражениями, либо как '<начальное выр> up
     <размер>'.  '<размер>' обозначает число элементов массива, которое
     содержит срез.  Получаемое значение есть массив, который является
     частью указанного.

'Значение поля структуры'
     Значение поля структуры получается как '<значение структуры>.<имя
     поля>', где '<имя поля>' указывает имя поля, заданное в определении
     режима структуры.  Режим полученного значения соответствует этому
     определению режима в определении структуры.

'Значения вызова процедуры'
     Значение вызова процедуры получается из значения, возвращенного
     процедурой(1).

     Значения местоположений режима длительности представляются буквами
     'ULONG'.

     Значения местоположений режима-времени выводятся как
          TIME(<сек>:<нсек>).

'Значение безаргументного оператора'
     Значение безаргументного оператора получается из значения
     экземпляра для текущего активного процесса.

'Значения выражений'
     Значение, доставляемое выражением, является результатом вычисления
     указанного выражения.  В случае ошибки (несовместимость режимов и
     тому подобное), вычисление выражения прерывается с соответствующим
     сообщением об ошибке.  Выражение может быть заключено в скобки, что
     приводит к вычислению этого выражения до любого другого,
     использующего результат выражения в скобках.  GDB поддерживает
     следующие операторы:

     'OR, ORIF, XOR'
     'AND, ANDIF'
     'NOT'
          Логические операторы, определенные на операндах булевого
          режима.

     '=, /='
          Операторы равенства и неравенства, определенные на всех
          режимах.

     '>, >='
     '<, <='
          Операторы отношения, заданные на предопределенных режимах.

     '+, -'
     '*, /, MOD, REM'
          Арифметические операторы, заданные на предопределенных
          режимах.

     '-'
          Оператор изменения знака.

     '//'
          Оператор соединения строк.

     '()'
          Оператор повторения строки.

     '->'
          Оператор ссылки местоположения, который может быть использован
          либо для получения адреса местоположения ('->loc'), или для
          разыменовывания ссылки местоположения ('loc->').

     'OR, XOR'
     'AND'
     'NOT'
          Операторы режимов powerset и строки битов.

     '>, >='
     '<, <='
          Операторы включения режима powerset.

     'IN'
          Оператор принадлежности.

   ---------- Footnotes ----------

   (1) Если, например, вызов процедуры используется в выражении, то эта
процедура вызывается со всеми своими побочными эффектами.  При
неаккуратном использовании это может привести к путанице.


File: gdb.info,  Node: Проверка диапазона и типов в Chill,  Next: Установки по умолчанию Chill,  Prev: Значения и операции с ними,  Up: Chill

9.4.3.4 Проверка диапазона и типов в Chill
..........................................

GDB считает два режима переменных Chill эквивалентными, если их размеры
равны.  Это правило применяется рекурсивно для более сложных типов
данных.  Это означает, что сложные режимы считаются эквивалентными, если
режимы всех элементов (которые тоже могут быть сложными, например,
массивами, структурами, и так далее) имеют одинаковый размер.

   Проверка диапазона производится для всех математических операций,
присваиваний, границ индексов массива и всех встроенных процедур.

   Строгие проверки типов включаются с помощью команды GDB 'set check
strong'.  Это навязывает строгую проверку диапазона и принадлежности
типу для всех действий, где используются конструкции Chill (выражения,
встроенные функции и так далее), в соответствии с семантикой,
определенной в спецификации языка z.200.

   Все проверки могут быть отключены командой GDB 'set check off'.


File: gdb.info,  Node: Установки по умолчанию Chill,  Prev: Проверка диапазона и типов в Chill,  Up: Chill

9.4.3.5 Установки по умолчанию Chill
....................................

Если проверки типа и диапазона установлены GDB автоматически, обе они по
умолчанию включены, когда рабочий язык переключается на Chill.  Это
происходит независимо от того, вы выбрали рабочий язык или GDB.

   Если вы разрешите GDB устанавливать рабочий язык автоматически, то
при попадании в код, скомпилированный из файла, чье имя заканчивается на
'.ch', он переключает рабочий язык на Chill.  *Note Распознавание GDB
исходного языка: Автоматическое, для дополнительной информации.


File: gdb.info,  Node: Символы,  Next: Изменения,  Prev: Языки,  Up: Top

10 Исследование таблицы символов
********************************

Команды, описанные в этой главе, позволяют вам получить информацию о
символах (именах переменных, функций и типов), определенных в вашей
программе.  Эта информация присуща тексту вашей программы и не
изменяется при ее выполнении.  GDB находит эту информацию в таблице
символов вашей программы, в файле, определенном при его вызове (*note
Выбор файлов: Параметры файлов.), или посредством одной из команд
управления файлами (*note Команды для задания файлов: Файлы.).

   Иногда вам может потребоваться сослаться на символы, содержащие
необычные знаки, которые GDB обычно трактует как разделители слов.
Наиболее часто это встречается при ссылках на статические переменные в
других исходных файлах (*note Переменные программы: Переменные.).  Имена
файлов записаны в объектных файлах как отладочные символы, но GDB обычно
производит разбор типичного имени файла, например 'foo.c', как три
слова: 'foo' '.'  'c'.  Чтобы GDB идентифицировал 'foo.c' как одно
слово, заключите его в одинарные кавычки; например,

     p 'foo.c'::x

ищет значение 'x' в области видимости файла 'foo.c'.

'info address СИМВОЛ'
     Описывает, где хранятся данные для СИМВОЛА.  Для регистровой
     переменной сообщается, в каком регистре она содержится.  Для
     нерегистровой локальной переменной печатается смещение в кадре
     стека, по которому переменная всегда хранится.

     Заметьте отличие от команды 'print &СИМВОЛ', которая вообще не
     работает для регистровых переменных, а для локальной переменной из
     стека печатает точный адрес текущего экземпляра переменной.

'whatis ВЫРАЖ'
     Напечатать тип данных выражения ВЫРАЖ.  На самом деле ВЫРАЖ не
     вычисляется, и присутствующие в нем побочные операции (такие как
     присваивания или вызовы функций) не выполняются.  *Note Выражения:
     Выражения.

'whatis'
     Вывести тип данных '$', последней записи в истории значений.

'ptype ИМЯ-ТИПА'
     Вывести описание типа данных ИМЯ-ТИПА.  ИМЯ-ТИПА может быть именем
     типа или, для кода Си, может иметь форму 'class ИМЯ-КЛАССА',
     'struct ТЕГ-СТРУКТУРЫ', 'union ТЕГ-ОБЪЕДИНЕНИЯ' или 'enum
     ТЕГ-ПЕРЕЧИСЛЕНИЯ'.

'ptype ВЫРАЖ'
'ptype'
     Вывести описание типа выражения ВЫРАЖ.  'ptype' отличается от
     'whatis' тем, что выводится детальное описание, а не только имя
     типа.

     Например, для такого описания переменной:

          struct complex {double real; double imag;} v;

     эти две команды выведут следующее:

          (gdb) whatis v
          type = struct complex
          (gdb) ptype v
          type = struct complex {
              double real;
              double imag;
          }

     Как и 'whatis', использование 'ptype' без параметра относится к
     типу '$', последней записи в истории значений.

'info types РЕГ-ВЫР'
'info types'
     Вывести краткое описание всех типов, имена которых соответствуют
     регулярному выражению РЕГ-ВЫР (или всех типов вашей программы, если
     вы используете эту команду без параметра).  Каждое полное имя типа
     сопоставляется так, как если бы оно было полной строкой; таким
     образом, 'i type value' выдает информацию обо всех типах в вашей
     программе, чьи имена включают строку 'value', а 'i type ^value$'
     выдает информацию только о типах с полным именем 'value'.

     Эта команда отличается от 'ptype' следующим: во-первых, как и
     'whatis', она не выводит детального описания; во-вторых, она
     перечисляет все исходные файлы, где определен тип.

'info source'
     Показать имя текущего исходного файла -- то есть исходного файла
     для функции, содержащей текущую точку выполнения, и язык, на
     котором она написана.

'info sources'
     Вывести имена всех исходных файлов вашей программы, для которых
     имеется отладочная информация, организуя их в два списка: файлы с
     уже прочитанными символами, и файлы, символы которых будут
     прочитаны, когда потребуется.

'info functions'
     Вывести имена и типы данных всех определенных функций.

'info functions РЕГ-ВЫР'
     Вывести имена и типы данных всех определенных функций, чьи имена
     удовлетворяют регулярному выражению РЕГ-ВЫР.  Так, 'info fun step'
     находит все функции, имена которых содержат 'step'; 'info fun
     ^step' находит функции с именами, начинающимися со 'step'.

'info variables'
     Напечатать имена и типы данных всех переменных, объявленных вне
     функций (то есть исключая локальные переменные).

'info variables РЕГ-ВЫР'
     Вывести имена и типы данных всех переменных (кpоме локальных),
     имена которых удовлетворяют регулярному выражению РЕГ-ВЫР.

     Некоторые системы допускают замещение отдельных объектных файлов,
     составляющих вашу программу, без ее остановки и перезапуска.
     Например, в VxWorks вы можете просто перекомпилировать дефектный
     объектный файл и продолжить выполнение.  Если вы работаете в одной
     из таких систем, вы можете позволить GDB перезагрузить символы для
     автоматически пересобранных модулей:

     'set symbol-reloading on'
          Заменить определения символов для соответствующего исходного
          файла, когда объектный файл с определенным именем снова
          доступен.

     'set symbol-reloading off'
          Не заменять определения символов при встрече объектного файла
          с таким же именем более одного раза.  Это состояние по
          умолчанию; если вы не работаете в системе, допускающей
          автоматическое пересобирание модулей, вы должны оставить
          'symbol-reloading' в состоянии 'off', так как иначе GDB может
          уничтожить символы пpи сборке больших программ, которые могут
          содеpжать несколько модулей с одинаковым именем (из разных
          каталогов или библиотек).

     'show symbol-reloading'
          Показать текущую установку 'on' или 'off'.

'set opaque-type-resolution on'
     Велит GDB производить разрешение неоднозначных типов.
     Неоднозначным является тип, описанный как указатель на 'struct',
     'class' или 'union' -- например, 'struct MyType *' -- то есть,
     используется в одном исходном файле, хотя полное описание 'struct
     MyType' находится в другом исходном файле.  По умолчанию
     установлено в 'on'.

     Изменения в установке этой подкоманды не вступят в силу, пока не
     будут загружены символы для какого-нибудь файла.

'set opaque-type-resolution off'
     Указывает GDB не производить разрешение неоднозначных типов.  В
     этом случае, тип выводится следующим образом:
          {<no data fields>}

'show opaque-type-resolution'
     Показать, производится разрешение неоднозначных типов или нет.

'maint print symbols ИМЯ-ФАЙЛА'
'maint print psymbols ИМЯ-ФАЙЛА'
'maint print msymbols ИМЯ-ФАЙЛА'
     Записать дамп данных отладочных символов в файл ИМЯ-ФАЙЛА.  Эти
     команды используются для отладки кода GDB, осуществляющего чтение
     символов.  Включаются только символы с отладочными данными.  Если
     вы используете 'maint print symbols', GDB включает все символы, для
     которых уже собрана полная информация: то есть ИМЯ-ФАЙЛА отражает
     символы только для тех файлов, символы которых GDB уже прочитал.
     Вы можете использовать команду 'info sources', чтобы определить,
     какие это файлы.  Если же вы используете 'maint print psymbols',
     дамп показывает информацию о тех символах, о которых GDB имеет лишь
     частичную информацию, то есть символы определены в файлах, которые
     GDB только просмотрел, но не прочитал полностью.  Наконец, 'maint
     print msymbols', выводит только минимальную информацию о символах,
     требуемую для каждого объектного файла, из которых GDB пpочитал
     какие-либо символы.  *Note Команды для задания файлов: Файлы, где
     обсуждается, как GDB считывает символы (в описании 'symbol-file').


File: gdb.info,  Node: Изменения,  Next: Файлы GDB,  Prev: Символы,  Up: Top

11 Изменение выполнения
***********************

Если вы думаете, что нашли ошибку в своей программе, вы можете захотеть
выяснить наверняка, приведет ли исправление кажущейся ошибки к
правильным результатам в остальной части программы.  Вы можете получить
ответ экспериментируя, используя средства GDB для изменения выполнения
программы.

   Например, вы можете сохранить новые значения в переменных или ячейках
памяти, подать своей программе сигнал, перезапустить ее с другого адреса
или даже преждевременно вернуться из функции.

* Menu:

* Присваивание::                Присваивание значения переменной
* Переходы::                    Продолжение выполнения с другого адреса
* Подача сигналов::             Подача сигнала вашей программе
* Возврат::                     Возврат из функции
* Вызовы::                      Вызовы функций вашей программы
* Внесение изменений::          Внесение изменений в вашу программу


File: gdb.info,  Node: Присваивание,  Next: Переходы,  Up: Изменения

11.1 Присваивание значений переменным
=====================================

Для изменения значения переменной, вычислите выражение присваивания.
*Note Выражения: Выражения.  Например,

     print x=4

сохраняет значение 4 в переменной 'x' и затем выводит значение данного
выражения (которое равно 4).  *Note Использование GDB с различными
языками программирования: Языки, для получения большей информации об
операторах в поддерживаемых языках.

   Если вы не хотите видеть значение присваивания, используйте команду
'set' вместо 'print'.  Команда 'set' аналогична команде 'print' за
исключением того, что значение выражения не выводится и не заносится в
историю значений (*note История значений: История значений.).  Выражение
вычисляется только ради его действия.

   Если начало строки параметров команды 'set' выглядит идентично
подкоманде 'set', используйте вместо нее команду 'set variable'.  Эта
команда аналогична 'set', но не имеет подкоманд.  Например, если в вашей
программе есть переменная 'width', то вы получите ошибку, если
попытаетесь установить новое значение просто с помощью 'set width=13',
потому что GDB имеет команду 'set width':

     (gdb) whatis width
     type = double
     (gdb) p width
     $4 = 13
     (gdb) set width=47
     Invalid syntax in expression.

Недопустимое выражение, это, конечно, '=47'.  Для того, чтобы
действительно установить переменную программы 'width', используйте

     (gdb) set var width=47

   Так как команда 'set' имеет много подкоманд, которые могут
конфликтовать с именами переменных в программе, то хорошей практикой
является использование команды 'set variable' вместо просто 'set'.
Например, если ваша программа имеет переменную 'g', у вас возникнут
проблемы, если вы попытаетесь установить новое значение с помощью 'set
g=4', потому что GDB имеет команду 'set gnutarget', которая сокращается
как 'set g':

     (gdb) whatis g
     type = double
     (gdb) p g
     $1 = 1
     (gdb) set g=4
     (gdb) p g
     $2 = 1
     (gdb) r
     The program being debugged has been started already.
     Start it from the beginning? (y or n) y
     Starting program: /home/smith/cc_progs/a.out
     "/home/smith/cc_progs/a.out": can't open to read symbols:
                                      Invalid bfd target.
     (gdb) show g
     The current BFD target is "=4".

Переменная программы 'g' не изменилась, и вы незаметно установили
'gnutarget' в неверное значение.  Для установки значения переменной 'g',
используйте

     (gdb) set var g=4

   GDB допускает больше неявных преобразований в присваиваниях, чем Си;
вы можете свободно сохранить целое значение в переменной-указателе и
наоборот, преобразовать любую структуру к любой другой, которая имеет ту
же длину или короче.

   Для сохранения значений в произвольных местах памяти, используйте
конструкцию '{...}' для создания значения определенного типа по
определенному адресу памяти (*note Выражения: Выражения.).  Например,
'{int}0x83040' ссылается на ячейку памяти '0x83040' как на целое (что
предполагает соответствующий размер и представление в памяти), и

     set {int}0x83040 = 4

записывает в эту ячейку памяти значение 4.


File: gdb.info,  Node: Переходы,  Next: Подача сигналов,  Prev: Присваивание,  Up: Изменения

11.2 Продолжение исполнения с другого адреса
============================================

Обычно, когда вы продолжаете выполнение программы, вы делаете это с того
места, где она остановилась, командой 'continue'.  Вместо этого, вы
можете продолжить выполнение с любого выбранного адреса при помощи
следующих команд:

'jump УКАЗ-СТР'
     Возобновить выполнение со строки УКАЗ-СТР.  Если там есть точка
     останова, выполнение немедленно прекращается.  *Note Вывод строк
     исходного текста: Вывод строк, для описания различных форм
     УКАЗ-СТР.  Использование команды 'tbreak' вместе с 'jump' является
     обычной практикой.  *Note Установка точек останова: Установка точек
     останова.

     Команда 'jump' не изменяет ни текущий кадр стека, ни указатель
     стека, ни содержимое каких-либо ячеек памяти или регистров, кроме
     счетчика программы.  Если строка УКАЗ-СТР находится вне
     выполняющейся в настоящее время функции, результаты могут быть
     странными, если эти функции используют аргументы или локальные
     переменные разных типов.  По этой причине, команда 'jump'
     запрашивает подтверждение, если указанная строка не находится в
     функции, выполняющейся в настоящее время.  Однако, даже странные
     результаты предсказуемы, если вы хорошо знакомы с машинным кодом
     вашей программы.

'jump *АДРЕС'
     Возобновить выполнение с инструкции, находящейся по адресу АДРЕС.

   На многих системах вы можете достичь такого же результата, как и с
командой 'jump', сохранив новое значение в регистр '$pc'.  Отличие
заключается в том, что это не начинает выполнение вашей программы, а
лишь изменяет адрес, с которого _будет_ выполняться программа, когда вы
продолжите выполнение.  Например,

     set $pc = 0x485

выполняет следующую команду 'continue' или команду пошагового выполнения
с адреса '0x485', а не с того адреса, где ваша программа остановилась.
*Note Продолжение и выполнение по шагам: Продолжение и пошаговое
выполнение.

   Наиболее общий случай использования команды 'jump' состоит в возврате
к выполнению уже пройденной части программы, возможно с большим
количеством установленных точек останова, чтобы исследовать выполнение
более детально.


File: gdb.info,  Node: Подача сигналов,  Next: Возврат,  Prev: Переходы,  Up: Изменения

11.3 Подача сигнала вашей программе
===================================

'signal СИГНАЛ'
     Возобновить выполнение с места остановки вашей программы, но
     немедленно подать ей сигнал СИГНАЛ.  СИГНАЛ может быть именем или
     номером сигнала.  Например, во многих системах 'signal 2' и 'signal
     SIGINT' -- два способа подать сигнал прерывания.

     Наоборот, если СИГНАЛ является нулем, выполнение продолжается без
     подачи сигнала.  Это полезно, если ваша программа остановилась
     из-за сигнала и в обычном случае увидит его при возобновлении
     выполнения командой 'continue'; 'signal 0' продолжит выполнение без
     сигнала.

     'signal' не повторяется, когда вы нажимаете <RET> второй раз после
     выполнения команды.

   Вызов команды 'signal' отличается от вызова утилиты 'kill' из
оболочки.  Подача сигнала посредством 'kill' заставляет GDB решать, что
делать с сигналом, в зависимости от таблиц обработки сигналов (*note
Сигналы::).  Команда 'signal' передает сигнал непосредственно вашей
программе.


File: gdb.info,  Node: Возврат,  Next: Вызовы,  Prev: Подача сигналов,  Up: Изменения

11.4 Возврат из функции
=======================

'return'
'return ВЫРАЖЕНИЕ'
     Вы можете отменить выполнение вызова функции с помощью команды
     'return'.  Если вы задаете параметр ВЫРАЖЕНИЕ, его значение
     используется в качестве возвращаемого значения.

   Когда вы используете 'return', GDB уничтожает выбранный кадр стека (и
все кадры внутри него).  Вы можете считать это преждевременным возвратом
из уничтоженного кадра.  Если вы хотите указать возвращаемое значение,
задайте его в качестве аргумента к 'return'.

   Это выталкивает выбранный кадр стека (*note Выбор кадра стека:
Выбор.) и все другие кадры внутри него, оставляя самым внутренним кадр,
из которого произошел вызов.  Этот кадр становится выбранным.  Указанное
значение сохраняется в регистрах, используемых для возвращаемых функцией
значений.

   Команда 'return' не возобновляет выполнение; она оставляет программу
остановленной в том состоянии, в котором бы она была сразу после
возврата из функции.  Напротив, команда 'finish' (*note Продолжение и
выполнение по шагам: Продолжение и пошаговое выполнение.) возобновляет
выполнение до естественного возврата из выбранного кадра стека.


File: gdb.info,  Node: Вызовы,  Next: Внесение изменений,  Prev: Возврат,  Up: Изменения

11.5 Вызов функций программы
============================

'call ВЫРАЖ'
     Вычислить выражение ВЫРАЖ без отображения пустых ('void')
     возвращенных значений.

   Вы можете использовать этот вариант команды 'print', если хотите
выполнить функцию из вашей программы, не засоряя вывод пустыми
возвращенными значениями.  Если результат не пустой, он выводится и
сохраняется в истории значений.

   Для A29K, устанавливаемая пользователем переменная
'call_scratch_address' задает положение рабочей области, которая будет
использоваться, когда GDB вызывает функцию на целевой машине.  Это
необходимо, так как обычный метод размещения рабочей области в стеке не
работает в системах с раздельными областями команд и данных.


File: gdb.info,  Node: Внесение изменений,  Prev: Вызовы,  Up: Изменения

11.6 Внесение изменений в программу
===================================

По умолчанию, GDB открывает файл, содержащий исполняемый код вашей
программы (или файл дампа памяти), в режиме только для чтения.  Это
предотвращает случайные изменения машинного кода; но это также
предотвращает и преднамеренное исправление двоичного файла вашей
программы.

   Если вы хотите иметь возможность исправлять двоичный код, вы можете
указать это явно с помощью команды 'set write'.  Например, вы можете
захотеть установить внутренние флаги отладки или даже сделать аварийные
исправления.

'set write on'
'set write off'
     Если вы установите 'set write on', GDB открывает исполняемые файлы
     и файлы дампов памяти в режиме для чтения и записи; если вы укажете
     'set write off' (устанавливается по умолчанию), GDB открывает их в
     режиме только для чтения.

     Если вы уже загрузили файл, то после установки 'set write' вам
     необходимо загрузить его снова (используя команды 'exec-file' или
     'core-file'), чтобы новые установки вступили в силу.

'show write'
     Показать, открыты исполняемые файлы и файлы дампов памяти для
     записи или нет.


File: gdb.info,  Node: Файлы GDB,  Next: Отладочные цели,  Prev: Изменения,  Up: Top

12 Файлы GDB
************

GDB должен знать имя файла программы, которая будет отлаживаться, чтобы
прочитать его таблицу символов и чтобы запустить его.  Для отладки дампа
памяти от предыдущего выполнения, вы также должны сообщить GDB имя этого
файла.

* Menu:

* Файлы::                       Команды для задания файлов
* Ошибки с символами::          Ошибки чтения файлов с символами


File: gdb.info,  Node: Файлы,  Next: Ошибки с символами,  Up: Файлы GDB

12.1 Команды для задания файлов
===============================

Вы можете указать имена исполняемого файла и файла дампа памяти.  Обычно
это делается во время вызова GDB, используя параметры с командами
запуска GDB (*note Вход и выход из GDB: Вызов.).

   Иногда во время сеанса GDB необходимо перейти к другому файлу.  Или
вы можете запустить GDB, забыв указать файл, который хотите
использовать.  В таких ситуациях полезны команды GDB для задания новых
файлов.

'file ИМЯ-ФАЙЛА'
     Использовать ИМЯ-ФАЙЛА в качестве программы для отладки.  Из нее
     читаются символы и содержание неизменяемой памяти.  Также она
     является программой, которая выполняется при использовании команды
     'run'.  Если вы не укажете каталог, и файл не будет найден в
     рабочем каталоге GDB, он использует переменную среды 'PATH' в
     качестве списка каталогов для поиска, точно так же, как это делает
     оболочка, когда ищет программу для выполнения.  Используя команду
     'path', вы можете изменить значение этой переменной как для GDB,
     так и для вашей программы.

     В системах с отображаемыми в память файлами, информация из таблицы
     символов для ИМЯ-ФАЙЛА может храниться во вспомогательном файле
     'ИМЯ-ФАЙЛА.syms'.  Если это так, GDB осуществляет отображение
     таблицы символов из 'ИМЯ-ФАЙЛА.syms', запускаясь намного быстрее.
     Смотрите описания ключей файлов '-mapped' и '-readnow' (доступных с
     командной строки и в командах 'file', 'symbol-file' или
     'add-symbol-file', описанных ниже), для получения большей
     информации.

'file'
     'file' без параметров велит GDB уничтожить любую имеющуюся
     информацию как об исполняемом файле, так и о таблице символов.

'exec-file [ ИМЯ-ФАЙЛА ]'
     Указывает, что программа, которая должна быть выполнена (но не
     таблица символов), находится в ИМЯ-ФАЙЛА.  Если необходимо, GDB
     ищет вашу программу с помощью переменной среды 'PATH'.  Отсутствие
     ИМЯ-ФАЙЛА означает, что необходимо уничтожить информацию о
     выполняемом файле.

'symbol-file [ ИМЯ-ФАЙЛА ]'
     Читать информацию таблицы символов из файла ИМЯ-ФАЙЛА.  При
     необходимости производится поиск с помощью переменной среды 'PATH'.
     Для получения таблицы символов и исполняемой программы из одного и
     того же файла, используйте команду 'file'.

     'symbol-file' без параметров сбрасывает информацию GDB о таблице
     символов вашей программы.

     Команда 'symbol-file' велит GDB забыть содержимое своих
     вспомогательных переменных, историю значений и все точки останова и
     выражения автоматического отображения, так как они могут содержать
     указатели на внутренние данные, хранящие символы и типы данных,
     которые являются частью данных старой таблицы символов,
     уничтоженной внутри GDB.

     'symbol-file' не повторяется, если вы снова нажимаете <RET> после
     первого выполнения.

     Когда GDB сконфигурирован для определенной среды, он распознает
     отладочную информацию в том формате, который обычно генерируется
     для этой среды; вы можете использовать или компилятор GNU, или
     другие компиляторы, которые придерживаются местных соглашений.
     Наилучшие результаты обычно достигаются с помощью компилятора GNU;
     например, используя 'gcc', вы можете создавать отладочную
     информацию для оптимизированного кода.

     Для большинства типов объектных файлов, за исключением старых
     систем SVR3, использующих COFF, команда 'symbol-file' обычно не
     считывает таблицу символов сразу целиком.  Вместо этого, она быстро
     сканирует ее для определения, какие исходные файлы и символы в ней
     присутствуют.  Детали читаются позже, по одному исходному файлу за
     раз, по мере необходимости.

     Такая стратегия чтения в две стадии используется для того, чтобы
     GDB вызывался быстрее.  За исключением редких пауз, чтение деталей
     таблицы символов для конкретного исходного файла в большинстве
     случаев практически незаметно.  (Команда 'set verbose' позволяет
     при желании превратить эти паузы в сообщения.  *Note Необязательные
     предупреждения и сообщения: Сообщения/предупреждения.)

     Мы еще не реализовали двухступенчатую стратегию чтения для COFF.
     Когда таблица символов сохранена в формате COFF, 'symbol-file'
     считывает данные таблицы символов сразу полностью.  Заметьте, что
     "stabs-in-COFF" все же реализует двухступенчатую стратегию, так как
     отладочная информация реально хранится в формате stabs.

'symbol-file ИМЯ-ФАЙЛА [ -readnow ] [ -mapped ]'
'file ИМЯ-ФАЙЛА [ -readnow ] [ -mapped ]'
     Если вы хотите быть уверены, что у GDB есть вся таблица символов
     целиком, вы можете отменить двухступенчатую стратегию чтения
     таблицы символов, используя параметр '-readnow' с любой командой,
     загружающей информацию таблицы символов.

     Если на вашей системе можно отображать файлы в память через
     системный вызов 'mmap', вы можете использовать другой параметр,
     '-mapped', чтобы GDB записывал символы для вашей программы в файл
     многократного использования.  Последующие сеансы отладки GDB
     отображают информацию о символах из этого вспомогательного файла
     (если программа не изменилась), вместо того, чтобы тратить время на
     чтение таблицы символов из исполняемой программы.  Использование
     параметра '-mapped' производит такой же эффект, как вызов GDB с
     ключом командной строки '-mapped'.

     Вы можете использовать оба параметра вместе, чтобы быть уверенным,
     что вспомогательный файл символов содержит всю информацию о
     символах вашей программы.

     Вспомогательный файл символов для программы ПРОГ называется
     'ПРОГ.syms'.  Если этот файл существует (и создан позже, чем
     соответствующая исполняемая программа), GDB всегда пытается
     использовать его при отладке ПРОГ; не требуется никаких специальных
     ключей или команд.

     Файл '.syms' является специфичным для рабочей машины, на которой вы
     вызываете GDB. Он содержит точный образ внутренней таблицы символов
     GDB. Он не может быть использован одновременно на разных рабочих
     платформах.

'core-file [ ИМЯ-ФАЙЛА ]'
     Определяет местонахождение файла дампа памяти, который будет
     использован как "содержимое памяти".  Обычно файлы дампов памяти
     содержат только некоторые части адресного пространства процесса,
     создавшего их; GDB может обращаться к исполняемому файлу за другими
     частями.

     'core-file' без параметра указывает, что файл дампа памяти
     использоваться не должен.

     Обратите внимание, что файл дампа памяти игнорируется, если в
     данное время ваша программа выполняется под управлением GDB. Так
     что если вы выполняли программу и желаете вместо этого отладить
     файл дампа, вы должны убить подпроцесс, в котором выполняется ваша
     программа.  Для этого используйте команду 'kill' (*note Уничтожение
     дочернего процесса: Уничтожение процесса.).

'add-symbol-file ИМЯ-ФАЙЛА АДРЕС'
'add-symbol-file ИМЯ-ФАЙЛА АДРЕС [ -readnow ] [ -mapped ]'
'add-symbol-file ИМЯ-ФАЙЛА -sРАЗДЕЛ АДРЕС'
     Команда 'add-symbol-file' считывает дополнительную информацию
     таблицы символов из файла ИМЯ-ФАЙЛА.  Вы должны использовать эту
     команду, если файл ИМЯ-ФАЙЛА был динамически загружен (другими
     средствами) в выполняющуюся программу.  АДРЕС должен быть адресом
     памяти, по которому был загружен файл; GDB сам его определить не
     может.  Вы можете указать дополнительно произвольное количество пар
     '-s РАЗДЕЛ АДРЕС', чтобы явно указать имя раздела и базовый адрес
     для него.  Вы можете указать произвольный АДРЕС как выражение.

     Таблица символов из файла ИМЯ-ФАЙЛА добавляется к таблице,
     изначально считанной по команде 'symbol-file'.  Вы можете
     использовать команду 'add-symbol-file' произвольное число раз;
     прочитанные таким образом символьные данные добавляются к старым.
     Чтобы уничтожить все старые данные, используйте команду
     'symbol-file' без аргументов.

     Команда 'add-symbol-file' не повторяется, если вы нажимаете <RET>
     после ее использования.

     Чтобы изменить способ обработки GDB таблицы символов для ИМЯ-ФАЙЛА,
     вы можете использовать параметры '-mapped' и '-readnow' так же, как
     и с командой 'symbol-file'.

'add-shared-symbol-file'
     Команда 'add-shared-symbol-file' может быть использована только для
     Motorola 88k в операционной системе Harris CXUX. GDB ищет
     разделяемые библиотеки автоматически, однако, если он не находит
     ваших, вы можете выполнить 'add-shared-symbol-file'.  Эта команда
     не имеет аргументов.

'section'
     Команда 'section' изменяет базовый адрес раздела РАЗДЕЛ
     выполняемого файла на АДРЕС.  Это может быть использовано, если
     выполняемый файл не содержит адресов разделов (что имеет место для
     формата a.out), или когда адреса, указанные в самом файле, неверны.
     Каждый раздел должен изменяться отдельно.  Команда 'info files',
     описанная ниже, перечисляет все разделы и их адреса.

'info files'
'info target'
     Команды 'info files' и 'info target' являются синонимами; они обе
     выводят текущую цель (*note Определение отладочной цели: Отладочные
     цели.), включая имена выполняемого файла и файла дампа памяти,
     используемых GDB, и файлов, из которых были загружены символы.
     Команда 'help target' выводит все возможные цели, а не только
     текущую.

   Все команды для задания файлов допускают в качестве аргументов как
абсолютные, так и относительные имена файлов.  GDB всегда
преобразовывает имя файла к абсолютному и запоминает его в таком виде.

   GDB поддерживает разделяемые библиотеки на HP-UX, SunOS, SVr4, Irix 5
и IBM RS/6000.

   Когда вы даете команду 'run', или когда исследуете файл дампа памяти,
GDB автоматически загружает определения символов из разделяемых
библиотек.  (Однако, если вы не отлаживаете файл дампа, GDB не понимает
ссылки на функции из разделяемой библиотеки до того, как вы выполните
команду 'run'.)

   На HP-UX, если программа загружает разделяемую библиотеку явно, GDB
автоматически загружает символы в момент вызова 'shl_load'.

'info share'
'info sharedlibrary'
     Вывести имена разделяемых библиотек, загруженных в данный момент.

'sharedlibrary РЕГ-ВЫР'
'share РЕГ-ВЫР'
     Загрузить символы разделяемых библиотек для файлов, удовлетворяющих
     регулярному выражению Unix.  Также как и для автоматически
     загруженных файлов, это загружает только разделяемые библиотеки,
     требуемые вашей программой для файла дампа памяти или после ввода
     'run'.  Если РЕГ-ВЫР опущено, загружаются все разделяемые
     библиотеки, требуемые вашей программой.

   В системах HP-UX, GDB сам определяет загрузку разделяемой библиотеки
и автоматически считывает символы из нее до некоторого изначально
установленного порогового значения, которое вы можете при желании
изменить.

   После этого порогового значения символы из разделяемых библиотек
должны загружаться явно.  Для загрузки этих символов используйте команду
'sharedlibrary ИМЯ-ФАЙЛА'.  Базовый адрес разделяемой библиотеки
определяется GDB автоматически и вы не должны его задавать.

   Для отображения или установки порогового значения используйте
следующие команды:

'set auto-solib-add ПОРОГ'
     Устанавливает размер порога автоматической загрузки в мегабайтах.
     Если ПОРОГ ненулевой, символы из всех библиотек разделяемых
     объектов будут загружаться автоматически, когда программа начинает
     выполнение, или когда динамический компоновщик информирует GDB о
     том, что была загружена новая библиотека, до тех пор, пока таблица
     символов программы и библиотек не превысит этот порог.  В противном
     случае, символы должны загружаться вручную, при помощи команды
     'sharedlibrary'.  По умолчанию порог равен 100 мегабайтам.

'show auto-solib-add'
     Отобразить величину текущего порога автоматической загрузки в
     мегабайтах.


File: gdb.info,  Node: Ошибки с символами,  Prev: Файлы,  Up: Файлы GDB

12.2 Ошибки чтения файлов с символами
=====================================

При чтении файла символов, GDB иногда сталкивается с такими проблемами,
как типы символов, которые он не распознает, или известные ошибки вывода
компилятора.  По умолчанию, GDB не сообщает вам о таких проблемах, так
как они сравнительно общие и прежде всего представляют интерес для
людей, занимающихся отладкой компиляторов.  Если вам интересна
информация о плохо составленных таблицах символов, вы можете запросить
GDB печатать только одно сообщение по каждому типу проблем, независимо
от того, сколько раз проблема появляется; или вы можете попросить GDB
напечатать больше сообщений, чтобы увидеть, сколько раз проблема
встречалась, командой 'set complaints' (*note Необязательные
предупреждения и сообщения: Сообщения/предупреждения.).

   Печатаемые сообщения и их значения, включают:

'inner block not inside outer block in СИМВОЛ'

     Информация о символах показывает, где области символов начинаются и
     заканчиваются (например, в начале функции или блока операторов).
     Эта ошибка указывает на то, что внутренний блок видимости не
     содержится целиком во внешнем.

     GDB обходит эту проблему, рассматривая внутренний блок так, как
     если бы он имел такую же область видимости, что и внешний.  Если
     внешний блок не является функцией, то СИМВОЛ в данном сообщении
     может быть показан как "'(don't known)'".

'block at АДРЕС out of order'

     Символьная информация для блоков символьных областей должна
     появляться в порядке увеличения адресов.  Данная ошибка указывает,
     что это не так.

     GDB не решает этой проблемы, и у него возникают трудности при
     определении местоположения символов в исходном файле, символы
     которого он считывает.  (Вы часто можете определить имя
     поврежденного исходного файла, указав 'set verbose on'.  *Note
     Необязательные предупреждения и сообщения:
     Сообщения/предупреждения.)

'bad block start address patched'

     Символьная информация для блоков символьных областей имеет меньший
     начальный адрес, чем у предшествующей строки исходного текста.
     Известно, что это происходит в компиляторе Си SunOS 4.1.1 (и более
     ранних версиях).

     GDB обходит проблему, обрабатывая блок символьной области как
     начинающийся с предыдущей исходной строки.

'bad string table offset in symbol N'

     Символ с номером N содержит указатель на таблицу строк, который
     превосходит размер таблицы.

     GDB обходит проблему, считая, что символ имеет имя 'foo', что может
     вызвать другие проблемы, если много символов заканчиваются этим
     именем.

'unknown symbol type 0xNN'

     Символьная информация содержит новые типы данных, которые GDB еще
     не знает, как считывать.  '0xNN' -- это тип символа неверно
     истолкованной информации, в шестнадцатеричном виде.

     GDB обходит ошибку, игнорируя эту символьную информацию.  Это
     обычно позволяет вам отлаживать программу, хотя некоторые символы и
     недоступны.  Если вы столкнетесь с такой проблемой и захотите ее
     отладить, вы можете отладить 'gdb' с помощью него же, установив
     точку останова на 'complain', затем дойти до функции
     'read_dbx_symtab' и исследовать '*bufp', чтобы увидеть символ.

'stub type has NULL name'

     GDB не может найти полное определение для структуры или класса.

'const/volatile indicator missing (ok if using g++ v1.x), got...'
     В символьной информации для функции-члена Си++ пропущена некоторая
     информация, которую последние версии компилятора должны для нее
     выводить.

'info mismatch between compiler and debugger'

     GDB не может разобрать спецификации типа, выведенной компилятором.

