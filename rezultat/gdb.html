This is gdb.html, produced by texi2any version 6.7 from gdb.texinfo.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* Gdb-ru: (gdb-ru).                  Отладчик GNU.
END-INFO-DIR-ENTRY

Этот файл описывает отладчик GNU GDB.

   'Отладка с помощью GDB: отладчик GNU уровня исходного кода', Восьмая
Редакция, Март 2000, для GDB версии 5.0.

   Copyright (C) 1988-2000 Free Software Foundation, Inc.
Перевод Copyright (C) 1999-2001 Дмитрий Сиваченко.  Под редакцией Олега
Тихонова.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: gdb.html,  Node: Top,  Next: Обзор,  Prev: (dir),  Up: (dir)

Отладка с помощью GDB
*********************

Этот файл описывает GDB, символьный отладчик GNU.

   Восьмая редакция, Март 2000, для GDB версии 5.0.

   Copyright (C) 1988-2000 Free Software Foundation, Inc.

* Menu:

* Обзор::                       Обзор GDB
* Пример сеанса::               Пример сеанса GDB

* Вызов::                       Вход и выход из GDB
* Команды::                     Команды GDB
* Выполнение::                  Выполнение программ под управлением GDB
* Остановка::                   Остановка и продолжение
* Стек::                        Исследование стека
* Исходные файлы::              Исследование исходных файлов
* Данные::                      Исследование данных

* Языки::                       Использование GDB с различными языками

* Символы::                     Исследование таблицы символов
* Изменения::                   Изменение выполнения
* Файлы GDB::                   Файлы GDB
* Отладочные цели::             Определение отладочной цели
* Конфигурации::                Информация о конфигурации
* Управление GDB::              Управление GDB
* Последовательности::          Фиксированные последовательности команд
* Emacs::                       Использование GDB под управлением GNU Emacs
* Примечания::                  Интерфейс примечаний GDB
* GDB/MI::                      Машинный интерфейс GDB

* Ошибки в GDB::                Отчеты об ошибках в GDB
* Редактирование командной строки::
                                Редактирование командной строки
* Интерактивное использование истории::
                                Интерактивное использование истории
* Форматирование документации:: Как отформатировать и распечатать
                                документацию по GDB
* Установка GDB::               Установка GDB
* Алфавитный указатель::        Алфавитный указатель


Обзор GDB

* Свободные программы::         Свободно распространяемые программы
* Выражение признательности::   Кто внес вклад в развитие GDB

Вход и выход из GDB

* Вызов GDB::
* Выход из GDB::
* Команды оболочки::

Вызов GDB

* Параметры файлов::
* Параметры режима::

Команды GDB

* Синтаксис команд::
* Завершение::
* Справка::

Выполнение программ под управлением GDB

* Компиляция::
* Начало выполнения::
* Аргументы::
* Среда::
* Рабочий каталог::
* Ввод-вывод::
* Присоединение::
* Уничтожение процесса::
* Нити::
* Процессы::

Остановка и продолжение исполнения

* Точки останова::
* Продолжение и пошаговое выполнение::
* Сигналы::
* Остановка нитей::

Точки останова, точки наблюдения и точки перехвата

* Установка точек останова::
* Установка точек наблюдения::
* Установка точек перехвата::
* Удаление точек останова::
* Отключение::
* Условия::
* Команды останова::
* Меню точки останова::
* Ошибки в точках останова::

Исследование стека

* Кадры::
* Цепочки вызовов::
* Выбор::
* Информация о кадре::

Исследование исходных файлов

* Вывод строк::
* Поиск::
* Пути для исходных файлов::
* Машинный код::

Исследование данных

* Выражения::
* Переменные::
* Массивы::
* Форматы вывода::
* Память::
* Автоматическое отображение::
* Параметры вывода::
* История значений::
* Вспомогательные переменные::
* Регистры::
* Вычисления с плавающей точкой::

Использование GDB с различными языками программирования

* Переход от одного языка к другому::
* Отображение языка::
* Проверка::
* Поддержка::

Переход от одного языка к другому

* Имена файлов::
* Установка рабочего языка::
* Автоматическое::

Проверка диапазона принадлежности типу

* Проверка типов::
* Проверка диапазона::

Поддерживаемые языки

* Си::
* Модула-2::
* Chill::

Си и Си++

* Операторы Си::
* Константы Си::
* Выражения Си++::
* Значения Си по умолчанию::
* Проверки в Си::
* Отладка Си::
* Отладка Си++::

Модула-2

* Операторы Модулы-2::
* Встроенные функции/процедуры::
* Константы Модулы-2::
* Установки по умолчанию М-2::
* Отклонения::
* Проверки Модулы-2::
* Область видимости в Модуле-2::
* GDB и Модула-2::

Chill

* Как отображаются режимы::
* Местоположения::
* Значения и операции с ними::
* Проверка диапазона и типов в Chill::
* Установки по умолчанию Chill::

Изменение выполнения

* Присваивание::
* Переходы::
* Подача сигналов::
* Возврат::
* Вызовы::
* Внесение изменений::

Файлы GDB

* Файлы::
* Ошибки с символами::

Определение отладочной цели

* Активные цели::
* Команды для целей::
* Порядок байтов::
* Удаленная отладка::
* Отображение объектов ядра::

Удаленная отладка

* Удаленный::

Удаленный последовательный протокол GDB

* Содержимое заглушки::
* Начальная загрузка::
* Сеанс отладки::
* Протокол::
* Сервер::
* NetWare::

Информация о конфигурации

* Чистая::
* Встроенная ОС::
* Встроенные процессоры::
* Архитектуры::

Чистая

* HP-UX::
* Информация о процессах SVR4::

Встроенные операционные системы

* VxWorks::

Использование GDB с VxWorks

* Соединение к VxWorks::
* Загрузка на VxWorks::
* Присоединение к VxWorks::

Встроенные процессоры

* Встроенный A29K::
* ARM::
* H8/300::
* H8/500::
* i960::
* M32R/D::
* M68K::
* M88K::
* Встроенный MIPS::
* PowerPC::
* PA::
* SH::
* Sparclet::
* Sparclite::
* ST2000::
* Z8000::

Встроенный AMD A29K

* A29K UDI::
* A29K EB29K::
* Коммуникации (EB29K)::
* gdb-EB29K::
* Удаленный журнал::

Hitachi H8/300

* Платы Hitachi::
* Hitachi ICE::
* Специально для Hitachi::

Intel i960

* Вызов Nindy::
* Параметры Nindy::
* Сброс Nindy::

Tsqware Sparclet

* Файл Sparclet::
* Соединение к Sparclet::
* Загрузка на Sparclet::
* Выполнение Sparclet::

Архитектуры

* A29K::
* Alpha::
* MIPS::

Управление GDB

* Приглашение::
* Редактирование::
* История::
* Размер экрана::
* Числа::
* Сообщения/предупреждения::
* Отладочный вывод::

Фиксированные последовательности команд

* Определяемые пользователем команды::
* Ловушки::
* Командные файлы::
* Вывод::

Сообщение об ошибках в GDB

* Критерий ошибки::
* Отчеты об ошибках::

Установка GDB

* Отдельный объектный каталог::
* Имена конфигураций::
* Ключи configure::



File: gdb.html,  Node: Обзор,  Next: Пример сеанса,  Up: Top

Обзор GDB
*********

Назначение отладчика, такого как GDB -- позволить вам увидеть, что
происходит "внутри" другой программы во время ее выполнения, или что
делала другая программа в момент краха.

   GDB может выполнять действия четырех основных типов (а также другие,
дополняющие эти основные), чтобы помочь вам выявить ошибку:

   * Начать выполнение вашей программы, задав все, что может повлиять на
     ее поведение.

   * Остановить вашу программу при указанных условиях.

   * Исследовать, что случилось, когда ваша программа остановилась.

   * Изменить вашу программу, чтобы вы могли поэкспериментировать с
     устранением эффектов одной ошибки и продолжить выявление других.

   Вы можете использовать GDB для отладки программ, написанных на Си и
Си++.  Для получения более подробной информации, смотрите *note
Поддерживаемые языки: Поддержка.  Для дополнительной информации,
смотрите *note Си и Си++: Си.

   GDB частично поддерживает языки Модула-2 и Chill.  Для получения
информации о Модуле-2, смотрите *note Модула-2: Модула-2.  Для получения
информации о Chill, см.  *note Chill::

   Отладка программ на Паскале, которые используют множества,
поддиапазоны, файловые переменные или вложенные функции, в настоящее
время не работает.  GDB не поддерживает ввод выражений, вывод значений,
и аналогичные возможности, использующие синтаксис Паскаля.

   GDB можно использовать для отладки программ, написанных на Фортране,
хотя может возникнуть необходимость ссылаться на некоторые переменные,
добавляя в конец имени знак подчеркивания.

* Menu:

* Свободные программы::         Свободно распространяемые программы
* Выражение признательности::   Кто внес вклад в развитие GDB


File: gdb.html,  Node: Свободные программы,  Next: Выражение признательности,  Up: Обзор

Свободно распространяемые программы
===================================

GDB -- "свободная программа", защищенная Универсальной Общественной
Лицензией GNU (GPL). GPL предоставляет вам свободу копировать или
изменять программу, но каждый человек, получая копию, также получает
свободу изменять эту копию (это означает, что у него должен быть доступ
к исходному коду), и свободу распространять последующие копии.  Обычные
компании, разрабатывающие программы, используют авторские права для
ограничения ваших свобод; Фонд Свободного Программного Обеспечения
использует GPL для сохранения этих свобод.

   Главное, Универсальная Общественная Лицензия -- это лицензия,
говорящая, что вы имеете эти свободы и что вы не можете их у кого-либо
отнять.


File: gdb.html,  Node: Выражение признательности,  Prev: Свободные программы,  Up: Обзор

Кто внес вклад в развитие GDB
=============================

Первоначальным автором GDB, как и многих других программ GNU, был Ричард
Столмен.  Многие другие люди внесли вклад в его разработку.  Этот раздел
пытается отдать должное основным участникам разработки.  Одним из
достоинств свободных программ является то, что каждый может внести свой
вклад в их развитие; к сожалению, мы не можем в действительности
поблагодарить здесь всех.  Файл 'ChangeLog' в поставке GDB представляет
детальнейший отчет.

   Изменения, сделанные задолго до версии 2.0, потеряны в тумане времен.

     _Оправдание:_ Дополнения к этому разделу особенно приветствуются.
     Если вы или ваши друзья (или враги, чтобы соблюдать справедливость)
     были незаслуженно пропущены в этом списке, мы будем рады добавить
     ваши имена!

   Особенно мы хотим сказать спасибо тем, кто присматривал за GDB между
основными выпусками, чтобы они не сочли свои многочисленные заслуги
оставленными без благодарности: Эндрю Кагни (выпуск 5.0); Джим Бленди
(выпуск 4.18); Джесон Моленда (выпуск 4.17); Стан Шебс (выпуск 4.14);
Фред Фиш (выпуски 4.16, 4.15, 4.13, 4.12, 4.11, 4.10, и 4.9); Сту
Гроссман и Джон Гилмор (выпуски 4.8, 4.7, 4.6, 4.5, и 4.4); Джон Гилмор
(выпуски 4.3, 4.2, 4.1, 4.0, и 3.9); Джим Кингдон (выпуски 3.5, 3.4, и
3.3) и Ренди Смит (выпуски 3.2, 3.1, и 3.0).

   Ричард Столмен, которому в различные времена помогали Петер ТерМаат,
Крис Хенсон и Ричард Млинарик, занимался выпусками до 2.8.

   Михаэль Тиманн является автором большей части поддержки GNU Си++ в
GDB, со значительным дополнительным вкладом от Пера Бозера.  Джеймс
Кларк написал дешифровщик(1) имен GNU Си++.  Ранняя работа по Си++ была
сделана Петером ТерМаатом (который также сделал много общей работы по
обновлению, приведшей к выпуску 3.0).

   Для исследования многих форматов объектных файлов GDB 4 использует
библиотеку подпрограмм BFD. BFD был совместным проектом Дэвида
В. Хенкел-Волласа, Рича Пиксли, Стива Чемберлена и Джона Гилмора.

   Дэвид Джонсон первоначально написал поддержку COFF; Пейс Виллисон
первоначально сделал поддержку инкапсулированного COFF.

   Брент Бенсон из Harris Computer Systems сделал поддержку DWARF2.

   Адам ДеБур и Брэндли Дэвис сделали поддержку ISI Optimum V. Пер
Бозер, Нобоюки Хикичи, и Алессандро Форин сделали поддержку MIPS.
Жан-Даниэль Фекет сделал поддержку Sun 386i.  Крис Хенсон улучшил
поддержку HP9000.  Нобоюки Хикичи и Томоюки Хаси сделали поддержку
Sony/News OS 3.  Дэвид Джонсон сделал поддержку Encore Umax.  Юрки
Куоппала сделал поддержку Altos 3068.  Джефф Ло сделал поддержку HP PA и
SOM. Кейс Паккард сделал поддержку NS32K. Доуг Ребсон сделал поддержку
Acorn Risc Machine.  Боб Раск сделал поддержку Harris Nighthawk CX-UX.
Крис Смит сделал поддержку Convex (и отладку программ на Фортране).
Джонатан Стоун сделал поддержку Pyramid.  Михаэль Тиманн сделал
поддержку SPARC. Тим Такер сделал поддержку для Gould NP1 и Gould
Powernode.  Пейс Виллисон сделал поддержку Intel 386.  Джей Восбург
сделал поддержку Symmetry.

   Андреас Шваб сделал поддержку M68K Linux.

   Рич Шаефер и Петер Шауер помогли реализовать поддержку разделяемых
библиотек SunOS.

   Джей Фенласон и Роланд МакГрес проверили совместимость GDB и GAS по
нескольким наборам машинных инструкций.

   Патрик Дювал, Тед Голдстейн, Викрам Кока и Гленн Инжел помогли
разработать удаленную отладку.  Корпорации Intel, Wind River Systems,
AMD и ARM сделали модули удаленной отладки для целей i960, VxWorks, A29K
UDI, и RDI соответственно.

   Брайан Фокс является автором библиотек Readline, предоставляющих
историю команд и возможность редактирования командной строки.

   Эндрю Бирс из SUNY Buffalo написал код для переключения языков,
поддержку Модулы-2, главу 'Языки' этого руководства.

   Фред Фиш написал большую часть поддержки Unix System Vr4.  Он также
улучшил поддержку завершения команд для поддержки перегруженных символов
Си++.

   Hitachi America, Ltd.  спонсировала поддержку для процессоров H8/300,
H8/500 и Super-H.

   NEC спонсировала поддержку процессоров v850, Vr4xxx и Vr5xxx.

   Mitsubishi спонсировала поддержку процессоров D10V, D30V и M32R/D.

   Toshiba спонсировала поддержку процессора TX39 Mips.

   Matsushita спонсировала поддержку процессоров MN10200 и MN10300.

   Fujitsu спонсировала поддержку процессоров SPARClite и FR30.

   Кунг Шу, Джефф Ло и Рик Слэдки добавили поддержку аппаратных точек
наблюдения.

   Михаэль Снайдер добавил поддержку точек трассировки.

   Сту Гроссман написал gdbserver.

   Джим Кингдон, Петер Шауер, Ян Тейлор и Сту Гроссман сделали почти
бесчисленное количество исправлений и улучшений во всем GDB.

   Следующие люди из Hewlett-Packard Company сделали поддержку
архитектуры PA-RISC 2.0, HP-UX 10.20, 10.30 и 11.0 (усеченный режим),
реализации нитей HP в ядре, компилятора HP aC++, и конечного интерфейса
пользователя: Бен Крепп, Ричард Тайтл, Джон Бишоп, Сюзан Макчиа, Кэси
Манн, Сэтиш Пай, Индиа Поул, Стив Рейраур и Елена Заннони.  Ким Хаас
предоставил специфичную для HP информацию для этого руководства.

   Cygnus Solutions спонсировала поддержку GDB и большую часть его
развития с 1991 года.  Среди инженеров Cygnus, работавших над GDB на
постоянной основе, Марк Александер, Джим Бленди, Пер Бозер, Кевин
Беттнер, Эдит Эпштейн, Крис Фейлор, Фред Фиш, Мартин Хант, Джим Ингам,
Джон Гилмор, Сту Гроссман, Кунг Шу, Джим Кингдон, Джон Мецлер, Фернандо
Нассер, Джеффри Ноер, Дон Перчик, Рич Пиксли, Зденек Радуч, Кейс Сейц,
Стан Шебс, Дэвид Тейлор и Елена Заннони.  Кроме того, Дейв Бролли, Ян
Кармихаэль, Стив Чемберлен, Ник Клифтон, Джэй Ти Конклин, Стен Кокс, Ди
Джей Делори, Ульрих Дреппер, Фрэнк Эйглер, Дуг Эванс, Син Фаган, Дэвид
Хенкель-Воллас, Ричард Хендерсон, Джефф Холком, Джефф Ло, Джим Лемке,
Том Лорд, Боб Мансон, Михаэль Мейсснер, Джейсон Меррилл, Кэтрин Мур, Дрю
Мосли, Кен Робурн, Гавин Ромиг-Кох, Роб Савой, Джейми Смит, Майк Стамп,
Ян Тейлор, Анжела Томас, Михаэль Тиманн, Том Тромей, Рон Унро, Джим
Вилсон и Дэвид Зун также внесли свой вклад в большей или меньшей
степени.

   ---------- Footnotes ----------

   (1) В Си++ и других объектно-ориентированных языках программирования,
у вас может быть несколько функций с одним именем, но с аргументами
разных типов.  Например:

     int add_two(int a, int b);
     double add_two(double a, double b);
     double add_two(double a, int b);

Компилятор генерирует код для вызова верной функции по заданным
аргументам.  Это называется "перегрузкой функций".

   Однако, компоновщик требует, чтобы все символы имели недвусмысленные
имена.  Поэтому компилятор _шифрует_ (от английского "mangle") имена
перегруженных функций так, чтобы они включали типы аргументов и
возвращаемые значения.  К примеру, приведенные выше функции могут быть
зашифрованы примерно так:

     add_two_Ret_int_int_int
     add_two_Ret_double_double_double
     add_two_Ret_double_double_int

(в действительности шифрованные имена выглядят безобразнее).  В
результате компоновщик может правильно обработать перегруженные функции.
_Дешифровщик_ (от английского "demangler") -- это программа (или
функция), которая выполняет обратную операцию: анализируя зашифрованные
имена, она выдает исходную сигнатуру функции.  Это необходимо, чтобы
отобразить то, что программист сможет понять и связать с исходным
текстом своей программы.  Для этого любому средству отладки,
поддерживающему Си++, обычно требуется дешифровщик.  (Прим. переводчика)


File: gdb.html,  Node: Пример сеанса,  Next: Вызов,  Prev: Обзор,  Up: Top

1 Пример сеанса GDB
*******************

Вы можете пользоваться этим руководством в свое удовольствие, чтобы
прочитать о GDB все.  Однако, достаточно небольшого количества команд,
чтобы начать пользоваться отладчиком.  Эта глава иллюстрирует эти
команды.

   В одной из предварительных версий программы GNU 'm4' (настраиваемый
макропроцессор), была допущена следующая ошибка: иногда, при замене
строк, определяющих кавычки, со значений по умолчанию, команды,
использовавшиеся для поиска одного макроопределения внутри другого,
прекращали работать.  В следующем коротком сеансе 'm4' мы определим
макрос 'foo', который раскрывается в '0000'; затем мы используем
встроенную процедуру 'm4' 'defn', чтобы определить точно такой же макрос
'bar'.  Однако, если мы изменим открывающую кавычку на '<QUOTE>', а
закрывающую на '<UNQUOTE>', та же самая процедура не сможет определить
новый синоним 'baz':

     $ cd gnu/m4
     $ ./m4
     define(foo,0000)

     foo
     0000
     define(bar,defn('foo'))

     bar
     0000
     changequote(<QUOTE>,<UNQUOTE>)

     define(baz,defn(<QUOTE>foo<UNQUOTE>))
     baz
     C-d
     m4: End of input: 0: fatal error: EOF in string(1)

Попытаемся с помощью GDB понять, что же происходит.

     $ gdb m4
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty"
      for details.

     GDB 5.0, Copyright 1999 Free Software Foundation, Inc...
     (gdb)

GDB читает только минимум символьных данных, достаточный для того, чтобы
знать, где в случае необходимости искать остальные; в результате первое
приглашение появляется очень быстро.  Теперь мы велим GDB использовать
меньшую чем обычно ширину экрана, чтобы примеры умещались на страницах
этого руководства.

     (gdb) set width 70

Нам необходимо увидеть, как работает встроенная процедура 'm4'
'changequote'.  Посмотрев исходный текст, мы знаем, что соответствующей
подпрограммой является 'm4_changequote', так что мы устанавливаем на ней
точку останова с помощью команды GDB 'break'.

     (gdb) break m4_changequote
     Breakpoint 1 at 0x62f4: file builtin.c, line 879.

Используя команду 'run', мы запускаем 'm4' под управлением GDB; до тех
пор, пока управление не достигло подпрограммы 'm4_changequote',
программа выполняется как обычно:

     (gdb) run
     Starting program: /work/Editorial/gdb/gnu/m4/m4
     define(foo,0000)

     foo
     0000

Чтобы активировать точку останова, мы вызываем 'changequote'.  GDB
приостанавливает выполнение 'm4', выводя на экран информацию о том
месте, где он остановился.

     changequote(<QUOTE>,<UNQUOTE>)

     Breakpoint 1, m4_changequote (argc=3, argv=0x33c70)
         at builtin.c:879
     879         if (bad_argc(TOKEN_DATA_TEXT(argv[0]),argc,1,3))

Теперь мы используем команду 'n' ('next'), чтобы продолжить выполнение
до следующей строки текущей функции.

     (gdb) n
     882         set_quotes((argc >= 2) ? TOKEN_DATA_TEXT(argv[1])\
      : nil,

'set_quotes' выглядит как нужная нам подпрограмма.  Мы можем войти в
нее, используя команду 's' ('step') вместо 'next'.  'step' переходит на
следующую исполняемую строку _любой_ подпрограммы, так что она входит в
'set_quotes'.

     (gdb) s
     set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     530         if (lquote != def_lquote)

Отображение, показывающее подпрограмму (и ее параметры), где 'm4' сейчас
приостановлен, называется отображением кадра стека.  Оно показывает
обзор стека.  Мы можем использовать команду 'backtrace' (которую можно
сокращать как 'bt'), чтобы посмотреть, в каком месте стека мы находимся:
команда 'backtrace' выводит кадр стека для каждой активной подпрограммы.

     (gdb) bt
     #0  set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     #1  0x6344 in m4_changequote (argc=3, argv=0x33c70)
         at builtin.c:882
     #2  0x8174 in expand_macro (sym=0x33320) at macro.c:242
     #3  0x7a88 in expand_token (obs=0x0, t=209696, td=0xf7fffa30)
         at macro.c:71
     #4  0x79dc in expand_input () at macro.c:40
     #5  0x2930 in main (argc=0, argv=0xf7fffb20) at m4.c:195

Пройдем по шагам еще несколько строк, чтобы понять, что же происходит.
Первые два раза мы можем использовать 's'; следующие два раза мы
пользуемся командой 'n', чтобы избежать вхождения в подпрограмму
'xstrdup'.

     (gdb) s
     0x3b5c  532         if (rquote != def_rquote)
     (gdb) s
     0x3b80  535         lquote = (lq == nil || *lq == '\0') ?  \
     def_lquote : xstrdup(lq);
     (gdb) n
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup(rq);
     (gdb) n
     538         len_lquote = strlen(rquote);

Последняя выведенная строка выглядит несколько странно; мы можем
исследовать переменные 'lquote' и 'rquote', чтобы понять, действительно
ли это определенные нами новые левая и правая кавычки.  Мы используем
команду 'p' ('print'), чтобы посмотреть их значения.

     (gdb) p lquote
     $1 = 0x35d40 "<QUOTE>"
     (gdb) p rquote
     $2 = 0x35d50 "<UNQUOTE>"

Действительно, 'lquote' и 'rquote' являются новыми кавычками.  Для
просмотра контекста, мы можем вывести десять строк исходного текста,
окружающих текущую строку, используя команду 'l' ('list').

     (gdb) l
     533             xfree(rquote);
     534
     535         lquote = (lq == nil || *lq == '\0') ? def_lquote\
      : xstrdup (lq);
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup (rq);
     537
     538         len_lquote = strlen(rquote);
     539         len_rquote = strlen(lquote);
     540     }
     541
     542     void

   Давайте пройдем еще две строки, которые устанавливают 'len_lquote' и
'len_rquote', и затем исследуем значения этих переменных.

     (gdb) n
     539         len_rquote = strlen(lquote);
     (gdb) n
     540     }
     (gdb) p len_lquote
     $3 = 9
     (gdb) p len_rquote
     $4 = 7

Это, очевидно, неправильно, так как 'len_lquote' и 'len_rquote'
обозначают длины переменных 'lquote' и 'rquote' соответственно.  Мы
можем присвоить им лучшие значения, используя команду 'p', так как она
может выводить значение любого выражения, а выражение может содержать
вызовы подпрограмм и присваивания.

     (gdb) p len_lquote=strlen(lquote)
     $5 = 7
     (gdb) p len_rquote=strlen(rquote)
     $6 = 9

Достаточно ли этого, чтобы решить проблему использования новых кавычек
во встроенной процедуре 'm4' 'defn'?  Мы можем продолжить выполнение
'm4' командой 'c' ('continue'), и затем попробовать пример,
первоначально вызывавший ошибку:

     (gdb) c
     Continuing.

     define(baz,defn(<QUOTE>foo<UNQUOTE>))

     baz
     0000

Получилось!  Теперь новые кавычки работают так же хорошо, как и
стандартные.  Кажется, проблема заключалась лишь в двух опечатках,
приводивших к неправильному определению длин.  Мы позволим 'm4' выйти,
подавая ему на вход EOF:

     C-d
     Program exited normally.(2)

Сообщение 'Program exited normally.' исходит от GDB; оно показывает, что
'm4' закончила выполнение.  Мы можем завершить наш сеанс работы с GDB
командой 'quit'.

     (gdb) quit

   ---------- Footnotes ----------

   (1) m4: Конец ввода: 0: фатальная ошибка: EOF в строке (Прим.
переводчика)

   (2) Программа завершилась нормально.  (Прим. переводчика)


File: gdb.html,  Node: Вызов,  Next: Команды,  Prev: Пример сеанса,  Up: Top

2 Вход и выход из GDB
*********************

Эта глава посвящена тому, как запустить GDB и как из него выйти.
Основные принципы:
   * введите 'gdb' для вызова GDB.
   * введите 'quit' или 'C-d' для выхода из него.

* Menu:

* Вызов GDB::                   Как начать работу с GDB
* Выход из GDB::                Как выйти из GDB
* Команды оболочки::            Как использовать команды оболочки из GDB


File: gdb.html,  Node: Вызов GDB,  Next: Выход из GDB,  Up: Вызов

2.1 Вызов GDB
=============

Вызывайте GDB путем запуска программы 'gdb'.  Начав работу, GDB
считывает команды с терминала до тех пор, пока вы не скажете ему выйти.

   Вы также можете запустить 'gdb' с различными аргументами и ключами,
чтобы с самого начала более детально задать среду отладки.

   Ключи командной строки, описанные здесь, предназначены для охвата
различных ситуаций; в действительности, в некоторых средах часть этих
ключей может быть недоступна.

   Чаще всего GDB вызывается с одним аргументом, который определяет
исполняемую программу:

     gdb ПРОГРАММА

Вы также можете указать при старте как исполняемую программу, так и файл
дампа памяти:

     gdb ПРОГРАММА ДАМП

   Если вы хотите отладить выполняющийся в данный момент процесс, то
вместо этого, вы можете указать вторым аргументом идентификатор этого
процесса:

     gdb ПРОГРАММА 1234

присоединит GDB к процессу '1234' (если, конечно, у вас нет файла с
именем '1234', GDB сначала проверяет наличие файла дампа памяти).

   Преимущества, которые можно получить при использовании второго
аргумента командной строки, требуют наличия достаточно полной
операционной системы; если вы используете GDB как удаленный отладчик,
присоединенный к компьютеру без операционной системы, там вообще может
не быть понятия "процесса", и часто нет никакого способа получить дамп.
GDB предупредит вас, если ему не удается присоединиться к процессу или
считать файл дампа памяти.

   Вы можете запустить 'gdb' без вывода начального сообщения,
описывающего отсутствие гарантии, задав ключ '-silent':

     gdb -silent

Кроме того, вы можете контролировать процесс запуска GDB с помощью
ключей командной строки.  GDB может сам напомнить вам о доступных
ключах.

Введите

     gdb -help

чтобы вывести на экран все доступные ключи с кратким описанием их
использования (сокращенный эквивалент -- 'gdb -h').

   Все заданные вами ключи и параметры командной строки обрабатываются
последовательно.  Порядок становится важным при использовании ключа
'-x'.

* Menu:

* Параметры файлов::            Выбор файлов
* Параметры режима::            Выбор режимов


File: gdb.html,  Node: Параметры файлов,  Next: Параметры режима,  Up: Вызов GDB

2.1.1 Выбор файлов
------------------

При запуске, GDB считывает параметры, отличные от ключей, как указатели
на исполняемую программу и файл дампа (или идентификатор процесса),
точно так же, как если бы эти параметры задавались ключами '-se' и '-c'
соответственно.  (GDB считает первый параметр, не имеющий
соответствующего флага ключа, эквивалентом ключа '-se', за которым
следует этот параметр; а второй такой параметр, если он есть, --
эквивалентом ключа '-c', за которым следует этот параметр.)

   Если GDB был сконфигурирован без включения поддержки файлов дампа,
что имеет место для большинства встроенных целей, то он выразит
недовольство вторым аргументом и проигнорирует его.

   Многие ключи имеют как длинную, так и краткую формы; в следующем
списке приводятся обе.  GDB также распознает недвусмысленные сокращения
длинных форм.  (Вы можете, по желанию, обозначать ключи с помощью '--',
а не '-', хотя мы показываем наиболее употребляемый формат.)

'-symbols ФАЙЛ'
'-s ФАЙЛ'
     Читать таблицу символов из файла ФАЙЛ.

'-exec ФАЙЛ'
'-e ФАЙЛ'
     Использовать ФАЙЛ как исполняемый для выполнения и исследования
     данных вместе с дампом памяти, когда это необходимо.

'-se ФАЙЛ'
     Читать таблицу символов из файла ФАЙЛ и использовать его как
     исполняемый файл.

'-core ФАЙЛ'
'-c ФАЙЛ'
     Использовать ФАЙЛ как дамп памяти для исследования.

'-c НОМЕР'
     Присоединиться к процессу с идентификатором НОМЕР, также, как по
     команде 'attach' (при условии, что нет файла в формате дампа памяти
     с именем НОМЕР; в этом случае '-c' определяет этот файл как дамп
     для считывания).

'-command ФАЙЛ'
'-x ФАЙЛ'
     Выполнить команды GDB из файла ФАЙЛ.  *Note Командные файлы:
     Командные файлы.

'-directory КАТАЛОГ'
'-d КАТАЛОГ'
     Добавить КАТАЛОГ к путям поиска файлов с исходными текстами.

'-m'
'-mapped'
     _Предупреждение: этот ключ зависит от возможностей операционной
     системы, которые реализованы не везде._
     Если отображаемые в память файлы поддерживаются в вашей системе
     через системный вызов 'mmap', вы можете использовать этот ключ,
     чтобы GDB записывал символы из вашей программы в файл в текущем
     каталоге, допускающий повторное использование.  Если программа,
     которую вы отлаживаете, называется '/tmp/fred', то отображаемым
     символьным файлом будет '/tmp/fred.syms'.  Последующие отладочные
     сеансы GDB замечают наличие этого файла и могут быстро отобразить в
     память символьную информацию из него, а не читать таблицу символов
     из выполняемого файла.

     Файл '.syms' специфичен для рабочей машины, на которой запускается
     GDB. Он содержит точный образ внутренней символьной таблицы GDB. Он
     не может быть разделен между несколькими рабочими платформами.

'-r'
'-readnow'
     Читать символьную таблицу каждого файла, содержащего таблицу
     символов, сразу целиком, а не стандартным образом, при котором она
     считывается постепенно по мере необходимости.  Эта команда
     замедляет запуск, но дальнейшие операции производятся быстрее.

   Ключи '-mapped' и '-readnow' обычно используются вместе, чтобы
построить файл '.syms', который содержит полную информацию о символах.
(*Note Команды для задания файлов: Файлы, для информации о файлах
'.syms'.)  Вот простой вызов GDB, не делающий ничего, кроме построения
файла '.syms' для использования в будущем:

     gdb -batch -nx -mapped -readnow имя-программы


File: gdb.html,  Node: Параметры режима,  Prev: Параметры файлов,  Up: Вызов GDB

2.1.2 Выбор режимов
-------------------

Вы можете вызывать GDB в различных альтернативных режимах -- например, в
пакетном или в "тихом" режиме.

'-nx'
'-n'
     Не выполнять команды ни из каких файлов инициализации (обычно
     называемых '.gdbinit', или 'gdb.ini' на PC). В нормальном режиме,
     GDB выполняет команды из этих файлов после обработки всех командных
     ключей и параметров.  *Note Командные файлы: Командные файлы.

'-quiet'
'-silent'
'-q'
     "Тихий".  Не печатать вводное сообщение и информацию об авторских
     правах.  Эти сообщения также подавляются в пакетном режиме.

'-batch'
     Выполняться в пакетном режиме.  Выйти со значением '0' после
     обработки всех командных файлов, заданных ключом '-x' (и всех
     команд из инициализационных файлов, если это не запрещено ключом
     '-n').  Выйти с ненулевым значением, если во время выполнения
     команд GDB из командных файлов произойдет ошибка.

     Пакетный режим может быть полезен при вызове GDB как фильтра;
     например, чтобы загрузить программу и запустить ее на другом
     компьютере; чтобы это было более удобно, сообщение

          Program exited normally.

     (которое обычно выдается при завершении программы, выполняемой под
     управлением GDB) при выполнении в пакетном режиме не выдается.

'-nowindows'
'-nw'
     "Без окон".  Если GDB имеет встроенный графический интерфейс
     пользователя (GUI), то этот ключ велит GDB использовать только
     интерфейс командной строки.  Если GUI недоступен, этот ключ не
     оказывает никакого действия.

'-windows'
'-w'
     Если GDB включает GUI, этот ключ требует использовать его, если
     только возможно.

'-cd КАТАЛОГ'
     Запустить GDB, используя в качестве рабочего каталога КАТАЛОГ,
     вместо текущего.

'-fullname'
'-f'
     GNU Emacs устанавливает этот ключ, когда вызывает GDB как
     подпроцесс.  Это велит GDB выводить полное имя файла и номер строки
     в стандартном, распознаваемом стиле всякий раз, когда отображается
     кадр стека (что включает каждую остановку вашей программы).  Этот
     распознаваемый формат выглядит как два знака '\032', за которыми
     следует имя файла, номер строки и символьная позиция, разделенные
     двоеточиями, и знак новой строки.  Программа интерфейса Emacs-GDB
     использует два знака '\032' как сигнал для отображения исходного
     текста для кадра.

'-epoch'
     Интерфейс Epoch Emacs-GDB устанавливает этот ключ, когда вызывает
     GDB как подпроцесс.  Это велит GDB изменить свои подпрограммы
     печати так, чтобы позволить Epoch отображать значения выражений в
     отдельном окне.

'-annotate УРОВЕНЬ'
     Этот ключ устанавливает "уровень примечаний" внутри GDB. Его эффект
     аналогичен использованию 'set annotate УРОВЕНЬ' (*note
     Примечания::).  Уровень примечаний контролирует, какое количество
     информации GDB выводит вместе с приглашением, значениями выражений,
     строками исходного текста и другими типами вывода.  Уровень 0
     является обычным, уровень 1 используется, когда GDB выполняется как
     подпроцесс GNU Emacs, уровень 2 выводит максимальное количество
     примечаний и подходит для программ, которые управляют GDB.

'-async'
     Использовать асинхронный цикл событий для интерфейса командной
     строки.  GDB обрабатывает все события, такие как ввод пользователя
     с клавиатуры, через специальный цикл событий.  Это позволяет GDB
     принимать и обрабатывать команды пользователя параллельно с
     выполнением отлаживаемого процесса(1), так что вы не должны ждать
     возвращения управления GDB, прежде чем ввести следующую команду.
     (_Замечание:_ в версии 5.0, асинхронное выполнение на целевой
     системе еще не поддерживается, так что режим '-async' еще не
     полностью реализован.)

     Когда стандартный ввод соединен с терминальным устройством, GDB по
     умолчанию использует асинхронный цикл событий, если это не
     отключено ключом '-noasync'.

'-noasync'
     Отключить асинхронный цикл событий для интерфейса командной строки.

'-baud БОД-В-СЕК'
'-b БОД-В-СЕК'
     Устанавливает скорость линии (скорость в бодах, или в битах в
     секунду) любого последовательного интерфейса, используемого GDB для
     удаленной отладки.

'-tty УСТРОЙСТВО'
'-t УСТРОЙСТВО'
     Запуститься, используя УСТРОЙСТВО для стандартного ввода и вывода
     вашей программы.

'-interpreter ИНТЕРП'
     Использовать интерпретатор ИНТЕРП к качестве интерфейса с
     управляющей программой или устройством.  Подразумевается, что этот
     ключ должен устанавливаться программами, которые взаимодействуют с
     GDB, используя его как выходной буфер.  Например,
     '--interpreter=mi' велит GDB использовать "интерфейс gdbmi" (*note
     Интерфейс GDB/MI: GDB/MI.).

'-write'
     Открыть выполняемый файл и файл дампа памяти как для чтения, так и
     для записи.  Это эквивалентно команде GDB 'set write on' (*note
     Внесение изменений::).

'-statistics'
     Этот ключ велит GDB печатать статистику о времени и использовании
     памяти после завершения каждой команды и возврата к приглашению.

'-version'
     Этот ключ велит GDB напечатать номер своей версии и объявление об
     отсутствии гарантий и затем завершиться.

   ---------- Footnotes ----------

   (1) GDB, собранный средствами DJGPP для MS-DOS/MS-Windows,
поддерживает этот режим функционирования, но цикл событий
приостанавливается, когда выполняется отлаживаемая программа.


File: gdb.html,  Node: Выход из GDB,  Next: Команды оболочки,  Prev: Вызов GDB,  Up: Вызов

2.2 Выход из GDB
================

'quit [ВЫРАЖЕНИЕ]'
'q'
     Чтобы выйти из GDB, используйте команду 'quit' (сокращенно 'q') или
     введите знак конца файла (обычно 'C-d').  Если вы не укажете
     ВЫРАЖЕНИЕ, GDB закончит работу нормально; в противном случае, он
     использует результат ВЫРАЖЕНИЯ как код ошибки.

   Прерывание (часто 'C-c') не приводит к выходу из GDB, а завершает
любую выполняющуюся команду и возвращает вас на командный уровень.  Вы
можете безопасно пользоваться прерыванием в любое время, потому что GDB
не позволяет ему вступить в силу до того, как это станет безопасным.

   Если вы использовали GDB для управления присоединенным процессом или
устройством, вы можете освободить его командой 'detach' (*note Отладка
запущенного ранее процесса: Присоединение.).


File: gdb.html,  Node: Команды оболочки,  Prev: Выход из GDB,  Up: Вызов

2.3 Команды оболочки
====================

Если вам потребовалось выполнить команды оболочки во время сеанса
отладки, нет смысла приостанавливать или покидать GDB; вам достаточно
воспользоваться командой 'shell'.

'shell КОМАНДНАЯ СТРОКА'
     Вызвать стандартную оболочку для выполнения КОМАНДНОЙ СТРОКИ.
     Переменная среды 'SHELL', если она существует, определяет, какую
     оболочку запустить.  В противном случае, GDB использует оболочку по
     умолчанию ('/bin/sh' в системах Unix, 'COMMAND.COM' в MS-DOS, и так
     далее).

   В средах разработки часто бывает необходимо воспользоваться утилитой
'make'.  Для этой цели вам не обязательно пользоваться командой 'shell'
в GDB:

'make MAKE-АРГ'
     Выполнить программу 'make' с указанными аргументами.  Это
     эквивалентно 'shell make MAKE-АРГ'.


File: gdb.html,  Node: Команды,  Next: Выполнение,  Prev: Вызов,  Up: Top

3 Команды GDB
*************

Вы можете сокращать команды GDB по нескольким первым знакам имени
команды, если это сокращение однозначно; и вы можете повторять
определенные команды GDB простым нажатием <RET>.  Вы также можете
использовать клавишу <TAB> для того, чтобы GDB сам дополнил остаток
слова в команде (или показал вам возможные альтернативы, если существует
несколько вариантов).

* Menu:

* Синтаксис команд::            Как давать команды GDB
* Завершение::                  Завершение команд
* Справка::                     Как запросить помощь у GDB


File: gdb.html,  Node: Синтаксис команд,  Next: Завершение,  Up: Команды

3.1 Синтаксис команд
====================

Команда GDB представляет собой одну строку ввода.  Никаких ограничений
на ее длину нет.  Она начинается именем команды, за которым следуют
параметры, значение которых определяется ее названием.  Например,
команда 'step' допускает в качестве параметра число шагов, как в 'step
5'.  Вы также можете использовать команду 'step' и без параметров.
Некоторые команды не допускают никаких параметров.

   Названия команд GDB всегда могут быть сокращены, если это сокращение
однозначно.  Другие возможные сокращения команд перечислены в
документации по отдельным командам.  В некоторых случаях допускаются
даже неоднозначные сокращения; например, 's' специально определено как
эквивалент 'step', хотя существуют другие команды, чьи названия
начинаются на 's'.  Вы можете проверить сокращения, задавая их как
параметр для команды 'help'.

   Введенная пустая строка (просто нажатие <RET>), означает повтор
предыдущей команды.  Определенные команды (например, 'run') не
повторяются таким способом; это те команды, непреднамеренное повторение
которых может вызвать проблемы, и которые вы вряд ли захотите повторять.

   Команды 'list' и 'x', при их повторе нажатием <RET>, вместо точного
повтора создают новые параметры.  Это позволяет легко просматривать
исходный текст или память.

   GDB может также использовать <RET> по-другому: для разделения
длинного вывода, аналогично обычной утилите 'more' (*note Размер экрана:
Размер экрана.).  Так как в такой ситуации легко нажать <RET> слишком
много раз, GDB блокирует повтор после любой команды, генерирующей такой
тип вывода.

   Любой текст, расположенный от знака '#' до конца строки является
комментарием; он ничего не делает.  В основном, это полезно в командных
файлах (*note Командные файлы: Командные файлы.).


File: gdb.html,  Node: Завершение,  Next: Справка,  Prev: Синтаксис команд,  Up: Команды

3.2 Завершение команд
=====================

GDB может дополнить за вас окончание слова в команде, если существует
только один вариант; он также может в любой момент показать, какие
завершения возможны для следующего слова в команде.  Это работает для
команд и подкоманд GDB, а также для имен символов в вашей программе.

   Нажмите <TAB> в любой момент, когда захотите, чтобы GDB дополнил
оставшуюся часть слова.  Если существует только одна возможность, GDB
дополняет слово и ждет, пока вы закончите команду (или нажмете <RET>,
чтобы ввести ее).  Например, если вы введете

     (gdb) info bre <TAB>

GDB дополнит остаток слова 'breakpoints', так как у команды 'info' есть
единственная подкоманда, начинающаяся с 'bre':

     (gdb) info breakpoints

Теперь вы можете нажать либо <RET>, чтобы выполнить команду 'info
breakpoints', либо удалить часть знаков и ввести что-то другое, если
'breakpoints' не является той командой, которую вы ожидали.  (Если вы с
самого начала были уверены, что хотите 'info breakpoints', вы также
могли просто нажать <RET> сразу после 'info bre', использовав сокращение
команды вместо завершения).

   Если при нажатии <TAB> существует несколько вариантов для следующего
слова, GDB издает звук.  Вы можете либо ввести больше знаков и
попробовать снова, либо нажать <TAB> второй раз; GDB выведет все
возможные завершения для этого слова.  Например, вы можете захотеть
установить точку останова на подпрограмме, чье имя начинается с 'make_',
но когда вы вводите 'b make_<TAB>', GDB лишь издает звук.  Повторное
нажатие <TAB> отображает все имена функций в вашей программе,
начинающиеся с этих знаков.  Например:

     (gdb) b make_ <TAB>
GDB издает звук; нажав <TAB> еще раз, видим:
     make_a_section_from_file     make_environ
     make_abs_section             make_function_type
     make_blockvector             make_pointer_type
     make_cleanup                 make_reference_type
     make_command                 make_symbol_completion_list
     (gdb) b make_

После отображения возможных вариантов, GDB копирует ваш частичный ввод
('b make_' в этом примере), так что вы можете закончить команду.

   Если вы сначала хотите только увидеть список альтернатив, вы можете
нажать 'M-?', а не нажимать <TAB> дважды.  'M-?' означает '<META> ?'.
Вы можете ввести это, либо нажав '?', удерживая клавишу, обозначенную на
вашей клавиатуре как <META> (если такая есть), либо как <ESC>, за
которой следует '?'.

   Иногда нужная вам строка, являясь логически "словом", может содержать
скобки или другие знаки, которые GDB обычно исключает из своего понятия
о слове.  Чтобы позволить завершению слов работать в такой ситуации, вы
можете заключить слова в командах GDB в ''' (знаки одинарных кавычек).

   Наиболее вероятная ситуация, где вам это может потребоваться, -- это
при вводе имени функции в Си++.  Это происходит потому, что Си++
допускает перегрузку функций (множественные определения одной и той же
функции, различающиеся типом параметров).  Например, когда вы хотите
установить точку останова, вам может потребоваться различать, имеете вы
в виду версию 'name' с параметром целого типа, 'name(int)', или же
версию с параметром вещественного типа, 'name(float)'.  Для
использования возможностей завершения слов в такой ситуации, введите
одинарную кавычку ''' в начале имени функции.  Это предупреждает GDB,
что ему может потребоваться принять во внимание больше информации, чем
обычно, когда вы нажимаете <TAB> или 'M-?' для запроса завершения слова:

     (gdb) b 'bubble( M-?
     bubble(double,double)    bubble(int,int)
     (gdb) b 'bubble(

   В некоторых случаях GDB может сам определить, что завершение имени
требует использования кавычек.  Когда это происходит, GDB вставляет
кавычку за вас (выполняя завершение настолько, на сколько это возможно),
если вы не ввели ее в первой позиции:

     (gdb) b bub <TAB>
GDB изменяет вашу строку ввода на следующую, и издает звук:
     (gdb) b 'bubble(

Вообще, GDB может определить, что кавычка нужна (и вставляет ее), если
вы запрашиваете завершение перегруженного символа до того, как начали
вводить список параметров.

   Для получения большей информации о перегруженных функциях, смотрите
*note Выражения Си++: Выражения Си++.  Вы можете использовать команду
'set overload-resolution off' для отключения распознавания перегруженных
символов; смотрите *note Возможности GDB для Си++: Отладка Си++.


File: gdb.html,  Node: Справка,  Prev: Завершение,  Up: Команды

3.3 Получение справки
=====================

Используя команду 'help', вы всегда можете запросить информацию о
командах у самого GDB.

'help'
'h'
     Вы можете использовать 'help' (сокращенно 'h') без параметров для
     отображения короткого списка именованных классов команд:

          (gdb) help
          List of classes of commands:

          aliases -- Aliases of other commands
          breakpoints -- Making program stop at certain points
          data -- Examining data
          files -- Specifying and examining files
          internals -- Maintenance commands
          obscure -- Obscure features
          running -- Running the program
          stack -- Examining the stack
          status -- Status inquiries
          support -- Support facilities
          tracepoints -- Tracing of program execution without
                         stopping the program
          user-defined -- User-defined commands

          Type "help" followed by a class name for a list of
          commands in that class.
          Type "help" followed by command name for full
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

'help КЛАСС'
     Используя один из общих классов справки как параметр, вы можете
     получить список отдельных команд этого класса.  Вот, например,
     отображение справки для класса 'status':

          (gdb) help status
          Status inquiries.

          List of commands:

          info -- Generic command for showing things
           about the program being debugged
          show -- Generic command for showing things
           about the debugger

          Type "help" followed by command name for full
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

'help КОМАНДА'
     Если указать имя команды в качестве параметра 'help', GDB выведет
     короткую справку о том, как ей пользоваться.

'apropos АРГ'
     Команда 'apropos АРГ' производит поиск по регулярному выражению,
     заданному в АРГ, во всех командах GDB и их документации.  Она
     выводит все найденные совпадения.  Например:

          apropos reload

     выводит:

          set symbol-reloading -- Set dynamic symbol table reloading
                                           multiple times in one run
          show symbol-reloading -- Show dynamic symbol table reloading
                                           multiple times in one run

'complete АРГ'
     Команда 'complete АРГ' перечисляет все возможные завершения для
     начала команды.  Используйте АРГ для задания начала команды,
     которую вы хотите завершить.  Например,

          complete i

     приводит к:

          if
          ignore
          info
          inspect

     Это предназначено для использования GNU Emacs.

   В дополнение к 'help', вы можете использовать команды GDB 'info' и
'show' для получения информации о состоянии вашей программы, или о
состоянии самого GDB. Каждая команда поддерживает много тем запросов;
это руководство описывает каждую тему в соответствующем месте.  Списки в
разделах 'info' и 'show' в Алфавитном указателе указывают на все
подкоманды.  *Note Алфавитный указатель::.

'info'
     Эта команда (сокращенно 'i') предназначена для описания состояния
     вашей программы.  Например, вы можете с помощью 'info args'
     просмотреть аргументы, переданные вашей программе, с помощью 'info
     registers' перечислить используемые в настоящий момент регистры или
     используя 'info breakpoints' вывести установленные вами точки
     останова.  Вы можете получить полный список подкоманд команды
     'info' с помощью 'help info'.

'set'
     Вы можете присвоить переменной среды результат выражения с помощью
     'set'.  Например, вы можете сделать приглашением GDB знак $
     используя 'set prompt $'.

'show'
     В отличие от 'info', команда 'show' предназначена для описания
     состояния самого GDB. Вы можете изменить почти все, что показывает
     'show', используя соответствующую команду 'set'.  Например,
     командой 'set radix' вы можете указать, какую систему счисления
     использовать для вывода, или просто узнать, какая система
     используется в данный момент с помощью команды 'show radix'.

     Для отображения всех устанавливаемых параметров и их текущих
     значений вы можете использовать 'show' без аргументов; также можно
     использовать 'info set'.  Обе команды приводят к одинаковому
     результату.

   Вот три еще подкоманды 'show'; они отличаются от остальных тем, не
имеют соответствующих 'set'-команд:

'show version'
     Показывает, какая версия GDB запущена.  Вам следует включать эту
     информацию в отчеты об ошибках в GDB. Если вы используете несколько
     версий GDB, вам может потребоваться определить, какая из них
     запущена; по мере развития отладчика появляются новые команды, а
     старые могут исчезнуть.  Кроме того, многие распространители
     операционных систем поставляют модифицированные версии GDB, также
     существуют модифицированные версии GDB в GNU/Linux.  Номер версии
     -- это номер, появляющийся при старте.

'show copying'
     Выводит информацию о правах на распространение GDB.

'show warranty'
     Отображает заявление GNU об отсутствии гарантий, или заявление о
     гарантиях, если ваша версия GDB поставляется с гарантиями.


File: gdb.html,  Node: Выполнение,  Next: Остановка,  Prev: Команды,  Up: Top

4 Выполнение программ под управлением GDB
*****************************************

Прежде чем выполнять программу под управлением GDB, при компиляции вы
должны сгенерировать отладочную информацию.

   Вы можете запустить GDB с параметрами или без, в любой среде по
вашему выбору.  Если вы отлаживаете программу на той же машине, на
которой выполняется GDB, вы можете перенаправлять ввод и вывод вашей
программы, отлаживать уже выполняющийся процесс или убить дочерний
процесс.

* Menu:

* Компиляция::                  Компиляция для отладки
* Начало выполнения::           Запуск вашей программы
* Аргументы::                   Аргументы вашей программы
* Среда::                       Среда вашей программы

* Рабочий каталог::             Рабочий каталог вашей программы
* Ввод-вывод::                  Ввод и вывод вашей программы
* Присоединение::               Отладка запущенного ранее процесса
* Уничтожение процесса::        Уничтожение дочернего процесса

* Нити::                        Отладка программ с несколькими нитями
* Процессы::                    Отладка программ с несколькими процессами


File: gdb.html,  Node: Компиляция,  Next: Начало выполнения,  Up: Выполнение

4.1 Компиляция для отладки
==========================

Для эффективной отладки программы, при компиляции вы должны
сгенерировать отладочную информацию.  Эта отладочная информация
сохраняется в объектном файле; она описывает тип данных каждой
переменной или функции и соответствие между номерами строк исходного
текста и адресами в выполняемом коде.

   Чтобы запросить генерацию отладочной информации, укажите ключ '-g'
при вызове компилятора.

   Многие компиляторы Си не могут обрабатывать ключи '-g' и '-O' вместе.
Используя такие компиляторы, вы не можете создавать оптимизированные
выполняемые файлы, содержащие отладочную информацию.

   GCC, GNU компилятор Си, поддерживает '-g' вместе с ключом '-O' или
без него, что делает возможной отладку оптимизированного кода.  Мы
рекомендуем вам _всегда_ использовать '-g' при компиляции программ.  Вы
можете думать, что ваша программа правильная, но нет никакого смысла
испытывать удачу.

   Когда вы отлаживаете программу, откомпилированную с '-g -O', помните,
что оптимизатор перестраивает ваш код; отладчик же показывает то, что
там находится в действительности.  Не удивляйтесь, если порядок
выполнения не будет в точности соответствовать вашему исходному файлу!
Крайний пример: если вы определяете переменную, но нигде ее не
используете, GDB никогда не увидит этой переменной, потому что при
оптимизации компилятор ее исключит.

   Некоторые вещи не работают с '-g -O' так же хорошо, как с одним '-g',
в частности, на машинах с планированием инструкций.  Если сомневаетесь,
перекомпилируйте с одним ключом '-g', и если это устранит проблему,
пожалуйста, сообщите нам об этом как об ошибке (включите тестовый
пример!).

   Ранние версии компилятора GNU Си допускали вариант ключа для
отладочной информации '-gg'.  GDB больше не поддерживает этот формат;
если этот ключ есть у вашего компилятора GNU Си, не используйте его.


File: gdb.html,  Node: Начало выполнения,  Next: Аргументы,  Prev: Компиляция,  Up: Выполнение

4.2 Начало выполнения вашей программы
=====================================

'run'
'r'
     Используйте команду 'run' для запуска вашей программы под
     управлением GDB. Сначала вы должны задать имя программы (кроме как
     на VxWorks) с параметрами GDB (*note Вход и выход из GDB: Вызов.),
     или используя команды 'file' или 'exec-file' (*note Команды для
     задания файлов: Файлы.).

   Если вы запускаете вашу программу в среде выполнения, поддерживающей
процессы, 'run' создает подчиненный процесс, и этот процесс выполняет
вашу программу.  (В средах, не поддерживающих процессы, 'run' выполняет
переход на начало вашей программы.)

   Выполнение программы зависит от определенной информации, которую она
получает от породившего ее процесса.  GDB предоставляет способы задать
эту информацию, что вы должны сделать _до_ запуска программы.  (Вы
можете изменить ее после старта, но такие изменения воздействуют на вашу
программу только при следующем запуске.)  Эта информация может быть
разделена на четыре категории:

_Параметры._
     Задайте параметры, которые нужно передать вашей программе, в
     качестве параметров команды 'run'.  Если на вашей системе доступна
     оболочка, она используется для передачи параметров, так что при их
     описании вы можете использовать обычные соглашения (такие как
     раскрывание шаблонов или подстановка переменных).  В системах Unix,
     вы можете контролировать, какая оболочка используется, с помощью
     переменной среды 'SHELL'.  *Note Аргументы вашей программы:
     Аргументы.

_Среда._
     Обычно ваша программа наследует свою среду от GDB, но вы можете
     использовать команды GDB 'set environment' и 'unset environment',
     чтобы изменить часть настроек среды, влияющих на нее.  *Note
     Рабочая среда вашей программы: Среда.

_Рабочий каталог._
     Ваша программа наследует свой рабочий каталог от GDB. Вы можете
     установить рабочий каталог GDB командой 'cd'.  *Note Рабочий
     каталог вашей программы: Рабочий каталог.

_Стандартный ввод и вывод._
     Обычно ваша программа использует те же устройства для стандартного
     ввода и вывода, что и GDB. Вы можете перенаправить ввод и вывод в
     строке команды 'run' или использовать команду 'tty', чтобы
     установить другое устройство для вашей программы.  *Note Ввод и
     вывод вашей программы: Ввод-вывод.

     _Предупреждение:_ Хотя перенаправление ввода и вывода работает, вы
     не можете использовать каналы для передачи выходных данных
     отлаживаемой программы другой программе; если вы попытаетесь это
     сделать, скорее всего GDB перейдет к отладке не той программы.

   Когда вы подаете команду 'run', ваша программа начинает выполняться
немедленно.  *Note Остановка и продолжение: Остановка, для обсуждения
того, как остановить вашу программу.  Как только программа остановилась,
вы можете вызывать функции вашей программы, используя команды 'print'
или 'call'.  *Note Исследование данных: Данные.

   Если время модификации символьного файла изменилось с того момента,
когда GDB последний раз считывал символы, он уничтожает свою символьную
таблицу и считывает ее заново.  При этом GDB старается сохранить ваши
текущие точки останова.


File: gdb.html,  Node: Аргументы,  Next: Среда,  Prev: Начало выполнения,  Up: Выполнение

4.3 Аргументы вашей программы
=============================

Аргументы к вашей программе могут быть заданы как аргументы к команде
'run'.  Они передаются оболочке, которая раскрывает символы шаблонов и
выполняет перенаправление ввода-вывода, и с того момента попадают в вашу
программу.  Переменная среды 'SHELL' (если она существует) определяет,
какую оболочку использует GDB. Если вы не определите 'SHELL', он
использует оболочку по умолчанию ('/bin/sh' в Unix).

   В не-Unix-системах, программу обычно запускает непосредственно GDB,
который эмулирует перенаправление ввода-вывода через соответствующие
системные вызовы, и символы шаблонов раскрываются кодом запуска, а не
оболочкой.

   'run' без аргументов использует те же аргументы, которые
использовались предыдущей командой 'run', или которые установлены
командой 'set args'.

'set args'
     Задает аргументы, которые будут использоваться при следующем
     запуске вашей программы.  Если у 'set args' нет аргументов, 'run'
     выполняет вашу программу без аргументов.  Если вы запустили
     программу с аргументами, то единственный способ запустить ее снова
     без аргументов -- это использовать 'set args' до следующего запуска
     командой 'run'.

'show args'
     Показать аргументы, которые будут переданы вашей программе при ее
     вызове.


File: gdb.html,  Node: Среда,  Next: Рабочий каталог,  Prev: Аргументы,  Up: Выполнение

4.4 Рабочая среда вашей программы
=================================

"Среда" состоит из набора переменных среды и их значений.  Переменные
среды обычно хранят такие данные, как ваше имя пользователя, домашний
каталог, тип терминала и путь поиска для запуска программ.  Как правило,
вы устанавливаете переменные среды с помощью оболочки, и они наследуются
всеми другими программами, которые вы вызываете.  При отладке может
оказаться полезным попробовать запустить программу в измененной среде,
не перезапуская GDB.

'path КАТАЛОГ'
     Добавить КАТАЛОГ в начало переменной среды 'PATH' (пути поиска
     выполняемых файлов), как для GDB, так и для вашей программы.  Вы
     можете указать названия нескольких каталогов, разделив их пробелом
     или системно-зависимым разделителем (':' в Unix, ';' в MS-DOS и
     MS-Windows).  Если КАТАЛОГ уже находится в списке путей, он
     переносится в начало, так что поиск в нем будет производиться
     раньше.

     Вы можете использовать строку 'cwd', чтобы сослаться на рабочий
     каталог, который является текущим в тот момент, когда GDB
     производит поиск.  Если вместо этого вы используете '.', то она
     будет указывать на тот каталог, в котором вы выполнили команду
     'path'.  GDB заменяет '.' в аргументе КАТАЛОГ (на текущий путь) до
     добавления КАТАЛОГА к списку путей поиска.

'show paths'
     Отобразить список путей для поиска выполняемых файлов (переменную
     среды 'PATH').

'show environment [ИМЯ-ПЕРЕМ]'
     Вывести значение переменной среды ИМЯ-ПЕРЕМ, которое будет передано
     вашей программе при ее старте.  Если вы не указываете ИМЯ-ПЕРЕМ,
     вывести названия и значения всех переменных среды, передаваемых
     вашей программе.  Вы можете сократить 'environment' как 'env'.

'set environment ИМЯ-ПЕРЕМ [=ЗНАЧЕНИЕ]'
     Присваивает ЗНАЧЕНИЕ переменной среды ИМЯ-ПЕРЕМ.  Значение меняется
     только для вашей программы, но не для самого GDB. ЗНАЧЕНИЕ может
     быть любой строкой; значениями переменных среды являются просто
     строки, а их интерпретацию обеспечивает ваша программа.  Параметр
     ЗНАЧЕНИЕ является необязательным; если он опущен, переменная
     устанавливается в пустое значение.

     Например, эта команда:

          set env USER = foo

     говорит отлаживаемой программе, что при последующих запусках именем
     пользователя является 'foo'.  (Пробелы, окружающие '=',
     использованы здесь для ясности; в действительности, они не
     обязательны.)

'unset environment ИМЯ-ПЕРЕМ'
     Удалить переменную ИМЯ-ПЕРЕМ из среды, передаваемой вашей
     программе.  Это отличается от 'set env ИМЯ-ПЕРЕМ ='; 'unset
     environment' удаляет переменную из среды, а не присваивает ей
     пустое значение.

   _Предупреждение:_ В системах Unix, GDB вызывает вашу программу,
используя оболочку, указанную вашей переменной среды 'SHELL', если она
определена (или '/bin/sh', если не определена).  Если переменная 'SHELL'
указывает на оболочку, которая выполняет файл инициализации -- такой как
'.cshrc' для оболочки C-shell, или '.bashrc' для BASH -- любая
переменная, которую вы установите в этом файле, воздействует на вашу
программу.  В этой связи, вы можете захотеть перенести установку
переменных среды в файлы, которые выполняются только при входе в
систему, такие как '.login' или '.profile'.


File: gdb.html,  Node: Рабочий каталог,  Next: Ввод-вывод,  Prev: Среда,  Up: Выполнение

4.5 Рабочий каталог вашей программы
===================================

Каждый раз, когда вы запускаете свою программу командой 'run', она
наследует рабочий каталог от текущего рабочего каталога GDB. В начальный
момент, рабочий каталог GDB наследуется от его родительского процесса
(обычно оболочки), но вы можете задать новый рабочий каталог командой
'cd' из GDB.

   Рабочий каталог GDB также служит каталогом по умолчанию для команд
отладчика, определяющих действия с файлами.  *Note Команды для задания
файлов: Файлы.

'cd КАТАЛОГ'
     Установить рабочий каталог GDB в КАТАЛОГ.

'pwd'
     Вывести рабочий каталог GDB.


File: gdb.html,  Node: Ввод-вывод,  Next: Присоединение,  Prev: Рабочий каталог,  Up: Выполнение

4.6 Ввод и вывод вашей программы
================================

По умолчанию, программа, которую вы запускаете под управлением GDB,
осуществляет ввод и вывод на тот же терминал, что и GDB. Для
взаимодействия с вами, GDB переключает терминал в свой собственный
терминальный режим, но он записывает терминальные режимы, которые
использовала ваша программа, и переключается назад к ним, когда вы
продолжаете выполнение программы.

'info terminal'
     Отображает информацию, записанную GDB о терминальных режимах,
     которые использует ваша программа.

   Вы можете перенаправить ввод и/или вывод вашей программы, используя
перенаправление оболочки с помощью команды 'run'.  Например,

     run > выходной-файл

запускает вашу программу, перенаправляя ее вывод в 'выходной-файл'.

   Другой способ задать, как ваша программа должна осуществлять ввод и
вывод, -- использовать команду 'tty'.  Эта команда принимает в качестве
аргумента имя файла, который будет использоваться по умолчанию для
будущих команд 'run'.  Она также сбрасывает управляющий терминал для
дочернего процесса для будущих команд 'run'.  Например,

     tty /dev/ttyb

указывает, что процессы, запущенные последующими командами 'run', для
ввода и вывода используют по умолчанию терминал '/dev/ttyb', и что он
будет их управляющим терминалом.

   Явное перенаправление в 'run' замещает эффект команды 'tty' для
устройств ввода-вывода, но не ее воздействие на управляющий терминал.

   Когда вы используете команду 'tty' или перенаправляете ввод в команде
'run', изменяется только ввод _для вашей программы_.  Ввод для GDB по
прежнему происходит через ваш терминал.


File: gdb.html,  Node: Присоединение,  Next: Уничтожение процесса,  Prev: Ввод-вывод,  Up: Выполнение

4.7 Отладка запущенного ранее процесса
======================================

'attach ИДЕНТ-ПРОЦЕССА'
     Эта команда присоединяется к выполняющемуся процессу -- процессу,
     который был запущен вне GDB. (Команда 'info files' показывает ваши
     активные цели.)  В качестве аргумента эта команда получает
     идентификатор процесса.  Обычный способ узнать идентификатор
     Unix-процесса -- воспользоваться утилитой 'ps' или командой
     оболочки 'jobs -l'.

     'attach' не повторяется, если вы нажмете <RET> второй раз после
     выполнения команды.

   Чтобы использовать 'attach', ваша программа должна выполняться в
среде, поддерживающей процессы; например, 'attach' не работает на
специальных машинах, не имеющих операционной системы.  Вы также должны
обладать полномочиями для посылки сигнала процессу.

   Когда вы используете 'attach', отладчик находит программу
выполняющегося процесса, производя поиск сперва в текущем рабочем
каталоге, а затем (если программа не найдена), используя пути поиска
исходных файлов (*note Определение каталогов с исходными файлами: Пути
для исходных файлов.).  Также, для загрузки программы вы можете
использовать команду 'file'.  *Note Команды для задания файлов: Файлы.

   Первое, что GDB делает после подготовки указанного процесса к отладке
-- останавливает его.  Вы можете исследовать и изменять присоединенный
процесс всеми командами GDB, которые обычно доступны, когда вы
запускаете процессы с помощью 'run'.  Вы можете устанавливать точки
останова; вы можете пошагово выполнять программу и продолжить ее обычное
выполнение, вы можете изменять области данных.  Если вы решите
продолжить выполнение процесса после присоединения к нему GDB, вы можете
использовать команду 'continue'.

'detach'
     Когда вы закончили отлаживать присоединенный процесс, для его
     освобождения из-под управления GDB вы можете использовать команду
     'detach'.  Отсоединение процесса продолжает его выполнение.  После
     команды 'detach', этот процесс и GDB снова становятся совершенно
     независимыми, и вы готовы присоединить или запустить с помощью
     'run' другой процесс.  'detach' не повторяется, если вы нажмете
     <RET> еще раз.

   Если вы выйдете из GDB или используете команду 'run', пока у вас есть
присоединенный процесс, вы убьете этот процесс.  По умолчанию, GDB
запрашивает подтверждение, если вы пытаетесь сделать одну из этих вещей;
вы можете контролировать, нужно вам это подтверждение или нет, используя
команду 'set confirm' (*note Необязательные предупреждения и сообщения:
Сообщения/предупреждения.).


File: gdb.html,  Node: Уничтожение процесса,  Next: Нити,  Prev: Присоединение,  Up: Выполнение

4.8 Уничтожение дочернего процесса
==================================

'kill'
     Уничтожить дочерний процесс, в котором ваша программа выполняется
     под управлением GDB.

   Эта команда полезна, если вы хотите отладить дамп памяти, а не
выполняющийся процесс.  GDB игнорирует любые дампы памяти, пока ваша
программа выполняется.

   В некоторых операционных системах программа не может быть выполнена
вне GDB, пока в ней есть точки останова, установленные отладчиком.  В
этой ситуации вы можете использовать команду 'kill', чтобы разрешить
выполнение вашей программы вне отладчика.

   Команда 'kill' также полезна, если вы хотите перекомпилировать и
перекомпоновать вашу программу, так как во многих системах невозможно
модифицировать исполняемый файл во время выполнения процесса.  В этом
случае, когда вы в следующий раз введете 'run', GDB заметит, что файл
изменился, и заново прочитает символьную таблицу (стараясь при этом
сохранить ваши точки останова).


File: gdb.html,  Node: Нити,  Next: Процессы,  Prev: Уничтожение процесса,  Up: Выполнение

4.9 Отладка программ с несколькими нитями
=========================================

В некоторых операционных системах, таких как HP-UX и Solaris, одна
программа может иметь несколько "нитей" выполнения.  Точная семантика
нитей меняется от одной операционной системы к другой, но в общем, нити
одной программы сродни нескольким процессам -- за исключением того, что
они разделяют одно адресное пространство (то есть, все они могут
исследовать и модифицировать одни и те же переменные).  С другой
стороны, каждая нить имеет свои собственные регистры и стек выполнения,
и, возможно, свои собственные участки памяти.

   GDB предоставляет следующие возможности для отладки многонитевых
программ:

   * автоматическое уведомление о новых нитях
   * 'thread НОМЕР-НИТИ', команда для переключения между нитями
   * 'info threads', команда для запроса информации о существующих нитях
   * 'thread apply [НОМЕР-НИТИ] [ALL] АРГ', команда для применения
     некоторой команды к списку нитей
   * точки останова, определяемые отдельно для каждой нити

     _Предупреждение:_ Пока эти возможности доступны не в любой
     конфигурации GDB, где операционная система поддерживает нити.  Если
     ваш GDB не поддерживает нити, эти команды не имеют эффекта.
     Например, в системах без поддержки нитей GDB ничего не выводит на
     команду 'info threads' и всегда отвергает команду 'thread', как в
     этом примере:

          (gdb) info threads
          (gdb) thread 1
          Thread ID 1 not known.  Use the "info threads" command to
          see the IDs of currently known threads.(1)

   Возможности GDB для отладки нитей позволяют вам наблюдать все нити во
время выполнения вашей программы, но когда управление переходит к GDB,
одна конкретная нить выделяется для отладки.  Она называется "текущей
нитью".  Отладочные команды показывают информацию о программе с точки
зрения текущей нити.

   Когда GDB обнаруживает новую нить в вашей программе, он выводит для
нее идентификатор на целевой системе с сообщением в форме '[New
СИСТ-ТЕГ]'.  СИСТ-ТЕГ является идентификатором нити, чья форма
различается в зависимости от конкретной системы.  Например, в LynxOS вы
можете увидеть

     [New process 35 thread 27]

когда GDB замечает новую нить.  Напротив, в системе SGI, СИСТ-ТЕГ
выглядит просто как 'process 368', без дополнительных спецификаций.

   Для отладочных целей, GDB присваивает свои собственные номера нитей
-- всегда в виде одного целого числа -- каждой нити в вашей программе.

'info threads'
     Вывести краткую информацию обо всех имеющихся в данный момент в
     вашей программе нитях.  Для каждой нити, GDB отображает (в этом
     порядке):

       1. номер нити, назначенный GDB

       2. идентификатор нити на целевой системе (СИСТ-ТЕГ)

       3. краткие сведения о текущем кадре стека для этой нити

     Звездочка '*' слева от номера нити GDB обозначает текущую нить.

     Например,

     (gdb) info threads
       3 process 35 thread 27  0x34e5 in sigpause ()
       2 process 35 thread 23  0x34e5 in sigpause ()
     * 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
         at threadtest.c:68

   В системах HP-UX:

   Для отладочных целей, GDB присваивает свои собственные номера нитей
-- небольшие целые, присваиваемые в порядке создания нитей -- каждой
нити в вашей программе.

   Когда GDB обнаруживает новую нить в вашей программе, он выводит как
номер нити, присвоенный GDB, так и идентификатор на целевой системе для
нити с сообщением в форме '[New СИСТ-ТЕГ]'.  СИСТ-ТЕГ является
идентификатором нити, чья форма различается в зависимости от конкретной
системы.  Например, в HP-UX, когда GDB замечает новую нить, вы увидите

     [New thread 2 (system thread 26594)]

'info threads'
     Вывести краткую информацию обо всех имеющихся в данный момент в
     вашей программе нитях.  Для каждой нити, GDB отображает (в этом
     порядке):

       1. номер нити, назначенный GDB

       2. идентификатор нити на целевой системе (СИСТ-ТЕГ)

       3. краткие сведения о текущем кадре стека для этой нити

     Звездочка '*' слева от номера нити GDB означает текущую нить.

     Например,

     (gdb) info threads
         * 3 system thread 26607  worker (wptr=0x7b09c318 "@") \

                                    at quicksort.c:137
           2 system thread 26606  0x7b0030d8 in __ksleep () \

                                    from /usr/lib/libc.2
           1 system thread 27905  0x7b003498 in _brk () \

                                    from /usr/lib/libc.2

'thread НОМЕР-НИТИ'
     Сделать нить с номером НОМЕР-НИТИ текущей.  Аргумент команды,
     НОМЕР-НИТИ, является внутренним номером нити GDB, который показан в
     первом поле 'info threads'.  GDB отвечает, выводя системный
     идентификатор выбранной вами нити и обзор ее кадра стека:

          (gdb) thread 2
          [Switching to process 35 thread 23]
          0x34e5 in sigpause ()

     Также как и с сообщением '[New ...]', форма текста после 'Switching
     to' зависит от соглашений для идентификации нитей в вашей системе.

'threads apply [НОМЕР-НИТИ] [ALL] АРГ'
     Команда 'thread apply' позволяет вам применить команду к одной или
     нескольким нитям.  Задайте номера нитей, на которые вы хотите
     воздействовать, в аргументе НОМЕР-НИТИ.  НОМЕР-НИТИ -- это
     внутренний номер нити GDB, который показан в первом поле 'info
     threads'.  Чтобы применить команду ко всем нитям, используйте
     'thread apply all' АРГ.

   Когда GDB останавливает вашу программу, вследствие точки останова или
по сигналу, он автоматически выбирает нить, в которой появилась эта
точка останова или сигнал.  GDB предупреждает вас о переключении
контекста сообщением в форме '[Switching to СИСТ-ТЕГ]' для идентификации
нити.

   *Note Остановка и запуск многонитевых программ: Остановка нитей, для
дополнительной информации о поведении GDB, когда вы останавливаете и
запускаете многонитевую программу.

   *Note Установка точек наблюдения: Установка точек наблюдения, для
информации о точках наблюдения в многонитевых программах.

   ---------- Footnotes ----------

   (1) Нить с идентификатором 1 неизвестна.  Используйте команду "info
threads", чтобы получить идентификаторы известных нитей.  (Прим.
переводчика)


File: gdb.html,  Node: Процессы,  Prev: Нити,  Up: Выполнение

4.10 Отладка многонитевых программ
==================================

В большинстве систем GDB не имеет специальной поддержки для отладки
программ, создающих дополнительные процессы с помощью функции 'fork'.
Когда программа вызывает 'fork', GDB будет продолжать отладку
родительского процесса, а дочерний процесс будет выполняться
беспрепятственно.  Если выполнение дочернего процесса дойдет до места,
где вы установили точку останова, дочерний процесс получит сигнал
'SIGTRAP', который приведет к остановке процесса (если он не
перехватывает этот сигнал).

   Однако, если вы хотите отладить дочерний процесс, существует
достаточно простое решение.  Поместите вызов 'sleep' в код программы,
который дочерний процесс выполнит после 'fork'.  Может быть удобным
вызывать 'sleep', только если установлена определенная переменная среды,
или если существует определенный файл, так что задержка не будет
происходить, если вы не захотите отлаживать дочерний процесс.  Пока
дочерний процесс спит, используйте программу 'ps' для получения его
идентификатора.  Затем укажите GDB (новому экземпляру GDB, если вы
отлаживаете также и родительский процесс) присоединиться к дочернему
процессу (*note Присоединение::).  Начиная с этого момента, вы можете
отлаживать дочерний процесс точно так же, как любой другой процесс, к
которому вы присоединились.

   В системе HP-UX (только в версиях 11.x и более поздних?)  GDB
предоставляет средства для отладки программ, которые создают
дополнительные процессы, используя функции 'fork' или 'vfork'.

   По умолчанию, когда программа ветвится, GDB будет продолжать отладку
родительского процесса, а дочерний процесс будет выполняться
беспрепятственно.

   Если вы хотите отлаживать дочерний процесс вместо родительского,
используйте команду 'set follow-fork-mode'.

'set follow-fork-mode РЕЖИМ'
     Устанавливает реакцию отладчика на вызов 'fork' или 'vfork' в
     программе.  Вызов 'fork' или 'vfork' создает новый процесс.  РЕЖИМ
     может быть:

     'parent'
          После ветвления отлаживается исходный процесс.  Дочерний
          процесс выполняется беспрепятственно.  Это поведение по
          умолчанию.

     'child'
          После ветвления отлаживается новый процесс.  Родительский
          процесс выполняется беспрепятственно.

     'ask'
          Отладчик будет запрашивать один из этих вариантов.

'show follow-fork-mode'
     Отображает текущую реакцию отладчика на вызов 'fork' или 'vfork'.

   Если вы запрашиваете отладку дочернего процесса, и за 'vfork' следует
'exec', GDB выполняет новую программу до первой установленной в ней
точки останова.  Если в вашей исходной программе была установлена точка
останова на функции 'main', она будет также установлена на 'main' в
дочернем процессе.

   Когда дочерний процесс порождается вызовом 'vfork', вы не можете
отлаживать дочерний или родительский процесс до тех пор, пока не
завершится вызов 'exec'.

   Если вы даете GDB команду 'run' после выполнения 'exec', новая
программа стартует заново.  Чтобы перезапустить родительский процесс,
используйте команду 'file' с именем выполняемого файла родительской
программы в качестве аргумента.

   Вы можете использовать команду 'catch', чтобы остановить GDB, когда
сделан вызов 'fork', 'vfork' или 'exec'.  *Note Установка точек
перехвата: Установка точек перехвата.


File: gdb.html,  Node: Остановка,  Next: Стек,  Prev: Выполнение,  Up: Top

5 Остановка и продолжение исполнения
************************************

Основные цели применения отладчика -- позволить вам остановить программу
до ее завершения или, в случае нарушений в работе программы, исследовать
программу и выяснить причину неполадок.

   Внутри GDB ваша программа может остановиться по нескольким причинам,
таким как сигнал, точка останова или достижение новой строки после
команды GDB, такой как 'step'.  Затем вы можете исследовать и изменять
значения переменных, устанавливать новые точки останова и удалять старые
и затем продолжить выполнение.  Обычно выводимые GDB сообщения
предоставляют достаточную информацию о состоянии вашей программы, но вы
также можете запросить эту информацию явно в любое время.

'info program'
     Отобразить информацию о состоянии вашей программы: выполняется она
     или нет, каким процессом она является, и почему остановлена.

* Menu:

* Точки останова::              Точки останова, наблюдения и перехвата
* Продолжение и пошаговое выполнение::
                                Возобновление выполнения
* Сигналы::                     Сигналы
* Остановка нитей::             Остановка и запуск многонитевых программ


File: gdb.html,  Node: Точки останова,  Next: Продолжение и пошаговое выполнение,  Up: Остановка

5.1 Точки останова, точки наблюдения и точки перехвата
======================================================

"Точка останова" останавливает вашу программу всякий раз, когда ее
выполнение достигает определенного места.  Для каждой точки останова вы
можете добавлять условия для лучшего управления условиями остановки.  Вы
можете устанавливать точки останова командой 'break' и ее вариантами
(*note Установка точек останова: Установка точек останова.), чтобы
задать место, где должна остановиться ваша программа, по номеру строки,
имени функции или точному адресу.

   В конфигурациях HP-UX, SunOS 4.x, SVR4 и Alpha OSF/1, вы можете
устанавливать точки останова в разделяемых библиотеках до запуска
выполняемого файла.  В системах HP-UX существует небольшое ограничение:
вы должны подождать, пока программа не перестанет выполняться, для
установки точек останова в подпрограммах из разделяемой библиотеки,
которые не вызываются напрямую из программы (например, подпрограммах,
являющихся аргументами вызова 'pthread_create').

   "Точка наблюдения" -- это специальная точка останова, которая
останавливает вашу программу при изменении значения выражения.  Вы
должны использовать другую команду для установки точки наблюдения (*note
Установка точек наблюдения: Установка точек наблюдения.), но помимо
этого, вы можете обращаться с ней так же, как с любой другой точкой
останова: вы включаете, отключаете и удаляете точки останова и точки
наблюдения при помощи одних и тех же команд.

   Вы можете сделать так, чтобы при каждой остановке в точке останова
автоматически отображались некоторые значения из вашей программы.  *Note
Автоматическое отображение: Автоматическое отображение.

   "Точка перехвата" -- это другая специализированная точка останова,
которая останавливает вашу программу при возникновении события
определенного типа, такого как выбрасывание исключения в Си++ или
загрузка библиотеки.  Так же, как с точками наблюдения, вы используете
другую команду для установки точки перехвата, (*note Установка точек
перехвата: Установка точек перехвата.), но помимо этого, вы можете
обращаться с ней так же, как с любой другой точкой останова.  (Для
остановки, когда ваша программа получает сигнал, используйте команду
'handle'; смотрите *note Сигналы: Сигналы.)

   Когда вы создаете точку останова, наблюдения или перехвата, GDB
присваивает ей номер; эти номера являются последовательными целыми
числами, начинающимися с единицы.  Во многих командах для управления
различными возможностями точек останова вы используете эти номера для
указания точки останова, которую вы хотите изменить.  Каждая точка
останова может быть "включена" или "отключена"; если точка останова
отключена, она не оказывает никакого влияния на вашу программу, пока вы
снова не включите ее.

   Некоторые команды GDB допускают в качестве указания точек останова,
на которые они действуют, их диапазоны.  Диапазон точек останова -- это
или номер одной точки, например '5', или два таких номера, в порядке
увеличения, разделенные дефисом, например '5-7'.  Когда команде задается
диапазон точек останова, она действует на все точки останова в этом
диапазоне.

* Menu:

* Установка точек останова::    Установка точек останова
* Установка точек наблюдения::  Установка точек наблюдения
* Установка точек перехвата::   Установка точек перехвата
* Удаление точек останова::     Удаление точек останова
* Отключение::                  Отключение точек останова
* Условия::                     Условия останова
* Команды останова::            Команды точки останова
* Меню точки останова::         Меню точки останова
* Ошибки в точках останова::    "Не удается поместить точки останова"


File: gdb.html,  Node: Установка точек останова,  Next: Установка точек наблюдения,  Up: Точки останова

5.1.1 Установка точек останова
------------------------------

Точки останова устанавливаются командой 'break' (сокращенно 'b').
Вспомогательная переменная отладчика '$bpnum' хранит номер последней
установленной вами точки останова; смотрите *note Вспомогательные
переменные: Вспомогательные переменные, для обсуждения того, что вы
можете делать со вспомогательными переменными.

   Вы можете задавать место для установки новой точки останова
несколькими способами.

'break ФУНКЦИЯ'
     Установить точку останова на входе в функцию ФУНКЦИЯ.  При
     использовании языков, допускающих перегрузку символов, таких как
     Си++, ФУНКЦИЯ может ссылаться более чем на одно возможное место
     останова.  *Note Меню точки останова: Меню точки останова, для
     обсуждения такой ситуации.

'break +СМЕЩЕНИЕ'
'break -СМЕЩЕНИЕ'
     Установить точку останова через несколько строк впереди или сзади
     от позиции, на которой выполнение остановилось в текущем выбранном
     "кадре стека".  (*Note Кадры стека: Кадры, для описания кадров
     стека.)

'break НОМЕР-СТРОКИ'
     Установить точку останова на строке НОМЕР-СТРОКИ в текущем исходном
     файле.  Текущий исходный файл -- это файл, исходный текст которого
     отображался последним.  Точка останова остановит вашу программу
     сразу перед выполнением какого-либо кода на этой строке.

'break ИМЯ-ФАЙЛА:НОМЕР-СТРОКИ'
     Установить точку останова на строке НОМЕР-СТРОКИ в исходном файле
     ИМЯ-ФАЙЛА.

'break ИМЯ-ФАЙЛА:ФУНКЦИЯ'
     Установить точку останова на входе в ФУНКЦИЮ, находящуюся в файле
     ИМЯ-ФАЙЛА.  Указание имени файла вместе с именем функции является
     излишним, за исключением ситуаций, когда несколько файлов содержат
     одинаково названные функции.

'break *АДРЕС'
     Установить точку останова по адресу АДРЕС.  Вы можете использовать
     это для установки точек останова в тех частях вашей программы,
     которые не имеют отладочной информации или исходных файлов.

'break'
     При вызове без аргументов, 'break' устанавливает точку останова на
     инструкции, которая должна быть выполнена следующей в выбранном
     кадре стека (*note Исследование стека: Стек.).  В любом выбранном
     кадре, кроме самого внутреннего, это останавливает вашу программу,
     как только управление возвращается в этот кадр.  Это похоже на
     результат команды 'finish' в кадре внутри выбранного кадра -- за
     исключением того, что 'finish' не оставляет активной точки
     останова.  Если вы используете 'break' без аргументов в самом
     внутреннем кадре, GDB останавливается, когда в следующий раз
     достигает текущего места; это может быть полезно внутри циклов.

     Обычно GDB игнорирует точки останова, когда он возобновляет
     выполнение, пока не будет выполнена хотя бы одна инструкция.  Если
     бы он этого не делал, вы не могли бы продолжать выполнение после
     точки останова, не отключив сперва ее.  Это правило применяется вне
     зависимости от того, существовала или нет точка останова, когда
     ваша программа остановилась.

'break ... if УСЛ'
     Установить точку останова с условием УСЛ; каждый раз, когда
     достигается эта точка останова, происходит вычисление выражения
     УСЛ, и остановка происходит, только если эта величина не равна нулю
     -- то есть, если УСЛ истинно.  '...' означает один из возможных
     аргументов, перечисленных выше (или отсутствие аргументов),
     описывающих место остановки.  *Note Условия остановки: Условия, для
     большей информации об условных точках останова.

'tbreak АРГ'
     Установить точку останова только до первой активизации.  Аргументы
     АРГ такие же, как для команды 'break', и точка останова
     устанавливается аналогичным образом, но она автоматически
     уничтожается после того, как ваша программа первый раз на ней
     остановится.  *Note Отключение точек останова: Отключение.

'hbreak АРГ'
     Установить аппаратно-поддерживаемую точку останова.  Аргументы АРГ
     такие же, как и для команды 'break', и точка останова
     устанавливается аналогичным образом, но она требует аппаратной
     поддержки, и некоторые целевые платформы могут ее не иметь.
     Основной целью этого является отладка кода EPROM/ROM, так что вы
     можете установить точку останова на инструкции без изменения
     инструкции.  Это может быть использовано с новой генерацией
     ловушек, предоставляемой SPARClite DSU и некоторыми машинами на
     базе x86.  Эти платформы будут генерировать ловушки, когда
     программа обращается к некоторым данным или адресу инструкции,
     которые назначены регистрам отладки.  Однако, регистры аппаратных
     точек останова могут хранить ограниченное число точек останова.
     Например, на DSU, только две точки останова могут быть установлены
     одновременно, и GDB будет отвергать эту команду, если используется
     больше.  Удалите или отключите неиспользуемые аппаратные точки
     останова перед установкой новых (*note Отключение точек останова:
     Отключение.).  *Note Условия останова: Условия.

'thbreak АРГ'
     Установить аппаратно-поддерживаемую точку останова, включенную
     только до первой активизации.  Аргументы АРГ такие же, как и для
     команды 'hbreak', и точка останова устанавливается аналогичным
     образом.  Однако, как в случае команды 'tbreak', точка останова
     автоматически уничтожается после того, как программа первый раз на
     ней остановится.  Также, как и в случае команды 'hbreak', точка
     останова требует аппаратной поддержки и некоторые аппаратные
     платформы могут ее не иметь.  *Note Отключение точек останова:
     Отключение.  Смотрите также *note Условия остановки: Условия.

'rbreak РЕГ-ВЫР'
     Установить точки останова на всех функциях, удовлетворяющих
     регулярному выражению РЕГ-ВЫР.  Эта команда устанавливает
     безусловные точки останова при всех совпадениях, выводя список всех
     установленных точек останова.  После установки, они рассматриваются
     точно так же, как точки останова, установленные командой 'break'.
     Вы можете удалять их, отключать или делать их условными таким же
     способом, как любые другие точки останова.

     Регулярные выражения имеют стандартный синтаксис, используемый
     такими средствами, как 'grep'.  Заметьте, что это отличается от
     синтаксиса, используемого оболочками; так, например, 'foo*'
     подходит для всех функций, которые включают 'fo', за которым
     следует любое число букв 'o'.  Существует неявное '.*' в начале и в
     конце введенного вами регулярного выражения, так что для нахождения
     только тех функций, которые начинаются на 'foo', используйте
     '^foo'.

     При отладке программ, написанных на Си++, 'rbreak' полезна для
     установки точек останова на перегруженных функциях, не являющихся
     членами никакого специального класса.

'info breakpoints [N]'
'info break [N]'
'info watchpoints [N]'
     Вывести таблицу всех установленных и не удаленных точек останова,
     наблюдения и перехвата, со следующими колонками для каждой точки:

     _Номер точки останова_
     _Тип_
          Точка останова, наблюдения или перехвата.
     _План_
          Помечена ли точка останова для отключения или удаления после
          активации.
     _Включена или отключена_
          Включенные точки останова помечаются как 'y'.  'n' отмечает
          отключенные точки.
     _Адрес_
          Адрес памяти, где расположена точка останова в вашей
          программе.
     _Где_
          Файл и номер строки, где расположена точка останова в исходном
          файле.

     Если точка останова условная, 'info break' показывает условие на
     строке, следующей за этой точкой; команды точки останова, если они
     есть, перечисляются после этого.

     'info break' с номером точки останова N в качестве аргумента
     отображает только эту точку.  Вспомогательная переменная '$_' и
     адрес по умолчанию для исследования для команды 'x' устанавливаются
     равными адресу последней из перечисленных точек останова (*note
     Исследование памяти: Память.).

     'info break' отображает то число раз, которое точка останова была
     активирована.  Это особенно полезно при использовании вместе с
     командой 'ignore'.  Вы можете игнорировать большое число активаций
     точки останова, посмотреть информацию о точке останова, чтобы
     узнать, сколько раз она активировалась, и затем запустить заново,
     игнорируя на единицу меньше, чем это число.  Это быстро приведет
     вас к последней активации этой точки останова.

   GDB позволяет вам установить любое число точек останова в одном и том
же месте вашей программы.  В этом нет ничего глупого или бессмысленного.
Когда точки останова являются условными, это даже полезно (*note Условия
останова: Условия.).

   GDB иногда сам устанавливает точки останова в вашей программе для
специальных целей, таких как правильная обработка 'longjmp' (в
программах на Си).  Этим внутренним точкам останова присваиваются
отрицательные номера, начиная с '-1'; 'info breakpoints' не отображает
их.

   Вы можете увидеть эти точки останова с помощью служебной команды GDB
'maint info breakpoints'.

'maint info breakpoints'
     Используя тот же формат, что и 'info breakpoints', отобразить как
     точки останова, установленные вами явно, так и те, которые GDB
     использует для внутренних целей.  Внутренние точки останова
     показываются с отрицательными номерами.  Колонка типа определяет,
     какого типа точка останова показана:

     'breakpoint'
          Обычная, явно установленная точка останова.

     'watchpoint'
          Обычная, явно установленная точка наблюдения.

     'longjmp'
          Внутренняя точка останова, используемая для корректной
          обработки пошагового выполнения вызовов 'longjmp'.

     'longjmp resume'
          Внутренняя точка останова на цели 'longjmp'.

     'until'
          Временная внутренняя точка останова, используемая командой GDB
          'until'.

     'finish'
          Временная внутренняя точка останова, используемая командой GDB
          'finish'.

     'shlib events'
          События в разделяемых библиотеках.


File: gdb.html,  Node: Установка точек наблюдения,  Next: Установка точек перехвата,  Prev: Установка точек останова,  Up: Точки останова

5.1.2 Установка точек наблюдения
--------------------------------

Вы можете использовать точку наблюдения для остановки выполнения, как
только изменится значение какого-либо выражения, не предсказывая
конкретное место, где это может произойти.

   В зависимости от вашей системы, точки наблюдения могут быть
реализованы программно или аппаратно.  GDB осуществляет программную
реализацию точек наблюдения путем пошагового выполнения вашей программы
и проверки значения переменной на каждом шаге, что в сотни раз медленнее
нормального выполнения.  (Но, тем не менее, это того стоит, если нужно
найти ошибку в программе, когда вы не представляете, в какой части она
находится.)

   В некоторых системах, таких как HP-UX, Linux и некоторых других
платформах, базирующихся на x86, GDB включает поддержку для аппаратных
точек наблюдения, которые не замедляют выполнение вашей программы.

'watch ВЫРАЖ'
     Устанавливает точку наблюдения за выражением.  GDB остановит
     программу, когда ВЫРАЖ сохраняется программой, и его значение
     изменяется.

'rwatch ВЫРАЖ'
     Устанавливает точку наблюдения, которая остановит программу, когда
     наблюдаемое ВЫРАЖ считывается программой.

'awatch ВЫРАЖ'
     Устанавливает точку наблюдения, которая остановит программу, когда
     ВЫРАЖ либо считывается, либо сохраняется программой.

'info watchpoints'
     Эта команда печатает список точек наблюдения, останова и перехвата;
     это то же самое, что и 'info break'.

   Когда это возможно, GDB устанавливает "аппаратную точку наблюдения".
Аппаратные точки наблюдения выполняются очень быстро, и отладчик
сообщает об изменении значения точно в месте инструкции, где это
изменение произошло.  Если GDB не может установить аппаратную точку
наблюдения, он устанавливает программную точку наблюдения, которая
выполняется намного медленнее и сообщает об изменении значения на
следующем операторе, а не инструкции, после появления изменения.

   Когда вы даете команду 'watch', GDB сообщает

     Hardware watchpoint НОМЕР: ВЫРАЖ

если ему удалось установить аппаратную точку наблюдения.

   В настоящее время, команды 'awatch' и 'rwatch' могут устанавливать
только аппаратные точки наблюдения, так как доступы к данным, которые не
изменяют величины наблюдаемого выражения, не могут быть замечены без
исследования каждой инструкции во время ее выполнения, а GDB пока этого
не делает.  Если GDB обнаруживает, что не может установить аппаратную
точку останова командами 'awatch' или 'rwatch', он напечатает сообщение,
аналогичное этому:

     Expression cannot be implemented with read/access watchpoint.(1)

   Иногда GDB не может установить аппаратную точку наблюдения из-за
того, что тип данных наблюдаемого выражения занимает больше места, чем
допускает аппаратная точка наблюдения на целевой платформе.  Например,
некоторые системы позволяют наблюдать за областями, занимающими до 4
байт; на таких системах вы не можете устанавливать аппаратные точки
наблюдения за выражениями, которые в результате дают число с плавающей
точкой двойной точности (которое обычно занимает 8 байт).  В качестве
одного из решений, можно разбить большую область на несколько меньших
областей, и затем наблюдать за каждой из них с помощью отдельной точки
наблюдения.

   Если вы установите слишком много аппаратных точек наблюдения, GDB
может быть не в состоянии задействовать их все, когда вы возобновите
выполнение вашей программы.  Так как точное количество активных точек
наблюдения неизвестно до того момента, как ваша программа должна
возобновить выполнение, GDB может быть не в состоянии предупредить вас
об этом, когда вы устанавливаете точку наблюдения, и предупреждение
будет напечатано, только когда программа возобновит выполнение:

     Hardware watchpoint НОМЕР: Could not insert watchpoint(2)

Если это происходит, удалите или отключите некоторые точки наблюдения.

   SPARClite DSU будет генерировать ловушки, когда программа обращается
к некоторым данным или адресу инструкции, которые отведены для
отладочных регистров.  Для адресов данных, DSU упрощает команду 'watch'.
Однако, аппаратные регистры точек останова могут принять только две
точки наблюдения за данными, и обе точки наблюдения должны быть одного
типа.  Например, вы можете установить две точки наблюдения с помощью
команды 'watch', две с помощью команды 'rwatch', *или* две с помощью
команды 'awatch', но вы не можете установить одну точку наблюдения с
помощью одной команды, а другую с помощью другой.  GDB не примет
команду, если вы попытаетесь совместить различные точки наблюдения.
Удалите или отключите неиспользуемые точки наблюдения перед установкой
новых.

   Если вы вызываете функцию интерактивно, используя 'print' или 'call',
все установленные вами точки наблюдения будут неактивными до тех, пор
пока GDB не достигнет точки останова другого типа, или пока вызов не
завершится.

   GDB автоматически удаляет точки наблюдения, которые наблюдают за
локальными переменными или за выражениями, которые используют такие
переменные, когда они выходят из области видимости, то есть когда
выполнение покидает блок, в котором эти переменные были определены.  В
частности, когда отлаживаемая программа завершается, _все_ локальные
переменные выходят из области видимости, и таким образом остаются
установленными только те точки наблюдения, которые наблюдают за
глобальными переменными.  Если вы снова запустите программу, вы должны
будете заново установить все такие точки наблюдения.  Одним из способов
сделать это будет установить точку останова на входе в функцию 'main',
и, когда программа остановится, установить все остальные точки
наблюдения.

     _Предупреждение:_ В многонитевых программах точки наблюдения
     являются лишь частично полезными.  С текущей реализацией точек
     наблюдения, GDB может наблюдать за величиной выражения только _в
     одной нити_.  Если вы уверены, что выражение может измениться
     только вследствие действий внутри текущей нити (и если вы также
     уверены, что никакая другая нить не может стать текущей), то вы
     можете использовать точки наблюдения как обычно.  Однако, GDB может
     не заметить, когда действия в другой нити изменяют выражение.

     _Предупреждение для HP-UX:_ В многонитевых программах программные
     точки наблюдения являются лишь частично полезными.  Если GDB
     создает программную точку наблюдения, она может наблюдать за
     величиной выражения только _в одной нити_.  Если вы уверены, что
     выражение может измениться только вследствие действий внутри
     текущей нити (и если вы также уверены, что никакая другая нить не
     может стать текущей), то вы можете использовать программные точки
     наблюдения как обычно.  Однако, GDB может не заметить, когда
     действия в другой нити изменяют выражение.  (Аппаратные же точки
     наблюдения напротив, наблюдают за выражением во всех нитях.)

   ---------- Footnotes ----------

   (1) Выражение не может быть реализовано с помощью точки наблюдения
чтения/доступа.  (Прим. переводчика)

   (2) Аппаратная точка наблюдения НОМЕР: Не удается поместить точку
наблюдения (Прим. переводчика)


File: gdb.html,  Node: Установка точек перехвата,  Next: Удаление точек останова,  Prev: Установка точек наблюдения,  Up: Точки останова

5.1.3 Установка точек перехвата
-------------------------------

Вы можете использовать "точки перехвата", чтобы вызвать остановку
отладчика в ответ на определенные типы событий в программе, такие как
исключения в Си++ или загрузка разделяемой библиотеки.  Для установки
точки перехвата используйте команду 'catch'.

'catch СОБЫТИЕ'
     Остановиться, когда происходит СОБЫТИЕ.  СОБЫТИЕ может быть одним
     из:
     'throw'
          Выбрасывание исключения Си++.

     'catch'
          Перехват исключения Си++.

     'exec'
          Вызов 'exec'.  В настоящее время это доступно только на HP-UX.

     'fork'
          Вызов 'fork'.  В настоящее время это доступно только на HP-UX.

     'vfork'
          Вызов 'vfork'.  В настоящее время это доступно только на
          HP-UX.

     'load'
     'load ИМЯ-БИБЛ'
          Динамическая загрузка любой разделяемой библиотеки или
          загрузка библиотеки ИМЯ-БИБЛ.  В настоящее время это доступно
          только на HP-UX.

     'unload'
     'unload ИМЯ-БИБЛ'
          Выгрузка любой динамически загруженной разделяемой библиотеки
          или выгрузка библиотеки ИМЯ-БИБЛ.  В настоящее время это
          доступно только на HP-UX.

'tcatch СОБЫТИЕ'
     Установить точку перехвата, которая включена только до первой
     активации.  Точка перехвата автоматически уничтожается после того,
     как событие перехвачено первый раз.

   Используйте команду 'info break' для получения списка текущих точек
перехвата.

   В настоящее время, в GDB существуют некоторые ограничения на
обработку исключений Си++ ('catch throw' и 'catch catch'):

   * Если вы вызываете функцию интерактивно, GDB обычно возвращает вам
     управление после того, как функция закончила выполнение.  Однако,
     если вызов возбуждает исключение, он может обойти механизм,
     возвращающий вам управление, и заставить вашу программу либо
     остановиться, либо просто продолжить выполнение до тех пор, пока
     она не активирует точку останова, получит сигнал, который ждет GDB,
     или выйдет.  Это имеет место, даже если вы установите точку
     перехвата для исключения; точки перехвата для исключений отключены
     при интерактивных вызовах.

   * Вы не можете возбуждать исключения интерактивно.

   * Вы не можете интерактивно установить обработчик исключения.

   Иногда 'catch' не является лучшим способом отладки обработки
исключений: если вам необходимо точно знать, где исключение возбуждено,
то лучше остановиться _до_ того, как вызван обработчик исключения, так
как в этом случае вы можете увидеть стек до того, как произойдет
какое-либо развертывание.  Если вместо этого вы установите точку
останова в обработчике исключений, то может быть нелегко определить, где
исключение было возбуждено.

   Для остановки сразу перед вызовом обработчика исключений, вам
необходимы некоторые знания о реализации.  В случае GNU Си++, исключения
возбуждаются путем вызова библиотечной функции '__raise_exception',
которая имеет следующий интерфейс ANSI Си:

         /* ADDR -- где хранится идентификатор исключения.
            ID -- идентификатор исключения.  */
         void __raise_exception (void **addr, void *id);

Для того, чтобы отладчик перехватывал все исключения до того, как
произойдет развертывание стека, установите точку останова на
'__raise_exception' (*note Точки останова: (точки наблюдения и точки
перехвата)Точки останова.).

   С помощью условных точек останова (*note Условия останова: Условия.),
зависящих от значения ID, вы можете остановить вашу программу, когда
возбуждается определенное исключение.  Вы можете использовать несколько
условных точек останова, чтобы остановить программу, когда возбуждается
любое из нескольких исключений.


File: gdb.html,  Node: Удаление точек останова,  Next: Отключение,  Prev: Установка точек перехвата,  Up: Точки останова

5.1.4 Удаление точек останова
-----------------------------

Часто бывает необходимо уничтожить точку останова, наблюдения или
перехвата, когда она сделала свое дело, и вы больше не хотите
останавливать там свою программу.  Это называется "уничтожением" точки
останова.  Точка останова, которая была уничтожена, более не существует;
она забыта.

   С помощью команды 'clear' вы можете удалять точки останова в
соответствии с тем, где они находятся в вашей программе.  С помощью
команды 'delete' вы можете удалять отдельные точки останова, наблюдения
или перехвата, указывая их номера.

   Не обязательно удалять точку останова, чтобы продолжить выполнение
после нее.  GDB автоматически игнорирует точки останова на первой
инструкции, которая должна быть выполнена, когда вы продолжаете
исполнение без изменения адреса выполнения.

'clear'
     Удаляет любые точки останова, установленные на следующей
     инструкции, которая должна быть выполнена в выбранном кадре стека
     (*note Выбор кадра: Выбор.).  Когда выбран самый внутренний кадр,
     это хороший способ удалить ту точку останова, на которой ваша
     программа только что остановилась.

'clear ФУНКЦИЯ'
'clear ИМЯ-ФАЙЛА:ФУНКЦИЯ'
     Удалить любые точки останова, установленные на входе в ФУНКЦИЮ.

'clear НОМЕР-СТРОКИ'
'clear ИМЯ-ФАЙЛА:НОМЕР-СТРОКИ'
     Удалить все точки останова, установленные на или внутри кода на
     указанной строке.

'delete [breakpoints] [ДИАПАЗОН...]'
     Удалить точки останова, наблюдения или перехвата из диапазона,
     указанного в качестве аргумента.  Если аргумент не задан, удалить
     все точки останова (GDB запрашивает подтверждение, если у вас не
     установлено 'set confirm off').  Вы можете сократить это команду
     как 'd'.


File: gdb.html,  Node: Отключение,  Next: Условия,  Prev: Удаление точек останова,  Up: Точки останова

5.1.5 Отключение точек останова
-------------------------------

Вместо того, чтобы удалять точку останова, наблюдения или перехвата, вам
может быть удобнее "отключить" ее.  Это делает точку останова
бездействующей, как если бы она была удалена, но информация о ней
запоминается, так что вы можете позже "включить" ее снова.

   Вы отключаете и включаете точки останова, наблюдения и перехвата
командами 'enable' и 'disable', возможно, указывая один или более
номеров точек останова в качестве аргументов.  Используйте 'info break'
или 'info watch' для распечатки списка точек останова, наблюдения и
перехвата, если вы не знаете, какие номера использовать.

   Точка останова, наблюдения или перехвата может находиться в одном из
четырех состояний:

   * Включена.  Точка останова останавливает вашу программу.  Точка
     останова, установленная командой 'break', изначально находится в
     таком состоянии.
   * Отключена.  Точка останова не оказывает воздействия на вашу
     программу.
   * Включена до первого срабатывания.  Точка останова останавливает
     вашу программу, но потом становится отключенной.
   * Включена для удаления.  Точка останова останавливает вашу
     программу, но сразу после этого она удаляется навсегда.  Точка
     останова, установленная командой 'tbreak', изначально находится в
     этом состоянии.

   Вы можете использовать следующие команды для включения или отключения
точек останова, наблюдения и перехвата:

'disable [breakpoints] [ДИАПАЗОН...]'
     Отключить указанные точки останова или все точки останова, если ни
     одна не перечислена.  Отключенная точка останова не оказывает
     никакого действия, но она не забывается.  Все параметры, такие как
     счетчик игнорирований, условия и команды запоминаются на случай,
     если точка останова позже будет снова включена.  Вы можете
     сокращать 'disable' как 'dis'.

'enable [breakpoints] [ДИАПАЗОН...]'
     Включает указанные (или все определенные) точки останова.  Они
     снова становятся значимыми для остановки вашей программы.

'enable [breakpoints] once ДИАПАЗОН...'
     Временно включить указанные точки останова.  GDB отключает любую из
     этих точек останова немедленно после срабатывания.

'enable [breakpoints] delete ДИАПАЗОН...'
     Включить указанные точки останова до первого срабатывания, затем
     уничтожить.  GDB удаляет любую из этих точек останова, как только
     ваша программа останавливается на ней.

   Кроме точек останова, установленных командой 'tbreak' (*note
Установка точек останова: Установка точек останова.), установленные вами
точки останова изначально включены; следовательно, они становятся
отключенными или включенными, только когда вы используете одну из
вышеперечисленных команд.  (Команда 'until' может устанавливать и
удалять свою собственную точку останова, но она не изменяет состояние
других точек останова; см.  *note Продолжение и выполнение по шагам:
Продолжение и пошаговое выполнение.)


File: gdb.html,  Node: Условия,  Next: Команды останова,  Prev: Отключение,  Up: Точки останова

5.1.6 Условия останова
----------------------

Простейшая точка останова останавливает вашу программу каждый раз, когда
управление достигает заданного места.  Вы можете также указать "условие"
для точки останова.  Условие является просто булевым выражением в вашем
языке программирования (*note Выражения: Выражения.).  Точка останова с
условием вычисляет выражение каждый раз, когда ваша программа достигает
ее, и ваша программа остановится только в том случае, если условие
_истинно_.

   Это противоположно использованию утверждений для проверки
правильности программы; в этом случае, вы хотите остановиться, когда
утверждение нарушается -- то есть, когда условие ложно.  В Си, если вы
хотите проверить утверждение, выраженное условием ASSERT, вы должны
установить условие '! ASSERT' на соответствующей точке останова.

   Условия также допускаются для точек наблюдения; вам они могут не
понадобиться, так как точка наблюдения так или иначе контролирует
значение выражения -- но может оказаться проще, скажем, просто
установить точку наблюдения на имя переменной и указать условие,
проверяющее, является ли новое значение тем, которое нас интересует.

   Условия останова могут иметь побочные эффекты и даже могут вызывать
функции в вашей программе.  Это может быть полезным, например, для
активации функций, которые запоминают продвижение выполнения вашей
программы, или для использования ваших собственных функций печати для
форматирования специальных структур данных.  Результаты полностью
предсказуемы, если нет другой включенной точки останова по тому же
адресу.  (В этом случае, GDB может сначала увидеть другую точку останова
и остановить вашу программу программу без проверки условия первой точки
останова.)  Заметьте, что для выполнения побочных эффектов при
достижении точки останова обычно более удобны и гибки команды точек
останова, а не условия останова (*note Команды точки останова: Команды
останова.).

   Условия останова можно задать в момент установки точки останова,
используя 'if' в аргументах команды 'break'.  *Note Установка точек
останова: Установка точек останова.  Они могут быть также изменены в
любой момент с помощью команды 'condition'.

   Вы также можете использовать ключевое слово 'if' с командой 'watch'.
Команда 'catch' не распознает ключевое слово 'if'; 'condition' является
единственным способом наложить дальнейшие условия на точку перехвата.

'condition НОМЕР ВЫРАЖЕНИЕ'
     Задайте ВЫРАЖЕНИЕ как условие остановки для точки останова,
     наблюдения или перехвата с номером НОМЕР.  После того, как вы
     установили условие, данная точка останова остановит вашу программу,
     только если значение ВЫРАЖЕНИЯ будет истинным (ненулевым, в Си).
     Когда вы используете 'condition', GDB немедленно проверяет
     ВЫРАЖЕНИЕ на синтаксическую корректность и на тот факт, что символы
     в нем ссылаются на реальные объекты в контексте данной точки
     останова.  Если ВЫРАЖЕНИЕ использует символы, не существующие в
     контексте точки останова, GDB выведет сообщение об ошибке:

          No symbol "foo" in current context.(1)

     Однако, GDB в действительности не вычисляет ВЫРАЖЕНИЕ в момент
     подачи команды 'condition' (или команды, устанавливающей точку
     останова с условием, такой как 'break if ...').  *Note Выражения:
     Выражения.

'condition НОМЕР'
     Снимает условие с точки останова с номером НОМЕР.  Она становится
     обычной безусловной точкой останова.

   Специальным случаем условия для точки останова является остановка
только тогда, когда точка останова была достигнута определенное число
раз.  Это настолько полезно, что существует специальный способ сделать
это, используя "счетчик игнорирования".  Каждая точка останова имеет
счетчик игнорирования, являющийся целым числом.  Как правило, счетчик
игнорирования равен нулю и, следовательно, не производит никакого
действия.  Но если ваша программа достигает точки останова, чей счетчик
игнорирования положителен, тогда вместо того чтобы остановиться, она
лишь уменьшит его на единицу и продолжит выполнение.  В результате, если
величина счетчика игнорирования равна N, точка останова не остановит
программу следующие N раз, когда программа его достигнет.

'ignore НОМЕР ЗНАЧЕНИЕ'
     Устанавливает счетчик игнорирований точки останова с номером НОМЕР
     в ЗНАЧЕНИЕ.  Следующие ЗНАЧЕНИЕ раз, когда точка останова будет
     достигнута, выполнение вашей программы не будет остановлено; GDB не
     производит никаких действий, только уменьшает счетчик
     игнорирований.

     Чтобы точка останова сработала при следующем достижении, установите
     счетчик в ноль.

     Когда вы используете 'continue' для возобновления выполнения вашей
     программы от точки останова, вы можете установить счетчик
     игнорирований непосредственно как аргумент к 'continue', а не
     использовать 'ignore'.  *Note Продолжение и выполнение по шагам:
     Продолжение и пошаговое выполнение.

     Если точка останова имеет положительный счетчик игнорирований и
     условие, то условие не проверяется.  Как только счетчик
     игнорирований достигнет нуля, GDB возобновит проверку условия.

     Вы можете достигнуть эффекта счетчика игнорирований с помощью
     такого условия, как '$foo-- <= 0', используя вспомогательную
     переменную отладчика, которая уменьшается каждый раз.  *Note
     Вспомогательные переменные: Вспомогательные переменные.

   Счетчики игнорирований можно использовать с точками останова, точками
наблюдения и точками перехвата.

   ---------- Footnotes ----------

   (1) В текущем контексте нет символа "foo".  (Прим. переводчика)


File: gdb.html,  Node: Команды останова,  Next: Меню точки останова,  Prev: Условия,  Up: Точки останова

5.1.7 Команды точки останова
----------------------------

Вы можете подать любой точке останова (наблюдения или перехвата) ряд
команд, которые будут выполняться при остановке вашей программы на этой
точке останова.  Например, вы можете захотеть вывести значения
определенных выражений, или включить другие точки останова.

'commands [НОМЕР]'
'... СПИСОК-КОМАНД ...'
'end'
     Определяет список команд для точки останова с номером НОМЕР.  Сами
     команды указываются в следующих строках.  Для завершения списка
     команд, введите строку, содержащую только 'end'.

     Чтобы удалить все команды точки останова, введите 'commands' и
     потом сразу 'end', то есть задайте пустой список команд.

     Без аргумента НОМЕР, 'commands' относится к последней установленной
     точке останова, наблюдения или перехвата (но не к последней
     встреченной).

   Нажатие <RET>, как средство повторения последней команды GDB,
отключено внутри СПИСКА-КОМАНД.

   Вы можете использовать команды для точки останова, чтобы снова
запустить вашу программу на выполнение.  Просто используйте команду
'continue', или 'step', или любую другую команду, возобновляющую
выполнение.

   После команды, возобновляющей выполнение, любые другие команды в
списке игнорируются.  Так сделано потому, что каждый раз, когда вы
возобновляете выполнение (даже просто с помощью 'next' или 'step'), вы
можете встретить другую точку останова -- которая может иметь свой
собственный список команд, что приведет к неоднозначности, какой из
списков выполнять.

   Если в качестве первой команды в списке вы укажете 'silent', обычное
сообщение об остановке на точке останова не будет выводиться.  Это может
быть желательно для точек останова, которые должны вывести определенное
сообщение и затем продолжить выполнение.  Если никакая из оставшихся
команд ничего не выводит, вы не увидите никакого знака о том, что точка
останова была достигнута.  'silent' имеет смысл только в начале списка
команд точки останова.

   Команды 'echo', 'output' и 'printf' позволяют вам более точно
контролировать выводимый текст, и часто полезны в "тихих" точках
останова.  *Note Команды управления выводом: Вывод.

   Например, вот как вы можете использовать команды точки останова для
вывода величины 'x' на входе в 'foo', когда 'x' положительна.

     break foo if x>0
     commands
     silent
     printf "x is %d\n",x
     cont
     end

   Одним из применений команд точки останова является компенсация одной
ошибки, так, чтобы вы могли искать другую.  Поместите точку останова
сразу после строки кода, содержащей ошибку, задайте ей условие для
определения случая, в котором было сделано что-то ошибочное, и
определите команды для присвоения правильных значений тем переменным,
для которых это требуется.  Закончите командой 'continue', чтобы ваша
программа не останавливалась, а начните с команды 'silent', чтобы не
было никакого вывода.  Вот пример:

     break 403
     commands
     silent
     set x = y + 4
     cont
     end


File: gdb.html,  Node: Меню точки останова,  Next: Ошибки в точках останова,  Prev: Команды останова,  Up: Точки останова

5.1.8 Меню точки останова
-------------------------

Некоторые языки программирования (особенно Си++) допускают, чтобы одно и
то же имя функции было определено несколько раз, для применения в
различных контекстах.  Это называется "перегрузкой".  Когда имя функции
перегружается, простой записи 'break ФУНКЦИЯ' недостаточно, чтобы
указать GDB, где вы хотите установить точку останова.  Если вы
столкнулись с этой проблемой, вы можете использовать что-то вроде 'break
ФУНКЦИЯ(ТИПЫ)' для указания, какую конкретную версию функции вы имеете в
виду.  В противном случае, GDB предлагает вам выбор из пронумерованных
вариантов для различных возможных точек останова и ждет вашего выбора с
приглашением '>'.  Первыми двумя вариантами всегда являются '[0] cancel'
и '[1] all'.  Ввод '1' устанавливает точку останова на каждом
определении ФУНКЦИИ, а ввод '0' прерывает команду 'break' без установки
новых точек останова.

   Например, следующая выдержка из сеанса иллюстрирует попытку
установить точку останова на перегруженном символе 'String::after'.  Мы
выбрали три конкретных определения имени функции:

     (gdb) b String::after
     [0] cancel
     [1] all
     [2] file:String.cc; line number:867
     [3] file:String.cc; line number:860
     [4] file:String.cc; line number:875
     [5] file:String.cc; line number:853
     [6] file:String.cc; line number:846
     [7] file:String.cc; line number:735
     > 2 4 6
     Breakpoint 1 at 0xb26c: file String.cc, line 867.
     Breakpoint 2 at 0xb344: file String.cc, line 875.
     Breakpoint 3 at 0xafcc: file String.cc, line 846.
     Multiple breakpoints were set.
     Use the "delete" command to delete unwanted
      breakpoints.
     (gdb)


File: gdb.html,  Node: Ошибки в точках останова,  Prev: Меню точки останова,  Up: Точки останова

5.1.9 "Не удается поместить точки останова"
-------------------------------------------

В некоторых операционных системах точки останова не могут быть
использованы в программе, если какой-либо другой процесс выполняет эту
программу.  В этом случае, попытка выполнить или продолжить выполнение
программы с точкой останова приводит к тому, что GDB печатает сообщение
об ошибке:

     Cannot insert breakpoints.
     The same program may be running in another process.(1)

   Когда это происходит, у вас есть три варианта дальнейших действий:

  1. Удалить или отключить точки останова и затем продолжить.

  2. Приостановить GDB и скопировать файл, содержащий вашу программу,
     под другим именем.  Возобновить работу GDB и использовать команду
     'exec-file' для указания, что GDB должен выполнять вашу программу
     под этим именем.  Затем запустите программу снова.

  3. Скомпоновать заново вашу программу так, чтобы сегмент текста был
     неразделяемым, используя ключ компоновщика '-N'.  Ограничения
     операционной системы могут не распространяться на неразделяемые
     выполняемые файлы.

   Аналогичное сообщение может выводиться, если вы запрашиваете слишком
много активных аппаратно-поддерживаемых точек останова и наблюдения:

     Stopped; cannot insert breakpoints.
     You may have requested too many hardware breakpoints and watchpoints.(2)

Это сообщение выводится, когда вы пытаетесь возобновить выполнение
программы, так как только тогда GDB знает точно, сколько аппаратных
точек останова и наблюдения ему нужно установить.

   Когда вы видите это сообщение, вам необходимо отключить или удалить
некоторые аппаратно-поддерживаемые точки останова и наблюдения и затем
продолжить.

   ---------- Footnotes ----------

   (1) Не удается поместить точки останова.  Возможно, эта программа
выполняется в другом процессе.  (Прим. переводчика)

   (2) Остановлено; не удается поместить точки останова.  Возможно, вы
запросили слишком много аппаратно-поддерживаемых точек останова и
наблюдения.  (Прим. переводчика)


File: gdb.html,  Node: Продолжение и пошаговое выполнение,  Next: Сигналы,  Prev: Точки останова,  Up: Остановка

5.2 Продолжение и выполнение по шагам
=====================================

"Продолжение" означает возобновление выполнения программы до ее
нормального завершения.  Напротив, "пошаговое выполнение" означает
выполнение еще одного "шага" вашей программы, где "шаг" быть либо одной
строкой исходного кода, либо одной машинной инструкцией (в зависимости
от того, какую именно команду вы используете).  И в случае продолжения,
и в случае выполнения по шагам, ваша программа может остановиться и
раньше, вследствие точки останова или сигнала.  (Если она
останавливается по сигналу, вы можете использовать 'handle', или 'signal
0' для возобновления выполнения.  *Note Сигналы: Сигналы.)

'continue [СЧЕТЧИК-ИГНОР]'
'c [СЧЕТЧИК-ИГНОР]'
'fg [СЧЕТЧИК-ИГНОР]'
     Возобновить выполнение программы с того адреса, где она
     остановилась последний раз; все точки останова, установленные по
     этому адресу, пропускаются.  Необязательный аргумент СЧЕТЧИК-ИГНОР
     позволяет вам задать количество последующих игнорирований точки
     останова в этом месте; его действие совпадает с действием 'ignore'
     (*note Условия останова: Условия.).

     Аргумент СЧЕТЧИК-ИГНОР имеет смысл, только если ваша программа
     остановилась в точке останова.  В остальных случаях аргумент к
     'continue' игнорируется.

     Синонимы 'c' и 'fg' (от "foreground", так как отлаживаемая
     программа считается фоновой), предоставляются исключительно для
     удобства и имеют в точности тот же смысл, что и 'continue'.

   Чтобы возобновить выполнение с другого места, вы можете использовать
'return' (*note Возврат из функции: Возврат.) чтобы вернуться назад к
вызывающей функции; или 'jump' (*note Продолжение с другого адреса:
Переходы.) для перехода к произвольному месту в вашей программе.

   Типичная техника для использования пошагового выполнения заключается
в установке точки останова (*note Точки останова: (точки наблюдения и
точки перехвата)Точки останова.) на начале функции или раздела вашей
программы, где предположительно находится ошибка, выполнении вашей
программы до остановки на этой точке останова, и затем пошаговом
выполнении подозреваемого участка, с исследованием интересуемых
переменных, пока вы не увидите, что случилась ошибка.

'step'
     Продолжить выполнение вашей программы, пока управление не достигнет
     другой строки исходного текста, затем остановить ее и вернуть
     управление GDB. Эту команду можно сокращать как 's'.

          _Предупреждение:_ Если вы используете команду 'step', когда
          управление находится внутри функции, которая была
          скомпилирована без отладочной информации, выполнение
          продолжается, пока управление не достигнет функции, которая
          _имеет_ ее.  Аналогично, пошаговое выполнение не будет
          заходить в функцию, скомпилированную без отладочной
          информации.  Для пошагового выполнения таких функций
          используйте команду 'stepi', описанную ниже.

     Команда 'step' останавливается только на первой инструкции строки
     исходного текста.  Это предотвращает множественные остановки,
     которые в противном случае могут возникнуть в операторе 'switch',
     цикле 'for', и так далее.  'step' продолжает останавливаться, если
     функция, имеющая отладочную информацию, вызывается внутри строки.
     Другими словами, 'step' _заходит внутрь_ функций, вызываемых в
     данной строке.

     Также, команда 'step' входит в функцию, только если для нее
     существует информация о номерах строк.  Иначе она действует, как
     команда 'next'.  Это позволяет избежать проблем, появляющихся при
     использовании 'cc -gl' на машинах MIPS. Раньше 'step' заходила в
     подпрограмму, если о ней существовала хоть какая-нибудь отладочная
     информация.

'step число'
     Продолжает выполнение, как по команде 'step', но делает это
     указанное ЧИСЛО раз.  Если до завершения указанного ЧИСЛА шагов
     достигается точка останова, или приходит сигнал, не связанный с
     пошаговым выполнением, пошаговое выполнение сразу останавливается.

'next [ЧИСЛО]'
     Продолжает выполнение до следующей строки исходного текста в
     текущем (внутреннем) кадре стека.  Это аналогично 'step', но вызовы
     функций, которые появляются внутри строки кода, выполняются без
     остановки.  Выполнение останавливается, когда управление достигает
     другой строки кода в исходном уровне стека, который выполнялся,
     когда вы дали команду 'next'.  Эта команда сокращается как 'n'.

     Аргумент ЧИСЛО является счетчиком повторений, как для 'step'.

     Команда 'next' останавливается только на первой инструкции исходной
     строки.  Это предотвращает множественные остановки, которые иначе
     могут возникнуть в операторах 'switch', циклах 'for' и так далее.

'set step-mode'
'set step-mode on'
     Команда 'set step-mode on' велит команде 'step' останавливаться на
     первой инструкции в функции, не содержащей отладочной информации о
     строках, а не выполнять ее без остановки.

     Это полезно в случаях, когда вы можете быть заинтересованы в
     изучении машинных инструкций функции, не имеющей символьной
     информации, и не хотите, чтобы GDB автоматически ее проскочил.

'set step-mode off'
     Велит команде 'step' выполнять все функции, не содержащие
     отладочной информации, без остановки.  Это значение используется по
     умолчанию.

'finish'
     Продолжить выполнение до возврата из функции в выбранном кадре
     стека.  Напечатать возвращенное значение (если таковое существует).

     Сравните это с командой 'return' (*note Возврат из функции:
     Возврат.).

'until'
'u'
     Продолжить выполнение до достижения строки исходного текста,
     следующей за текущей, в текущем кадре стека.  Эта команда
     используется для избежания выполнения цикла по шагам больше одного
     раза.  Она похожа на команду 'next', за исключением того, что когда
     'until' встречает переход, она автоматически продолжает выполнение,
     пока счетчик выполнения программы не станет больше, чем адрес
     перехода.

     Это означает, что когда вы достигаете конца цикла после его
     выполнения по шагам, 'until' продолжает выполнение вашей программы,
     пока она не выйдет из цикла.  Напротив, команда 'next' в конце
     цикла просто переходит назад в начало цикла, что заставляет вас
     выполнять по шагам следующую итерацию.

     'until' всегда останавливает вашу программу, если она пытается
     выйти из текущего кадра стека.

     'until' может привести к несколько неожиданным результатам, если
     порядок машинных кодов не совпадает с порядком строк исходного
     текста.  Например, в следующем отрывке сеанса отладки, команда 'f'
     ('frame') показывает, что выполнение остановилось на строке '206';
     хотя, когда мы используем 'until', мы переходим к строке '195':

          (gdb) f
          #0  main (argc=4, argv=0xf7fffae8) at m4.c:206
          206                 expand_input();
          (gdb) until
          195             for ( ; argc > 0; NEXTARG) {

     Это произошло потому, что для эффективности выполнения компилятор
     сгенерировал код для проверки окончания цикла в конце, а не в
     начале цикла -- даже если проверка в цикле 'for' Си написана до
     тела цикла.  Кажется, что команда 'until' переместилась назад к
     началу цикла, когда двигалась к этому выражению; однако, в
     действительности она не переходила к более раннему оператору -- в
     терминах фактического машинного кода.

     'until' без аргументов работает посредством пошагового выполнения
     отдельных инструкций, и, следовательно, является более медленной,
     чем 'until' с аргументом.

'until ПОЛОЖЕНИЕ'
'u ПОЛОЖЕНИЕ'
     Продолжить выполнение вашей программы, пока либо указанное место не
     будет достигнуто, либо не произойдет возврат из текущего кадра
     стека.  ПОЛОЖЕНИЕ может быть любой из доступных форм аргумента для
     'break' (*note Установка точек останова: Установка точек
     останова.).  Эта форма команды использует точки останова и,
     следовательно, является более быстрой, чем 'until' без аргумента.

'stepi'
'stepi АРГ'
'si'
     Выполнить одну машинную инструкцию, затем остановиться и вернуться
     в отладчик.

     При пошаговом выполнении машинных инструкций, часто бывает полезным
     сделать 'display/i $pc'.  Это велит GDB автоматически отображать
     инструкцию, которая будет выполняться следующей, каждый раз, когда
     ваша программа останавливается.  *Note Автоматическое отображение:
     Автоматическое отображение.

     Аргумент является счетчиком повторений, как для 'step'.

'nexti'
'nexti АРГ'
'ni'
     Выполнить одну машинную инструкцию, но если это вызов функции,
     продолжать до возврата из нее.

     Аргумент является счетчиком повторений, как для 'next'.


File: gdb.html,  Node: Сигналы,  Next: Остановка нитей,  Prev: Продолжение и пошаговое выполнение,  Up: Остановка

5.3 Сигналы
===========

Сигнал -- это асинхронное событие, которое может произойти в программе.
Операционная система определяет возможные типы сигналов и дает каждому
типу имя и номер.  В Unix, например, 'SIGINT' -- это сигнал, получаемый
программой, когда вы вводите знак прерывания (часто 'C-c'); 'SIGSEGV' --
сигнал, получаемый программой при ссылке на область памяти, отличную от
всех используемых областей; 'SIGALRM' появляется при срабатывании
интервального таймера (возникает, только если ваша программа запросила
временной сигнал).

   Некоторые сигналы, такие как 'SIGALRM', являются обычной частью
функционирования вашей программы.  Другие, такие как 'SIGSEGV',
обозначают ошибки; эти сигналы являются "фатальными" (они немедленно
убивают вашу программу), если программа не определила заранее другой
способ их обработки.  'SIGINT' не указывает на ошибку в вашей программе,
но обычно является фатальным, так что он может выполнять функцию
прерывания: убить программу.

   GDB способен обнаружить любое появление сигнала в вашей программе.
Вы можете заранее сообщить GDB, что делать для каждого типа сигнала.

   Обычно, GDB установлен так, чтобы игнорировать неошибочные сигналы,
такие как 'SIGALRM' (чтобы не мешать их действию при исполнении вашей
программы), но немедленно останавливать вашу программу всякий раз, когда
возникает сигнал об ошибке.  Вы можете изменить эти установки командой
'handle'.

'info signals'
'info handle'
     Напечатать таблицу всех типов сигналов и описания, как GDB будет
     обрабатывать каждый из них.  Вы можете использовать эту команду,
     чтобы посмотреть номера всех определенных типов сигналов.

     'info handle' является синонимом для 'info signals'.

'handle СИГНАЛ КЛЮЧЕВЫЕ-СЛОВА...'
     Изменить способ, которым GDB обрабатывает СИГНАЛ.  СИГНАЛ может
     быть номером сигнала или его именем (с 'SIG' или без него в
     начале).  КЛЮЧЕВЫЕ-СЛОВА определяют, какие сделать изменения.

   Ключевые слова, допускаемые командой 'handle', могут быть сокращены.
Вот их полные имена:

'nostop'
     GDB не должен останавливать вашу программу при получении этого
     сигнала.  Все же он может вывести сообщение, уведомляющее о
     получении сигнала.

'stop'
     GDB должен остановить вашу программу при получении этого сигнала.
     Это также подразумевает ключевое слово 'print'.

'print'
     GDB должен вывести сообщение при возникновении данного сигнала.

'noprint'
     GDB вообще не должен замечать возникновение сигнала.  Это также
     подразумевает ключевое слово 'nostop'.

'pass'
     GDB должен позволить вашей программе увидеть этот сигнал; программа
     может обработать сигнал, или же она может завершиться, если сигнал
     фатальный и не обработан.

'nopass'
     GDB не должен позволять вашей программе видеть этот сигнал.

   Когда сигнал останавливает вашу программу, он невидим для нее, пока
вы не продолжите выполнение.  Затем ваша программа видит сигнал, если _в
данный момент_ на рассматриваемый сигнал распространяется действие
команды 'pass'.  Другими словами, после того, как GDB сообщит о сигнале,
вы можете использовать команду 'handle' c 'pass' или 'nopass', чтобы
указать, должна ли ваша программа увидеть этот сигнал при продолжении.

   Вы также можете использовать команду 'signal' для того, чтобы
помешать вашей программе увидеть сигнал или, наоборот, заставить ее
заметить обычно игнорируемый сигнал, или чтобы подать ей произвольный
сигнал в любое время.  Например, если ваша программа остановилась
вследствие какой-либо ошибки обращения к памяти, вы можете записать
правильные значения в ошибочные переменные и продолжить выполнение в
надежде посмотреть на дальнейшее выполнение, но ваша программа,
вероятно, немедленно остановилась бы из-за фатального сигнала, как
только она его заметила бы.  Чтобы помешать этому, вы можете продолжить
выполнение с 'signal 0'.  *Note Подача сигнала вашей программе: Подача
сигналов.


File: gdb.html,  Node: Остановка нитей,  Prev: Сигналы,  Up: Остановка

5.4 Остановка и запуск многонитевых программ
============================================

Когда ваша программа имеет несколько нитей выполнения (*note Отладка
многонитевых программ: Нити.), вы можете выбрать, установить точки
останова либо во всех, либо в каких-то отдельных нитях.

'break НОМ-СТРОКИ thread НОМЕР-НИТИ'
'break НОМ-СТРОКИ thread НОМЕР-НИТИ if ...'
     НОМ-СТРОКИ определяет строки исходного текста; существует несколько
     способов их задания, но результат всегда один и тот же -- указание
     строки исходного текста.

     Используйте классификатор 'thread НОМЕР-НИТИ' с командой точки
     останова, чтобы указать GDB, что вы хотите остановить программу,
     только когда определенная нить достигнет этой точки.  НОМЕР-НИТИ --
     это один из числовых идентификаторов нити, присвоенный GDB,
     показываемый в первой колонке при выводе 'info threads'.

     Если при установке точки останова вы не укажете 'thread
     НОМЕР-НИТИ', точка останова будет действовать для _всех_ нитей
     вашей программы.

     Вы также можете использовать классификатор 'thread' для условных
     точек останова; в этом случае, поместите 'thread НОМЕР-НИТИ' перед
     условием точки останова, вот так:

          (gdb) break frik.c:13 thread 28 if bartab > lim

   При любой остановке вашей программы под управлением GDB прекращается
выполнение _всех_ нитей, а не только текущей.  Это позволяет вам
исследовать полное состояние программы, включая переключение между
нитями, не опасаясь, что это может изменить что-либо в дальнейшем.

   Наоборот, когда вы снова запускаете программу, _все_ нити начинают
выполняться.  _Это верно даже при пошаговом выполнении_ такими
командами, как 'step' или 'next'.

   В частности, GDB не может пошагово выполнять все нити параллельно.
Так как планированием выполнения нити занимается операционная система
отлаживаемой цели (не контролируемая GDB), то пока в текущей нити
выполняется один шаг, в других может выполниться несколько.  Более того,
когда выполнение программы останавливается, другие потоки вообще могут
остановиться в середине операторов, а не на границе между ними.

   Вы даже можете обнаружить, что после продолжения исполнения или после
пошагового выполнения ваша программа остановилась в другой нити.  Это
случается всякий раз, когда другая нить достигает точки останова,
получает сигнал, или в ней возникает исключительная ситуация, прежде чем
первая нить завершает выполнение того, что вы запросили.

   В некоторых операционных системах вы можете заблокировать планировщик
заданий и тем самым позволить выполняться только одной нити.

'set scheduler-locking РЕЖИМ'
     Устанавливает режим блокировки планировщика заданий.  Если он
     установлен в 'off', то блокировки нет и любая нить может
     выполняться в любое время.  Если этот режим установлен в 'on', то
     только текущая нить может выполняться, когда выполнение
     продолжается.  Режим 'step' производит оптимизацию для пошагового
     выполнения.  Он не дает другим нитям "захватывать приглашение"
     путем приоритетного прерывания обслуживания текущей нити во время
     пошагового выполнения.  Другие нити едва ли получат возможность
     начать выполнение, когда вы выполняете очередной шаг.  С большей
     вероятностью они начнут выполняться, когда вы выполняете команду
     'next' на вызове функции, и им ничто не помешает выполняться, когда
     вы используете такие команды, как 'continue', 'until' или 'finish'.
     Однако, если другие нити не достигнут точки останова в течение
     отведенного им для выполнения времени, они никогда не перехватят
     приглашение GDB у отлаживаемой вами нити.

'show scheduler-locking'
     Отобразить текущий режим блокировки.


File: gdb.html,  Node: Стек,  Next: Исходные файлы,  Prev: Остановка,  Up: Top

6 Исследование стека
********************

Когда ваша программа остановилась, первое, что вам нужно знать -- где
она остановилась, и как она туда попала.

   Каждый раз, когда ваша программа производит вызов функции, о нем
создается определенная информация.  Она включает положение вызова в
вашей программе, параметры вызова и локальные переменные вызываемой
функции.  Информация сохраняется в блоке данных, называемом "кадром
стека".  Кадры стека размещаются в области памяти, называемой "стеком
вызовов".

   Команды GDB для исследования стека позволяют вам увидеть всю эту
информацию при остановке вашей программы.

   Один из кадров стека является "выбранным", и многие команды GDB
неявно относятся к нему.  В частности, когда вы запрашиваете у GDB
значение переменной вашей программы, это значение находится в выбранном
кадре.  Для выбора интересующего вас кадра существуют специальные
команды GDB. *Note Выбор кадра: Выбор.

   Когда ваша программа останавливается, GDB автоматически выбирает
текущий выполняющийся кадр и выдает его краткое описание, аналогично
команде 'frame' (*note Информация о кадре стека: Информация о кадре.).

* Menu:

* Кадры::                       Кадры стека
* Цепочки вызовов::             Цепочки вызовов
* Выбор::                       Выбор кадра
* Информация о кадре::          Информация о кадре


File: gdb.html,  Node: Кадры,  Next: Цепочки вызовов,  Up: Стек

6.1 Кадры стека
===============

Cтек вызовов разделен на непрерывные участки, называемые "кадрами
стека", или "кадрами" для краткости; каждый кадр является данными,
связанными с одним вызовом одной функции.  Кадр содержит аргументы,
переданные функции, ее локальные переменные и адрес, с которого она
выполняется.

   Когда ваша программа стартует, стек содержит только один кадр -- для
функции 'main'.  Он называется "начальным" или "внешним" кадром.  Каждый
раз при вызове функции создается новый кадр.  При каждом выходе из
функции кадр вызова этой функции уничтожается.  Если функция является
рекурсивной, для нее может существовать множество кадров.  Кадр для
функции, исполняемой в данный момент, называется "внутренним" кадром.
Это кадр, созданный самым последним из всех существующих кадров стека.

   Внутри вашей программы кадры стека идентифицируются своим адресом.
Кадр стека состоит из множества байт, каждый из которых имеет свой
собственный адрес; каждый тип компьютеров имеет свой способ для выбора
одного байта, чей адрес служит адресом кадра.  Обычно, пока выполнение
происходит в данном кадре, этот адрес содержится в регистре, называемом
"регистром указателя кадра".

   GDB присваивает номера всем существующим кадрам стека, начиная с нуля
для внутреннего кадра, единицу -- вызвавшему его кадру, и так далее.  В
действительности, эти номера не существуют в вашей программе; они
назначаются GDB, чтобы предоставить вам способ различать кадры стека в
командах GDB.

   Некоторые компиляторы позволяют компилировать функции так, чтобы они
выполнялись без создания кадров стека.  (Например, ключ gcc
'-fomit-frame-pointer' создает функции без кадра.)  Это иногда делается
с часто используемыми библиотечными функциями, чтобы сэкономить время,
требуемое для установки кадра.  GDB имеет ограниченные возможности для
обработки таких вызовов.  Если вызов внутренней функции происходит без
создания кадра стека, GDB, тем не менее, описывает его так, как если бы
он имел отдельный кадр, который имеет, как обычно, номер 0, позволяя
корректно трассировать цепочку вызовов функций.  Однако, GDB не имеет
средств для работы с функциями без кадра в другом месте стека.

'frame АРГ'
     Команда 'frame' позволяет вам перемещаться от одного кадра стека к
     другому и распечатывать выбранный вами кадр.  АРГ может быть либо
     адресом кадра, либо его номером.  Без аргумента, 'frame' выводит
     текущий кадр стека.

'select-frame'
     Команда 'select-frame' позволяет вам перемещаться от одного кадра
     стека к другому без его распечатки.  Это "тихая" версия 'frame'.


File: gdb.html,  Node: Цепочки вызовов,  Next: Выбор,  Prev: Кадры,  Up: Стек

6.2 Цепочки вызовов
===================

Цепочка вызовов предоставляет собой информацию о том, как ваша программа
оказалась там, где она есть.  Она отображает по одной строке для каждого
кадра, начиная с текущего выполняющегося кадра (кадра 0), за которым
следует кадр, из которого он был вызван (кадр 1), и далее вверх по
стеку.

'backtrace'
'bt'
     Вывести цепочку вызовов всего стека: по одной строке на кадр, для
     всех кадров в стеке.

     Вы можете прервать цепочку вызовов в любое время, введя знак
     системного прерывания, обычно 'C-c'.

'backtrace N'
'bt N'
     То же самое, но выводятся только N внутренних кадров.

'backtrace -N'
'bt -N'
     То же самое, но выводятся только N внешних кадров.

   'where' и 'info stack' (сокращенно 'info s') -- дополнительные
синонимы для 'backtrace'.

   Каждая строка в цепочке вызовов показывает номер кадра и имя функции.
Счетчик команд также показывается, если только вы не используете 'set
print address off'.  Цепочка вызовов также показывает имя исходного
файла, номер строки и аргументы функции.  Значение счетчика команд
опускается, если он указывает на начало кода для данной строки.

   Ниже приведен пример цепочки вызовов.  Она была получена командой 'bt
3', так что она показывает три внутренних кадра.

     #0  m4_traceon (obs=0x24eb0, argc=1, argv=0x2b8c8)
         at builtin.c:993
     #1  0x6e38 in expand_macro (sym=0x2b600) at macro.c:242
     #2  0x6840 in expand_token (obs=0x0, t=177664, td=0xf7fffb08)
         at macro.c:71
     (More stack frames follow...)

Информация о нулевом кадре не начинается со значения счетчика команд,
что указывает на то, что ваша программа остановилась в начале кода для
строки '993' файла 'builtin.c'.


File: gdb.html,  Node: Выбор,  Next: Информация о кадре,  Prev: Цепочки вызовов,  Up: Стек

6.3 Выбор кадра
===============

Большинство команд для исследования стека и других данных в вашей
программе применяются выбранному в данный момент кадру.  Здесь приведены
команды для выбора кадра стека; все они завершаются выводом краткого
описания выбранного кадра стека.

'frame N'
'f N'
     Выбрать кадр номер N.  Напоминаем, что нулевой кадр -- это
     внутренний (исполняемый в данный момент) кадр, первый кадр -- тот,
     из которого вызван нулевой, и так далее.  Кадр с наибольшим номером
     -- это кадр для функции 'main'.

'frame АДРЕС'
'f АДРЕС'
     Выбрать кадр, расположенный по адресу АДРЕС.  В основном это
     полезно, если формирование цепочки кадров стека было нарушено из-за
     ошибки, сделавшей невозможным для GDB правильное присвоение номеров
     всем кадрам.  Кроме того, это может быть полезным, когда у вашей
     программы есть несколько стеков и происходит переключение от одного
     к другому.

     В архитектуре SPARC, команде 'frame' для выбора произвольного кадра
     необходимо указать два адреса: указатель кадра и указатель вершины
     стека.

     В архитектурах MIPS и Alpha требуется два адреса: указатель вершины
     стека и указатель команд.

     В архитектуре 29k требуется три адреса: указатель вершины стека
     регистров, указатель команд и указатель вершины стека памяти.

'up N'
     Переместиться вверх по стеку на N кадров.  Для положительных
     значений N, это перемещение происходит по направлению к внешнему
     кадру, к кадрам с большими номерами, к кадрам, которые существуют
     дольше.  По умолчанию N принимается равным единице.

'down N'
     Передвинуться вниз по стеку на N кадров.  Для положительных
     значений N, это продвижение происходит по направлению к внутреннему
     кадру, к кадру с меньшим номером, к кадрам, которые были созданы
     позже.  По умолчанию, значение N принимается равным единице.  Вы
     можете сокращать 'down' как 'do'.

   Все эти команды заканчиваются выводом двух строк, описывающих кадр.
Первая строка показывает номер кадра, имя функции, аргументы, имя
исходного файла и номер выполняемой строки в этом кадре.  Вторая строка
показывает содержимое этой строки исходного текста.

   Например:

     (gdb) up
     #1  0x22f0 in main (argc=1, argv=0xf7fffbf4, env=0xf7fffbfc)
         at env.c:10
     10              read_input_file (argv[i]);

   После такого вывода, команда 'list' без аргументов выводит десять
строк, расположенных вокруг точки выполнения в кадре.  *Note Вывод строк
исходного текста: Вывод строк.

'up-silently N'
'down-silently N'
     Эти две команды являются вариантами 'up' и 'down' соответственно,
     отличаясь от них тем, что делают свою работу "тихо", не отображая
     новый кадр.  Они предназначены для использования в основном в
     командных сценариях GDB, где вывод может быть ненужным и
     отвлекающим.


File: gdb.html,  Node: Информация о кадре,  Prev: Выбор,  Up: Стек

6.4 Информация о кадре стека
============================

Существуют несколько других команд для вывода информации о выбранном
кадре стека.

'frame'
'f'
     При использовании без аргументов, эта команда не выбирает новый
     кадр, а выводит краткое описание текущего выбранного кадра стека.
     Эту команду можно сокращать как 'f'.  С аргументом, эта команда
     используется для выбора кадра стека.  *Note Выбор кадра стека:
     Выбор.

'info frame'
'info f'
     Эта команда выводит подробное описание выбранного кадра стека,
     включающее:

        * адрес кадра
        * адрес следующего вниз по стеку кадра (вызываемого из данного)
        * адрес следующего вверх по стеку кадра (того, из которого был
          вызван данный)
        * язык, на котором написан исходный код, соответствующий этому
          кадру
        * адрес аргументов кадра
        * адрес локальных переменных кадра
        * сохраненный в кадре счетчик команд (адрес выполнения в кадре,
          вызвавшем данный)
        * регистры, которые были сохранены в кадре

     Подробное описание полезно, если из-за какой-либо ошибки формат
     стека не соответствует обычным соглашениям.

'info frame АДРЕС'
'info f АДРЕС'
     Вывести подробное описание кадра стека, расположенного по адресу
     АДРЕС, не выбирая этот кадр.  Выбранный кадр этой командой не
     изменяется.  Она требует параметр АДРЕС того же типа, что и команда
     'frame' (для некоторых архитектур не один, а несколько).  *Note
     Выбор кадра стека: Выбор.

'info args'
     Вывести аргументы выбранного кадра, каждый на отдельной строке.

'info locals'
     Вывести локальные переменные выбранного кадра, каждую на отдельной
     строке.  Выводятся все переменные (объявленные как статические или
     как автоматические), доступные в точке выполнения выбранного кадра
     стека.

'info catch'
     Выводит список всех обработчиков исключительных ситуаций,
     являющихся активными в текущей точке выполнения текущего кадра
     стека.  Чтобы увидеть другие обработчики исключительных ситуаций,
     перейдите в соответствующую секцию (используя команды 'up', 'down'
     или 'frame'); затем наберите 'info catch'.  *Note Установка точек
     перехвата: Установка точек перехвата.


File: gdb.html,  Node: Исходные файлы,  Next: Данные,  Prev: Стек,  Up: Top

7 Исследование исходных файлов
******************************

GDB может выводить части исходных текстов вашей программы, так как
отладочная информация, записанная в ней, сообщает GDB, какие исходные
файлы использовались при создании программы.  Когда ваша программа
останавливается, GDB сам выводит строку, на которой она остановилась.
Аналогично, когда вы выбираете кадр стека (*note Выбор кадра стека:
Выбор.), GDB выводит строку, на которой остановилось выполнение в этом
кадре.  Вы можете выводить другие части исходных файлов с помощью явных
команд.

   Если вы используете GDB через интерфейс к GNU Emacs, вы можете
предпочесть воспользоваться средствами Emacs для просмотра исходных
текстов; смотрите *note Использование GDB под управлением GNU Emacs:
Emacs.

* Menu:

* Вывод строк::                 Вывод строк исходного текста
* Поиск::                       Поиск в исходных файлах
* Пути для исходных файлов::    Определение каталогов для исходных файлов
* Машинный код::                Исходный текст и машинный код


File: gdb.html,  Node: Вывод строк,  Next: Поиск,  Up: Исходные файлы

7.1 Вывод строк исходного текста
================================

Чтобы вывести строки файла с исходным текстом, используйте команду
'list' (сокращенно 'l').  По умолчанию выводятся десять строк.
Существует несколько способов определения того, какую часть файла вы
хотите вывести.

   Здесь представлены наиболее употребительные формы команды 'list':

'list НОМЕР-СТРОКИ'
     Вывести строки, расположенные вокруг строки с номером НОМЕР-СТРОКИ
     в текущем исходном файле.

'list ФУНКЦИЯ'
     Вывести строки, расположенные вокруг начала функции ФУНКЦИЯ.

'list'
     Вывести еще определенное количество строк.  Если последние
     выведенные строки выводились с помощью команды 'list', то выводятся
     строки, следующие за последними выведенными; если, однако,
     последней выведенной строкой была одиночная строка, выведенная как
     часть отображения кадра стека (*note Исследование стека: Стек.), то
     выводятся строки, расположенные вокруг нее.

'list -'
     Вывести строки, расположенные непосредственно перед последними
     выведенными.

   По умолчанию, для любой из этих форм команды 'list' GDB выводит
десять строк исходного текста.  Вы можете изменить это командой 'set
listsize':

'set listsize ЧИСЛО'
     Установить количество выводимых командой 'list' строк в ЧИСЛО (если
     аргумент команды 'list' не задает явно какое-нибудь другое число).

'show listsize'
     Отобразить количество строк, выводимых по команде 'list'.

   Повторение команды 'list' нажатием <RET> отбрасывает аргумент, так
что это эквивалентно вводу просто 'list'.  Это полезнее, чем вывод тех
же самых строк снова.  Исключение сделано для параметра '-'; этот
параметр сохраняется при повторе команды, так что каждое повторение
приводит к перемещению вверх по исходному файлу.

   Обычно команда 'list' ожидает от вас ноль, один или два "указателя
строк".  Указатели строк определяют строки исходного текста; существует
несколько способов их задания, но результат всегда заключается в задании
строки исходного текста.  Вот полное описание возможных параметров
команды 'list':

'list УКАЗ-СТР'
     Вывести строки, расположенные вокруг строки, определяемой УКАЗ-СТР.

'list ПЕРВ,ПОСЛ'
     Вывести строки с ПЕРВ до ПОСЛ.  Оба параметра являются указателями
     строк.

'list ,ПОСЛ'
     Вывести строки, расположенные перед ПОСЛ.

'list ПЕРВ,'
     Вывести строки, начиная с ПЕРВ.

'list +'
     Вывести строки, расположенные сразу за последними выведенными.

'list -'
     Вывести строки, расположенные непосредственно перед последними
     выведенными.

'list'
     Описано в предыдущей таблице.

   Ниже перечислены способы указания одиночной строки исходного текста
-- все виды указателей строк.

'НОМЕР'
     Определяет строку с номером НОМЕР из текущего исходного файла.
     Если в качестве параметров к команде 'list' задано два указателя
     строк, это относится к тому же исходному файлу, что и первый
     указатель строки.

'+СМЕЩЕНИЕ'
     Указывает на строку, смещенную вперед на СМЕЩЕНИЕ строк
     относительно последней выведенной строки.  Когда используется в
     качестве второго указателя строки для команды 'list', имеющей два
     указателя, задает строку, смещенную на СМЕЩЕНИЕ строк вниз
     относительно строки, определенной первым указателем.

'-СМЕЩЕНИЕ'
     Указывает на строку, расположенную на СМЕЩЕНИЕ строк раньше
     последней выведенной строки.

'ИМЯ-ФАЙЛА:НОМЕР'
     Задает строку НОМЕР из исходного файла ИМЯ-ФАЙЛА.

'ФУНКЦИЯ'
     Определяет строку, с которой начинается тело функции ФУНКЦИЯ.
     Например, в Си это строка с открывающейся фигурной скобкой.

'ИМЯ-ФАЙЛА:ФУНКЦИЯ'
     Определяет строку с открывающейся фигурной скобкой, с которой
     начинается тело функции ФУНКЦИЯ в файле ИМЯ-ФАЙЛА.  Имя файла
     необходимо лишь для того, чтобы избежать неоднозначности, когда в
     различных исходных файлах есть одинаково названные функции.

'*АДРЕС'
     Определяет строку, соответствующую адресу АДРЕС программы.  АДРЕС
     может быть любым выражением.


File: gdb.html,  Node: Поиск,  Next: Пути для исходных файлов,  Prev: Вывод строк,  Up: Исходные файлы

7.2 Поиск в исходных файлах
===========================

Существуют две команды для поиска по регулярному выражению в текущем
исходном файле.

'forward-search РЕГ-ВЫРАЖ'
'search РЕГ-ВЫРАЖ'
     Команда 'forward-search РЕГ-ВЫРАЖ' проверяет на соответствие
     регулярному выражению РЕГ-ВЫРАЖ каждую строку, начиная со строки,
     следующей за последней выведенной.  Найденная строка выводится.  Вы
     можете использовать синоним 'search РЕГ-ВЫРАЖ' или сокращать имя
     команды как 'fo'.

'reverse-search РЕГ-ВЫРАЖ'
     Команда 'reverse-search РЕГ-ВЫРАЖ', двигаясь назад, проверяет на
     соответствие регулярному выражению РЕГ-ВЫРАЖ каждую строку, начиная
     с предшествующей последней выведенной.  Найденная строка выводится.
     Вы можете сокращать эту команду как 'rev'.


File: gdb.html,  Node: Пути для исходных файлов,  Next: Машинный код,  Prev: Поиск,  Up: Исходные файлы

7.3 Определение каталогов с исходными файлами
=============================================

Исполняемые программы иногда не сохраняют имена каталогов, в которых
находились исходные файлы, из которых они скомпилированы, а хранят лишь
имена файлов.  Даже если они их сохранили, каталоги могли быть
перемещены в период между компиляцией и сеансом отладки.  У GDB есть
список каталогов для поиска исходных файлов; он называется "путь для
исходных файлов".  Каждый раз, когда GDB требуется исходный файл, он
перебирает по порядку все каталоги из этого списка, пока не находит файл
с требуемым именем.  Заметьте, что пути поиска исполняемых файлов для
этой цели _не_ используются, как не используется и текущий рабочий
каталог, если только он не присутствует в пути для исходных файлов.

   Если GDB не может найти исходный файл, используя путь для исходных
файлов, а в объектном файле программы указан какой-либо каталог, GDB
просматривает также и его.  В последнюю очередь, если путь для исходных
файлов пуст и запись о каталоге компиляции отсутствует, GDB
просматривает текущий каталог.

   При переустановке или переупорядочивании пути для исходных файлов,
GDB очищает любую запомненную им информацию о том, где исходные файлы
были найдены и о расположении строк в них.

   Когда вы вызываете GDB, путь для исходных файлов содержит только
'cdir' и 'cwd', в этом порядке.  Для добавления других каталогов,
используйте команду 'directory'.

'directory ИМЯ-КАТАЛОГА ...'
'dir ИМЯ-КАТАЛОГА ...'
     Добавить каталог ИМЯ-КАТАЛОГА в начало пути для исходных файлов.
     Этой команде могут быть заданы несколько имен, разделенные ':' (';'
     в MS-DOS и MS-Windows, где ':' обычно является частью абсолютного
     имени файла) или пробелом.  Вы можете указать каталог, который уже
     содержится в пути для исходных файлов; это переместит его в начало,
     так что GDB будет просматривать его раньше.

     Вы можете использовать строку '$cdir' для ссылки на каталог
     компиляции (если информация о нем сохранена), и '$cwd' для ссылки
     на текущий рабочий каталог.  '$cwd' -- это не то же самое, что '.'.
     Первая отслеживает текущий рабочий каталог, который может меняться
     во время вашего сеанса работы с GDB, тогда как вторая сразу
     преобразовывается в текущий каталог в момент его добавления в путь
     для исходных файлов.

'directory'
     Очистить путь для файлов с исходными текстами.  Эта команда требует
     подтверждения.

'show directories'
     Вывести путь поиска исходных файлов: показать, какие каталоги он
     содержит.

   Если ваш путь для исходных файлов перемешан с уже неиспользуемыми
каталогами, GDB может иногда вызвать недоумение, найдя неправильный
вариант исходного файла.  Вы можете исправить ситуацию следующим
образом:

  1. Использовать 'directory' без параметров, чтобы очистить путь поиска
     исходных файлов.

  2. Использовать 'directory' с подходящими аргументами, чтобы
     переустановить каталоги, которые вы хотите видеть в пути для
     исходных файлов.  Вы можете добавить все каталоги одной командой.


File: gdb.html,  Node: Машинный код,  Prev: Пути для исходных файлов,  Up: Исходные файлы

7.4 Исходный текст и машинный код
=================================

Вы можете использовать команду 'info line', чтобы отобразить строки
исходного текста в программные адреса (и наоборот), и команду
'disassemble', чтобы вывести диапазон адресов в виде машинных
инструкций.  При запуске в режиме GNU Emacs, команда 'info line' выводит
стрелку, указывающую на заданную строку.  Также 'info line' выводит
адреса как в символьной форме, так и в шестнадцатеричной.

'info line УКАЗ-СТР'
     Выводит начальный и конечный адреса скомпилированного кода,
     соответствующего строке исходного текста УКАЗ-СТР.  Вы можете
     определить строки исходного текста любым способом, воспринимаемым
     командой 'list' (*note Вывод строк исходного текста: Вывод строк.).

   Например, мы можем использовать 'info line' для определения положения
объектного кода первой строки функции 'm4_changequote':

     (gdb) info line m4_changequote
     Line 895 of "builtin.c" starts at pc 0x634c and ends at 0x6350.

Мы также можем запросить (используя '*АДРЕС' как форму задания
УКАЗ-СТР), какая строка исходного текста соответствует определенному
адресу:

     (gdb) info line *0x63ff
     Line 926 of "builtin.c" starts at pc 0x63e4 and ends at 0x6404.

   После 'info line', адрес, используемый по умолчанию для команды 'x',
меняется на начальный адрес строки, так что 'x/i' достаточно для начала
исследования машинного кода (*note Исследование памяти: Память.).  Этот
адрес также сохраняется как значение вспомогательной переменной '$_'
(*note Вспомогательные переменные: Вспомогательные переменные.).

'disassemble'
     Эта специализированная команда служит для дампа диапазона памяти в
     виде машинных инструкций.  Диапазоном памяти по умолчанию является
     функция, в которой находится счетчик программы в выбранном кадре.
     Одиночным параметром этой команды является значение счетчика
     программы; GDB выводит дамп функции, которой принадлежит указанный
     адрес.  Два параметра определяют диапазон адресов для дампа (первый
     включается, второй исключается).

   Следующий пример показывает результат дисассемблирования диапазона
адресов кода HP PA-RISC 2.0:

     (gdb) disas 0x32c4 0x32e4
     Dump of assembler code from 0x32c4 to 0x32e4:
     0x32c4 <main+204>:      addil 0,dp
     0x32c8 <main+208>:      ldw 0x22c(sr0,r1),r26
     0x32cc <main+212>:      ldil 0x3000,r31
     0x32d0 <main+216>:      ble 0x3f8(sr4,r31)
     0x32d4 <main+220>:      ldo 0(r31),rp
     0x32d8 <main+224>:      addil -0x800,dp
     0x32dc <main+228>:      ldo 0x588(r1),r26
     0x32e0 <main+232>:      ldil 0x3000,r31
     End of assembler dump.

   Некоторые архитектуры имеют несколько широко используемых наборов
мнемоник инструкций или другой синтаксис.

'set disassembly-flavor НАБОР-ИНСТРУКЦИЙ'
     Выбрать набор инструкций для использования при дисассемблировании
     программы командами 'disassemble' и 'x/i'.

     В настоящее время эта команда определена только для Intel x86.  Вы
     можете установить НАБОР-ИНСТРУКЦИЙ в 'intel' или 'att'.  По
     умолчанию установлено 'att', диалект AT&T используется по умолчанию
     ассемблерами Unix на архитектурах, базирующихся на x86.


File: gdb.html,  Node: Данные,  Next: Языки,  Prev: Исходные файлы,  Up: Top

8 Исследование данных
*********************

Для исследования данных в вашей программе обычно используется команда
'print' (сокращенно 'p') или ее синоним 'inspect'.  Она вычисляет и
выводит значение выражения, записанного на том же языке, что и ваша
программа (*note Использование GDB с различными языками: Языки.).

'print ВЫРАЖ'
'print /F ВЫРАЖ'
     ВЫРАЖ является выражением (на исходном языке).  По умолчанию,
     значение ВЫРАЖ выводится в формате, соответствующем его типу
     данных; вы можете выбрать другой формат, указав '/F', где F --
     буква, определяющая формат; смотрите *note Форматы вывода: Форматы
     вывода.

'print'
'print /F'
     Если вы опустите ВЫРАЖ, GDB отображает последнее значение снова (из
     "истории значений"; *note История значений: История значений.).
     Это предоставляет вам удобный способ изучить то же самое значение в
     другом формате.

   Команда 'x' позволяет исследовать данные на более низком уровне.  Она
исследует данные в памяти по указанному адресу и выводит их в указанном
формате.  *Note Исследование памяти: Память.

   Если вас интересует информация о типах или о том, как объявлены поля
структуры или класса, используйте команду 'ptype ВЫРАЖ' вместо 'print'.
*Note Исследование таблицы символов: Символы.

* Menu:

* Выражения::                   Выражения
* Переменные::                  Переменные программы
* Массивы::                     Искусственные массивы
* Форматы вывода::              Форматы вывода
* Память::                      Исследование памяти
* Автоматическое отображение::  Автоматическое отображение
* Параметры вывода::            Параметры вывода
* История значений::            История значений
* Вспомогательные переменные::  Вспомогательные переменные
* Регистры::                    Регистры
* Вычисления с плавающей точкой::
                                Аппаратные средства поддержки вычислений
                                с плавающей точкой


File: gdb.html,  Node: Выражения,  Next: Переменные,  Up: Данные

8.1 Выражения
=============

'print' и многие другие команды GDB принимают в качестве параметра
выражение и вычисляют его значение.  В выражении GDB допустимо
использование любого типа констант, переменных или операторов,
определенных в используемом вами языке программирования, включая
условные выражения, вызовы функций, приведение типов и строковые
постоянные.  К сожалению, исключением являются символы, определенные
командами препроцессора '#define'.

   GDB поддерживает константы-массивы в выражениях, введенных
пользователем.  Синтаксис следующий: {ЭЛЕМЕНТ, ЭЛЕМЕНТ...}.  Например,
вы можете использовать команду 'print {1, 2, 3}', чтобы создать в памяти
массив, который будет доступен в программе так же, как выделенный
функцией 'malloc'.

   По причине широкого распространения Си, большинство выражений в
примерах этого руководства написаны на Си.  *Note Использование GDB с
различными языками: Языки, для информации об использовании выражений в
других языках.

   В этом разделе мы обсуждаем операторы, которые вы можете использовать
в выражениях GDB независимо от используемого вами языка
программирования.

   Приведения типов поддерживается во всех языках, а не только в Си, так
как бывает очень полезно преобразовать число в указатель, чтобы
исследовать структуру, расположенную по этому адресу в памяти.

   GDB поддерживает эти операторы, в дополнении к следующим, являющимися
общими для языков программирования:

'@'
     '@' является бинарным оператором, позволяющим рассматривать области
     памяти как массивы.  *Note Исскуственные массивы: Массивы, для
     дополнительной информации.

'::'
     '::' позволяет вам указывать переменную в терминах файла или
     функции, где она определена.  *Note Переменные программы:
     Переменные.

'{ТИП} АДРЕС'
     Ссылается на объект типа ТИП, хранящийся в памяти по адресу АДРЕС.
     АДРЕС может быть любым выражением, значением которого является
     целое число или указатель (но вокруг бинарных операторов, также как
     и вокруг оператора приведения типа, требуются скобки).  Эта
     конструкция допустима вне зависимости от того, какого типа данные
     предположительно расположены по АДРЕСУ.


File: gdb.html,  Node: Переменные,  Next: Массивы,  Prev: Выражения,  Up: Данные

8.2 Переменные программы
========================

Чаще всего в качестве выражения используется имя переменной вашей
программы.

   Переменные в выражениях трактуются в контексте выбранного кадра стека
(*note Выбор кадра стека: Выбор.); они могут быть либо

   * глобальными (или статическими)

либо

   * видимыми из точки выполнения в данном кадре, в соответствии с
     правилами определения области видимости языка программирования.

Это означает, что в функции

     foo (a)
          int a;
     {
       bar (a);
       {
         int b = test ();
         bar (b);
       }
     }

вы можете исследовать и использовать переменную 'a' всякий раз, когда
ваша программа выполняется в пределах функции 'foo', но переменную 'b'
можно использовать или исследовать только тогда, когда ваша программа
выполняется внутри блока, в котором она объявлена.

   Есть исключение: вы можете ссылаться на переменную или функцию,
областью видимости которой является единственный исходный файл, даже
если точка текущего выполнения в нем не находится.  Допускается
существование нескольких переменных или функций с одинаковым именем (в
различных исходных файлах).  Если это так, обращение к этому имени
приводит к непредсказуемым результатам.  Если хотите, вы можете указать
статическую переменную в конкретной функции или в файле, используя
двойное двоеточие:

     ФАЙЛ::ПЕРЕМЕННАЯ
     ФУНКЦИЯ::ПЕРЕМЕННАЯ

Здесь ФАЙЛ или ФУНКЦИЯ -- название контекста для статической ПЕРЕМЕННОЙ.
В первом случае вы можете использовать кавычки, чтобы GDB рассматривал
имя файла как одно слово; например, чтобы вывести глобальное значение
переменной 'x', определенной в 'f2.c':

     (gdb) p 'f2.c'::x

   Такое использование '::' крайне редко конфликтует с похожим
использованием той же записи в Си++.  GDB также поддерживает
использование оператора определения области видимости Си++ в выражениях.

     _Предупреждение:_ В некоторых случаях, в определенной точке функции
     (сразу после входа в новую область видимости и непосредственно
     перед выходом из нее) может показаться, что локальная переменная
     имеет неверное значение.

   Вы можете столкнуться с этой проблемой при пошаговом выполнении по
одной машинной инструкции.  Она возникает из-за того, что на большинстве
машин процедура установки кадра стека (включая определения локальных
переменных) занимает более одной инструкции; если вы производите
пошаговое выполнение по одной машинной инструкции, может показаться, что
переменная имеет неверное значение, пока кадр стека не будет полностью
построен.  При выходе, для уничтожения кадра стека обычно также
требуется более одной инструкции; после начала пошагового выполнения
этой группы инструкций определения локальных переменных могут пропасть.

   Это также может случиться, когда компилятор делает значительную
оптимизацию.  Чтобы быть уверенным, что вы всегда видите точные
значения, отключите всю оптимизацию при компиляции.

   Другой возможный эффект оптимизации компилятора заключается в
уничтожении неиспользуемых переменных или в присвоении переменных
регистрам (а не адресам памяти).  В зависимости от поддержки таких
ситуаций, предоставляемой форматом отладочной информации, который
использует компилятор, GDB может не вывести значения таких локальных
переменных.  Если это происходит, GDB выведет сообщение, подобное этому:

     No symbol "foo" in current context.

   Для решения таких проблем или перекомпилируйте программу без
оптимизации, или используйте другой формат отладочной информации, если
компилятор поддерживает несколько таких форматов.  Например GCC,
компилятор GNU Си/Си++, обычно поддерживает ключ '-gstabs'.  '-gstabs'
создает отладочную информацию в формате, являющимся развитием таких
форматов, как COFF. У вас может быть возможность использовать DWARF2
('-gdwarf-2'), который тоже является эффективной формой представления
отладочной информации.  Смотрите *note Ключи для отладки вашей программы
или GNU CC: (gcc.info)Ключи для отладки, для дополнительной информации.


File: gdb.html,  Node: Массивы,  Next: Форматы вывода,  Prev: Переменные,  Up: Данные

8.3 Искусственные массивы
=========================

Часто бывает полезным вывести несколько объектов одного типа,
расположенных в памяти последовательно; часть массива или динамический
массив, для которого в программе существует только указатель.

   Вы можете это сделать, обращаясь к непрерывному участку памяти как к
"искусственному массиву", используя бинарный оператор '@'.  Левым
операндом для '@' должен быть первый элемент желаемого массива, и он
должен быть индивидуальным объектом.  Правым операндом должна быть длина
массива.  Результатом операции будет массив, все элементы которого имеют
тот же тип, что и левый аргумент.  Первым элементом массива является
левый аргумент; второй элемент формируется из байтов памяти,
непосредственно следующих за байтами, содержащими первый элемент, и так
далее.  Например, если в программе есть строка

     int *array = (int *) malloc (len * sizeof (int));

то вы можете вывести содержимое 'array' с помощью

     p *array@len

   Левый операнд операции '@' должен находиться в памяти.  Значения
массивов, полученных операцией '@', при индексации ведут себя точно так
же, как и другие массивы, и приводятся к указателям при использовании в
выражениях.  Искусственные массивы чаще всего появляются в выражениях
через историю значений (*note История значений: История значений.),
после вывода одного из них.

   Другой способ создания искусственного массива -- использование
приведения типов.  Оно заново интерпретирует значение так, как если бы
оно было массивом.  Значение не обязано находиться в памяти.

     (gdb) p/x (short[2])0x12345678
     $1 = {0x1234, 0x5678}

   Если вы опускаете длину массива (как в '(ТИП[])ЗНАЧЕНИЕ'), GDB для
удобства вычисляет его размер для заполнения значениями (как
'sizeof(ЗНАЧЕНИЕ)/sizeof(ТИП)':

     (gdb) p/x (short[])0x12345678
     $2 = {0x1234, 0x5678}

   Иногда механизма искусственных массивов бывает недостаточно; в
сравнительно сложных структурах данных интересующие нас элементы могут
не быть смежными -- например, если вас интересуют значения указателей в
массиве.  Одно из удачных решений этой проблемы -- использование
вспомогательной переменной (*note Вспомогательные переменные:
Вспомогательные переменные.) в качестве счетчика в выражении, выводящем
первое интересующее нас значение, а затем повторять это выражение
нажатием <RET>.  Предположим, например, у вас есть массив 'dtab'
указателей на структуры, и вас интересуют значения полей 'fv' в каждой
структуре.  Ниже приведен пример ваших возможных действий:

     set $i = 0
     p dtab[$i++]->fv
     <RET>
     <RET>
     ...


File: gdb.html,  Node: Форматы вывода,  Next: Память,  Prev: Массивы,  Up: Данные

8.4 Форматы вывода
==================

По умолчанию, GDB печатает значение в соответствии с его типом.  Это не
всегда отвечает вашему желанию.  Например, вы можете захотеть вывести
число в шестнадцатеричной записи или указатель в десятичной.  Или вы
можете захотеть просмотреть данные по некоторому адресу в памяти в виде
строки знаков или в виде инструкций.  Для этого при выводе значения
задайте "формат вывода".

   Простейшим применением форматов вывода является форматирование вывода
уже вычисленного выражения.  Чтобы сделать это, начните параметры
команды 'print' с косой черты и символа формата.  Поддерживаются
следующие символы формата:

'x'
     Рассматривать биты значения как целое и вывести целое в
     шестнадцатеричном виде.

'd'
     Вывести как десятичное целое со знаком.

'u'
     Вывести как десятичное целое без знака.

'o'
     Вывести как восьмеричное целое.

't'
     Вывести как целое в двоичном виде.  Буква 't' означает "two".  (1)

'a'
     Вывести в виде адреса, как абсолютного в шестнадцатеричной записи,
     так и в виде смещения от ближайшего предшествующего символа.  Вы
     можете использовать этот формат, чтобы определить, где (в какой
     функции) расположен какой-либо неизвестный адрес:

          (gdb) p/a 0x54320
          $3 = 0x54320 <_initialize_vx+396>

'c'
     Рассматривать как целое и вывести в виде строковой постоянной.

'f'
     Рассматривать биты значения как число с плавающей точкой и вывести
     с использованием обычного синтаксиса для этих чисел.

   Например, чтобы вывести счетчик программы в шестнадцатеричном виде
(*note Регистры::), введите

     p/x $pc

Обратите внимание, что перед косой чертой не требуется пробела, потому
что имена команд в GDB не могут содержать косую черту.

   Чтобы вывести последнее значение из истории значений в другом
формате, вы можете воспользоваться командой 'print' лишь с указанием
формата и без выражения.  Например, 'p/x' выведет последнее значение в
шестнадцатеричной форме.

   ---------- Footnotes ----------

   (1) 'b' не может быть использовано, потому что эти символы формата
также используются с командой 'x', где 'b' означает "byte"; смотрите
*note Исследование памяти: Память.


File: gdb.html,  Node: Память,  Next: Автоматическое отображение,  Prev: Форматы вывода,  Up: Данные

8.5 Исследование памяти
=======================

Вы можете использовать команду 'x' (от слова "examine") для исследования
памяти в одном из нескольких форматов, независимо от типов данных вашей
программы.

'x/NFU АДРЕС'
'x АДРЕС'
'x'
     Для исследования памяти используйте команду 'x'.

   N, F и U -- необязательные параметры, определяющие, сколько памяти
отобразить и в каком формате; АДРЕС -- это выражение, задающее адрес, с
которого вы хотите начать отображение памяти.  Если вы используете
значения по умолчанию для NFU, то вам не нужно вводить косую черту '/'.
Некоторые команды устанавливают удобные значения по умолчанию для
АДРЕСА.

N, счетчик повторений
     Счетчик повторений является десятичным целым числом; по умолчанию
     1.  Он определяет, сколько памяти отобразить (считая в единицах U).

F, формат отображения
     Формат отображения -- это один из форматов, используемых командой
     'print', 's' (строка, оканчивающаяся нулем), или 'i' (машинная
     инструкция).  Первоначально, значением по умолчанию установлено 'x'
     (шестнадцатеричная форма).  Значение по умолчанию изменяется каждый
     раз, когда вы используете либо 'x', либо 'print'.

U, размер единицы измерений
     Размер единицы измерений может быть одним из

     'b'
          Байты.
     'h'
          Полуслова (два байта).
     'w'
          Слова (четыре байта).  Это первоначальное значение по
          умолчанию.
     'g'
          Длинные слова (восемь байт).

     Каждый раз, когда вы определяете размер единицы измерений командой
     'x', этот размер становится размером по умолчанию при последующем
     использовании 'x'.  (Для форматов 's' и 'i' размер единицы
     измерений игнорируется и обычно не пишется.)

АДРЕС, начальный адрес отображения
     АДРЕС -- это адрес, с которого вы хотите, чтобы GDB начинал
     отображение памяти.  Значение выражения не обязано должно быть
     указателем (хотя может им быть); оно всегда интерпретируется как
     целый адрес байта в памяти.  *Note Выражения: Выражения, для
     дополнительной информации о выражениях.  Значением по умолчанию для
     АДРЕСА обычно является адрес, следующий за последним изученным
     адресом, но некоторые другие команды также устанавливают это
     значение: 'info breakpoints' (в адрес последней выведенной точки
     останова), 'info line' (в начальный адрес строки) и 'print' (если
     вы используете эту команду для отображения значения из памяти).

   Например, 'x/3uh 0x54320' -- запрос на вывод трех полуслов ('h')
памяти в формате беззнаковых десятичных целых ('u'), начиная с адреса
'0x54320'.  'x/4xw $sp' выводит четыре слова ('w') памяти, расположенные
над указателем стека (здесь '$sp'; *note Регистры: Регистры.), в
шестнадцатеричном виде ('x').

   Так как все буквы, обозначающие размер единиц измерения, отличаются
от букв, определяющих форматы вывода, вы не должны запоминать, формат
или размер единиц измерений указывается раньше; это можно делать в любом
порядке.  Спецификации вывода '4xw' и '4wx' означают в точности одно и
то же.  (Однако, число N должно быть первым; 'wx4' не сработает.)

   Хотя размер единицы измерения U игнорируется для форматов 's' и 'i',
вы, тем не менее, можете воспользоваться счетчиком повторений N;
например, '3i' указывает, что вы хотите вывести три машинные инструкции,
включая любые операнды.  Команда 'disassemble' предоставляет
альтернативный способ исследования машинных инструкций; смотрите *note
Исходный и машинный код: Машинный код.

   Все значения по умолчанию для аргументов команды 'x' разработаны
таким образом, чтобы облегчить продолжение сканирования памяти с
минимальными конкретизациями при очередном использовании 'x'.  Например,
после того, как вы просмотрели три машинные инструкции с помощью 'x/3i
АДРЕС', вы можете просмотреть следующие семь, используя просто 'x/7'.
Если вы повторяете команду 'x' нажатием <RET>, число повторений N
остается прежним; другие параметры берутся по умолчанию, как для
последовательных использований 'x'.

   Адреса и их содержимое, выводимые командой 'x', не сохраняются в
истории значений, так как они мешали бы.  Вместо этого, GDB делает их
доступными для последующего использования в выражениях как значения
вспомогательных переменных '$_' и '$__'.  После команды 'x', последний
исследованный адрес доступен для использования в выражениях во
вспомогательной переменной '$_'.  Содержимое этого адреса, исследованное
только что, доступно во вспомогательной переменной '$__'.

   Если команде 'x' задан счетчик повторений, адрес и его содержимое
сохраняются из последнего выведенного элемента памяти; это не то же
самое, что последний выведенный адрес, если в последней строке вывода
были отображены несколько элементов.


File: gdb.html,  Node: Автоматическое отображение,  Next: Параметры вывода,  Prev: Память,  Up: Данные

8.6 Автоматическое отображение
==============================

Если вам необходимо часто выводить значение какого-либо выражения (чтобы
увидеть, как оно меняется), вы можете добавить его в "список
автоматического отображения", чтобы GDB выводил его значение каждый раз
при остановке вашей программы.  Каждому выражению, добавленному в
список, присваивается идентификационный номер; чтобы удалить выражение
из списка, вы указываете этот номер.  Автоматическое отображение
выглядит следующим образом:

     2: foo = 38
     3: bar[5] = (struct hack *) 0x3804

Это отображение показывает номера элементов, выражения и их текущие
значения.  Как и при отображении, запрашиваемом вручную с помощью 'x'
или 'print', вы можете указать предпочитаемый формат вывода; фактически,
'display' выбирает между 'print' и 'x' в зависимости от того, насколько
детально задана спецификация формата: 'x' используется, если вы
указываете размер элемента или один из двух форматов ('i' и 's'),
которые поддерживаются только 'x'; в остальных случаях применяется
'print'.

'display выраж'
     Добавляет выражение ВЫРАЖ к списку выражений, отображаемых каждый
     раз, когда ваша программа останавливается.  *Note Выражения:
     Выражения.

     'display' не повторяется, если вы повторно нажимаете <RET> после ее
     использования.

'display/ФОРМАТ ВЫРАЖ'
     Если ФОРМАТ определяет только формат вывода, а не размер или
     счетчик повторений, выражение ВЫРАЖ добавляется в список
     автоматического отображения, но его отображение осуществляется в
     указанном формате ФОРМАТ.  *Note Форматы вывода: Форматы вывода.

'display/ФОРМАТ АДРЕС'
     Если ФОРМАТОМ является 'i' или 's', или он включает в себя размер
     элементов или их число, выражение АДРЕС добавляется как адрес
     памяти для исследования при каждой остановке вашей программы.  Под
     исследованием в данном случае подразумевается выполнение 'x/ФОРМАТ
     АДРЕС'.  *Note Исследование памяти: Память.

   Например, команда 'display/i $pc' может быть полезна, чтобы при
каждой остановке видеть машинную инструкцию, которая будет выполняться
следующей ('$pc' -- это общее обозначение счетчика программы; *note
Регистры: Регистры.).

'undisplay НОМЕРА...'
'delete display НОМЕРА...'
     Удалить элементы с номерами НОМЕРА из списка выражений, подлежащих
     отображению.

     'undisplay' не повторяется при последующем нажатии <RET>.  (Иначе
     вы сразу получили бы сообщение об ошибке 'No display number ...'.)

'disable display НОМЕРА...'
     Отключить отображение элементов с номерами НОМЕРА.  Отключенные
     элементы не выводятся автоматически, но и не забываются.
     Впоследствии их можно снова включить.

'enable display НОМЕРА...'
     Включить отображение элементов с номерами НОМЕРА.  Выражения,
     соответствующие этим номерам, снова будут выводиться автоматически,
     пока вы не укажете обратное.

'display'
     Отобразить текущие значения выражений из списка, точно так же, как
     это происходит при остановке вашей программы.

'info display'
     Вывести список выражений, ранее установленных для автоматического
     отображения, каждое с его номером элемента, но не показывая
     значений.  Список включает отключенные выражения, с соответствующей
     пометкой.  Он также включает в себя выражения, которые не могут
     быть показаны прямо сейчас, потому что обращаются к автоматическим
     переменным, недоступным в данный момент.

   Если отображаемое выражение обращается к локальным переменным, оно не
имеет смысла вне того лексического контекста, для которого оно
устанавливалось.  Такое выражения отключается, как только выполнение
входит в контекст, где одна из его переменных становится неопределенной.
Например, если вы дадите команду 'display last_char', находясь внутри
функции с аргументом 'last_char', GDB будет отображать этот аргумент,
пока программа останавливается внутри этой функции.  Как только она
остановится где-то еще -- где нет переменной 'last_char' -- отображение
будет отключено автоматически.  Вы можете снова включить его при
следующей остановке программы там, где 'last_char' будет вновь иметь
смысл.


File: gdb.html,  Node: Параметры вывода,  Next: История значений,  Prev: Автоматическое отображение,  Up: Данные

8.7 Параметры вывода
====================

GDB предоставляет следующие способы управления выводом массивов,
структур и символов.

Данные параметры полезны при отладке программ на любом языке:

'set print address'
'set print address on'
     GDB выводит адреса памяти, показывающие положение стека, структур,
     указателей, точек останова и так далее, даже когда он отображает
     также содержимое этих адресов.  Значение по умолчанию установлено в
     'on'.  Например, вот как выглядит отображение кадра стека с
     установленным 'set print address on':

          (gdb) f
          #0  set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
              at input.c:530
          530         if (lquote != def_lquote)

'set print address off'
     Не выводить адреса при отображении их содержимого.  Вот, например,
     тот же кадр стека, отображенный с установкой 'set print address
     off':

          (gdb) set print addr off
          (gdb) f
          #0  set_quotes (lq="<<", rq=">>") at input.c:530
          530         if (lquote != def_lquote)

     Вы можете использовать 'set print address off', чтобы удалить все
     машинно-зависимые отображения из интерфейса GDB. Например, с 'print
     address off', вы должны получить одинаковый текст для цепочек
     вызовов на всех машинах, независимо от того, включают они указатели
     в качестве аргументов или нет.

'show print address'
     Показать, должны выводиться адреса или нет.

   При выводе адреса в символьной форме, GDB обычно выводит ближайший
предшествующий символ плюс смещение.  Если этот символ не определяет
адрес однозначно (например, это имя, областью действия которого является
один исходный файл), вам может потребоваться дать пояснения.  Один из
способов это сделать -- с помощью 'info line'; например, 'info line
*0x4537'.  Альтернативный способ заключается в том, чтобы GDB выводил
имя исходного файла и номер строки при выводе символьного адреса:

'set print symbol-filename on'
     Велит GDB выводить имя исходного файла и номер строки символа в
     символьной форме адреса.

'set print symbol-filename off'
     Не выводить имя исходного файла и номер строки символа.
     Принимается по умолчанию.

'show print symbol-filename'
     Показать, будет GDB выводить имя исходного файла и номер строки в
     символьной форме адреса или нет.

   Другая ситуация, в которой полезно показывать имена файлов и номера
строк, возникает при дисассемблировании кода; GDB показывает вам номер
строки и исходный файл, которые соответствуют каждой инструкции.

   Вы также можете захотеть видеть символьную форму только в том случае,
если выводимый адрес достаточно близок к ближайшему предшествующему
символу:

'set print max-symbolic-offset МАКС-СМЕЩЕНИЕ'
     Велит GDB выводить символьные формы только тех адресов, для которых
     смещение между ближайшим предшествующим символом и адресом меньше,
     чем МАКС-СМЕЩЕНИЕ.  По умолчанию значение МАКС-СМЕЩЕНИЕ равно 0; в
     этом случае GDB всегда выводит адрес в символьной форме, если ему
     предшествует хоть какой-нибудь символ.

'show print max-symbolic-offset'
     Запрашивает информацию о максимальном смещении, для которого GDB
     выводит символьную форму адреса.

   Если у вас есть указатель, и вы не знаете, на что он указывает,
попробуйте 'set print symbol-filename on'.  Затем вы можете определить
название и исходный файл переменной, на которую он указывает, используя
'p/a УКАЗАТЕЛЬ'.  Это интерпретирует адрес в символьной форме.
Например, здесь GDB показывает, что переменная 'ptt' указывает на другую
переменную 't', определенную в файле 'hi2.c':

     (gdb) set print symbol-filename on
     (gdb) p/a ptt
     $4 = 0xe008 <t in hi2.c>

     _Предупреждение:_ Для указателей, ссылающихся на локальные
     переменные, 'p/a' не показывает символьное имя и имя файла,
     которому принадлежит объект ссылки, даже если установлен
     соответствующий параметр 'set print'.

   Другие установки управляют выводом объектов различных типов:

'set print array'
'set print array on'
     Структурный вывод массивов.  Этот формат удобнее для чтения, но
     занимает больше места.  По умолчанию отключено.

'set print array off'
     Вернуться к сжатому формату вывода массивов.

'show print array'
     Показать, какой формат (сжатый или структурный) выбран для
     отображения массивов.

'set print elements ЧИСЛО-ЭЛЕМЕНТОВ'
     Установить ограничение на количество выводимых GDB элементов
     массива.  Если GDB выводит большой массив, вывод прерывается после
     того, как будет выведено установленное командой 'set print
     elements' число элементов.  Это ограничение также действует при
     отображении строк.  Когда GDB стартует, этот предел принимается
     равным 200.  Установка ЧИСЛО-ЭЛЕМЕНТОВ в ноль означает, что вывод
     не ограничен.

'show print elements'
     Показать количество элементов большого массива, которые будут
     выведены GDB. Если это число равно 0, вывод не ограничивается.

'set print null-stop'
     Указывает GDB прекращать вывод знаков массива, как только
     встретится первый NULL.  Это полезно, когда большие массивы
     фактически содержат только короткие строки.  По умолчанию
     отключено.

'set print pretty on'
     Велит GDB выводить структуры в формате с отступами, по одному
     элементу в строке, например:

          $1 = {
            next = 0x0,
            flags = {
              sweet = 1,
              sour = 1
            },
            meat = 0x54 "Pork"
          }

'set print pretty off'
     Указывает GDB выводить структуры в компактном формате, как здесь:

          $1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
          meat = 0x54 "Pork"}

     Этот формат устанавливается по умолчанию.

'show print pretty'
     Показать, какой формат GDB использует для вывода структур.

'set print sevenbit-strings on'
     Осуществлять вывод, используя только семибитные знаки; если этот
     параметр установлен, GDB отображает любые восьмибитные знаки (в
     строках или знаковых значениях), используя запись '\'NNN.  Эта
     установка очень удобна, если вы работаете на английском (ASCII) и
     используете старший бит знаков как маркер или "мета"-бит.

'set print sevenbit-strings off'
     Выводить восьмибитные знаки полностью.  Это позволяет использовать
     большее количество международных наборов знаков; устанавливается по
     умолчанию.

'show print sevenbit-strings'
     Показать, выводит GDB только семибитные литеры или нет.

'set print union on'
     Велит GDB выводить объединения, содержащиеся в структурах.
     Устанавливается по умолчанию.

'set print union off'
     Указывает GDB не выводить объединения, содержащиеся в структурах.

'show print union'
     Запросить GDB, будет ли он выводить объединения, содержащиеся в
     структурах.

     Например, пусть даны описания

          typedef enum {Tree, Bug} Species;
          typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
          typedef enum {Caterpillar, Cocoon, Butterfly}
                        Bug_forms;

          struct thing {
            Species it;
            union {
              Tree_forms tree;
              Bug_forms bug;
            } form;
          };

          struct thing foo = {Tree, {Acorn}};

     с установленным 'set print union on', команда 'p foo' выведет

          $1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}

     а с установленным 'set print union off', эта же команда выведет

          $1 = {it = Tree, form = {...}}

Следующие установки представляют интерес при отладке программ на Си++:

'set print demangle'
'set print demangle on'
     Печатать идентификаторы Си++ в их изначальной, а не в
     закодированной ("искаженной") форме, передаваемой ассемблеру и
     компоновщику для сборки с контролем типа.  Установлено по
     умолчанию.

'show print demangle'
     Показать, в искаженной или восстановленной форме выводятся
     идентификаторы Си++.

'set print asm-demangle'
'set print asm-demangle on'
     Выводить идентификаторы Си++ в их исходной форме, а не в
     искаженной, даже при выводе ассемблерного кода, например при
     дисассемблировании инструкций.  По умолчанию отключено.

'show print asm-demangle'
     Показать, в закодированной или восстановленной форме выводятся
     имена Си++ при выводе кода ассемблера.

'set demangle-style СТИЛЬ'
     Выбрать одну из нескольких схем кодирования, используемых
     различными компиляторами для представления имен Си++.  Параметр
     СТИЛЬ может быть следующим:

     'auto'
          Позволить GDB выбрать стиль декодирования посредством изучения
          вашей программы.

     'gnu'
          Декодирование основывается на алгоритме кодирования
          компилятора GNU Си++ ('g++').  Устанавливается по умолчанию.

     'hp'
          Декодирование основывается на алгоритме кодирования HP ANSI
          Си++ ('aCC').

     'lucid'
          Декодирование основывается на алгоритме кодирования
          компилятора Lucid Си++ ('lcc').

     'arm'
          Декодировать, используя алгоритм из 'C++ Annotated Reference
          Manual'.  *Предупреждение:* одной этой установки недостаточно,
          чтобы производить отладку исполняемых программ,
          сгенерированных 'cfront'.  Чтобы реализовать это, GDB требует
          дальнейших усовершенствований.

     Если вы опустите СТИЛЬ, то увидите список возможных форматов.

'show demangle-style'
     Отобразить текущий стиль кодирования, используемый для
     декодирования символов Си++.

'set print object'
'set print object on'
     При отображении указателя на объект, идентифицировать _фактический_
     (производный), а не _объявленный_ тип объекта, используя таблицу
     виртуальных функций.

'set print object off'
     Отображать только объявленный тип объекта, не ссылаясь на таблицу
     виртуальных функций.  Устанавливается по умолчанию.

'show print object'
     Показать, какой из типов объекта выводится.

'set print static-members'
'set print static-members on'
     Выводить статические члены при отображении объекта Си++.
     Установлено по умолчанию.

'set print static-members off'
     Не выводить статические члены при отображении объекта Си++.

'show print static-members'
     Показать, выводятся статические члены Си++ или нет.

'set print vtbl'
'set print vtbl on'
     Осуществлять структурный вывод таблиц виртуальных функций Си++.  По
     умолчанию отключено.  (Команды 'vtbl' не работают для программ,
     скомпилированных компилятором HP ANSI Си++ ('aCC').)

'set print vtbl off'
     Не производить структурного вывода таблиц виртуальных функций Си++.

'show print vtbl'
     Показать, производится структурный вывод таблиц виртуальных функций
     Си++ или нет.


File: gdb.html,  Node: История значений,  Next: Вспомогательные переменные,  Prev: Параметры вывода,  Up: Данные

8.8 История значений
====================

Значения, выведенные командой 'print', сохраняются в "истории значений"
GDB. Это позволяет вам обращаться к ним в других выражениях.  Значения
сохраняются, пока таблица символов не будет заново считана или
уничтожена (например, командами 'file' или 'symbol-file').  При
изменении таблицы символов история значений уничтожается, так как
значения могут содержать указатели на типы, определенные в таблице
символов.

   Выведенным значениям присваиваются "номера в истории", по которым вы
можете на них ссылаться.  Эти номера являются последовательными целыми
числами, начинающимися с единицы.  Команда 'print' показывает номер в
истории, присвоенный значению, выводя перед ним '$НОМЕР = ', где НОМЕР
-- это номер в истории.

   Для обращения к какому-либо предшествующему значению, используйте
'$', за которым следует номер в истории.  Способ, которым 'print'
маркирует вывод, продуман так, чтобы напоминать вам об этом.  Просто '$'
ссылается на самое последнее значение в истории, а '$$' -- на
предпоследнее.  '$$N' ссылается на N-е с конца значение; '$$2' --
значение, находящееся перед '$$', '$$1' эквивалентно '$$', а '$$0'
эквивалентно '$'.

   Предположим, например, вы только что вывели указатель на структуру и
хотите посмотреть ее содержимое.  Для этого достаточно ввести

     p *$

   Если у вас есть цепочка структур, где компонента 'next' указывает на
следующую, вы можете вывести содержимое следующей структуры так:

     p *$.next

Вы можете выводить последовательные звенья в цепочке повторяя эту
команду.  Это можно сделать простым нажатием <RET>.

   Обратите внимание на то, что в историю записываются значения, а не
выражения.  Если значение 'x' равно 4, и вы наберете:

     print x
     set x=5

то значение, записанное в историю значений командой 'print', будет
по-прежнему равно 4, хотя значение 'x' изменилось.

'show values'
     Вывести из истории последние десять значений с их номерами.  Это
     похоже на команду 'p $$9', повторенную десять раз, за исключением
     того, что 'show values' не изменяет историю.

'show values N'
     Вывести десять значений из истории, расположенных вокруг элемента с
     номером N.

'show values +'
     Вывести десять значений из истории, следующих сразу после
     последнего выведенного значения.  Если доступных значений больше
     нет, 'show values +' не выводит ничего.

   Нажатие <RET> для повтора 'show values N' действует точно так же, как
'show values +'.


File: gdb.html,  Node: Вспомогательные переменные,  Next: Регистры,  Prev: История значений,  Up: Данные

8.9 Вспомогательные переменные
==============================

GDB предоставляет "вспомогательные переменные", которые вы можете в нем
использовать, чтобы сохранить значение и обратиться к нему позже.  Эти
переменные существуют только в GDB; они не являются частью вашей
программы, и установка вспомогательной переменной не оказывает
непосредственного влияния на ее дальшейшее выполнение.  Поэтому вы
можете пользоваться ими совершенно свободно.

   Имена вспомогательных переменных начинаются с '$'.  Любое имя с
приставкой '$' может использоваться для вспомогательной переменной, если
только оно не является предопределенным машинно-зависимым именем
регистра, (*note Регистры: Регистры.).  (Ссылки на историю значений,
напротив, есть _числа_, которым предшествует '$'.  *Note История
значений: История значений.)

   Вы можете сохранить значение во вспомогательной переменной с помощью
выражения присваивания, как если бы вы устанавливали переменную в вашей
программе.  Например:

     set $foo = *object_ptr

сохранит в '$foo' значение объекта, на который указывает 'object_ptr'.

   Первое использование вспомогательной переменной создает ее, но
значением переменной будет 'void', пока вы не присвоите ей новое.  С
помощью другого присваивания вы можете в любое время изменить значение.

   Вспомогательные переменные не имеют фиксированного типа.  Вы можете
присваивать вспомогательной переменной значение любого типа, включая
структуры и массивы, даже если у этой переменной уже было значение
другого типа.  Будучи использованной в выражении, вспомогательная
переменная имеет тип своего текущего значения.

'show convenience'
     Вывести список используемых вспомогательных переменных с их
     значениями.  Сокращается как 'show conv'.

   Один из способов использования вспомогательных переменных -- в
качестве увеличивающегося счетчика или продвигающегося указателя.
Например, чтобы напечатать поле из последовательных элементов массива
структур:

     set $i = 0
     print bar[$i++]->contents

Повторяйте эту команду нажатием <RET>.

   Некоторые вспомогательные переменные создаются GDB автоматически, и
им присваиваются значения, которые вероятно могут оказаться полезными.

'$_'
     Переменная '$_' устанавливается автоматически командой 'x' в
     последний исследованный адрес (*note Исследование памяти: Память.).
     Другие команды, которые устанавливают адрес по умолчанию для
     исследования командой 'x', также присваивают '$_' упомянутый адрес;
     эти команды включают 'info line' и 'info breakpoint'.  Переменная
     '$_' имеет тип 'void *', если только она не установлена командой
     'x'; в этом случае она является указателем на тип переменной '$__'.

'$__'
     Переменная '$__' устанавливается автоматически командой 'x' в
     значение, находящееся по последнему исследованному адресу.  Ее тип
     выбирается соответствующим формату, в котором это значение было
     выведено.

'$_exitcode'
     Переменной '$_exitcode' автоматически присваивается код завершения,
     когда отлаживаемая программа завершается.

   В системах HP-UX, если вы ссылаетесь на функцию или переменную, чье
имя начинается со знака доллара, GDB сначала производит поиск
пользовательского или системного имени, перед поиском вспомогательной
переменной.


File: gdb.html,  Node: Регистры,  Next: Вычисления с плавающей точкой,  Prev: Вспомогательные переменные,  Up: Данные

8.10 Регистры
=============

В выражениях, вы можете обращаться к содержимому машинных регистров,
обозначая их как переменные с именами, начинающимся с '$'.  Имена
регистров различаются от машины к машине; для вывода имен регистров,
используемых на вашей машине, воспользуйтесь командой 'info registers'.

'info registers'
     Вывести имена и содержимое всех регистров, кроме регистров с
     плавающей точкой (в выбранном кадре стека).

'info all-registers'
     Вывести имена и содержимое всех регистров, включая регистры с
     плавающей точкой.

'info registers ИМЯ-РЕГ ...'
     Выводит "относительное" значение каждого из указанных в ИМЯ-РЕГ
     регистров.  Как подробно обсуждается ниже, значения регистров
     обычно относятся к выбранному кадру стека.  ИМЯ-РЕГ может быть
     любым допустимым на вашей машине именем регистра, с '$' в начале
     имени или без.

   GDB распознает четыре "стандартных" имени регистров, которые доступны
(в выражениях) на большинстве машин -- если только они не конфликтуют с
каноническим для архитектуры обозначением регистров.  Названия регистров
'$pc' и '$sp' используются для регистра счетчика программы и указателя
вершины стека.  '$fp' используется как имя регистра, содержащего
указатель на текущий кадр стека, а '$ps' -- как имя регистра,
содержащего состояние процессора.  Например, вы можете вывести счетчик
программы в шестнадцатеричной записи с помощью

     p/x $pc

или вывести следующую исполняемую инструкцию, используя

     x/i $pc

или увеличить указатель вершины стека на четыре(1) с помощью

     set $sp += 4

   Когда возможно, эти четыре стандартных имени регистров доступны на
вашей машине, даже если она имеет другую каноническую мнемонику, если не
возникает конфликта.  Команда 'info registers' показывает канонические
имена.  В SPARC, например, 'info registers' отображает регистр состояния
процессора как '$psr', но вы также можете называть его '$ps'; а на
машинах, базирующихся на платформе x86, '$ps' является синонимом для
регистра EFLAGS.

   Когда регистр изучается таким образом, GDB всегда рассматривает
содержимое обычного регистра как целое.  Некоторые машины имеют
специальные регистры, которые могут содержать только значение с
плавающей точкой; их значения трактуются как величины с плавающей
точкой.  Не существует способа сослаться на содержимое обычного регистра
как на величину с плавающей точкой (хотя вы можете распечатать его
значение командой _print_ как величину с плавающей точкой, используя
'print/f $ИМЯ-РЕГ').

   Некоторые регистры имеют различные "необработанные" и "виртуальные"
форматы данных.  Это означает, что формат данных, в котором операционная
система сохраняет содержимое регистра, не совпадает с тем, который
обычно воспринимается вашей программой.  Например, регистры сопроцессора
с плавающей точкой 68881 всегда сохраняются в "расширенном"
(необработанном) формате, но все программы на Си работают с "двойным"
(виртуальным) форматом.  В подобных случаях, GDB обычно работает только
с виртуальным форматом (форматом, имеющим смысл в вашей программе), но
команда 'info registers' выводит данные в обоих форматах.

   Обычно значения регистров относятся к выбранному кадру стека (*note
Выбор кадра: Выбор.).  Это значит, что вы получаете значение, которое
содержалось бы в регистре, если бы произошел выход из всех внутренних
кадров стека, и их сохраненные регистры были бы восстановлены.  Для
того, чтобы увидеть истинное содержимое аппаратных регистров, вы должны
выбрать самый внутренний кадр (с помощью 'frame 0').

   Однако, GDB, исходя из машинного кода, сгенерированного вашим
компилятором, должен установить, где сохранены регистры.  Если некоторые
регистры не сохранены, или если GDB не в состоянии найти сохраненные
регистры, выбранный кадр стека не имеет значения.

   ---------- Footnotes ----------

   (1) На машинах, где стек растет вниз в памяти (в наши дни, на
большинстве машин), это способ удалить одно слово из стека.  Это
подразумевает, что выбран самый внутренний кадр; когда выбраны другие
кадры стека, установка '$sp' не разрешена.  Используйте 'return' для
извлечения целого кадра из стека, вне зависимости от архитектуры машины;
смотрите *note Возврат из функции: Возврат.


File: gdb.html,  Node: Вычисления с плавающей точкой,  Prev: Регистры,  Up: Данные

8.11 Аппаратные средства поддержки вычислений с плавающей точкой
================================================================

В зависимости от конфигурации, GDB может выдать вам больше информации о
состоянии аппаратных средств поддержки вычислений с плавающей точкой.

'info float'
     Отобразить аппаратно-зависимую информацию о модуле поддержки
     вычислений с плавающей точкой.  Ее точное содержание и размещение
     зависит от микросхемы поддержки вычислений с плавающей точкой.  В
     настоящее время, 'info float' поддерживается на машинах ARM и x86.


File: gdb.html,  Node: Языки,  Next: Символы,  Prev: Данные,  Up: Top

9 Использование GDB с различными языками программирования
*********************************************************

Хотя языки программирования обычно имеют общие аспекты, их выражения
редко выглядят одинаково.  Например, в ANSI Си, разыменование указателя
'p' осуществляется операцией '*p', а в Модуле-2 это выполняется как
'p^'.  Представление (и отображение) значений также может быть
различным.  Шестнадцатеричные числа в Си отображаются как '0x1ae', в то
время как в Модуле-2 они отображаются как '1AEH'.

   В GDB встроена специальная информация о некоторых языках, которая
позволяет описывать действия, подобные упомянутым, на языке вашей
программы, и позволяет GDB выводить значения в виде, принятом в языке,
на котором написана ваша программа.  Язык, которым вы пользуетесь для
построения выражений, называется "рабочим языком".

* Menu:

* Переход от одного языка к другому::
                                Переход от одного языка к другому
* Отображение языка::           Отображение языка
* Проверка::                    Проверки диапазона и соответствия типов
* Поддержка::                   Поддерживаемые языки


File: gdb.html,  Node: Переход от одного языка к другому,  Next: Отображение языка,  Up: Языки

9.1 Переход от одного языка к другому
=====================================

Существует два способа управления рабочим языком: либо GDB устанавливает
его автоматически, либо вы можете сделать это самостоятельно.  Для этих
целей вы можете воспользоваться командой 'set language'.  По умолчанию,
при старте GDB устанавливает язык автоматически.  Рабочий язык
используется, чтобы определить, как интерпретируются вводимые вами
выражения, как выводятся значения, и так далее.

   В дополнение к рабочему языку, каждый исходный файл, с которым
работает GDB, имеет свой собственный рабочий язык.  Для некоторых
форматов объектных файлов компилятор может указывать, на каком языке
написан конкретный исходный файл.  Однако, чаще всего GDB распознает
язык по имени файла.  Язык исходного файла определяет, будут ли
восстанавливаться имена Си++; таким образом, 'backtrace' может
показывать каждый кадр в соответствии с исходным языком.  Не существует
способа установить язык исходного файла из GDB, но вы можете установить
язык, ассоциированный с расширением файла.  *Note Отображение языка
программирования: Отображение языка.

   Наиболее часто эта проблема возникает, когда вы используете
программу, такую как 'cfront' или 'f2c', которая создает текст на Си, но
написана на другом языке.  В этом случае нужно сделать, чтобы программа
использовала директивы '#line' в выводе текста Си; тогда GDB будет знать
правильный язык исходного текста первоначальной программы, и выведет
этот исходный код, а не сгенерированный код Си.

* Menu:

* Имена файлов::                Расширения имен файлов и языки
* Установка рабочего языка::    Установки рабочего языка вручную
* Автоматическое::              Распознавание GDB исходного языка


File: gdb.html,  Node: Имена файлов,  Next: Установка рабочего языка,  Up: Переход от одного языка к другому

9.1.1 Соответствие расширений файлов и языков
---------------------------------------------

Если имя исходного файла заканчивается одним из следующих расширений, то
GDB воспринимает это как указание на обозначенный язык.

'.c'
     Исходный файл Си

'.C'
'.cc'
'.cp'
'.cpp'
'.cxx'
'.c++'
     Исходный файл Си++

'.f'
'.F'
     Исходный файл Фортрана

'.ch'
'.c186'
'.c286'
     Исходный файл CHILL

'.mod'
     Исходный файл Модулы-2

'.s'
'.S'
     Исходный файл Ассемблера.  В действительности, воспринимается почти
     также, как Си, но GDB не пропускает вводные части функций при
     пошаговом выполнении.

   В дополнение к этому, вы можете установить язык, ассоциированный с
расширением имени файла.  *Note Отображение языка программирования:
Отображение языка.


File: gdb.html,  Node: Установка рабочего языка,  Next: Автоматическое,  Prev: Имена файлов,  Up: Переход от одного языка к другому

9.1.2 Установка рабочего языка
------------------------------

Если вы позволяете GDB устанавливать язык автоматически, выражения в
сеансе отладки и в вашей программе интерпретируются одинаково.

   По желанию, вы можете установить язык сами.  Для этого воспользуйтесь
командой 'set language ЯЗЫК', где ЯЗЫК -- название языка, например, 'c'
или 'modula-2'.  Чтобы получить перечень поддерживаемых языков, наберите
'set language'.

   Установка языка вручную запрещает GDB автоматически переключать
рабочий язык.  Это может привести к неприятным последствиям, если вы
попытаетесь отладить программу, когда рабочий язык не совпадает с
исходным языком, а выражение допустимо в обоих языках, но означает
разные вещи.  Например, если текущий исходный файл написан на Си, а в
GDB выбрана Модула-2, команда

     print a = b + c

может не привести к ожидаемому результату.  В Си это означает сложить
'b' и 'c' и поместить результат в 'a'.  Выведенным результатом будет
значение 'a'.  В Модуле-2 это означает сравнение 'a' с результатом
'b+c', выдающее значение типа 'BOOLEAN'.


File: gdb.html,  Node: Автоматическое,  Prev: Установка рабочего языка,  Up: Переход от одного языка к другому

9.1.3 Распознавание GDB исходного языка
---------------------------------------

Для автоматической установки рабочего языка, используйте 'set language
local' или 'set language auto'.  Тогда GDB будет определять рабочий язык
автоматически.  То есть при остановке вашей программы в кадре стека
(обычно, в точке останова), GDB устанавливает рабочий язык в тот,
который записан для функции в этом кадре.  Если язык для кадра
неизвестен (то есть, если функция или блок, соответствующие кадру, были
определены в исходном файле, не имевшем распознаваемого расширения),
текущий рабочий язык не изменяется, а GDB выдает предупреждающее
сообщение.

   Для большинства программ, которые написаны целиком на одном языке,
автоматическая установка языка может показаться ненужной.  Однако, в
основной программе, написанной на одном исходном языке, могут
использоваться программные модули и библиотеки, написанные на другом
исходном языке.  Использование в этом случае 'set language auto'
освобождает вас от установки рабочего языка вручную.


File: gdb.html,  Node: Отображение языка,  Next: Проверка,  Prev: Переход от одного языка к другому,  Up: Языки

9.2 Отображение языка программирования
======================================

Следующие команды помогают вам определить, какой язык является рабочим,
а также на каком языке были написаны исходные файлы.

'show language'
     Отобразить текущий рабочий язык.  Это тот язык, который вы можете
     использовать в командах типа 'print' для построения и вычисления
     выражений, в которые могут входить переменные вашей программы.

'info frame'
     Отобразить исходный язык для данного кадра стека.  Этот язык
     становится рабочим, если используется идентификатор из этого кадра.
     *Note Информация о кадре стека: Информация о кадре, для
     дополнительной информации.

'info source'
     Отобразить исходный язык данного исходного файла.  *Note
     Исследование таблицы символов: Символы, для получения
     дополнительной информации.

   При необычных обстоятельствах, у вас могут быть исходные файлы с
расширениями, не входящими в стандартный список.  Вы можете явно
установить расширение, ассоциированное с языком:

'set extension-language .РАСШ ЯЗЫК'
     Установить соответствие исходных файлов с расширением .РАСШ с
     исходным языком ЯЗЫК.

'info extensions'
     Перечислить все расширения имен файлов и соответствующие им языки.


File: gdb.html,  Node: Проверка,  Next: Поддержка,  Prev: Отображение языка,  Up: Языки

9.3 Проверка диапазона и принадлежности типу
============================================

     _Предупреждение:_ В этот выпуск включены команды GDB для проверки
     диапазона и соответствия типов, но они пока не оказывают никакого
     действия.  Этот раздел описывает их предполагаемые возможности.

   Некоторые языки обеспечивают защиту от достаточно общих ошибок с
помощью набора проверок времени компиляции и времени выполнения.  Это
включает проверку типов аргументов функций и операторов и обеспечивает
проверку математического переполнения во время выполнения.  Проверки
такого рода помогают убедиться в корректности программы после ее
компиляции путем устранения несоответствия типов, и предоставляя
активную проверку ошибок выхода за пределы диапазона во время
выполнения.

   По вашему желанию, GDB может проводить подобные проверки.  Хотя GDB
не проверяет операторы вашей программы, он может, например, проверять
выражения, введенные непосредственно в GDB для вычисления командой
'print'.  Как и в случае рабочего языка, GDB может также автоматически
решить, выполнять проверку или нет, основываясь на исходном языке вашей
программы.  *Note Поддерживаемые языки: Поддержка, для информации об
установках по умолчанию для поддерживаемых языков.

* Menu:

* Проверка типов::              Обзор проверки типов
* Проверка диапазона::          Обзор проверки диапазона


File: gdb.html,  Node: Проверка типов,  Next: Проверка диапазона,  Up: Проверка

9.3.1 Краткий обзор проверки соответствия типов
-----------------------------------------------

Некоторые языки, такие как Модула-2, должны иметь жесткое соответствие
типов, то есть аргументы операторов и функций должны иметь правильный
тип, в противном случае возникает ошибка.  Описанные здесь проверки
предотвращают ошибки несоответствия типов, которые могут вызвать ошибки
времени выполнения.  Например,

     1 + 2 => 3
но
     error-> 1 + 2.3

   Во втором примере ошибка, потому что 'CARDINAL' 1 не совместим по
типу с 'REAL' 2.3.

   Для выражений, используемых вами в командах GDB, вы можете указать
GDB не производить проверку; или же рассматривать любое несоответствие
как ошибку и прекращать обработку выражения; или только выводить
предупреждение в случае возникновения несоответствия, но вычислять
выражение в любом случае.  В последнем случае, GDB вычисляет выражения,
подобные второму примеру, но также выводит предупреждающее сообщение.

   Даже если вы отключили проверку типов, GDB может прекратить обработку
выражения по другим причинам, связанным с типами.  Например, GDB не
знает, как сложить 'int' и 'struct foo'.  Такие типы ошибок не имеют
ничего общего с используемым языком и обычно возникают из выражений,
подобных описанному выше, которые нет смысла вычислять.

   Каждый язык определяет степень строгости контроля типов.  Например,
как Модула-2, так и Си требуют, чтобы аргументы арифметических операций
были числами.  В Си, перечисляемые типы и указатели могут быть
представлены в виде чисел, так что они допустимы в качестве аргументов
математических операторов.  *Note Поддерживаемые языки: Поддержка, для
более подробного обсуждения конкретных языков.

   GDB предоставляет некоторые дополнительные команды для контроля
проверки типов:

'set check type auto'
     Включить или отключить контроль типов, в зависимости от текущего
     рабочего языка.  *Note Поддерживаемые языки: Поддержка, для
     установок по умолчанию для каждого языка.

'set check type on'
'set check type off'
     Включить или отключить контроль типов, пренебрегая установкой по
     умолчанию для текущего рабочего языка.  Вывести предупреждающее
     сообщение, если установка не соответствует используемой по
     умолчанию.  Если возникает несоответствие типов во время вычисления
     выражения при включенном контроле типов, GDB выводит сообщение и
     прерывает вычисление выражения.

'set check type warn'
     При возникновении несоответствия типов вывести предупреждающее
     сообщение, но попытаться вычислить выражение.  Вычисление выражения
     все же может быть невозможным по другим причинам.  Например, GDB не
     может складывать числа со структурами.

'show type'
     Показать текущую установку проверки типов, а также была ли она
     установлена GDB автоматически.


File: gdb.html,  Node: Проверка диапазона,  Prev: Проверка типов,  Up: Проверка

9.3.2 Краткий обзор проверки диапазона
--------------------------------------

В некоторых языках (например, в Модуле-2), выход за границы диапазона
типа считается ошибкой; эти ошибки отслеживаются с помощью контроля
времени выполнения.  Эти проверки диапазона служат для того, чтобы
избежать переполнения при вычислениях и не допустить превышения
индексами элементов массива границ индексации.

   В выражениях, используемых вами в командах GDB, вы можете указать GDB
обрабатывать ошибки диапазона одним из трех способов: игнорировать их,
всегда рассматривать как ошибки и прерывать обработку выражения, или
выводить предупреждение и продолжать вычисление выражения.

   Ошибки диапазона могут возникать при числовом переполнении, при
превышении границы индексации массива или при использовании константы,
не принадлежащей ни одному типу.  Однако, некоторые языки не считают
переполнение ошибкой.  Во многих реализациях Си математическое
переполнение вызывает "циклический переход" к меньшему значению.
Например, если M -- наибольшее целое значение, а S -- наименьшее, то

     M + 1 => S

   Это также является специфичным для конкретных языков, а в некоторых
случаях -- для отдельного компилятора или машины.  Для дальнейших
сведений по отдельным языкам, *Note Поддерживаемые языки: Поддержка.

   GDB обеспечивает некоторые дополнительные команды для контроля
проверки диапазона:

'set check range auto'
     Включить или отключить контроль диапазона, в зависимости от
     текущего рабочего языка.  *Note Поддерживаемые языки: Поддержка,
     для получения информации об установках по умолчанию для каждого
     языка.

'set check range on'
'set check range off'
     Включить или отключить контроль типов, пренебрегая установкой по
     умолчанию для текущего рабочего языка.  Если установка не
     соответствует используемой по умолчанию, выводится предупреждающее
     сообщение.  Если происходит ошибка диапазона и контроль включен,
     выводится сообщение и вычисление выражения прерывается.

'set check range warn'
     При выявлении ошибки диапазона GDB выведет предупреждающее
     сообщение, но попытается вычислить выражение.  Тем не менее,
     вычисление выражения может быть невозможным по другим причинам,
     таким как обращение к памяти, которой процесс не владеет (типичный
     пример для многих систем Unix).

'show range'
     Показать текущую установку проверки диапазона, и была ли она
     установлена GDB автоматически.


File: gdb.html,  Node: Поддержка,  Prev: Проверка,  Up: Языки

9.4 Поддерживаемые языки
========================

GDB поддерживает Си, Си++, Фортран, Java, Chill, Ассемблер и Модулу-2.
Некоторые возможности GDB могут быть задействованы в выражениях
независимо от используемого языка: операторы GDB '@' и '::' и
конструкция '{тип}адрес' (*note Выражения: Выражения.) могут быть
использованы в конструкциях любого поддерживаемого языка.

   Следующие разделы подробно описывают, до какой степени каждый из
исходных языков поддерживается GDB. Эти разделы не задумывались как
учебники или руководства по языкам; они лишь служат справочным
руководством по тому, что допускает анализатор выражений GDB, и как
должны выглядеть входные и выходные форматы в различных языках.
Существует много хороших книг по каждому из этих языков; пожалуйста,
загляните в них, если вам нужен учебник или справочник по языку.

* Menu:

* Си::          Си и Си++
* Модула-2::    Модула-2
* Chill::       Chill


File: gdb.html,  Node: Си,  Next: Модула-2,  Up: Поддержка

9.4.1 Си и Си++
---------------

Поскольку Си и Си++ тесно связаны, многие возможности GDB применимы к
ним обоим.  Когда это имеет место, мы обсуждаем эти языки вместе.

   Средства отладки Си++ обеспечиваются совместно компилятором Си++ и
GDB. Следовательно, для эффективной отладки программы на Си++, вам
следует пользоваться одним из поддерживаемых компиляторов, например GNU
'g++', или компилятором HP ANSI Си++ ('aCC').

   При использовании GNU Си++, для получения наилучших результатов
используйте формат отладочной информации stabs.  Вы можете выбрать его
явно с помощью ключа командной строки '-gstabs' или '-gstabs+'.
Смотрите *note Ключи для отладки вашей программы или GNU CC:
(gcc.info)Отладочные ключи, для дополнительной информации.

* Menu:

* Операторы Си::                Операторы Си и Си++
* Константы Си::                Константы Си и Си++
* Выражения Си++::              Выражения Си++
* Значения Си по умолчанию::    Значения по умолчанию Си и Си++
* Проверки в Си::               Проверки диапазона и типов Си и Си++
* Отладка Си::                  GDB и Си
* Отладка Си++::                Возможности GDB для Си++


File: gdb.html,  Node: Операторы Си,  Next: Константы Си,  Up: Си

9.4.1.1 Операторы Си и Си++
...........................

Операторы должны быть определены на значениях определенных типов.
Например, '+' определен на числах, но не на структурах.  Операторы часто
определяются на группах типов.

   Для целей Си и Си++, имеют место следующие определения:

   * _Целые типы_ включают 'int' с любыми спецификаторами класса памяти;
     'char'; 'enum'; и, для Си++, 'bool'.

   * _Типы с плавающей точкой_ включают 'float', 'double' и 'long
     double' (если поддерживается целевой платформой).

   * _Типы указателей_ включают все типы, определенные как '(ТИП *)'.

   * _Скалярные типы_ включают все вышеперечисленные типы.

Поддерживаются следующие операторы, перечисленные здесь в порядке
возрастания приоритета:

','
     Запятая, или оператор последовательного выполнения.  Выражения,
     разделенные в списке запятыми, вычисляются слева направо;
     результатом всего выражения является результат, полученный
     последним.

'='
     Присваивание.  Значение выражения присваивания -- присвоенное
     значение.  Определено на скалярных типах.

'ОПЕР='
     Используется в выражениях в форме 'A ОПЕР= B' и преобразовывается в
     'A = A ОПЕР B'. 'ОПЕР=' и '=' имеют одинаковый приоритет.  ОПЕР
     может быть одним из операторов '|', '^', '&', '<<', '>>', '+', '-',
     '*', '/', '%'.

'?:'
     Тернарный оператор.  'A ? B : C' истолковывается так: если A, то B,
     иначе C.  A должно быть целого типа.

'||'
     Логическое ИЛИ.  Определено на целых типах.

'&&'
     Логическое И.  Определено на целых типах.

'|'
     Побитовое ИЛИ.  Определено на целых типах.

'^'
     Побитовое исключающее ИЛИ.  Определено на целых типах.

'&'
     Побитовое И.  Определено на целых типах.

'==, !='
     Равенство и неравенство.  Определено на скалярных типах.  Значение
     этих выражений отлично от нуля для истины и 0 для лжи.

'<, >, <=, >='
     Меньше чем, больше чем, меньше или равно, больше или равно.
     Определено на скалярных типах.  Значение этих выражений равно 0 для
     лжи и отлично от нуля для истины.

'<<, >>'
     Левый сдвиг и правый сдвиг.  Определено на целых типах.

'@'
     Оператор GDB создания "искусственного массива" (*note Выражения:
     Выражения.).

'+, -'
     Сложение и вычитание.  Определено на целочисленных типах, типах с
     плавающей точкой и указателях.

'*, /, %'
     Умножение, деление и остаток.  Умножение и деление определены на
     целочисленных типах и типах с плавающей точкой.  Остаток определен
     на целочисленных типах.

'++, --'
     Инкремент и декремент.  При появлении перед переменной, операция
     выполняется прежде, чем переменная используется в выражении; при
     появлении после переменной, значение переменной используется до
     выполнения операции.

'*'
     Разыменование указателя.  Определено для указателей.  Имеет тот же
     приоритет, что и '++'.

'&'
     Оператор получения адреса.  Определен на переменных.  Имеет тот же
     приоритет, что и '++'.

     Для отладки Си++, GDB реализует использование '&' независимо от
     того, что позволяет сам язык Си++: вы можете использовать
     '&(&ССЫЛКА)' (или просто '&&ССЫЛКА'), чтобы исследовать адрес, по
     которому хранится переменная-ссылка Си++ (объявленная с помощью
     '&ССЫЛКА').

'-'
     Унарный минус.  Определен на целочисленных типах и типах с
     плавающей точкой.  Имеет тот же приоритет, что и '++'.

'!'
     Логическое отрицание.  Определено на целочисленных типах.  Имеет
     тот же приоритет, что и '++'.

'~'
     Оператор побитового дополнения.  Определен на целочисленных типах.
     Имеет тот же приоритет, что и '++'.

'., ->'
     Элемент структуры и указатель на элемент структуры.  Для удобства,
     GDB считает их эквивалентными, определяя, следует ли разыменовывать
     указатель, основываясь на сохраненной информации о типах.
     Определен на данных структуры ('struct') и объединения ('union').

'.*, ->*'
     Разыменовывание указателя на элемент.

'[]'
     Индексация массива.  'A[I]' определяется как '*(A+I)'.  Имеет тот
     же приоритет, что и '->'.

'()'
     Список параметров функции.  Имеет тот же приоритет, что и '->'.

'::'
     Оператор Си++ определения области видимости.  Определен на типах
     'struct', 'union' и 'class'.

'::'
     Двойное двоеточие также представляет оператор GDB области видимости
     (*note Выражения: Выражения.).  Имеет тот же приоритет, что и '::',
     описанный выше.

   Если оператор переопределен в пользовательском коде, GDB обычно
пытается выполнить переопределенную версию, а не использовать
предопределенное значение оператора.


File: gdb.html,  Node: Константы Си,  Next: Выражения Си++,  Prev: Операторы Си,  Up: Си

9.4.1.2 Константы Си и Си++
...........................

GDB позволяет вам выражать константы Си и Си++ следующими способами:

   * Целочисленные константы -- это последовательности цифр.
     Восьмеричные константы начинаются с '0' (с нуля), а
     шестнадцатеричные константы -- с '0x' или '0X'.  Константы также
     могут заканчиваться буквой 'l', указывая, что значение константы
     должно рассматриваться как длинное ('long').

   * Константы с плавающей точкой -- это последовательность цифр, за
     которой следует десятичная точка, другая последовательность цифр,
     и, возможно, порядок.  Порядок указывается в форме 'e[[+]|-]NNN',
     где NNN -- другая последовательность цифр.  Для положительных
     порядков '+' является необязательным.  Константа с плавающей точкой
     может также заканчиваться буквой 'f' или 'F', это указывает на то,
     что константа должна рассматриваться как 'float' (в отличие от
     'double' по умолчанию), или буквой 'l' или 'L', что указывает на
     константу типа 'long double'.

   * Перечисляемые константы состоят из перечисляемых идентификаторов,
     или их целочисленных эквивалентов.

   * Знаковые константы -- это одиночный знак, заключенный в одиночные
     кавычки ('''), или число -- порядковое значение соответствующего
     знака (обычно его значение ASCII).  Внутри кавычек, одиночный знак
     может быть представлен либо буквой, либо "экранирующей
     последовательностью", которая имеет форму '\NNN', где NNN является
     восьмеричным представлением порядкового значения знака; или форму
     '\X', где 'X' -- специальный предопределенный знак, например, '\n'
     для знака новой строки.

   * Строковые константы -- последовательность знаковых констант (без
     одиночных кавычек), заключенная в двойные кавычки ('"').  Туда
     могут входить любые допустимые знаковые константы (как описано
     выше).  Двойным кавычкам внутри строки должна предшествовать
     обратная косая черта, так что '"a\"b'c"', например, является
     строкой из пяти знаков.

   * Константы-указатели представляют собой целочисленные значения.  Вы
     можете также записывать указатели на константы, используя оператор
     Cи '&'.

   * Константы-массивы -- заключенные в фигурные скобки ('{' и '}')
     списки элементов, разделенные запятыми.  Например, '{1,2,3}'
     является массивом с тремя целочисленными элементами, '{{1,2},
     {3,4}, {5,6}}' является массивом размерности три на два, а '{&"hi",
     &"there", &"fred"}' является трехэлементным массивом указателей.


File: gdb.html,  Node: Выражения Си++,  Next: Значения Си по умолчанию,  Prev: Константы Си,  Up: Си

9.4.1.3 Выражения Си++
......................

Обработчик выражений GDB может интерпретировать большинство выражений
Си++.

     _Предупреждение:_ GDB может отлаживать программы на Си++, только
     если вы используете подходящий компилятор.  Обычно отладка Си++
     зависит от использования дополнительной отладочной информации в
     таблице символов и, таким образом, требует специальной поддержки.
     В частности, если ваш компилятор генерирует a.out, MIPS ECOFF,
     RS/6000 XCOFF или ELF с расширениями stabs к таблице символов, все
     эти средства доступны.  (С GNU CC вы можете использовать ключ
     '-gstabs', чтобы явно запросить расширения отладки stabs).  С
     другой стороны, если формат объектного кода -- стандартный COFF или
     DWARF в ELF, значительная часть поддержки Си++ в GDB _не_ работает.

  1. Допускаются вызовы функций-членов; вы можете использовать выражения
     типа

          count = aml->GetOriginal(x, y)

  2. Пока функция-член активна (в выбранном кадре стека), вашим
     выражениям доступно то же пространство имен, что и функции-члену;
     то есть GDB допускает неявные ссылки на указатель экземпляра класса
     'this' по тем же правилам, что и Си++.

  3. Вы можете вызывать перегруженные функции; GDB производит вызов
     функции с правильным определением, но с некоторыми ограничениями.
     GDB не совершает преобразования, для выполнения которых требуются
     преобразования типов, определенные пользователем, вызовы
     конструкторов или конкретизации не существующих в программе
     шаблонов.  Он также не может обрабатывать списки с неопределенным
     числом аргументов или аргументы со значениями по умолчанию.

     Он производит преобразования и расширения целочисленных типов,
     расширения типов с плавающей точкой, арифметические преобразования,
     преобразования указателей, преобразования класса объекта в базовые
     классы и стандартные преобразования, например функции или массива к
     указателю; это требует точного совпадения числа аргументов функции.

     Разрешение перегруженных имен производится всегда, если не указано
     'set overload-resolution off'.  *Note Возможности GDB для Си++:
     Отладка Си++.

     Вы должны указать 'set overload-resolution off', чтобы задать
     функцию явно при вызове перегруженной функции, как в примере

          p 'foo(char,int)'('x', 13)

     Возможности GDB для завершения команд могут упростить это; смотрите
     *note Завершение команд: Завершение.

  4. GDB понимает переменные, объявленные как ссылки Си++; вы можете
     использовать их в выражениях, точно как вы делаете в исходном
     тексте Си++ -- они автоматически разыменовываются.

     В списке параметров, показываемом GDB при отображении кадра стека,
     значения переменных-ссылок не отображаются (в отличие от других
     переменных); это позволяет избежать неудобств из-за того, что
     ссылки часто используются для больших структур.  _Адрес_
     переменной-ссылки всегда выводится, если только вы не установили
     'set print address off'.

  5. GDB поддерживает оператор Си++ определения области видимости имени
     '::' -- ваши выражения могут использовать его так же, как в вашей
     программе.  Так как одна область видимости может быть определена
     внутри другой, вы можете при необходимости неоднократно
     использовать '::', например, в выражении типа 'ОБЛ1::ОБЛ2::ИМЯ'.
     GDB также позволяет определить область видимости имени путем ссылки
     на исходный файл, при отладке как Си, так и Си++ (*note Переменные
     программы: Переменные.).

   Кроме того, при использовании с компилятором HP Си++, GDB правильно
поддерживает вызов виртуальных функций, вывод виртуальных баз объектов,
вызов функций в базовом подобъекте, приведение объектов и выполнение
операторов, определенных пользователем.


File: gdb.html,  Node: Значения Си по умолчанию,  Next: Проверки в Си,  Prev: Выражения Си++,  Up: Си

9.4.1.4 Значения Си и Си++ по умолчанию
.......................................

Если вы разрешаете GDB устанавливать проверки диапазона и принадлежности
типу автоматически, обе они по умолчанию _отключены_, если рабочий язык
изменяется на Си или Си++.  Это происходит независимо от того, выбираете
рабочий язык вы или GDB.

   Если вы разрешаете GDB устанавливать язык автоматически, он
распознает исходные файлы, чьи имена заканчиваются расширением '.c',
'.C' или '.cc' и так далее, и когда GDB начинает обработку кода,
скомпилированного из одного из этих файлов, он устанавливает рабочий
язык в Си или Си++.  *Note Распознавание GDB рабочего языка:
Автоматическое, для более подробного обсуждения.


File: gdb.html,  Node: Проверки в Си,  Next: Отладка Си,  Prev: Значения Си по умолчанию,  Up: Си

9.4.1.5 Проверки диапазона и принадлежности типу в Си и Си++
............................................................

Когда GDB производит разбор выражений Си или Си++, по умолчанию проверки
соответствия типов не проводятся.  Однако, если вы их включите, GDB
считает типы двух переменных эквивалентными, если:

   * Обе переменные структурированы и имеют один и тот же тег структуры,
     объединения или перечисления.

   * Имена типов обеих переменных совпадают или были объявлены
     эквивалентными через 'typedef'.

   Проверка диапазона, если она включена, выполняется для математических
операций.  Индексы массивов не проверяются, так как они часто
применяются для индексирования указателей, которые сами по себе
массивами не являются.


File: gdb.html,  Node: Отладка Си,  Next: Отладка Си++,  Prev: Проверки в Си,  Up: Си

9.4.1.6 GDB и Си
................

Команды 'set print union' и 'show print union' применимы к типу 'union'.
При установке в 'on', любые объединения, находящиеся внутри структуры
или класса, также выводятся.  В противном случае, они отображаются как
'{...}'.

   Оператор '@' помогает при отладке динамических массивов,
сформированных с помощью указателей и функции выделения памяти.  *Note
Выражения: Выражения.


File: gdb.html,  Node: Отладка Си++,  Prev: Отладка Си,  Up: Си

9.4.1.7 Возможности GDB для Си++
................................

Некоторые команды GDB особенно полезны при использовании с Си++, а
некоторые разработаны специально для него.  Ниже приведено их краткое
описание:

'меню точки останова'
     Когда вы хотите установить точку останова в перегруженной функции,
     меню точки останова GDB помогает вам указать, какое определение
     функции вам нужно.  *Note Меню точки останова: Меню точки останова.

'rbreak РЕГ-ВЫР'
     Установка точек останова при помощи регулярных выражений полезна
     при использовании перегруженных функций, не являющихся членами
     специальных классов.  *Note Установка точек останова: Установка
     точек останова.

'catch throw'
'catch catch'
     Отлаживайте обработку исключений Си++ с помощью этих команд.  *Note
     Установка точек перехвата: Установка точек перехвата.

'ptype ИМЯ-ТИПА'
     Вывести отношения наследования вместе с другой информацией для типа
     ИМЯ-ТИПА.  *Note Исследование таблицы символов: Символы.

'set print demangle'
'show print demangle'
'set print asm-demangle'
'show print asm-demangle'
     Управляет отображением символов Си++ в их исходной форме, как при
     выводе кода в виде исходного текста Си++, так и при выводе
     результата дисассемблирования.  *Note Параметры вывода: Параметры
     вывода.

'set print object'
'show print object'
     Выбрать, выводить производные (реальные) или описанные типы
     объектов.  *Note Параметры вывода: Параметры вывода.

'set print vtbl'
'show print vtbl'
     Управляет форматом вывода таблиц виртуальных функций.  *Note
     Параметры вывода: Параметры вывода.  (Команды 'vtbl' не работают
     для программ, скомпилированных компилятором HP ANSI Си++ ('aCC').)

'set overload-resolution on'
     Включить разрешение перегруженных символов при вычислении выражений
     Си++.  Значение по умолчанию 'on'.  Для перегруженных функций, GDB
     вычисляет аргументы и ищет функции, чьи сигнатуры удовлетворяют
     типам аргументов, используя стандартные правила преобразования Си++
     (смотрите *note Выражения Си++: Выражения Си++, для дополнительной
     информации).  Если GDB не может найти такие функции, он выводит
     сообщение.

'set overload-resolution off'
     Отключить разрешение перегруженных символов при вычислении
     выражений Си++.  Для перегруженных функций, не являющихся
     функциями-членами класса, GDB выбирает функцию с указанным именем,
     которую он первой находит в таблице символов, вне зависимости от
     того, правильного типа ее аргументы или нет.  Для перегруженных
     функций, являющихся функциями-членами класса, GDB ищет функцию, чья
     сигнатура _точно_ совпадает с типами аргументов.

'Перегруженные имена символов'
     Вы можете указать конкретное определение перегруженного символа,
     используя ту же запись, что и для объявления таких символов в Си++:
     введите 'СИМВОЛ(ТИПЫ)' вместо просто СИМВОЛ.  Вы также можете
     воспользоваться средствами завершения слова командной строки GDB,
     чтобы вывести список возможных вариантов, или чтобы завершить набор
     за вас.  *Note Завершение команд: Завершение, для подробного
     обсуждения, как это сделать.


File: gdb.html,  Node: Модула-2,  Next: Chill,  Prev: Си,  Up: Поддержка

9.4.2 Модула-2
--------------

Расширения, сделанные в GDB для поддержки Модулы-2, поддерживаются
только для программ, скомпилированных компилятором Модулы-2 GNU (который
сейчас разрабатывается).  Другие компиляторы Модулы-2 в настоящее время
не поддерживаются, и попытка отладки исполняемых программ, полученных
ими, скорее всего приведет к ошибке при считывании GDB таблицы символов
этой программы.

* Menu:

* Операторы Модулы-2::           Встроенные операторы
* Встроенные функции/процедуры:: Встроенные функции и процедуры
* Константы Модулы-2::           Константы Модулы-2
* Установки по умолчанию М-2::   Установки по умолчанию для Модулы-2
* Отклонения::                   Отклонения от стандарта Модулы-2
* Проверки Модулы-2::            Проверки диапазона и типа в Модулы-2
* Область видимости в Модуле-2:: Операторы определения области видимости
                                 '::' и '.'
* GDB и Модула-2::               GDB и Модула-2


File: gdb.html,  Node: Операторы Модулы-2,  Next: Встроенные функции/процедуры,  Up: Модула-2

9.4.2.1 Операторы Модулы-2
..........................

Операторы должны быть определены на значениях определенных типов.
Например, '+' определен на числах, но не на структурах.  Операторы часто
определяются на группах типов.  Для целей Модулы-2, имеют место
следующие определения:

   * _Целые типы_ состоят из 'INTEGER', 'CARDINAL' и их поддиапазонов.

   * _Знаковые типы_ состоят из 'CHAR' и его поддиапазонов.

   * _Типы с плавающей точкой_ состоят из 'REAL'.

   * _Типы-указатели_ состоят из всего, объявленного как 'POINTER TO
     ТИП'.

   * _Скалярные типы_ включают все вышеперечисленное.

   * _Типы-множества_ состоят из типов 'SET' и 'BITSET'.

   * _Булевый тип_ состоит из 'BOOLEAN'.

Поддерживаются следующие операторы; они представлены в порядке
возрастания приоритета:

','
     Разделитель аргументов функции или индексов массива.

':='
     Присваивание.  Значением 'ПЕРЕМ := ЗНАЧ' является ЗНАЧ.

'<, >'
     Меньше чем, больше чем для целочисленных типов, типов с плавающей
     точкой и перечислимых типов.

'<=, >='
     Меньше или равно, больше или равно.  Определено на целочисленных
     типах, типах с плавающей точкой и перечислимых типах.  Включение
     для множеств.  Такой же приоритет, как у '<'.

'=, <>, #'
     Равенство и два способа выражения неравенства; допустимо на
     скалярных типах.  Такой же приоритет, как у '<'.  В сценариях GDB,
     для неравенства допустимо только '<>', так как '#' конфликтует со
     знаком комментария.

'IN'
     Установка принадлежности.  Определено на множествах и типах их
     элементов.  Такой же приоритет, как у '<'.

'OR'
     Дизъюнкция (логическое ИЛИ). Определена на булевых типах.

'AND, &'
     Конъюнкция (логическое И). Определена на булевых типах.

'@'
     Оператор "искусственного массива" GDB (*note Выражения:
     Выражения.).

'+, -'
     Сложение и вычитание на целочисленных типах и типах с плавающей
     точкой или объединение и разность на множественных типах.

'*'
     Умножение на целочисленных типах и типах с плавающей точкой или
     пересечение на типах-множествах.

'/'
     Деление на типах с плавающей точкой.  Симметрическая разность
     множеств на типах-множествах.  Такой же приоритет, как у '*'.

'DIV, MOD'
     Целочисленное деление и остаток.  Определены на целочисленных
     типах.  Такой же приоритет, как у '*'.

'-'
     Отрицание.  Определено на данных типов 'INTEGER' и 'REAL'.

'^'
     Разыменовывание указателя.  Определено на типах-указателях.

'NOT'
     Булево отрицание.  Определено на булевых типах.  Такой же
     приоритет, как у '^'.

'.'
     Селектор полей 'RECORD'.  Определен для данных типа 'RECORD'.
     Такое же приоритет, как у '^'.

'[]'
     Индексация массива.  Определена для данных типа 'ARRAY'.  Такой же
     приоритет, как у '^'.

'()'
     Список параметров процедуры.  Определен на объектах 'PROCEDURE'.
     Такой же приоритет, как у '^'.

'::, .'
     Операторы GDB и Модулы-2 определения области видимости.

     _Предупреждение:_ Множества и операции над ними еще не
     поддерживаются, так что GDB трактует использование оператора 'IN'
     или операторов '+', '-', '*', '/', '=', , '<>', '#', '<=', и '>='
     на множествах как ошибку.


File: gdb.html,  Node: Встроенные функции/процедуры,  Next: Константы Модулы-2,  Prev: Операторы Модулы-2,  Up: Модула-2

9.4.2.2 Встроенные функции и процедуры
......................................

Модула-2 также делает доступными несколько встроенных процедур и
функций.  При их описании используются следующие метапеременные:

A
     представляет переменную типа 'ARRAY'.

C
     представляет константу или переменную типа 'CHAR'.

I
     представляет переменную или константу целого типа.

M
     представляет идентификатор, принадлежащий множеству.  Обычно
     используется в одной функции с метапеременной S.  Тип S должен быть
     'SET OF МЕТАТИП' (где МЕТАТИП -- тип M).

N
     представляет переменную или константу целого типа или типа с
     плавающей точкой.

R
     представляет переменную или константу типа с плавающей точкой.

T
     представляет тип.

V
     представляет переменную.

X
     представляет переменную или константу одного из нескольких типов.
     Смотрите пояснение к функции для дополнительной информации.

   Ниже описаны все встроенные процедуры Модулы-2, возвращающие
результат.

'ABS(N)'
     Возвращает абсолютное значение N.

'CAP(C)'
     Если C -- строчная буква, процедура возвращает ее эквивалент в
     верхнем регистре, иначе возвращает сам аргумент.

'CHR(I)'
     Возвращает знак, порядковое значение которого есть I.

'DEC(V)'
     Уменьшает значение переменной V на единицу.  Возвращает новое
     значение.

'DEC(V,I)'
     Уменьшает значение переменной V на I.  Возвращает новое значение.

'EXCL(M,S)'
     Удаляет элемент M из множества S.  Возвращает новое множество.

'FLOAT(I)'
     Возвращает эквивалент целого числа I в формате с плавающей точкой.

'HIGH(A)'
     Возвращает индекс последнего элемента A.

'INC(V)'
     Увеличивает значение переменной V на единицу.  Возвращает новое
     значение.

'INC(V,I)'
     Увеличивает значение переменной V на I.  Возвращает новое значение.

'INCL(M,S)'
     Добавляет элемент M в множество S, если его там еще нет.
     Возвращает новое множество.

'MAX(T)'
     Возвращает максимальное значение типа T.

'MIN(T)'
     Возвращает минимальное значение типа T.

'ODD(I)'
     Возвращает булево значение TRUE, если число I нечетно.

'ORD(X)'
     Возвращает порядковое значение своего аргумента.  Например,
     порядковое значение знака -- его ASCII-значение (на машинах,
     поддерживающих набор знаков ASCII).  X должна принадлежать
     упорядоченному типу, что включает целочисленные, знаковый и
     перечислимый типы.

'SIZE(X)'
     Возвращает размер аргумента.  X может быть переменной или типом.

'TRUNC(R)'
     Возвращает целую часть R.

'VAL(T,I)'
     Возвращает элемент типа T, порядковое значение которого есть I.

     _Предупреждение:_ Множества и операции над ними еще не
     поддерживаются, так что GDB рассматривает использование процедур
     'INCL' и 'EXCL' как ошибку.


File: gdb.html,  Node: Константы Модулы-2,  Next: Установки по умолчанию М-2,  Prev: Встроенные функции/процедуры,  Up: Модула-2

9.4.2.3 Константы
.................

GDB позволяет вам выражать константы Модулы-2 следующими способами:

   * Целые константы являются просто последовательностью цифр.  При
     использовании в выражении, константа интерпретируется так, чтобы
     быть совместимой по типу с остальной частью выражения.
     Шестнадцатеричные целые числа определяются окончанием 'H', а
     восьмеричные -- окончанием 'B'.

   * Константы с плавающей точкой задаются как последовательность цифр,
     за которой следует десятичная точка и другая последовательность
     цифр.  Необязательный порядок может быть задан в форме 'E[+|-]NNN',
     где '[+|-]NNN' и есть желаемый порядок.  Все цифры константы с
     плавающей точкой должны быть десятичными (по основанию 10).

   * Знаковые константы состоят из одиночных знаков, заключенных в пару
     одинаковых кавычек: либо одиночных ('''), либо двойных ('"').  Они
     также могут быть заданы своим порядковым значением (обычно
     ASCII-значением), за которым следует 'C'.

   * Строковые константы состоят из последовательности знаков,
     окруженных парой одинаковых кавычек: либо одиночных ('''), либо
     двойных ('"').  Также допускаются экранирующие последовательности в
     стиле Си.  *Note Константы Си и Си++: Константы Си, для краткого
     объяснения экранирующих последовательностей.

   * Перечислимые константы состоят из перечислимого идентификатора.

   * Булевы константы состоят из идентификаторов 'TRUE' и 'FALSE'.

   * Константы-указатели состоят только из целочисленных значений.

   * Константы-множества пока не поддерживаются.


File: gdb.html,  Node: Установки по умолчанию М-2,  Next: Отклонения,  Prev: Константы Модулы-2,  Up: Модула-2

9.4.2.4 Установки по умолчанию Модулы-2
.......................................

Если проверка диапазона или принадлежности типу устанавливается GDB
автоматически, то по умолчанию обе они устанавливаются в 'on', если
рабочим языком становится Модула-2.  Это происходит независимо от того,
кто выбрал рабочий язык -- вы или GDB.

   Если вы разрешаете GDB выбирать язык автоматически, то при анализе
кода, скомпилированного из файла, чье имя оканчивается на '.mod', GDB
установит рабочим языком Модулу-2.  *Note Распознавание GDB исходного
языка: Автоматическое, для дополнительной информации.


File: gdb.html,  Node: Отклонения,  Next: Проверки Модулы-2,  Prev: Установки по умолчанию М-2,  Up: Модула-2

9.4.2.5 Отклонения от стандарта Модулы-2
........................................

Для упрощения отладки программ на Модуле-2 было сделано несколько
изменений.  В основном, это сделано путем ослабления строгости контроля
типов:

   * В отличие от стандарта Модулы-2, константы-указатели могут быть
     сформированы целыми числами.  Это позволяет вам изменять
     переменные-указатели в процессе отладки.  (В стандарте Модулы-2,
     реальный адрес, содержащийся в переменной-указателе, скрыт от вас;
     его можно изменить лишь прямым присваиванием значения другой
     переменной-указателя или выражения, возвращающего указатель.)

   * Для представления непечатаемых знаков можно использовать в строках
     и знаковых константах экранирующие последовательности Си.  GDB
     выводит строки со встроенными экранирующими последовательностями.
     Одиночные непечатаемые знаки выводятся с помощью формата
     'CHR(NNN)'.

   * Оператор присваивания (':=') возвращает значение своего правого
     аргумента.

   * Все встроенные процедуры как изменяют, так _и_ возвращают свой
     аргумент.


File: gdb.html,  Node: Проверки Модулы-2,  Next: Область видимости в Модуле-2,  Prev: Отклонения,  Up: Модула-2

9.4.2.6 Проверки диапазона и принадлежности типу Модулы-2
.........................................................

     _Предупреждение:_ в этом выпуске, GDB еще не выполняет проверки
     диапазона и принадлежности типу.

   GDB считает две переменные Модулы-2 эквивалентными по типу, если:

   * Их типы были объявлены эквивалентными посредством оператора 'TYPE
     T1 = T2'

   * Они были объявлены на одной и той же строке.  (Примечание: Это
     верно для компилятора GNU Модула-2, но это может не выполняться для
     других компиляторов.)

   Пока проверка соответствия типов включена, любая попытка
скомбинировать переменные неэквивалентных типов является ошибкой.

   Проверка диапазона выполняется во всех математических операциях,
присваиваниях, при индексации массивов и во всех встроенных функциях и
процедурах.


File: gdb.html,  Node: Область видимости в Модуле-2,  Next: GDB и Модула-2,  Prev: Проверки Модулы-2,  Up: Модула-2

9.4.2.7 Операторы определения области видимости '::' и '.'
..........................................................

Существует несколько тонких различий между операторами области видимости
Модулы-2 ('.') и GDB ('::').  Оба имеют похожий синтаксис:


     МОДУЛЬ . ИДЕНТ
     ОБЛАСТЬ :: ИДЕНТ

где ОБЛАСТЬ -- имя модуля или процедуры, МОДУЛЬ -- имя модуля, а ИДЕНТ
-- любой идентификатор, описанный в пределах вашей программы, за
исключением другого модуля.

   Использование оператора '::' заставляет GDB искать идентификатор
ИДЕНТ в ОБЛАСТИ.  Если он в ней не найден, GDB ищет его во всех
областях, содержащих ОБЛАСТЬ.

   Использование оператора '.' заставляет GDB искать идентификатор
ИДЕНТ, который был импортирован из модуля определения МОДУЛЬ, в текущей
области видимости.  В этом операторе cчитается ошибкой, если
идентификатор ИДЕНТ не был импортирован из модуля определения МОДУЛЬ,
или если ИДЕНТ не является в нем идентификатором.


File: gdb.html,  Node: GDB и Модула-2,  Prev: Область видимости в Модуле-2,  Up: Модула-2

9.4.2.8 GDB и Модула-2
......................

Некоторые команды GDB имеют мало смысла при отладке программ на
Модуле-2.  Пять подкоманд из команд 'set print' и 'show print' применимы
исключительно к Си и Си++: 'vtbl', 'demangle', 'asm-demangle', 'object'
и 'union'.  Первые четыре применимы к Си++, а последняя к типу Си
'union', который не имеет прямого аналога в Модуле-2.

   Оператор '@' (*note Выражения: Выражения.), хоть и доступен при
использовании любого языка, бесполезен при работе с Модулой-2.  Его цель
состоит в том, чтобы помочь при отладке "динамических массивов", которые
не могут быть созданы в Модуле-2 в отличие от Си или Си++.  Однако,
конструкция '{ТИП}АДР-ВЫР' все же полезна, так как адрес может быть
определен целочисленной константой.

   В сценариях GDB, оператор неравенства Модулы-2 '#' интерпретируется
как начало комментария.  Используйте вместо него '<>'.


File: gdb.html,  Node: Chill,  Prev: Модула-2,  Up: Поддержка

9.4.3 Chill
-----------

Расширения, сделанные в GDB для поддержки Chill, работают только с
программами, созданными компилятором GNU Chill.  Другие компиляторы
Chill в настоящее время не поддерживаются, и попытка отладить программы,
полученные с их помощью, скорее всего приведет к ошибке в тот момент,
когда GDB будет считывать таблицу символов выполняемого файла.

   Этот раздел охватывает темы, связанные с Chill, и возможности GDB для
их поддержки.

* Menu:

* Как отображаются режимы::     Как отображаются режимы
* Местоположения::              Местоположения и доступ к ним
* Значения и операции с ними::  Значения и операции с ними
* Проверка диапазона и типов в Chill::
* Установки по умолчанию Chill::


File: gdb.html,  Node: Как отображаются режимы,  Next: Местоположения,  Up: Chill

9.4.3.1 Как отображаются режимы
...............................

Поддержка GDB типов данных (режимов) Chill непосредственно связана с
возможностями компилятора GNU Chill и, следовательно, слегка отличается
от стандартной спецификации языка.  Вот предоставляемые режимы:

'_Дискретные режимы:_'
        * _Целочисленные режимы_, которые предопределены как 'BYTE,
          UBYTE, INT, UINT, LONG, ULONG',
        * _Булевский режим_, который предопределен как 'BOOL',
        * _Знаковый режим_, который предопределен как 'CHAR',
        * _Режим-множество_, который отображается ключевым словом 'SET'.
               (gdb) ptype x
               type = SET (karli = 10, susi = 20, fritzi = 100)
          Если тип является ненумерованным множеством, значения
          элементов множества опускаются.
        * _Режим-диапазон_, который отображается как
               тип = <базовый-режим>(<нижняя граница> : <верхняя граница>)
          где '<нижняя граница>, <верхняя граница>' может быть любым
          дискретным буквенным выражением (например, имена элементов
          множества).

'_Режим powerset:_'
     Режим Powerset отображается ключевым словом 'POWERSET', за которым
     следует режим элемента.
          (gdb) ptype x
          type = POWERSET SET (egon, hugo, otto)

'_Режимы-ссылки:_'
        * _Режим привязанной ссылки_, который отображается ключевым
          словом 'REF', за которым следует название режима, к которому
          ссылка привязана.
        * _Режим свободной ссылки_, который отображается ключевым словом
          'PTR'.

'_Процедурный режим_'
     Процедурный режим отображается в виде 'тип = PROC(<список
     параметров>) <возвращаемый режим> EXCEPTIONS (<список
     исключений>)'.  '<список параметров>' представляет собой список
     режимов параметров.  '<возвращаемый режим>' указывает режим
     результата процедуры, если она возвращает результат.  '<список
     исключений>' перечисляет все возможные исключения, которые могут
     быть возбуждены процедурой.

'_Синхронизационные режимы:_'
        * _Режим события_, который отображается как
               EVENT (<длина события>)
          где '<длина события>' является необязательной.
        * _Буферный режим_, который отображается как
               BUFFER (<длина буфера>)<режим элементов буфера>
          где '(<длина буфера>)' является необязательной.

'_Режимы времени:_'
        * _Режим длительности_, который предопределен как 'DURATION'
        * _Режим абсолютного времени_, который предопределен как 'TIME'

'_Вещественные режимы:_'
     Вещественные режимы предопределены как 'REAL' и 'LONG_REAL'.

'_Строковые режимы:_'
        * _Режим строки знаков_, который отображается как
               CHARS(<длина строки>)
          за которым следует ключевое слово 'VARYING', если строковый
          режим является изменяющимся режимом
        * _Режим строки битов_, который отображается как
               BOOLS(<длина строки>)

'_Режим массива:_'
     Режим массива отображается ключевым словом 'ARRAY(<диапазон>)', за
     которым следует режим элементов (который, в свою очередь, может
     быть режимом массива).
          (gdb) ptype x
          type = ARRAY (1:42)
                    ARRAY (1:20)
                       SET (karli = 10, susi = 20, fritzi = 100)

'_Структурный режим_'
     Структурный режим отображается ключевым словом 'STRUCT(<список
     полей>)'.  '<список полей>' состоит из имен и режимов полей
     структуры.  Структуры с вариантами имеют ключевое слово 'CASE
     <поле> OF <варианты поля> ESAC' в их списке полей.  Так как текущая
     версия компилятора GNU Chill не реализует обработку тегов (нет
     проверок времени выполнения вариантных полей и, следовательно, нет
     отладочной информации), вывод всегда содержит все вариантные поля.
          (gdb) ptype str
          type = STRUCT (
              as x,
              bs x,
              CASE bs OF
              (karli):
                  cs a
              (ott):
                  ds x
              ESAC
          )


File: gdb.html,  Node: Местоположения,  Next: Значения и операции с ними,  Prev: Как отображаются режимы,  Up: Chill

9.4.3.2 Местоположения и доступ к ним
.....................................

Местоположением в Chill является объект, который может содержать
значения.

   Доступ к значению местоположения обычно производится посредством
(описанного) имени местоположения.  Вывод удовлетворяет спецификации
значений в программах на Chill.  То, как значения задаются, является
темой следующего раздела, смотрите *note Значения и операции с ними::.

   Псевдоместоположение 'RESULT' (или 'result') может использоваться для
отображения или изменения результата процедуры, активной в настоящий
момент:

     set result := EXPR

Это делает то же самое, что и действие Chill 'RESULT EXPR' (которое в
GDB недоступно).

   Значения местоположений режима ссылок выводятся, в случае режима
свободной ссылки, посредством 'PTR(<шестнадцатеричное значение>)', и с
помощью '(REF <режим ссылки>) (<шестнадцатеричное значение>)' в случае
привязанной ссылки.  '<шестнадцатеричное значение>' представляет адрес,
на который указывает ссылка.  Для доступа к значению местоположения,
указываемого ссылкой, используйте оператор разыменовывания '->'.

   Значения местоположений процедурного режима отображаются как
     { PROC
     (<режимы аргументов> ) <возвращаемый режим> } <адрес> <имя
     местоположения процедуры>
   '<режимы аргументов>' -- это список режимов, в соответствии со
спецификацией параметров процедуры, а '<адрес>' указывает адрес точки
входа.

   Подструктуры значений строковых режимов, режимов массивов или
структур (например, срезы массивов, поля структурных местоположений)
доступны при использовании определенных операторов, которые описаны в
следующем разделе, смотрите *note Значения и операции с ними::.

   Значение местоположения может быть интерпретировано как имеющее
другой режим посредством преобразования местоположений.  Это
преобразование режимов записывается как '<имя
режима>(<местоположение>)'.  Пользователь должен учесть, что размеры
режимов должны быть равными, в противном случае возникает ошибка.  Более
того, не производится никаких проверок диапазона местоположения по
сравнению с режимом назначения, и, следовательно, результат может быть
достаточно обескураживающим.

     (gdb) print int (s(3 up 4)) XXX TO be filled in !! XXX


File: gdb.html,  Node: Значения и операции с ними,  Next: Проверка диапазона и типов в Chill,  Prev: Местоположения,  Up: Chill

9.4.3.3 Значения и операции с ними
..................................

Значения используются для изменения местоположений, для более подробного
изучения сложных структур и для отфильтровывания значимой информации из
большого объема данных.  Определено несколько операций (зависящих от
режима), которые позволяют проводить подобные изучения.  Эти операции
применимы не только к значениям-константам, но также и к
местоположениям, что может оказаться достаточно полезным при отладке
сложных структур.  Во время разбора командной строки (например, вычисляя
выражение), GDB рассматривает имена местоположений как значения этих
местоположений.

   Этот раздел описывает, как должны задаваться значения, и какие
операции допустимо использовать с этими значениями.

'Буквенные значения'
     Буквенные значения определяются также, как в программах GNU Chill.
     Для подробной спецификации, смотрите главу 1.5 Руководства по
     реализации GNU Chill.

'Значения-наборы'
     Набор может быть задан как '<имя режима>[<набор>]', где '<имя
     режима>' может быть опущено, если режим набора определяется
     однозначно.  Эта однозначность определяется из контекста
     вычисляемого выражения.  '<набор>' может быть одним из:

        * _Набор powerset_
        * _Набор массивов_
        * _Набор структур_

     Наборы-powerset, наборы массивов и наборы структур определяются так
     же, как в программах на Chill.

'Значение элемента строки'
     Значение элемента строки задается как
          <строковое значение>(<индекс>)
     где '<индекс>' является целочисленным выражением.  Это дает
     знаковое значение, которое эквивалентно знаку, указываемому в
     строке индексом '<индекс>'.

'Значение среза строки'
     Значение среза строки задается как '<значение строки>(<спецификация
     среза>)', где '<спецификация среза>' может быть либо диапазоном
     целых выражений, либо задаваться в виде '<начальное выражение> up
     <размер>'.  '<размер>' обозначает число элементов, которое содержит
     срез.  Полученная величина является строкой, которая является
     частью указанной строки.

'Значения элементов массива'
     Значение элемента массива указывается в виде '<величина
     массива>(<выр>)' и дает величину элемента массива с режимом как у
     указанного массива.

'Значение среза массива'
     Срез массива задается как '<значение массива>(<спецификация
     среза>)', где '<спецификация среза>' может быть диапазоном,
     определенным либо выражениями, либо как '<начальное выр> up
     <размер>'.  '<размер>' обозначает число элементов массива, которое
     содержит срез.  Получаемое значение есть массив, который является
     частью указанного.

'Значение поля структуры'
     Значение поля структуры получается как '<значение структуры>.<имя
     поля>', где '<имя поля>' указывает имя поля, заданное в определении
     режима структуры.  Режим полученного значения соответствует этому
     определению режима в определении структуры.

'Значения вызова процедуры'
     Значение вызова процедуры получается из значения, возвращенного
     процедурой(1).

     Значения местоположений режима длительности представляются буквами
     'ULONG'.

     Значения местоположений режима-времени выводятся как
          TIME(<сек>:<нсек>).

'Значение безаргументного оператора'
     Значение безаргументного оператора получается из значения
     экземпляра для текущего активного процесса.

'Значения выражений'
     Значение, доставляемое выражением, является результатом вычисления
     указанного выражения.  В случае ошибки (несовместимость режимов и
     тому подобное), вычисление выражения прерывается с соответствующим
     сообщением об ошибке.  Выражение может быть заключено в скобки, что
     приводит к вычислению этого выражения до любого другого,
     использующего результат выражения в скобках.  GDB поддерживает
     следующие операторы:

     'OR, ORIF, XOR'
     'AND, ANDIF'
     'NOT'
          Логические операторы, определенные на операндах булевого
          режима.

     '=, /='
          Операторы равенства и неравенства, определенные на всех
          режимах.

     '>, >='
     '<, <='
          Операторы отношения, заданные на предопределенных режимах.

     '+, -'
     '*, /, MOD, REM'
          Арифметические операторы, заданные на предопределенных
          режимах.

     '-'
          Оператор изменения знака.

     '//'
          Оператор соединения строк.

     '()'
          Оператор повторения строки.

     '->'
          Оператор ссылки местоположения, который может быть использован
          либо для получения адреса местоположения ('->loc'), или для
          разыменовывания ссылки местоположения ('loc->').

     'OR, XOR'
     'AND'
     'NOT'
          Операторы режимов powerset и строки битов.

     '>, >='
     '<, <='
          Операторы включения режима powerset.

     'IN'
          Оператор принадлежности.

   ---------- Footnotes ----------

   (1) Если, например, вызов процедуры используется в выражении, то эта
процедура вызывается со всеми своими побочными эффектами.  При
неаккуратном использовании это может привести к путанице.


File: gdb.html,  Node: Проверка диапазона и типов в Chill,  Next: Установки по умолчанию Chill,  Prev: Значения и операции с ними,  Up: Chill

9.4.3.4 Проверка диапазона и типов в Chill
..........................................

GDB считает два режима переменных Chill эквивалентными, если их размеры
равны.  Это правило применяется рекурсивно для более сложных типов
данных.  Это означает, что сложные режимы считаются эквивалентными, если
режимы всех элементов (которые тоже могут быть сложными, например,
массивами, структурами, и так далее) имеют одинаковый размер.

   Проверка диапазона производится для всех математических операций,
присваиваний, границ индексов массива и всех встроенных процедур.

   Строгие проверки типов включаются с помощью команды GDB 'set check
strong'.  Это навязывает строгую проверку диапазона и принадлежности
типу для всех действий, где используются конструкции Chill (выражения,
встроенные функции и так далее), в соответствии с семантикой,
определенной в спецификации языка z.200.

   Все проверки могут быть отключены командой GDB 'set check off'.


File: gdb.html,  Node: Установки по умолчанию Chill,  Prev: Проверка диапазона и типов в Chill,  Up: Chill

9.4.3.5 Установки по умолчанию Chill
....................................

Если проверки типа и диапазона установлены GDB автоматически, обе они по
умолчанию включены, когда рабочий язык переключается на Chill.  Это
происходит независимо от того, вы выбрали рабочий язык или GDB.

   Если вы разрешите GDB устанавливать рабочий язык автоматически, то
при попадании в код, скомпилированный из файла, чье имя заканчивается на
'.ch', он переключает рабочий язык на Chill.  *Note Распознавание GDB
исходного языка: Автоматическое, для дополнительной информации.


File: gdb.html,  Node: Символы,  Next: Изменения,  Prev: Языки,  Up: Top

10 Исследование таблицы символов
********************************

Команды, описанные в этой главе, позволяют вам получить информацию о
символах (именах переменных, функций и типов), определенных в вашей
программе.  Эта информация присуща тексту вашей программы и не
изменяется при ее выполнении.  GDB находит эту информацию в таблице
символов вашей программы, в файле, определенном при его вызове (*note
Выбор файлов: Параметры файлов.), или посредством одной из команд
управления файлами (*note Команды для задания файлов: Файлы.).

   Иногда вам может потребоваться сослаться на символы, содержащие
необычные знаки, которые GDB обычно трактует как разделители слов.
Наиболее часто это встречается при ссылках на статические переменные в
других исходных файлах (*note Переменные программы: Переменные.).  Имена
файлов записаны в объектных файлах как отладочные символы, но GDB обычно
производит разбор типичного имени файла, например 'foo.c', как три
слова: 'foo' '.'  'c'.  Чтобы GDB идентифицировал 'foo.c' как одно
слово, заключите его в одинарные кавычки; например,

     p 'foo.c'::x

ищет значение 'x' в области видимости файла 'foo.c'.

'info address СИМВОЛ'
     Описывает, где хранятся данные для СИМВОЛА.  Для регистровой
     переменной сообщается, в каком регистре она содержится.  Для
     нерегистровой локальной переменной печатается смещение в кадре
     стека, по которому переменная всегда хранится.

     Заметьте отличие от команды 'print &СИМВОЛ', которая вообще не
     работает для регистровых переменных, а для локальной переменной из
     стека печатает точный адрес текущего экземпляра переменной.

'whatis ВЫРАЖ'
     Напечатать тип данных выражения ВЫРАЖ.  На самом деле ВЫРАЖ не
     вычисляется, и присутствующие в нем побочные операции (такие как
     присваивания или вызовы функций) не выполняются.  *Note Выражения:
     Выражения.

'whatis'
     Вывести тип данных '$', последней записи в истории значений.

'ptype ИМЯ-ТИПА'
     Вывести описание типа данных ИМЯ-ТИПА.  ИМЯ-ТИПА может быть именем
     типа или, для кода Си, может иметь форму 'class ИМЯ-КЛАССА',
     'struct ТЕГ-СТРУКТУРЫ', 'union ТЕГ-ОБЪЕДИНЕНИЯ' или 'enum
     ТЕГ-ПЕРЕЧИСЛЕНИЯ'.

'ptype ВЫРАЖ'
'ptype'
     Вывести описание типа выражения ВЫРАЖ.  'ptype' отличается от
     'whatis' тем, что выводится детальное описание, а не только имя
     типа.

     Например, для такого описания переменной:

          struct complex {double real; double imag;} v;

     эти две команды выведут следующее:

          (gdb) whatis v
          type = struct complex
          (gdb) ptype v
          type = struct complex {
              double real;
              double imag;
          }

     Как и 'whatis', использование 'ptype' без параметра относится к
     типу '$', последней записи в истории значений.

'info types РЕГ-ВЫР'
'info types'
     Вывести краткое описание всех типов, имена которых соответствуют
     регулярному выражению РЕГ-ВЫР (или всех типов вашей программы, если
     вы используете эту команду без параметра).  Каждое полное имя типа
     сопоставляется так, как если бы оно было полной строкой; таким
     образом, 'i type value' выдает информацию обо всех типах в вашей
     программе, чьи имена включают строку 'value', а 'i type ^value$'
     выдает информацию только о типах с полным именем 'value'.

     Эта команда отличается от 'ptype' следующим: во-первых, как и
     'whatis', она не выводит детального описания; во-вторых, она
     перечисляет все исходные файлы, где определен тип.

'info source'
     Показать имя текущего исходного файла -- то есть исходного файла
     для функции, содержащей текущую точку выполнения, и язык, на
     котором она написана.

'info sources'
     Вывести имена всех исходных файлов вашей программы, для которых
     имеется отладочная информация, организуя их в два списка: файлы с
     уже прочитанными символами, и файлы, символы которых будут
     прочитаны, когда потребуется.

'info functions'
     Вывести имена и типы данных всех определенных функций.

'info functions РЕГ-ВЫР'
     Вывести имена и типы данных всех определенных функций, чьи имена
     удовлетворяют регулярному выражению РЕГ-ВЫР.  Так, 'info fun step'
     находит все функции, имена которых содержат 'step'; 'info fun
     ^step' находит функции с именами, начинающимися со 'step'.

'info variables'
     Напечатать имена и типы данных всех переменных, объявленных вне
     функций (то есть исключая локальные переменные).

'info variables РЕГ-ВЫР'
     Вывести имена и типы данных всех переменных (кpоме локальных),
     имена которых удовлетворяют регулярному выражению РЕГ-ВЫР.

     Некоторые системы допускают замещение отдельных объектных файлов,
     составляющих вашу программу, без ее остановки и перезапуска.
     Например, в VxWorks вы можете просто перекомпилировать дефектный
     объектный файл и продолжить выполнение.  Если вы работаете в одной
     из таких систем, вы можете позволить GDB перезагрузить символы для
     автоматически пересобранных модулей:

     'set symbol-reloading on'
          Заменить определения символов для соответствующего исходного
          файла, когда объектный файл с определенным именем снова
          доступен.

     'set symbol-reloading off'
          Не заменять определения символов при встрече объектного файла
          с таким же именем более одного раза.  Это состояние по
          умолчанию; если вы не работаете в системе, допускающей
          автоматическое пересобирание модулей, вы должны оставить
          'symbol-reloading' в состоянии 'off', так как иначе GDB может
          уничтожить символы пpи сборке больших программ, которые могут
          содеpжать несколько модулей с одинаковым именем (из разных
          каталогов или библиотек).

     'show symbol-reloading'
          Показать текущую установку 'on' или 'off'.

'set opaque-type-resolution on'
     Велит GDB производить разрешение неоднозначных типов.
     Неоднозначным является тип, описанный как указатель на 'struct',
     'class' или 'union' -- например, 'struct MyType *' -- то есть,
     используется в одном исходном файле, хотя полное описание 'struct
     MyType' находится в другом исходном файле.  По умолчанию
     установлено в 'on'.

     Изменения в установке этой подкоманды не вступят в силу, пока не
     будут загружены символы для какого-нибудь файла.

'set opaque-type-resolution off'
     Указывает GDB не производить разрешение неоднозначных типов.  В
     этом случае, тип выводится следующим образом:
          {<no data fields>}

'show opaque-type-resolution'
     Показать, производится разрешение неоднозначных типов или нет.

'maint print symbols ИМЯ-ФАЙЛА'
'maint print psymbols ИМЯ-ФАЙЛА'
'maint print msymbols ИМЯ-ФАЙЛА'
     Записать дамп данных отладочных символов в файл ИМЯ-ФАЙЛА.  Эти
     команды используются для отладки кода GDB, осуществляющего чтение
     символов.  Включаются только символы с отладочными данными.  Если
     вы используете 'maint print symbols', GDB включает все символы, для
     которых уже собрана полная информация: то есть ИМЯ-ФАЙЛА отражает
     символы только для тех файлов, символы которых GDB уже прочитал.
     Вы можете использовать команду 'info sources', чтобы определить,
     какие это файлы.  Если же вы используете 'maint print psymbols',
     дамп показывает информацию о тех символах, о которых GDB имеет лишь
     частичную информацию, то есть символы определены в файлах, которые
     GDB только просмотрел, но не прочитал полностью.  Наконец, 'maint
     print msymbols', выводит только минимальную информацию о символах,
     требуемую для каждого объектного файла, из которых GDB пpочитал
     какие-либо символы.  *Note Команды для задания файлов: Файлы, где
     обсуждается, как GDB считывает символы (в описании 'symbol-file').


File: gdb.html,  Node: Изменения,  Next: Файлы GDB,  Prev: Символы,  Up: Top

11 Изменение выполнения
***********************

Если вы думаете, что нашли ошибку в своей программе, вы можете захотеть
выяснить наверняка, приведет ли исправление кажущейся ошибки к
правильным результатам в остальной части программы.  Вы можете получить
ответ экспериментируя, используя средства GDB для изменения выполнения
программы.

   Например, вы можете сохранить новые значения в переменных или ячейках
памяти, подать своей программе сигнал, перезапустить ее с другого адреса
или даже преждевременно вернуться из функции.

* Menu:

* Присваивание::                Присваивание значения переменной
* Переходы::                    Продолжение выполнения с другого адреса
* Подача сигналов::             Подача сигнала вашей программе
* Возврат::                     Возврат из функции
* Вызовы::                      Вызовы функций вашей программы
* Внесение изменений::          Внесение изменений в вашу программу


File: gdb.html,  Node: Присваивание,  Next: Переходы,  Up: Изменения

11.1 Присваивание значений переменным
=====================================

Для изменения значения переменной, вычислите выражение присваивания.
*Note Выражения: Выражения.  Например,

     print x=4

сохраняет значение 4 в переменной 'x' и затем выводит значение данного
выражения (которое равно 4).  *Note Использование GDB с различными
языками программирования: Языки, для получения большей информации об
операторах в поддерживаемых языках.

   Если вы не хотите видеть значение присваивания, используйте команду
'set' вместо 'print'.  Команда 'set' аналогична команде 'print' за
исключением того, что значение выражения не выводится и не заносится в
историю значений (*note История значений: История значений.).  Выражение
вычисляется только ради его действия.

   Если начало строки параметров команды 'set' выглядит идентично
подкоманде 'set', используйте вместо нее команду 'set variable'.  Эта
команда аналогична 'set', но не имеет подкоманд.  Например, если в вашей
программе есть переменная 'width', то вы получите ошибку, если
попытаетесь установить новое значение просто с помощью 'set width=13',
потому что GDB имеет команду 'set width':

     (gdb) whatis width
     type = double
     (gdb) p width
     $4 = 13
     (gdb) set width=47
     Invalid syntax in expression.

Недопустимое выражение, это, конечно, '=47'.  Для того, чтобы
действительно установить переменную программы 'width', используйте

     (gdb) set var width=47

   Так как команда 'set' имеет много подкоманд, которые могут
конфликтовать с именами переменных в программе, то хорошей практикой
является использование команды 'set variable' вместо просто 'set'.
Например, если ваша программа имеет переменную 'g', у вас возникнут
проблемы, если вы попытаетесь установить новое значение с помощью 'set
g=4', потому что GDB имеет команду 'set gnutarget', которая сокращается
как 'set g':

     (gdb) whatis g
     type = double
     (gdb) p g
     $1 = 1
     (gdb) set g=4
     (gdb) p g
     $2 = 1
     (gdb) r
     The program being debugged has been started already.
     Start it from the beginning? (y or n) y
     Starting program: /home/smith/cc_progs/a.out
     "/home/smith/cc_progs/a.out": can't open to read symbols:
                                      Invalid bfd target.
     (gdb) show g
     The current BFD target is "=4".

Переменная программы 'g' не изменилась, и вы незаметно установили
'gnutarget' в неверное значение.  Для установки значения переменной 'g',
используйте

     (gdb) set var g=4

   GDB допускает больше неявных преобразований в присваиваниях, чем Си;
вы можете свободно сохранить целое значение в переменной-указателе и
наоборот, преобразовать любую структуру к любой другой, которая имеет ту
же длину или короче.

   Для сохранения значений в произвольных местах памяти, используйте
конструкцию '{...}' для создания значения определенного типа по
определенному адресу памяти (*note Выражения: Выражения.).  Например,
'{int}0x83040' ссылается на ячейку памяти '0x83040' как на целое (что
предполагает соответствующий размер и представление в памяти), и

     set {int}0x83040 = 4

записывает в эту ячейку памяти значение 4.


File: gdb.html,  Node: Переходы,  Next: Подача сигналов,  Prev: Присваивание,  Up: Изменения

11.2 Продолжение исполнения с другого адреса
============================================

Обычно, когда вы продолжаете выполнение программы, вы делаете это с того
места, где она остановилась, командой 'continue'.  Вместо этого, вы
можете продолжить выполнение с любого выбранного адреса при помощи
следующих команд:

'jump УКАЗ-СТР'
     Возобновить выполнение со строки УКАЗ-СТР.  Если там есть точка
     останова, выполнение немедленно прекращается.  *Note Вывод строк
     исходного текста: Вывод строк, для описания различных форм
     УКАЗ-СТР.  Использование команды 'tbreak' вместе с 'jump' является
     обычной практикой.  *Note Установка точек останова: Установка точек
     останова.

     Команда 'jump' не изменяет ни текущий кадр стека, ни указатель
     стека, ни содержимое каких-либо ячеек памяти или регистров, кроме
     счетчика программы.  Если строка УКАЗ-СТР находится вне
     выполняющейся в настоящее время функции, результаты могут быть
     странными, если эти функции используют аргументы или локальные
     переменные разных типов.  По этой причине, команда 'jump'
     запрашивает подтверждение, если указанная строка не находится в
     функции, выполняющейся в настоящее время.  Однако, даже странные
     результаты предсказуемы, если вы хорошо знакомы с машинным кодом
     вашей программы.

'jump *АДРЕС'
     Возобновить выполнение с инструкции, находящейся по адресу АДРЕС.

   На многих системах вы можете достичь такого же результата, как и с
командой 'jump', сохранив новое значение в регистр '$pc'.  Отличие
заключается в том, что это не начинает выполнение вашей программы, а
лишь изменяет адрес, с которого _будет_ выполняться программа, когда вы
продолжите выполнение.  Например,

     set $pc = 0x485

выполняет следующую команду 'continue' или команду пошагового выполнения
с адреса '0x485', а не с того адреса, где ваша программа остановилась.
*Note Продолжение и выполнение по шагам: Продолжение и пошаговое
выполнение.

   Наиболее общий случай использования команды 'jump' состоит в возврате
к выполнению уже пройденной части программы, возможно с большим
количеством установленных точек останова, чтобы исследовать выполнение
более детально.


File: gdb.html,  Node: Подача сигналов,  Next: Возврат,  Prev: Переходы,  Up: Изменения

11.3 Подача сигнала вашей программе
===================================

'signal СИГНАЛ'
     Возобновить выполнение с места остановки вашей программы, но
     немедленно подать ей сигнал СИГНАЛ.  СИГНАЛ может быть именем или
     номером сигнала.  Например, во многих системах 'signal 2' и 'signal
     SIGINT' -- два способа подать сигнал прерывания.

     Наоборот, если СИГНАЛ является нулем, выполнение продолжается без
     подачи сигнала.  Это полезно, если ваша программа остановилась
     из-за сигнала и в обычном случае увидит его при возобновлении
     выполнения командой 'continue'; 'signal 0' продолжит выполнение без
     сигнала.

     'signal' не повторяется, когда вы нажимаете <RET> второй раз после
     выполнения команды.

   Вызов команды 'signal' отличается от вызова утилиты 'kill' из
оболочки.  Подача сигнала посредством 'kill' заставляет GDB решать, что
делать с сигналом, в зависимости от таблиц обработки сигналов (*note
Сигналы::).  Команда 'signal' передает сигнал непосредственно вашей
программе.


File: gdb.html,  Node: Возврат,  Next: Вызовы,  Prev: Подача сигналов,  Up: Изменения

11.4 Возврат из функции
=======================

'return'
'return ВЫРАЖЕНИЕ'
     Вы можете отменить выполнение вызова функции с помощью команды
     'return'.  Если вы задаете параметр ВЫРАЖЕНИЕ, его значение
     используется в качестве возвращаемого значения.

   Когда вы используете 'return', GDB уничтожает выбранный кадр стека (и
все кадры внутри него).  Вы можете считать это преждевременным возвратом
из уничтоженного кадра.  Если вы хотите указать возвращаемое значение,
задайте его в качестве аргумента к 'return'.

   Это выталкивает выбранный кадр стека (*note Выбор кадра стека:
Выбор.) и все другие кадры внутри него, оставляя самым внутренним кадр,
из которого произошел вызов.  Этот кадр становится выбранным.  Указанное
значение сохраняется в регистрах, используемых для возвращаемых функцией
значений.

   Команда 'return' не возобновляет выполнение; она оставляет программу
остановленной в том состоянии, в котором бы она была сразу после
возврата из функции.  Напротив, команда 'finish' (*note Продолжение и
выполнение по шагам: Продолжение и пошаговое выполнение.) возобновляет
выполнение до естественного возврата из выбранного кадра стека.


File: gdb.html,  Node: Вызовы,  Next: Внесение изменений,  Prev: Возврат,  Up: Изменения

11.5 Вызов функций программы
============================

'call ВЫРАЖ'
     Вычислить выражение ВЫРАЖ без отображения пустых ('void')
     возвращенных значений.

   Вы можете использовать этот вариант команды 'print', если хотите
выполнить функцию из вашей программы, не засоряя вывод пустыми
возвращенными значениями.  Если результат не пустой, он выводится и
сохраняется в истории значений.

   Для A29K, устанавливаемая пользователем переменная
'call_scratch_address' задает положение рабочей области, которая будет
использоваться, когда GDB вызывает функцию на целевой машине.  Это
необходимо, так как обычный метод размещения рабочей области в стеке не
работает в системах с раздельными областями команд и данных.


File: gdb.html,  Node: Внесение изменений,  Prev: Вызовы,  Up: Изменения

11.6 Внесение изменений в программу
===================================

По умолчанию, GDB открывает файл, содержащий исполняемый код вашей
программы (или файл дампа памяти), в режиме только для чтения.  Это
предотвращает случайные изменения машинного кода; но это также
предотвращает и преднамеренное исправление двоичного файла вашей
программы.

   Если вы хотите иметь возможность исправлять двоичный код, вы можете
указать это явно с помощью команды 'set write'.  Например, вы можете
захотеть установить внутренние флаги отладки или даже сделать аварийные
исправления.

'set write on'
'set write off'
     Если вы установите 'set write on', GDB открывает исполняемые файлы
     и файлы дампов памяти в режиме для чтения и записи; если вы укажете
     'set write off' (устанавливается по умолчанию), GDB открывает их в
     режиме только для чтения.

     Если вы уже загрузили файл, то после установки 'set write' вам
     необходимо загрузить его снова (используя команды 'exec-file' или
     'core-file'), чтобы новые установки вступили в силу.

'show write'
     Показать, открыты исполняемые файлы и файлы дампов памяти для
     записи или нет.


File: gdb.html,  Node: Файлы GDB,  Next: Отладочные цели,  Prev: Изменения,  Up: Top

12 Файлы GDB
************

GDB должен знать имя файла программы, которая будет отлаживаться, чтобы
прочитать его таблицу символов и чтобы запустить его.  Для отладки дампа
памяти от предыдущего выполнения, вы также должны сообщить GDB имя этого
файла.

* Menu:

* Файлы::                       Команды для задания файлов
* Ошибки с символами::          Ошибки чтения файлов с символами


File: gdb.html,  Node: Файлы,  Next: Ошибки с символами,  Up: Файлы GDB

12.1 Команды для задания файлов
===============================

Вы можете указать имена исполняемого файла и файла дампа памяти.  Обычно
это делается во время вызова GDB, используя параметры с командами
запуска GDB (*note Вход и выход из GDB: Вызов.).

   Иногда во время сеанса GDB необходимо перейти к другому файлу.  Или
вы можете запустить GDB, забыв указать файл, который хотите
использовать.  В таких ситуациях полезны команды GDB для задания новых
файлов.

'file ИМЯ-ФАЙЛА'
     Использовать ИМЯ-ФАЙЛА в качестве программы для отладки.  Из нее
     читаются символы и содержание неизменяемой памяти.  Также она
     является программой, которая выполняется при использовании команды
     'run'.  Если вы не укажете каталог, и файл не будет найден в
     рабочем каталоге GDB, он использует переменную среды 'PATH' в
     качестве списка каталогов для поиска, точно так же, как это делает
     оболочка, когда ищет программу для выполнения.  Используя команду
     'path', вы можете изменить значение этой переменной как для GDB,
     так и для вашей программы.

     В системах с отображаемыми в память файлами, информация из таблицы
     символов для ИМЯ-ФАЙЛА может храниться во вспомогательном файле
     'ИМЯ-ФАЙЛА.syms'.  Если это так, GDB осуществляет отображение
     таблицы символов из 'ИМЯ-ФАЙЛА.syms', запускаясь намного быстрее.
     Смотрите описания ключей файлов '-mapped' и '-readnow' (доступных с
     командной строки и в командах 'file', 'symbol-file' или
     'add-symbol-file', описанных ниже), для получения большей
     информации.

'file'
     'file' без параметров велит GDB уничтожить любую имеющуюся
     информацию как об исполняемом файле, так и о таблице символов.

'exec-file [ ИМЯ-ФАЙЛА ]'
     Указывает, что программа, которая должна быть выполнена (но не
     таблица символов), находится в ИМЯ-ФАЙЛА.  Если необходимо, GDB
     ищет вашу программу с помощью переменной среды 'PATH'.  Отсутствие
     ИМЯ-ФАЙЛА означает, что необходимо уничтожить информацию о
     выполняемом файле.

'symbol-file [ ИМЯ-ФАЙЛА ]'
     Читать информацию таблицы символов из файла ИМЯ-ФАЙЛА.  При
     необходимости производится поиск с помощью переменной среды 'PATH'.
     Для получения таблицы символов и исполняемой программы из одного и
     того же файла, используйте команду 'file'.

     'symbol-file' без параметров сбрасывает информацию GDB о таблице
     символов вашей программы.

     Команда 'symbol-file' велит GDB забыть содержимое своих
     вспомогательных переменных, историю значений и все точки останова и
     выражения автоматического отображения, так как они могут содержать
     указатели на внутренние данные, хранящие символы и типы данных,
     которые являются частью данных старой таблицы символов,
     уничтоженной внутри GDB.

     'symbol-file' не повторяется, если вы снова нажимаете <RET> после
     первого выполнения.

     Когда GDB сконфигурирован для определенной среды, он распознает
     отладочную информацию в том формате, который обычно генерируется
     для этой среды; вы можете использовать или компилятор GNU, или
     другие компиляторы, которые придерживаются местных соглашений.
     Наилучшие результаты обычно достигаются с помощью компилятора GNU;
     например, используя 'gcc', вы можете создавать отладочную
     информацию для оптимизированного кода.

     Для большинства типов объектных файлов, за исключением старых
     систем SVR3, использующих COFF, команда 'symbol-file' обычно не
     считывает таблицу символов сразу целиком.  Вместо этого, она быстро
     сканирует ее для определения, какие исходные файлы и символы в ней
     присутствуют.  Детали читаются позже, по одному исходному файлу за
     раз, по мере необходимости.

     Такая стратегия чтения в две стадии используется для того, чтобы
     GDB вызывался быстрее.  За исключением редких пауз, чтение деталей
     таблицы символов для конкретного исходного файла в большинстве
     случаев практически незаметно.  (Команда 'set verbose' позволяет
     при желании превратить эти паузы в сообщения.  *Note Необязательные
     предупреждения и сообщения: Сообщения/предупреждения.)

     Мы еще не реализовали двухступенчатую стратегию чтения для COFF.
     Когда таблица символов сохранена в формате COFF, 'symbol-file'
     считывает данные таблицы символов сразу полностью.  Заметьте, что
     "stabs-in-COFF" все же реализует двухступенчатую стратегию, так как
     отладочная информация реально хранится в формате stabs.

'symbol-file ИМЯ-ФАЙЛА [ -readnow ] [ -mapped ]'
'file ИМЯ-ФАЙЛА [ -readnow ] [ -mapped ]'
     Если вы хотите быть уверены, что у GDB есть вся таблица символов
     целиком, вы можете отменить двухступенчатую стратегию чтения
     таблицы символов, используя параметр '-readnow' с любой командой,
     загружающей информацию таблицы символов.

     Если на вашей системе можно отображать файлы в память через
     системный вызов 'mmap', вы можете использовать другой параметр,
     '-mapped', чтобы GDB записывал символы для вашей программы в файл
     многократного использования.  Последующие сеансы отладки GDB
     отображают информацию о символах из этого вспомогательного файла
     (если программа не изменилась), вместо того, чтобы тратить время на
     чтение таблицы символов из исполняемой программы.  Использование
     параметра '-mapped' производит такой же эффект, как вызов GDB с
     ключом командной строки '-mapped'.

     Вы можете использовать оба параметра вместе, чтобы быть уверенным,
     что вспомогательный файл символов содержит всю информацию о
     символах вашей программы.

     Вспомогательный файл символов для программы ПРОГ называется
     'ПРОГ.syms'.  Если этот файл существует (и создан позже, чем
     соответствующая исполняемая программа), GDB всегда пытается
     использовать его при отладке ПРОГ; не требуется никаких специальных
     ключей или команд.

     Файл '.syms' является специфичным для рабочей машины, на которой вы
     вызываете GDB. Он содержит точный образ внутренней таблицы символов
     GDB. Он не может быть использован одновременно на разных рабочих
     платформах.

'core-file [ ИМЯ-ФАЙЛА ]'
     Определяет местонахождение файла дампа памяти, который будет
     использован как "содержимое памяти".  Обычно файлы дампов памяти
     содержат только некоторые части адресного пространства процесса,
     создавшего их; GDB может обращаться к исполняемому файлу за другими
     частями.

     'core-file' без параметра указывает, что файл дампа памяти
     использоваться не должен.

     Обратите внимание, что файл дампа памяти игнорируется, если в
     данное время ваша программа выполняется под управлением GDB. Так
     что если вы выполняли программу и желаете вместо этого отладить
     файл дампа, вы должны убить подпроцесс, в котором выполняется ваша
     программа.  Для этого используйте команду 'kill' (*note Уничтожение
     дочернего процесса: Уничтожение процесса.).

'add-symbol-file ИМЯ-ФАЙЛА АДРЕС'
'add-symbol-file ИМЯ-ФАЙЛА АДРЕС [ -readnow ] [ -mapped ]'
'add-symbol-file ИМЯ-ФАЙЛА -sРАЗДЕЛ АДРЕС'
     Команда 'add-symbol-file' считывает дополнительную информацию
     таблицы символов из файла ИМЯ-ФАЙЛА.  Вы должны использовать эту
     команду, если файл ИМЯ-ФАЙЛА был динамически загружен (другими
     средствами) в выполняющуюся программу.  АДРЕС должен быть адресом
     памяти, по которому был загружен файл; GDB сам его определить не
     может.  Вы можете указать дополнительно произвольное количество пар
     '-s РАЗДЕЛ АДРЕС', чтобы явно указать имя раздела и базовый адрес
     для него.  Вы можете указать произвольный АДРЕС как выражение.

     Таблица символов из файла ИМЯ-ФАЙЛА добавляется к таблице,
     изначально считанной по команде 'symbol-file'.  Вы можете
     использовать команду 'add-symbol-file' произвольное число раз;
     прочитанные таким образом символьные данные добавляются к старым.
     Чтобы уничтожить все старые данные, используйте команду
     'symbol-file' без аргументов.

     Команда 'add-symbol-file' не повторяется, если вы нажимаете <RET>
     после ее использования.

     Чтобы изменить способ обработки GDB таблицы символов для ИМЯ-ФАЙЛА,
     вы можете использовать параметры '-mapped' и '-readnow' так же, как
     и с командой 'symbol-file'.

'add-shared-symbol-file'
     Команда 'add-shared-symbol-file' может быть использована только для
     Motorola 88k в операционной системе Harris CXUX. GDB ищет
     разделяемые библиотеки автоматически, однако, если он не находит
     ваших, вы можете выполнить 'add-shared-symbol-file'.  Эта команда
     не имеет аргументов.

'section'
     Команда 'section' изменяет базовый адрес раздела РАЗДЕЛ
     выполняемого файла на АДРЕС.  Это может быть использовано, если
     выполняемый файл не содержит адресов разделов (что имеет место для
     формата a.out), или когда адреса, указанные в самом файле, неверны.
     Каждый раздел должен изменяться отдельно.  Команда 'info files',
     описанная ниже, перечисляет все разделы и их адреса.

'info files'
'info target'
     Команды 'info files' и 'info target' являются синонимами; они обе
     выводят текущую цель (*note Определение отладочной цели: Отладочные
     цели.), включая имена выполняемого файла и файла дампа памяти,
     используемых GDB, и файлов, из которых были загружены символы.
     Команда 'help target' выводит все возможные цели, а не только
     текущую.

   Все команды для задания файлов допускают в качестве аргументов как
абсолютные, так и относительные имена файлов.  GDB всегда
преобразовывает имя файла к абсолютному и запоминает его в таком виде.

   GDB поддерживает разделяемые библиотеки на HP-UX, SunOS, SVr4, Irix 5
и IBM RS/6000.

   Когда вы даете команду 'run', или когда исследуете файл дампа памяти,
GDB автоматически загружает определения символов из разделяемых
библиотек.  (Однако, если вы не отлаживаете файл дампа, GDB не понимает
ссылки на функции из разделяемой библиотеки до того, как вы выполните
команду 'run'.)

   На HP-UX, если программа загружает разделяемую библиотеку явно, GDB
автоматически загружает символы в момент вызова 'shl_load'.

'info share'
'info sharedlibrary'
     Вывести имена разделяемых библиотек, загруженных в данный момент.

'sharedlibrary РЕГ-ВЫР'
'share РЕГ-ВЫР'
     Загрузить символы разделяемых библиотек для файлов, удовлетворяющих
     регулярному выражению Unix.  Также как и для автоматически
     загруженных файлов, это загружает только разделяемые библиотеки,
     требуемые вашей программой для файла дампа памяти или после ввода
     'run'.  Если РЕГ-ВЫР опущено, загружаются все разделяемые
     библиотеки, требуемые вашей программой.

   В системах HP-UX, GDB сам определяет загрузку разделяемой библиотеки
и автоматически считывает символы из нее до некоторого изначально
установленного порогового значения, которое вы можете при желании
изменить.

   После этого порогового значения символы из разделяемых библиотек
должны загружаться явно.  Для загрузки этих символов используйте команду
'sharedlibrary ИМЯ-ФАЙЛА'.  Базовый адрес разделяемой библиотеки
определяется GDB автоматически и вы не должны его задавать.

   Для отображения или установки порогового значения используйте
следующие команды:

'set auto-solib-add ПОРОГ'
     Устанавливает размер порога автоматической загрузки в мегабайтах.
     Если ПОРОГ ненулевой, символы из всех библиотек разделяемых
     объектов будут загружаться автоматически, когда программа начинает
     выполнение, или когда динамический компоновщик информирует GDB о
     том, что была загружена новая библиотека, до тех пор, пока таблица
     символов программы и библиотек не превысит этот порог.  В противном
     случае, символы должны загружаться вручную, при помощи команды
     'sharedlibrary'.  По умолчанию порог равен 100 мегабайтам.

'show auto-solib-add'
     Отобразить величину текущего порога автоматической загрузки в
     мегабайтах.


File: gdb.html,  Node: Ошибки с символами,  Prev: Файлы,  Up: Файлы GDB

12.2 Ошибки чтения файлов с символами
=====================================

При чтении файла символов, GDB иногда сталкивается с такими проблемами,
как типы символов, которые он не распознает, или известные ошибки вывода
компилятора.  По умолчанию, GDB не сообщает вам о таких проблемах, так
как они сравнительно общие и прежде всего представляют интерес для
людей, занимающихся отладкой компиляторов.  Если вам интересна
информация о плохо составленных таблицах символов, вы можете запросить
GDB печатать только одно сообщение по каждому типу проблем, независимо
от того, сколько раз проблема появляется; или вы можете попросить GDB
напечатать больше сообщений, чтобы увидеть, сколько раз проблема
встречалась, командой 'set complaints' (*note Необязательные
предупреждения и сообщения: Сообщения/предупреждения.).

   Печатаемые сообщения и их значения, включают:

'inner block not inside outer block in СИМВОЛ'

     Информация о символах показывает, где области символов начинаются и
     заканчиваются (например, в начале функции или блока операторов).
     Эта ошибка указывает на то, что внутренний блок видимости не
     содержится целиком во внешнем.

     GDB обходит эту проблему, рассматривая внутренний блок так, как
     если бы он имел такую же область видимости, что и внешний.  Если
     внешний блок не является функцией, то СИМВОЛ в данном сообщении
     может быть показан как "'(don't known)'".

'block at АДРЕС out of order'

     Символьная информация для блоков символьных областей должна
     появляться в порядке увеличения адресов.  Данная ошибка указывает,
     что это не так.

     GDB не решает этой проблемы, и у него возникают трудности при
     определении местоположения символов в исходном файле, символы
     которого он считывает.  (Вы часто можете определить имя
     поврежденного исходного файла, указав 'set verbose on'.  *Note
     Необязательные предупреждения и сообщения:
     Сообщения/предупреждения.)

'bad block start address patched'

     Символьная информация для блоков символьных областей имеет меньший
     начальный адрес, чем у предшествующей строки исходного текста.
     Известно, что это происходит в компиляторе Си SunOS 4.1.1 (и более
     ранних версиях).

     GDB обходит проблему, обрабатывая блок символьной области как
     начинающийся с предыдущей исходной строки.

'bad string table offset in symbol N'

     Символ с номером N содержит указатель на таблицу строк, который
     превосходит размер таблицы.

     GDB обходит проблему, считая, что символ имеет имя 'foo', что может
     вызвать другие проблемы, если много символов заканчиваются этим
     именем.

'unknown symbol type 0xNN'

     Символьная информация содержит новые типы данных, которые GDB еще
     не знает, как считывать.  '0xNN' -- это тип символа неверно
     истолкованной информации, в шестнадцатеричном виде.

     GDB обходит ошибку, игнорируя эту символьную информацию.  Это
     обычно позволяет вам отлаживать программу, хотя некоторые символы и
     недоступны.  Если вы столкнетесь с такой проблемой и захотите ее
     отладить, вы можете отладить 'gdb' с помощью него же, установив
     точку останова на 'complain', затем дойти до функции
     'read_dbx_symtab' и исследовать '*bufp', чтобы увидеть символ.

'stub type has NULL name'

     GDB не может найти полное определение для структуры или класса.

'const/volatile indicator missing (ok if using g++ v1.x), got...'
     В символьной информации для функции-члена Си++ пропущена некоторая
     информация, которую последние версии компилятора должны для нее
     выводить.

'info mismatch between compiler and debugger'

     GDB не может разобрать спецификации типа, выведенной компилятором.


File: gdb.html,  Node: Отладочные цели,  Next: Конфигурации,  Prev: Файлы GDB,  Up: Top

13 Определение отладочной цели
******************************

"Цель" -- это среда выполнения, занятая вашей программой.

   Часто GDB выполняется в той же рабочей среде, что и ваша программа; в
этом случае отладочная цель задается неявно в момент использования
команд 'file' или 'core'.  Когда вам нужна большая гибкость -- например,
выполнение GDB на другой машине, или управление автономной системой
через последовательный порт или системой реального времени через
соединение TCP/IP -- вы можете использовать команду 'target' для
определения цели одного из типов, сконфигурированных для GDB (*note
Команды для управления целями: Команды для целей.).

* Menu:

* Активные цели::               Активные цели
* Команды для целей::           Команды для управления целями
* Порядок байтов::              Выбор целевого порядка байтов
* Удаленная отладка::           Удаленная отладка
* Отображение объектов ядра::    Отображение объектов ядра


File: gdb.html,  Node: Активные цели,  Next: Команды для целей,  Up: Отладочные цели

13.1 Активные цели
==================

Существует три класса целей: процессы, файлы дампов памяти и выполняемые
файлы.  GDB может обрабатывать одновременно до трех активных целей, по
одной в каждом классе.  Это позволяет вам (например) запустить процесс и
проверять его действия, не прерывая вашу работу над файлом дампа.

   Например, если вы выполняете 'gdb a.out', то исполняемый файл 'a.out'
является единственной активной целью.  Если вы назначите также файл
дампа -- возможно, от предыдущего выполнения, завершившегося ошибкой и
создавшего дамп, -- тогда GDB имеет две активные цели и использует их
вместе, просматривая сначала файл дампа, а затем исполняемый файл, для
выполнения запросов к адресам памяти.  (Обычно эти два класса целей
дополняют друг друга, так как файлы дампа памяти содержат только память
программы, доступную для чтения и записи (переменные и тому подобное), и
машинное состояние, в то время как исполняемые файлы содержат только
текст программы и инициализированные данные.)

   Когда вы вводите 'run', ваш исполняемый файл становится также
активным целевым процессом.  Когда целевой процесс активен, все команды
GDB, запрашивающие адреса памяти, относятся к этой цели; адреса в
активной цели файла дампа или выполняемого файла неизвестны, пока
активен целевой процесс.

   Используйте команды 'core-file' и 'exec-file' для выбора новой цели
файла дампа памяти или выполняемого файла (*note Команды для задания
файлов: Файлы.).  Для определения в качестве цели процесса, который уже
выполняется, используйте команду 'attach' (*note Отладка запущенного
ранее процесса: Присоединение.).


File: gdb.html,  Node: Команды для целей,  Next: Порядок байтов,  Prev: Активные цели,  Up: Отладочные цели

13.2 Команды для управления целями
==================================

'target ТИП ПАРАМЕТРЫ'
     Соединяет рабочую среду GDB с целевой машиной или процессом.  Целью
     обычно является протокол для взаимодействия со средствами отладки.
     Параметр ТИП используется, чтобы определить тип или протокол
     целевой машины.

     Дальнейшие ПАРАМЕТРЫ интерпретируются целевым протоколом, но обычно
     включают такие вещи, как имена устройств или имена рабочих машин, с
     которыми осуществляется связь, номера процессов и скорости в бодах.

     Команда 'target' не повторяется при повторном нажатии <RET> после
     ее выполнения.

'help target'
     Отображает имена всех доступных целей.  Чтобы отобразить выбранные
     в данный момент цели, используйте либо 'info target', либо 'info
     files' (*note Команды для задания файлов: Файлы.).

'help target ИМЯ'
     Описывает определенную цель, включая любые параметры, необходимые
     для ее выбора.

'set gnutarget АРГ'
     GDB использует свою собственную библиотеку BFD(1) для чтения ваших
     файлов.  GDB знает, читает ли он "выполняемый файл", "файл дампа
     памяти" или "объектный (.o)" файл; однако вы можете определить
     формат файла командой 'set gnutarget'.  В отличие от большинства
     команд 'target', в команде 'gnutarget' слово 'target' относится к
     программе, а не к машине.

          _Предупреждение:_ Для определения формата файла посредством
          'set gnutarget', вы должны знать фактическое имя BFD.

     *Note Команды для задания файлов: Файлы.

'show gnutarget'
     Используйте команду 'show gnutarget' для отображения, какого
     формата файлы 'gnutarget' установлен считывать.  Если вы не
     установили 'gnutarget', GDB определит формат для каждого файла
     автоматически, и 'show gnutarget' выведет 'The current BFD target
     is "auto"'.

   Ниже приведены некоторые наиболее распространенные цели (доступные
или нет, в зависимоси от конфигурации GDB):

'target exec ПРОГРАММА'
     Выполняемый файл.  'target exec ПРОГРАММА' -- это то же самое, что
     и 'exec-file ПРОГРАММА'.

'target core ИМЯ-ФАЙЛА'
     Файл дампа памяти.  'target core ИМЯ-ФАЙЛА' -- это то же самое, что
     и 'core-file ИМЯ-ФАЙЛА'.

'target remote УСТР'
     Удаленная последовательная цель является уникальным для GDB
     протоколом.  Параметр УСТР определяет, какое последовательное
     устройство использовать для соединения (например, '/dev/ttya').
     *Note Удаленная отладка: Удаленная отладка.  'target remote'
     поддерживает команду 'load'.  Это полезно, только если вы можете
     получить заглушку для целевой системы каким-нибудь другим способом
     и можете разместить ее в памяти, где она не будет затерта
     загрузкой.

'target sim'
     Встроенный эмулятор ЦП. GDB включает эмуляторы для большинства
     архитектур.  Вообще,
                  target sim
                  load
                  run
     работает; однако, вы не можете предполагать, что доступны какое-то
     отображение памяти, драйверы устройств или даже элементарные
     функции ввода-вывода, хотя некоторые эмуляторы действительно
     предоставляют это.  Для информации о деталях эмуляторов для
     конкретного процессора, смотрите соответствующий *note Встроенные
     процессоры: Встроенные процессоры.

   Некоторые конфигурации могут также включать такие цели:

'target nrom УСТР'
     Эмулятор NetROM ROM. Эта цель поддерживает только загрузку.

   Для различных конфигураций GDB доступны различные цели; ваша
конфигурация может иметь больше или меньше целей.

   Многие удаленные цели требуют, чтобы вы загрузили код выполняемого
файла после того как успешно установили соединение.

'load ИМЯ-ФАЙЛА'
     В зависимости от того, какие возможности удаленной отладки
     сконфигурированы в GDB, может быть доступна команда 'load'.  Если
     она существует, ее задачей является сделать ИМЯ-ФАЙЛА (выполняемый
     файл) доступным для отладки на удаленной системе -- например, путем
     загрузки или динамической сборки.  'load' также записывает таблицу
     символов ИМЯ-ФАЙЛА в GDB, как команда 'add-symbol-file'.

     Если ваш GDB не имеет команды 'load', попытка выполнить ее выдает
     сообщение об ошибке "'You can't do that when your target is ...'".

     Файл загружается по адресу, указанному в выполняемом файле.  Для
     некоторых форматов объектных файлов вы можете задать адрес загрузки
     при сборке программы; для других форматов, таких как a.out, формат
     объектного файла задает фиксированный адрес.

     'load' не повторяется, если вы нажимаете <RET> снова после ее
     использования.

   ---------- Footnotes ----------

   (1) от 'Binary File Descriptor' (библиотека описания двоичных
файлов).  (Прим. переводчика)


File: gdb.html,  Node: Порядок байтов,  Next: Удаленная отладка,  Prev: Команды для целей,  Up: Отладочные цели

13.3 Выбор целевого порядка байтов
==================================

Некоторые типы процессоров, такие как MIPS, PowerPC и Hitachi SH,
предоставляют возможность выполнения либо с порядком байтов от старшего,
либо с порядком байтов от младшего.  Обычно выполняемый файл или таблица
символов содержат информацию для определения используемого порядка
байтов, и вам не нужно об этом заботиться.  Однако, иногда вам все же
может пригодиться вручную изменить порядок байтов процессора,
определенный GDB.

'set endian big'
     Велит GDB считать, что целевой порядок байтов от старшего.

'set endian little'
     Велит GDB считать, что целевой порядок байтов от младшего.

'set endian auto'
     Велит GDB использовать порядок байтов, указанный в выполняемом
     файле.

'show endian'
     Отображает текущую установку GDB для целевого порядка байтов.

   Заметьте, что эти команды управляют только интерпретацией символьных
данных в рабочей системе, и они совершенно не оказывают действия на
целевую систему.


File: gdb.html,  Node: Удаленная отладка,  Next: Отображение объектов ядра,  Prev: Порядок байтов,  Up: Отладочные цели

13.4 Удаленная отладка
======================

Если вы пытаетесь отлаживать программу, выполняющуюся на машине, которая
не может запустить GDB обычным способом, часто бывает полезна удаленная
отладка.  Например, вы можете использовать удаленную отладку для ядра
операционной системы или для малой системы, которая не имеет достаточно
мощной операционной системы общего назначения для вызова отладчика со
всеми возможностями.

   Некоторые конфигурации GDB имеют специальный последовательный или
TCP/IP-интерфейсы для того, чтобы это работало с конкретными отладочными
целями.  Кроме того, GDB распространяется с общим последовательным
протоколом (уникальным для GDB, но не для конкретной целевой системы),
который вы можете использовать, если пишете удаленные заглушки -- код,
выполняемый в удаленной системе для связи с GDB.

   В вашей конфигурации GDB могут быть доступны другие удаленные цели;
используете 'help target', чтобы получить их список.

* Menu:

* Удаленный::                   Удаленный последовательный протокол GDB


File: gdb.html,  Node: Удаленный,  Up: Удаленная отладка

13.4.1 Удаленный последовательный протокол GDB
----------------------------------------------

Для отладки программы, выполняемой на другой машине (отладочной
"целевой" машине), вы сперва должны создать все обычные предпосылки для
самостоятельного выполнения программы.  Например, для программы на Си
вам нужны:

  1. Процедура запуска для установки среды выполнения Си; она обычно
     имеет имя типа 'crt0'.  Процедура запуска может быть обеспечена
     аппаратными средствами, или вы должны написать свою собственную.

  2. Библиотека подпрограмм Си для поддержки вызовов подпрограмм вашей
     программы, особенно для управления вводом и выводом.

  3. Способ установки вашей программы на другую машину -- например,
     программа загрузки.  Такие программы часто предоставляются
     поставщиками аппаратных средств, но вам может потребоваться
     написать вашу собственную, пользуясь документацией к аппаратному
     обеспечению.

   Следующим шагом будет принятие мер по использованию вашей программой
последовательного порта для связи с машиной, где выполняется GDB
("рабочей" машиной).  В общих чертах, схема выглядит следующим образом:

_На рабочей машине_
     GDB уже понимает, как использовать этот протокол; после установки
     всего остального, вы можете просто использовать команду 'target
     remote' (*note Определение отладочной цели: Отладочные цели.).

_На целевой машине_
     вы должны скомпоновать вместе с вашей программой несколько
     подпрограмм специального назначения, которые реализуют удаленный
     последовательный протокол GDB. Файл, содержащий эти подпрограммы,
     называется "отладочной заглушкой".

     На некоторых удаленных целях, вы можете использовать
     вспомогательную программу 'gdbserver' вместо компоновки заглушки
     вместе с вашей программой.  *Note Использование программы
     'gdbserver': Сервер, для детального изучения.

   Отладочная заглушка специфична для архитектуры удаленной машины;
например, используйте 'sparc-stub.c' для отладки программ на машинах
SPARC.

   Следующие работающие удаленные заглушки распространяются вместе с
GDB:

'i386-stub.c'
     Для Intel 386 и совместимых архитектур.

'm68k-stub.c'
     Для архитектур Motorola 680x0.

'sh-stub.c'
     Для архитектур Hitachi SH.

'sparc-stub.c'
     Для архитектур SPARC.

'sparcl-stub.c'
     Для архитектур Fujitsu SPACRLITE.

   Файл 'README' в поставке GDB может содержать другие недавно
добавленные заглушки.

* Menu:

* Содержимое заглушки::   Что заглушка может сделать для вас
* Начальная загрузка::    Что вы должны сделать для заглушки
* Сеанс отладки::         Собираем все вместе
* Протокол::              Определение протокола связи
* Сервер::                Использование программы 'gdbserver'
* NetWare::               Использование программы 'gdbserve.nlm'


File: gdb.html,  Node: Содержимое заглушки,  Next: Начальная загрузка,  Up: Удаленный

13.4.1.1 Что заглушка может сделать для вас
...........................................

Отладочная заглушка для вашей архитектуры содержит следующие три
подпрограммы:

'set_debug_traps'
     Когда ваша программа останавливается, эта подпрограмма организует
     выполнение 'handle_exception'.  Вы должны явно вызвать эту
     подпрограмму в начале вашей программы.

'handle_exception'
     Это главная рабочая лошадка, но ваша программа никогда не вызывает
     ее явно -- установочный код организует запуск 'handle_exception',
     когда вызывается ловушка.

     'handle_exception' получает управление, когда ваша программа
     останавливается во время выполнения (например, в точке останова), и
     организует связь с GDB на рабочей машине.  Именно здесь реализуется
     протокол связи; 'handle_exception' действует как представитель GDB
     на целевой машине.  Сперва она посылает суммарную информацию о
     состоянии вашей программы, затем продолжает выполняться, извлекая и
     передавая любую информацию, требующуюся GDB, пока вы не выполните
     команду GDB, возобновляющую выполнение вашей программы; в этом
     месте 'handle_exception' возвращает управление вашему коду на
     целевой машине.

'breakpoint'
     Используйте эту вспомогательную подпрограмму для установки в вашей
     программе точек останова.  В зависимости от конкретной ситуации,
     это может быть единственным способом для GDB получить управление.
     Например, если ваша целевая машина имеет некую клавишу прерывания,
     вам не нужно вызывать эту подпрограмму; нажатие клавиши прерывания
     передаст управление 'handle_exception' -- в действительности, GDB.
     На некоторых машинах простое получение знаков на последовательный
     порт может также вызвать ловушку; опять, в этой ситуации вам не
     нужно вызывать 'breakpoint' из вашей программы -- простое
     выполнение 'target remote' из рабочего сеанса GDB передаст
     управление.

     Вызывайте 'breakpoint', если ни одно из этих предположений не
     верно, или вы просто хотите быть уверенным, что ваша программа
     остановится в предопределенной точке от начала вашего сеанса
     отладки.


File: gdb.html,  Node: Начальная загрузка,  Next: Сеанс отладки,  Prev: Содержимое заглушки,  Up: Удаленный

13.4.1.2 Что вы должны сделать для заглушки
...........................................

Отладочные заглушки, поставляемые с GDB, ориентированы на
микропроцессоры определенной архитектуры, но они не имеют информации об
остальной части вашей целевой отладочной машины.

   В первую очередь, вам нужно сообщить заглушке, как связаться с
последовательным портом.

'int getDebugChar()'
     Напишите эту подпрограмму для чтения одного знака из
     последовательного порта.  Она может быть идентична 'getchar' для
     вашей целевой системы; разные имена используются, чтобы позволить
     вам их различать, если вы этого хотите.

'void putDebugChar(int)'
     Напишите эту подпрограмму для записи одного знака в
     последовательный порт.  Она может быть идентична 'putchar' для
     вашей целевой системы; разные имена используются, чтобы позволить
     вам их различать, если вы этого хотите.

   Если вы хотите, чтобы GDB мог остановить вашу программу во время ее
выполнения, вам нужно использовать управляемый прерываниями
последовательный драйвер и настроить его для остановки при получении
'^C' ('\003', знак control-C). Это тот знак, который GDB использует для
указания удаленной системе остановиться.

   Указание отладочной цели вернуть GDB правильный статус, вероятно,
потребует изменений в стандартной заглушке; один быстрый и неаккуратный
способ состоит в выполнении лишь инструкции точки останова
("неаккуратность" состоит в том, что GDB выдает 'SIGTRAP' вместо
'SIGINT').

   Вот другие процедуры, которые вы должны обеспечить:

'void exceptionHandler (int НОМЕР-ИСКЛЮЧЕНИЯ, void *АДРЕС-ИСКЛЮЧЕНИЯ)'
     Напишите эту функцию для установки АДРЕСА-ИСКЛЮЧЕНИЯ в таблицы
     обработки исключительных ситуаций.  Вам нужно сделать это, потому
     что у заглушки нет способа узнать, как устроены таблицы обработки
     исключений в вашей целевой системе (например, процессорная таблица
     может находиться в ПЗУ и содержать элементы, указывающие на таблицу
     в ОЗУ).  НОМЕР-ИСКЛЮЧЕНИЯ -- это номер исключительной ситуации,
     которая должна быть изменена; его значение зависит от архитектуры
     (например, различные номера могут представлять деление на ноль,
     доступ с нарушением выравнивания и так далее).  Когда это
     исключение возникает, управление должно быть передано
     непосредственно АДРЕСУ-ИСКЛЮЧЕНИЯ, и процессорное состояние (стек,
     регистры и так далее) должно быть таким же, как во время
     возникновения процессорного исключения.  Так что если вы хотите
     использовать инструкцию перехода для достижения АДРЕСА-ИСКЛЮЧЕНИЯ,
     это должен быть простой переход, не переход к подпрограмме.

     Для 386, АДРЕС-ИСКЛЮЧЕНИЯ должен быть установлен как обработчик
     затвора вызова прерывания, чтобы во время его выполнения остальные
     прерывания маскировались.  Он должен иметь уровень полномочий 0
     (наибольшие полномочия).  Заглушки SPARC и 68k могут маскировать
     прерывания самостоятельно без помощи 'exceptionHandler'.

'void flush_i_cache()'
     Только для SPARC и SPARCLITE.  Напишите эту подпрограмму для
     очистки кеша инструкций на вашей целевой машине, если он есть.
     Если кеша инструкций нет, эта подпрограмма может ничего не делать.

     На целевых машинах, имеющих кеш инструкций, GDB требует эту
     функцию, чтобы удостовериться, что состояние вашей программы
     стабильно.

Вы должны также удостовериться, что доступна такая библиотечная
процедура:

'void *memset(void *, int, int)'
     Это стандартная библиотечная функция 'memset', которая
     устанавливает область памяти в заданное значение.  Если у вас есть
     одна из свободных версий 'libc.a', 'memset' может быть найдена там;
     иначе вы должны или получить ее от изготовителя аппаратного
     обеспечения, или написать свою собственную.

   Если вы не используете компилятор GNU Си, вам также могут
понадобиться другие стандартные библиотечные подпрограммы; это меняется
от одной заглушки к другой, но в общем, заглушки часто используют
различные общие библиотечные подпрограммы, которые 'gcc' генерирует как
встроенный код.


File: gdb.html,  Node: Сеанс отладки,  Next: Протокол,  Prev: Начальная загрузка,  Up: Удаленный

13.4.1.3 Собираем все вместе
............................

Вкратце, когда ваша программа готова к отладке, вы должны проделать
следующие шаги.

  1. Убедитесь, что вы определили поддерживающие процедуры низкого
     уровня (*note Что вы должны сделать для заглушки: Начальная
     загрузка.):
          'getDebugChar', 'putDebugChar',
          'flush_i_cache', 'memset', 'exceptionHandler'.

  2. Вставьте следующие строки в начале вашей программы:

          set_debug_traps();
          breakpoint();

  3. Для заглушки 680x0, вы должны предоставить переменную
     'exceptionHook'.  Обычно вы используете просто

          void (*exceptionHook)() = 0;

     если до вызова 'set_debug_traps' вы установили ее для указания на
     функцию в вашей программе.  Эта функция вызывается, когда GDB
     продолжает выполнение после останова на ловушке (например, ошибка
     шины).  Функция, указанная 'exceptionHook', вызывается с одним
     параметром типа 'int', который является номером исключения.

  4. Откомпилируйте и скомпонуйте вместе: вашу программу, отладочную
     заглушку GDB для вашей целевой архитектуры и подпрограммы
     поддержки.

  5. Убедитесь, что у вас есть последовательное соединение между вашей
     целевой и рабочей машинами, и идентифицируйте последовательный порт
     на рабочей машине.

  6. Загрузите вашу программу на целевую машину (или поместите ее туда
     любыми средствами, предоставляемыми производителем) и запустите ее.

  7. Для начала удаленной отладки, запустите GDB на рабочей машине и
     укажите в качестве выполняемого файла программу, которая
     выполняется на удаленной машине.  Это сообщает GDB, как найти
     символы и содержание неизменяемых областей вашей программы.

  8. Установите связь, используя команду 'target remote'.  Ее аргументы
     определяют, как взаимодействовать с целевой машиной -- либо через
     устройство, подключенное к последовательной линии, либо через порт
     TCP (обычно подключенный к терминальному серверу, который, в свою
     очередь, имеет последовательную линию до цели).  Например, чтобы
     использовать последовательную линию, присоединенную к устройству
     '/dev/ttyb', выполните:

          target remote /dev/ttyb

     Чтобы использовать TCP-соединение, используйте аргумент в форме
     'МАШИНА:порт'.  Например, для соединения с портом 2828 на
     терминальном сервере 'manyfarms':

          target remote manyfarms:2828

   Теперь вы можете использовать все обычные команды для исследования и
изменения данных, пошагового выполнения и продолжения исполнения
удаленной программы.

   Для возобновления выполнения удаленной программы и прекращения ее
отладки, используйте команду 'detach'.

   Всякий раз, когда GDB ожидает удаленную программу, если вы вводите
знак прерывания (часто 'C-C'), GDB пытается остановить программу.  Это
может привести или не привести к успеху, частично в зависимости от
аппаратных средств и последовательных драйверов, которые использует
удаленная система.  Если вы снова введете знак прерывания, GDB выведет
такое приглашение:

     Interrupted while waiting for the program.
     Give up (and stop debugging it)?  (y or n)

   Если вы введете 'y', GDB прекратит сеанс удаленной отладки.  (Если вы
позже решите попытаться снова, вы можете вновь использовать 'target
remote', чтобы соединиться еще раз.)  Если вы введете 'n', GDB вернется
к ожиданию.


File: gdb.html,  Node: Протокол,  Next: Сервер,  Prev: Сеанс отладки,  Up: Удаленный

13.4.1.4 Коммуникационный протокол
..................................

Файлы заглушек, поставляемые с GDB, реализуют коммуникационный протокол
со стороны целевой машины, а со стороны GDB он реализуется в исходном
файле GDB 'remote.c'.  Обычно вы можете просто позволить этим программам
взаимодействовать и не вдаваться в детали.  (Если вы разрабатываете свой
собственный файл заглушки, вы также можете игнорировать детали: начните
с одного из существующих файлов заглушки.  'sparc-stub.c' организован
наилучшим образом, и потому его легче всего читать.)

   Однако, бывают случаи, когда вам необходимо кое-что знать о протоколе
-- например, если существует только один последовательный порт на вашей
целевой машине, вы можете захотеть, чтобы ваша программа делала
что-нибудь особенное, если она распознает предназначенный для GDB пакет.

   В следующих примерах, '<-' и '->' используются для обозначения
переданных и полученных данных соответственно.

   Все команды и ответы GDB (не подтверждения) посылаются в виде ПАКЕТА.
ПАКЕТ представлен знаком '$', реальными ДАННЫМИ-ПАКЕТА и завершающим
знаком '#', за которым следуют две цифры КОНТРОЛЬНОЙ-СУММЫ:

     $ДАННЫЕ-ПАКЕТА#КОНТРОЛЬНАЯ-СУММА

Двузначная КОНТРОЛЬНАЯ-СУММА вычисляется как сумма по модулю 256 всех
знаков между начальным '$' и конечным '#' (восьмибитная беззнаковая
контрольная сумма).

   Разработчикам следует учесть, что до GDB версии 5.0 спецификация
протокола также включала необязательный двузначный ИД-ПОСЛЕДОВ:

     $ИД-ПОСЛЕДОВ:ДАННЫЕ-ПАКЕТА#КОНТРОЛЬНАЯ-СУММА

Этот ИД-ПОСЛЕДОВ добавлялся к подтверждению.  GDB никогда не генерировал
ИД-ПОСЛЕДОВ.  Заглушки, занимающиеся обработкой пакетов, добавленные в
GDB начиная с версии 5.0, не должны принимать пакеты с ИД-ПОСЛЕДОВ.

   Когда или рабочая, или целевая машина получает пакет, первым
ожидаемым ответом является подтверждение: или '+' (для указания, что
пакет получен корректно), или '-' (чтобы запросить повторную передачу):

     <- $ДАННЫЕ-ПАКЕТА#КОНТРОЛЬНАЯ-СУММА
     -> +

   Рабочая машина (GDB) посылает КОМАНДЫ, а целевая (отладочная
заглушка, включенная в вашу программу) посылает ОТВЕТ.  В случае КОМАНД
пошагового выполнения и продолжения, ответ посылается только тогда,
когда операция закончена (цель снова остановлена).

   ДАННЫЕ-ПАКЕТА состоят из последовательности знаков, за исключением
'#' и '$' (для дополнительных исключений, смотрите пакет 'X').

   Поля внутри пакета должны разделяться при помощи ',', ';' или ':'.
Если не оговорено противное, все числа представлены в шестнадцатеричном
виде без начальных нулей.

   Разработчикам следует учесть, что до GDB версии 5.0, знак ':' не мог
появляться третьим знаком в пакете (так как потенциально это могло
привести к конфликту с ИД-ПОСЛЕДОВ).

   ДАННЫЕ ответа могут быть для экономии закодированы методом длины
серий.  '*' означает, что следующий знак является ASCII-кодом, который
обозначает количество повторений знака, предшествующего '*'.  Кодировкой
является 'n+29', что дает печатный знак для 'n >=3' (когда кодировка
переменной длины начинает давать преимущество).  Печатные знаки '$',
'#', '+', '-' или знаки с номерами, большими 126, использоваться не
должны.

   Некоторые удаленные системы использовали другой механизм кодировки с
переменной длиной, иногда называемый cisco-кодировкой.  За '*' следуют
две шестнадцатеричные цифры, обозначающие размер пакета.

   Итак:
     "0* "
означает то же, что и "0000".

   При ошибке, ответ, возвращаемый для некоторых пакетов, включает
двузначный номер ошибки.  Этот номер определен смутно.

   Для любой КОМАНДЫ, не поддерживаемой заглушкой, должен быть возвращен
пустой ответ ('$#00').  Таким образом, протокол можно расширять.  По
этому ответу новые версии GDB могут определить, поддерживается тот или
иной пакет.

   От заглушки требуется поддержка КОМАНД 'g', 'G', 'm', 'M', 'c' и 's'.
Все остальные КОМАНДЫ являются необязательными.

   Вот полный список всех определенных на данный момент КОМАНД и
соответствующих им ответов ДАННЫЕ:
Пакет                  Запрос                 Описание
                                              
расширенные операции   '!'                    Использовать расширенный
                                              удаленный протокол.  Имеет
                                              постоянное действие --
                                              требует установки только
                                              один раз.  Расширенный
                                              удаленный протокол
                                              поддерживает пакеты 'R'.
                       ответ ''               Заглушки, поддерживающие
                                              расширенный удаленный
                                              протокол, возвращают '',
                                              что, к сожалению, совпадает
                                              с ответом, возвращаемым
                                              заглушками, которые не
                                              поддерживают расширения
                                              протокола.
                                              
последний сигнал       '?'                    Указывает причину, по
                                              которой цель остановилась.
                                              Ответ такой же, как для
                                              пошагового выполнения и
                                              продолжения.
                       ответ                  смотрите ниже
                                              
зарезервировано        'a'                    Зарезервировано для
                                              использования в будущем
                                              
установить аргументы   'A'ДЛИНА-АРГ','ЧИСЛО-АРГ','АРГ',...'
программы
*(зарезервировано)*
                                              В программу передается
                                              инициализированный массив
                                              'argv[]'.  ДЛИНА-АРГ задает
                                              число байт в закодированном
                                              в шестнадцатеричный вид
                                              потоке байт АРГ.  Смотрите
                                              'gdbserver' для
                                              дополнительной информации.
                       ответ 'OK'
                       ответ 'E'NN
                       
установить скорость    'b'БОД                 Установить скорость
*(не рекомендовано)*                          последовательной линии в
                                              БОД.
                                              
установить точку       'B'АДРЕС,РЕЖИМ         Установить (РЕЖИМ 'S') или
останова *(не                                 удалить (РЕЖИМ 'C') точку
рекомендовано)*                               останова по адресу АДРЕС.
                                              _Это было замещено пакетами
                                              'Z' и 'z'._
                                              
продолжить             'c'АДРЕС               АДРЕС -- это адрес для
                                              возобновления выполнения.
                                              Если он опущен, возобновить
                                              с текущего адреса.
                       ответ                  смотрите ниже
                                              
продолжить с           'C'СИГ';'АДРЕС         Продолжить с сигналом СИГ
сигналом                                      (шестнадцатеричный номер
                                              сигнала).  Если '';'АДРЕС'
                                              опущено, выполнение
                                              возобновляется с прежнего
                                              адреса.
                       ответ                  смотрите ниже
                                              
переключить режим      'd'                    переключить флаг отладки.
отладки *(не                                  
рекомендовано)*
отсоединиться          'D'                    Отсоединить GDB от
                                              удаленной системы.
                                              Посылается удаленной
                                              системе перед тем, как GDB
                                              отсоединится.
                       ответ _нет ответа_     GDB не ждет никакого ответа
                                              после посылки этого пакета.
                                              
зарезервировано        'e'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'E'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'f'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'F'                    Зарезервировано для
                                              использования в будущем
                                              
чтение регистров       'g'                    Чтение регистров общего
                                              назначения.
                       ответ XX...            Каждый байт данных регистра
                                              описывается двумя
                                              шестнадцатеричными цифрами.
                                              Они передаются с целевым
                                              порядком байтов.  Размер
                                              каждого регистра и его
                                              позиция внутри ПАКЕТА 'g'
                                              определяются внутренними
                                              макросами GDB
                                              REGISTER_RAW_SIZE и
                                              REGISTER_NAME.
                                              Спецификация нескольких
                                              стандартных пакетов 'g'
                                              приведена ниже.
                       'E'NN                  в случае ошибки.
                                              
запись в регистры      'G'XX...               Смотрите 'g' для описания
                                              данных XX... .
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            в случае ошибки
                                              
зарезервировано        'h'                    Зарезервировано для
                                              использования в будущем
                                              
выбрать нить           'H'CT...               Установить нить для
                                              последующих операций ('m',
                                              'M', 'g', 'G' и других).  C
                                              = 'c' для нитей,
                                              используемых при пошаговом
                                              выполнении и продолжении;
                                              T... может быть -1 для всех
                                              нитей.  C = 'g' для нитей,
                                              используемых в других
                                              операциях.  Если ноль --
                                              выбрать любую нить.
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            в случае ошибки
                                              
пошаговое выполнение   'i'АДРЕС','NNN         Выполнить один тактовый
по тактовому циклу                            цикл на удаленной машине.
*(черновик)*                                  Если '','NNN' указано,
                                              выполнить NNN циклов.  Если
                                              указан АДРЕС, пошаговое
                                              выполнение по одному
                                              тактовому циклу начинается
                                              этого адреса.
                                              
сигнал, затем          'I'                    Смотрите 'i' и 'S', там
выполнение по                                 аналогичный синтаксис и
тактовым циклам                               семантика.
*(зарезервировано)*                           
зарезервировано        'j'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'J'                    Зарезервировано для
                                              использования в будущем
                                              
убить                  'k'                    FIXME: _Нет описания, как
                                              действовать в случае, если
                                              был выбран контекст
                                              определенной нити (то есть
                                              'k' убивает только эту
                                              нить?)_.
                                              
зарезервировано        'l'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'L'                    Зарезервировано для
                                              использования в будущем
                                              
чтение памяти          'm'АДРЕС','ДЛИНА       Прочитать ДЛИНУ байт
                                              памяти, начиная с адреса
                                              АДРЕС.  Ни GDB, ни заглушка
                                              не предполагают, что
                                              передача области памяти
                                              происходит по адресам,
                                              выровненным по границе
                                              слова.  FIXME: _Нужен
                                              механизм передачи области
                                              памяти, выровненной по
                                              границе слова._
                       ответ XX...            XX... представляет собой
                                              содержимое памяти.  Может
                                              содержать меньше
                                              запрошенного числа байт,
                                              если удалось прочитать
                                              только часть данных.  Ни
                                              GDB, ни заглушка не
                                              предполагают, что передача
                                              области памяти происходит
                                              по адресам, выровненным по
                                              границе слова.  FIXME:
                                              _Нужен механизм передачи
                                              области памяти, выровненной
                                              по границе слова._
                       ответ 'E'NN            NN представляет номер
                                              ошибки
                                              
запись в память        'M'АДРЕС,ДЛИНА':'XX... Записать ДЛИНУ байт памяти,
                                              начиная с адреса АДРЕС.
                                              XX... -- это данные.
                       ответ 'OK'             при успехе
                       ответ 'E'NN            при ошибке (это включает
                                              случай, когда была записана
                                              только часть данных).
                                              
зарезервировано        'n'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'N'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'o'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'O'                    Зарезервировано для
                                              использования в будущем
                                              
чтение регистров       'p'N...                Смотрите запись регистров.
*(зарезервировано)*
                       возврат R....          Значение регистра в целевом
                                              порядке байт,
                                              закодированное в
                                              шестнадцатеричном виде.
                                              
запись регистров       'P'N...'='R...         Записать в регистр N...
                                              значение R..., которое
                                              содержит две
                                              шестнадцатеричные цифры для
                                              каждого байта в регистре
                                              (целевой порядок байтов).
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            при ошибке
                                              
общий запрос           'q'ЗАПРОС              Запросить информацию о
                                              ЗАПРОСЕ.  Вообще, запросы
                                              GDB начинаются с заглавной
                                              буквы.  Специальные запросы
                                              от производителей должны
                                              использовать приставку
                                              компании (из маленьких
                                              букв).  Например:
                                              'qfsf.var'.  За ЗАПРОСОМ
                                              может следовать
                                              необязательный список,
                                              разделенный ',' или ';'.
                                              Заглушки должны проверять,
                                              что они производят
                                              сравнение с полным именем
                                              ЗАПРОСА.
                       ответ 'XX...'          Данные от запроса,
                                              закодированные
                                              шестнадцатеричными цифрами.
                                              Ответ не может быть пустым.
                       ответ 'E'NN            ответ при ошибке
                       ответ ''               Указывает на нераспознанный
                                              ЗАПРОС.
                                              
общая установка        'Q'ПЕРЕМ'='ЗНАЧ        Установить значение ПЕРЕМ в
                                              ЗНАЧ.  Смотрите 'q' для
                                              обсуждения соглашений,
                                              касающихся имен.
                                              
сброс *(не             'r'                    Установка всей системы в
рекомендовано)*                               исходное состояние.
                                              
удаленная              'R'XX                  Перезапустить удаленный
перезагрузка                                  сервер.  XX не имеет ясного
                                              определения, хотя оно
                                              нужно.  FIXME: _Нужен
                                              пример взаимодействия,
                                              объясняющий как эти пакеты
                                              используются в расширенном
                                              удаленном режиме_.
                                              
пошаговое выполнение   's'АДРЕС               АДРЕС -- это адрес для
                                              возобновления выполнения.
                                              Если АДРЕС опущен,
                                              возобновить выполнение с
                                              того же адреса.
                       ответ                  смотрите ниже
                                              
пошаговое выполнение   'S'СИГ';'АДРЕС         Как 'C', но разница такая
с сигналом                                    же, как между 'step' и
                                              'continue'.
                       ответ                  смотрите ниже
                                              
поиск                  't'АДРЕС':'PP','MM     Поиск совпадения с шаблоном
                                              PP и маской MM в обратном
                                              направлении, начиная с
                                              АДРЕСА.  PP и MM -- 4
                                              байта.  В АДРЕСЕ должно
                                              быть не менее трех цифр.
                                              
жива ли нить           'T'XX                  Определить, жива ли нить
                                              XX.
                       ответ 'OK'             нить все еще жива
                       ответ 'E'NN            нить мертва
                                              
зарезервировано        'u'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'U'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'v'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'V'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'w'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'W'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'x'                    Зарезервировано для
                                              использования в будущем
                                              
запись в память        'X'АДРЕС','ДЛИНА:XX... АДРЕС -- это адрес, ДЛИНА
(двоичная)                                    -- это число байт, XX... --
                                              это двоичные данные.  Знаки
                                              '$', '#' и '0x7d'
                                              экранируются с помощью
                                              '0x7d'.
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            в случае ошибки
                                              
зарезервировано        'y'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'Y'                    Зарезервировано для
                                              использования в будущем
                                              
удалить точку          'z'T','АДРЕС','ДЛИНА   Смотрите 'Z'.
останова или                                  
наблюдения
*(черновик)*
поместить точку        'Z'T','АДРЕС','ДЛИНА   T представляет тип: '0' в
останова или                                  случае программной точки
наблюдения                                    останова, '1' -- аппаратная
*(черновик)*                                  точка останова, '2' --
                                              точка наблюдения за
                                              записью, '3' -- точка
                                              наблюдения за чтением, '4'
                                              -- точка наблюдения за
                                              доступом; АДРЕС -- это
                                              адрес; ДЛИНА задается в
                                              байтах.  Для программной
                                              точки останова, ДЛИНА
                                              задает размер инструкции,
                                              на которую надо поместить
                                              заплату.  Для аппаратных
                                              точек останова и
                                              наблюдения, ДЛИНА указывает
                                              размер области памяти для
                                              наблюдения.  Чтобы избежать
                                              потенциальных проблем с
                                              повторными пакетами,
                                              операции должны быть
                                              реализованы идемпотентным
                                              образом.
                       ответ 'E'NN            в случае ошибки
                       ответ 'OK'             в случае успеха
                       ''                     Если не поддерживается.
                                              
зарезервировано        <другое>               Зарезервировано для
                                              использования в будущем
                                              

   Пакеты 'C', 'c', 'S', 's' и '?' могут получить в качестве ответа все
нижеперечисленное.  В случае пакетов 'C', 'c', 'S' и 's', этот ответ
возвращается только тогда, когда цель останавливается.  Ниже, точное
значение 'номера сигнала' определено нечетко.  Вообще, используется одно
из соглашений UNIX о номерах сигналов.

'S'AA                         AA -- это номер сигнала
                              
'T'AAN...':'R...';'N...':'R...';'N...':'R...';'AA = две шестнадцатеричные цифры номера
                              сигнала; N... = (шестнадцатеричный) номер
                              регистра, R... = содержимое регистра в
                              целевом порядке байт, размер определяется
                              'REGISTER_RAW_SIZE'; N... = 'thread',
                              R... = идентификатор процесса нити, это
                              шестнадцатеричное целое; N... = другая
                              строка, не начинающаяся с
                              шестнадцатеричной цифры.  GDB должен
                              игнорировать эту пару N..., R... и
                              переходить к следующей.  Таким образом мы
                              можем расширять протокол.
                              
'W'AA                         Процесс завершается с кодом выхода AA.
                              Это применимо только к определенным типам
                              целей.
                              
'X'AA                         Процесс завершается с сигналом AA.
                              
'N'AA';'T...';'D...';'B...    AA = номер сигнала; T... = адрес символа
*(устарело)*                  "_start"; D... = база раздела данных;
                              B... = база раздела bss.  _Примечание:
                              используется только целями Cisco Systems.
                              Разница между этим ответом и запросом
                              "qOffsets" заключается в том, что пакет
                              'N' может прибыть самопроизвольно, тогда
                              как запрос 'qOffsets' инициируется
                              рабочим отладчиком._
                              
'O'XX...                      XX... -- шестнадцатеричное представление
                              ASCII-данных.  Это может произойти в
                              любой момент, пока программа выполняется
                              и отладчик должен продолжать ждать 'W',
                              'T' и тому подобное.
                              

   Следующие пакеты для установок и запросов уже были определены.

текущая нить   'q''C'         Возвратить идентификатор текущей нити.
               ответ          Где ИДЕНТ-ПРОЦ -- 16-битный идентификатор
               'QC'ИДЕНТ-ПРОЦ процесса, представленный
                              шестнадцатеричными цифрами.
               ответ *        Любой другой ответ подразумевает старый
                              идентификатор процесса.
                              
идентификаторы 'q''fThreadInfo'
всех нитей
               'q''sThreadInfo'Получить список идентификаторов активных
                              нитей от целевой ОС. Так как число
                              активных нитей может оказаться слишком
                              большим и не поместиться в пакет ответа,
                              этот запрос работает итерациями: для
                              получения полного списка нитей может
                              потребоваться более одной
                              последовательности запрос/ответ.  Первым
                              запросом последовательности будет
                              'qf''ThreadInfo'; последующими запросами
                              последовательности будут запросы
                              'qs''ThreadInfo'.
                              Замечание: замещает запрос 'qL' (смотрите
                              ниже).
               ответ          Идентификатор одной нити
               'm'<ИД>
               ответ          список идентификаторов нитей, разделенных
               'm'<ИД>,<ИД>...запятыми
               ответ 'l'      (буква 'l' в нижнем регистре) обозначает
                              конец списка.
                              В ответ на каждый запрос, цель будет
                              отвечать списком из разделенных запятыми
                              идентификаторов нитей, в
                              шестнадцатеричном представлении, с
                              порядком байт от старшего.  GDB будет
                              отвечать на каждый ответ запросом других
                              идентификаторов (используя форму 'qs'
                              запроса), пока цель не ответит 'l' (буква
                              'l' в нижнем регистре, от английского
                              слова ''last'').
                              
дополнительная 'q''ThreadExtraInfo'','ИД
информация о
нити
                              Здесь ИД является идентификатором нити в
                              шестнадцатеричном представлении, в
                              порядке байт от старшего.  Получает
                              печатаемое описание строки атрибутов нити
                              от целевой ОС. Эта строка может содержать
                              все что угодно, что целевая ОС сочтет
                              интересным для GDB сообщить пользователю
                              о нити.  Эта строка выводится в
                              отображении GDB 'info threads'.
                              Примерами возможной дополнительной
                              информации являются "Runnable" или
                              "Blocked on Mutex".
               ответ XX...    Где XX... -- ASCII-данные в
                              шестнадцатеричном представлении,
                              содержащие печатную строку с
                              дополнительной информацией об атрибутах
                              нити.
                              
запрос         'q''L'НАЧ-ФЛАГЧИСЛО-НИТЕЙСЛЕД-НИТЬ
СПИСОК или
СПИСОК-НИТЕЙ
*(не
рекомендовано)*
                              Получить информацию о нити от
                              операционной системы, где происходит
                              выполнение.  Здесь: НАЧ-ФЛАГ (одна
                              шестнадцатеричная цифра) есть единица,
                              что указывает на первый запрос, или ноль,
                              что определяет последующий запрос;
                              ЧИСЛО-НИТЕЙ (две шестнадцатеричные цифры)
                              -- максимальное число нитей, которое
                              может содержать пакет ответа; и СЛЕД-НИТЬ
                              (восемь шестнадцатеричных цифр), для
                              последующих запросов (НАЧ-ФЛАГ равен
                              нулю), возвращается в ответ как АРГ-НИТЬ.
                              Замечание: этот запрос был замещен
                              запросом 'q''fThreadInfo' (смотрите
                              выше).
               ответ
               'q''M'ЧИСЛОКОНЕЦАРГ-НИТЬНИТЬ...
                              Здесь: ЧИСЛО (две шестнадцатеричные
                              цифры) -- число возвращаемых нитей; КОНЕЦ
                              (одна шестнадцатеричная цифра), есть
                              ноль, который определяет, что есть еще
                              нити, и единица, определяющая, что больше
                              нитей нет; АРГ-НИТЬ (восемь
                              шестнадцатеричных цифр) представляет
                              собой СЛЕД-НИТЬ из пакета запроса;
                              НИТЬ... -- это последовательность
                              идентификаторов нитей от цели.
                              ИДЕНТ-НИТИ (восемь шестнадцатеричных
                              цифр).  Смотрите
                              'remote.c:parse_threadlist_response()'.
                              
вычислить      'q''CRC:'АДРЕС','ДЛИНА
CRC блока
памяти
               ответ 'E'NN    Ошибка (например, ошибка доступа к
                              памяти)
               ответ          Лишняя 32-битная циклическая проверка
               'C'CRC32       указанной области памяти.
                              
запросить      'q''Offsets'   Получить смещения разделов, которые
смещения                      целевая машина использовала при повторном
разделов                      размещении загруженного образа.
                              _Замечание: если смещение 'Bss' включено
                              в ответ, GDB это игнорирует и вместо
                              этого применяет к разделу 'Bss' смещение
                              'Data'._
               ответ
               'Text='XXX';Data='YYY';Bss='ZZZ
               
запросить      'q''P'РЕЖИМИДЕНТ-НИТИ
информацию о
нити
                              Возвращает информацию об ИДЕНТ-НИТИ.
                              Здесь: РЕЖИМ является 32-битным режимом в
                              шестнадцатеричном представлении;
                              ИДЕНТ-НИТИ -- 64-битный идентификатор
                              нити в шестнадцатеричном представлении.
               ответ *        Смотрите
                              'remote.c:remote_unpack_thread_info_response()'.
                              
удаленная      'q''Rcmd,'КОМАНДА
команда
                              КОМАНДА (в шестнадцатеричном
                              представлении) передается для выполнения
                              локальному интерпретатору.  Неверные
                              команды должны сообщаться при помощи
                              выходной строки.  Перед конечным
                              результирующим пакетом, целевая машина
                              может также ответить некоторым
                              количеством промежуточных 'O'ВЫВОД
                              пакетов вывода на консоль.  _Разработчики
                              должны учесть, что предоставление доступа
                              к интерпретатору заглушки может иметь
                              последствия для безопасности_.
               ответ 'OK'     Ответ на команду без вывода.
               ответ ВЫВОД    Ответ на команду со строкой вывода ВЫВОД,
                              в шестнадцатеричном представлении.
               ответ 'E'NN    Указывает на неправильно сформированный
                              запрос.
                              
               reply ''       Когда 'q''Rcmd' не распознана.
                              

   Следующие пакеты 'g'/'G' были определены раньше.  Ниже, некоторые
32-битные регистры передаются в виде 64 бит.  Эти регистры должны быть
расширены нулем/знаком (как?), чтобы заполнять выделенное место.  Байты
регистра передаются в целевом порядке байтов.  Две части в байте
регистра передаются от более значимого к менее значимому.

MIPS32                               Все регистры передаются как
                                     32-битные величины в таком
                                     порядке: 32 общего назначения; sr;
                                     lo; hi; bad; cause; pc; 32
                                     регистра с плавающей точкой; fsr;
                                     fir; fp.
                                     
MIPS64                               Все регистры передаются как
                                     64-битные величины (включая такие
                                     32-битные регистры, как 'sr').
                                     Порядок такой же, как для
                                     'MIPS32'.
                                     

   Вот пример последовательности для перезапускаемой цели.  Заметьте,
что перезапуск не получает никакого непосредственного вывода:

     <- R00
     -> +
     _target restarts_
     <- ?
     -> +
     -> T001:1234123412341234
     <- +

   Пример последовательности при при пошаговом выполнении цели по одной
инструкции:

     <- G1445...
     -> +
     <- s
     -> +
     _time passes_
     -> T001:1234123412341234
     <- +
     <- g
     -> +
     -> 1455...
     <- +


File: gdb.html,  Node: Сервер,  Next: NetWare,  Prev: Протокол,  Up: Удаленный

13.4.1.5 Использование программы 'gdbserver'
............................................

'gdbserver' является управляющей программой для Unix-подобных систем,
которая позволяет вам установить соединение вашей программы с удаленным
GDB посредством 'target remote', но без компоновки с обычной отладочной
заглушкой.

   'gdbserver' не является полной заменой отладочных заглушек, потому
что требует по существу тех же средств операционной системы, что и сам
GDB. Фактически, система, на которой может выполняться 'gdbserver' для
соединения с удаленным GDB, может также выполнять GDB локально!  Тем не
менее, 'gdbserver' иногда полезен, так как по размеру эта программа
гораздо меньше, чем GDB. 'gdbserver' также легче переносить, чем весь
GDB, так что вы сможете быстрее начать работать в новой системе,
используя его.  Наконец, если вы разрабатываете программы для систем
реального времени, вы можете обнаружить, что накладные расходы,
связанные с операциями реального времени, делают более удобным
проведение всей возможной разработки на другой системе, например, с
помощью кросс-компиляции.  Вы можете использовать 'gdbserver', чтобы
реализовать аналогичный выбор для отладки.

   GDB и 'gdbserver' общаются или через последовательную линию, или
через TCP-соединение, используя стандартный удаленный последовательный
протокол GDB.

_На целевой машине_
     вам необходимо иметь копию программы, которую вы хотите отладить.
     'gdbserver' не нуждается в таблице символов вашей программы, так
     что вы можете ее исключить, если необходимо сэкономить
     пространство.  Всю обработку символов осуществляет GDB на рабочей
     машине.

     Чтобы использовать сервер, вы должны сообщить ему, как
     взаимодействовать с GDB, имя вашей программы и ее аргументы.
     Синтаксис следующий:

          target> gdbserver COMM ПРОГРАММА [ АРГ ... ]

     COMM -- это или имя устройства (для использования последовательной
     линии), или имя рабочей машины и номер порта TCP. Например, для
     отладки Emacs с параметром 'foo.txt' и взаимодействия с GDB через
     последовательный порт '/dev/com1':

          target> gdbserver /dev/com1 emacs foo.txt

     'gdbserver' пассивно ждет рабочего GDB для связи с ним.

     При использовании TCP-соединения вместо последовательной линии:

          target> gdbserver host:2345 emacs foo.txt

     Единственное отличие от предыдущего примера состоит в первом
     параметре, определяющем, что вы связываетесь с рабочим GDB через
     TCP. Параметр 'host:2345' означает, что 'gdbserver' должен ожидать
     TCP-соединение от машины 'host' к локальному порту TCP 2345.  (В
     настоящее время часть 'host' игнорируется.)  Вы можете выбрать
     любой номер порта, какой захотите, если при этом он не конфликтует
     с какими-либо портами TCP, уже использующимися на целевой системе
     (например, '23' зарезервирован для 'telnet').(1)  Вы должны
     использовать тот же номер порта с командой рабочего GDB 'target
     remote'.

_На рабочей машине GDB_
     вам нужна копия вашей программы с символьными данными, так как GDB
     нужна информация о символах и отладочная информация.  Запустите GDB
     как обычно, используя имя локальной копии вашей программы в
     качестве первого аргумента.  (Вам также может понадобиться ключ
     '--baud', если последовательная линия работает на скорости,
     отличной от 9600бит/сек.)  После этого, используйте 'target
     remote', чтобы установить связь с 'gdbserver'.  Ее параметры --
     либо имя устройства (обычно последовательного устройства, такого
     как '/dev/ttyb'), либо дескриптор порта TCP в форме 'МАШИНА:ПОРТ'.
     Например:

          (gdb) target remote /dev/ttyb

     взаимодействует с сервером через последовательную линию
     '/dev/ttyb', а

          (gdb) target remote the-target:2345

     взаимодействует через TCP-соединение с портом 2345 на рабочей
     машине 'the-target'.  Для TCP-соединения, вы должны запустить
     'gdbserver' до использования команды 'target remote'.  Иначе вы
     можете получить ошибку, текст которой зависит от рабочей системы,
     но обычно он выглядит примерно так: 'Connection refused'.

   ---------- Footnotes ----------

   (1) Если вы выберете номер порта, который конфликтует с другим
сервисом, 'gdbserver' печатает сообщение об ошибке и завершает работу.


File: gdb.html,  Node: NetWare,  Prev: Сервер,  Up: Удаленный

13.4.1.6 Использование программы 'gdbserve.nlm'
...............................................

'gdbserve.nlm' -- это управляющая программа для систем NetWare, которая
позволяет вам установить соединение вашей программы с удаленным GDB
посредством 'target remote'.

   GDB и 'gdbserve.nlm' общаются через последовательную линию, используя
стандартный удаленный последовательный протокол GDB.

_На целевой машине_
     вам необходимо иметь копию программы, которую вы хотите отладить.
     'gdbserve.nlm' не нуждается в таблице символов вашей программы, так
     что вы можете ее исключить, если необходимо сэкономить
     пространство.  GDB осуществляет всю обработку символов на рабочей
     машине.

     Чтобы использовать сервер, вы должны сообщить ему, как
     взаимодействовать с GDB, имя вашей программы и ее аргументы.
     Синтаксис следующий:

          load gdbserve [ BOARD=ПЛАТА ] [ PORT=ПОРТ ]
                        [ BAUD=БОД ] ПРОГРАММА [ АРГ ... ]

     ПЛАТА и ПОРТ определяют последовательную линию; БОД определяет
     скорость в бодах, используемую соединением.  Значения ПОРТ и NODE
     по умолчанию равны 0, БОД по умолчанию 9600бит/сек.

     Например, для отладки Emacs с параметром 'foo.txt' и взаимодействия
     с GDB через последовательный порт номер 2 на плате 1, используя
     соединение 19200бит/сек:

          load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt

_На рабочей машине GDB_
     вам нужна копия вашей программы с символьными данными, так как GDB
     требуется символьная и отладочная информация.  Запустите GDB как
     обычно, используя имя локальной копии вашей программы в качестве
     первого параметра.  (Вам также может понадобиться ключ '--baud',
     если последовательная линия работает на скорости, отличной от
     9600бит/сек.)  После этого, используйте 'target remote' для
     установки связи с 'gdbserve.nlm'.  Ее аргумент -- имя устройства
     (обычно последовательного устройства, такого как '/dev/ttyb').
     Например:

          (gdb) target remote /dev/ttyb

     соединение с сервером через последовательную линию '/dev/ttyb'.


File: gdb.html,  Node: Отображение объектов ядра,  Prev: Удаленная отладка,  Up: Отладочные цели

13.5 Отображение объектов ядра
==============================

Некоторые цели поддерживают отображение объектов ядра.  При помощи этих
возможностей, GDB взаимодействует непосредственно с операционной
системой и может выводить информацию об объектах уровня операционной
системы, например, о блокировках и других объектах синхронизации.  Какие
именно объекты могут быть отображены, определяется в зависимости от
конкретной ОС.

   Используйте команду 'set os', чтобы установить тип операционной
системы.  Это говорит GDB, какой модуль отображения объектов ядра
инициализировать:

     (gdb) set os cisco

   Если команда 'set os' выполнится успешно, GDB выведет некоторую
информацию об операционной системе и создаст новую команду 'info',
которая может быть использована для посылки запросов на целевую машину.
Название команды 'info' выбирается в зависимости от операционной
системы:

     (gdb) info cisco
     List of Cisco Kernel Objects
     Object     Description
     any        Any and all objects

   Дальнейшие подкоманды могут использоваться для запросов о конкретных
объектах, информация о которых есть в ядре.

   В настоящее время не существует другого способа определить,
поддерживается та или иная операционная система, кроме как попробовать.


File: gdb.html,  Node: Конфигурации,  Next: Управление GDB,  Prev: Отладочные цели,  Up: Top

14 Информация о конфигурации
****************************

В то время как почти все команды GDB доступны для всех чистых и
кросс-версий отладчика, существуют некоторые исключения.  Эта глава
описывает вещи, доступные только в определенных конфигурациях.

   Существует три основные категории конфигураций: чистые конфигурации,
где рабочая и целевая машины совпадают, конфигурации для встроенных
операционных систем, которые обычно совпадают для нескольких различных
архитектур процессоров, и отдельные встроенные процессоры, которые
сильно отличаются друг от друга.

* Menu:

* Чистая::
* Встроенная ОС::
* Встроенные процессоры::
* Архитектуры::


File: gdb.html,  Node: Чистая,  Next: Встроенная ОС,  Up: Конфигурации

14.1 Чистая конфигурация
========================

Этот раздел описывает детали, специфичные для определенных чистых
конфигураций.

* Menu:

* HP-UX::                       HP-UX
* Информация о процессах SVR4:: Информация о процессах SVR4


File: gdb.html,  Node: HP-UX,  Next: Информация о процессах SVR4,  Up: Чистая

14.1.1 HP-UX
------------

В системах HP-UX, если вы ссылаетесь на функцию или переменную, имя
которой начинается со знака доллара, GDB сперва ищет имя пользователя
или системы, до поиска вспомогательной переменной.


File: gdb.html,  Node: Информация о процессах SVR4,  Prev: HP-UX,  Up: Чистая

14.1.2 Информация о процессах SVR4
----------------------------------

Многие версии SVR4 предоставляют средства, называемые '/proc', которые
могут быть использованы для исследования образа выполняемого процесса,
задействуя подпрограммы файловой системы.  Если GDB сконфигурирован для
операционной системы, поддерживающей эти средства, команда 'info proc'
доступна для получения отчета по некоторым видам информации о процессе,
выполняющем вашу программу.  'info proc' работает только на системах
SVR4, которые включают код 'procfs'.  Среди этих систем: OSF/1 (Digital
Unix), Solaris, Irix и Unixware, но не HP-UX или Linux, к примеру.

'info proc'
     Выдает доступную суммарную информацию о процессе.

'info proc mappings'
     Сообщает диапазоны адресов, доступных в программе, с информацией,
     может ли ваша программа читать, записывать или исполнять каждый из
     диапазонов.

'info proc times'
     Время запуска, время пользовательского и системного ЦП для вашей
     программы и ее потомков.

'info proc id'
     Сообщает информацию об идентификаторах процессов, относящихся к
     вашей программе: ее собственный идентификатор, идентификатор ее
     родителя, группы процесса и сеанса.

'info proc status'
     Общая информация о состоянии процесса.  Если процесс остановлен, то
     этот отчет включает причину останова и любые полученные сигналы.

'info proc all'
     Показывает всю вышеперечисленную информацию о процессе.


File: gdb.html,  Node: Встроенная ОС,  Next: Встроенные процессоры,  Prev: Чистая,  Up: Конфигурации

14.2 Встроенные операционные системы
====================================

Этот раздел описывает конфигурации, задействующие отладку встроенных
операционных систем, которые доступны для нескольких различных
архитектур.

* Menu:

* VxWorks::                     Использование GDB с VxWorks

   GDB включает возможность отлаживать программы, выполняющиеся в
различных операционных системах реального времени.


File: gdb.html,  Node: VxWorks,  Up: Встроенная ОС

14.2.1 Использование GDB с VxWorks
----------------------------------

'target vxworks ИМЯ-МАШИНЫ'
     Система VxWorks, присоединенная посредством TCP/IP. Аргумент
     ИМЯ-МАШИНЫ есть имя или IP-адрес машины целевой системы.

   На VxWorks, 'load' компонует ИМЯ-ФАЙЛА динамически на текущей целевой
системе и добавляет ее символьную информацию в GDB.

   GDB позволяет разработчикам запускать и отлаживать с Unix-машин
задачи, выполняющиеся на сетевых целях VxWorks.  Уже выполняющиеся
задачи, запущенные из оболочки VxWorks, также могут быть отлажены.  GDB
использует код, который может выполняться как на машине Unix, так и на
целевой машине VxWorks.  Программа 'gdb' устанавливается и выполняется
на Unix-машине.  (Она может быть установлена под именем 'vxgdb', чтобы
отличать ее от GDB для отладки программ на рабочей машине.)

'VxWorks-timeout АРГ'
     Сейчас все цели, базирующиеся на VxWorks, поддерживают параметр
     'vxworks-timeout'.  Этот параметр устанавливается пользователем, и
     АРГ представляют число секунд, в течение которых GDB ожидает ответы
     на вызовы удаленных процедур.  Вы можете использовать это, если
     ваша целевая машина VxWorks является медленным программным
     эмулятором или находится далеко на другом конце медленного сетевого
     соединения.

   Следующая информация о соединении к VxWorks была свежей, когда это
руководство было написано; более новые выпуски VxWorks могут
использовать обновленные процедуры.

   Для использования GDB с VxWorks, вы должны пересобрать ваше ядро
VxWorks, чтобы включить подпрограммы интерфейса удаленной отладки в
библиотеку VxWorks 'rdb.a'.  Чтобы это сделать, определите 'INCLUDE_RDB'
в конфигурационном файле VxWorks 'configAll.h' и пересоберите ядро
VxWorks.  Получившееся ядро содержит 'rdb.a' и порождает задачу отладки
исходного кода 'tRdbTask', когда VxWorks загружается.  Для большей
информации по конфигурированию и сборке VxWorks, смотрите руководство
изготовителя.

   Когда вы включили 'rdb.a' в образ вашей системы VxWorks и так
установили ваши пути поиска выполняемых файлов, чтобы можно было найти
GDB, вы готовы к вызову отладчика.  Из вашей рабочей Unix-машины,
выполните 'gdb' (или 'vxgdb', в зависимости от вашей установки).

   GDB появляется и показывает приглашение:

     (vxgdb)

* Menu:

* Соединение к VxWorks::        Соединение к VxWorks
* Загрузка на VxWorks::         Загрузка на VxWorks
* Присоединение к VxWorks::     Запуск задач


File: gdb.html,  Node: Соединение к VxWorks,  Next: Загрузка на VxWorks,  Up: VxWorks

14.2.1.1 Соединение к VxWorks
.............................

Команда GDB 'target' позволяет вам соединяться с целевой машиной VxWorks
в сети.  Для соединения с целью по имени "'tt'" введите:

     (vxgdb) target vxworks tt

   GDB покажет сообщения, аналогичные этим:

     Attaching remote machine across net...
     Connected to tt.

   Затем GDB пытается считать таблицы символов всех объектных модулей,
загруженных на целевой машине VxWorks с того момента, как она была
включена.  GDB находит эти файлы путем поиска в каталогах, перечисленных
в путях поиска команд (*note Рабочая среда вашей программы: Среда.);
если ему не удается найти объектный файл, он выводит подобное сообщение:

     prog.o: No such file or directory.

   Если это происходит, добавьте соответствующий каталог к путям поиска
с помощью команды GDB 'path' и выполните команду 'target' снова.


File: gdb.html,  Node: Загрузка на VxWorks,  Next: Присоединение к VxWorks,  Prev: Соединение к VxWorks,  Up: VxWorks

14.2.1.2 Загрузка на VxWorks
............................

Если вы соединились с целевой машиной VxWorks и хотите отладить объект,
который еще не был загружен, вы можете использовать команду GDB 'load',
чтобы загрузить файл из Unix в VxWorks.  Объектный файл, заданный в
качестве аргумента к 'load', в действительности открывается дважды:
сначала целевой машиной VxWorks, чтобы загрузить код, а затем GDB, чтобы
считать таблицу символов.  Это может привести к проблемам, если текущие
рабочие каталоги в этих системах различаются.  Если обе системы
монтируют по NFS одни и те же файловые системы, вы можете избежать этих
проблем, используя абсолютные пути.  В противном случае, проще всего
установить рабочий каталог на обеих системах в тот, в котором расположен
объектный файл, и затем ссылаться на него по имени, без пути.  Например,
программа 'prog.o' может находиться в 'VXPATH/vw/demo/rdb' на VxWorks и
в 'HOSTPATH/vw/demo/rdb' на рабочей машине.  Для загрузки этой
программы, введите в VxWorks следующее:

     -> cd "VXPATH/vw/demo/rdb"

Затем, в GDB, введите:

     (vxgdb) cd HOSTPATH/vw/demo/rdb
     (vxgdb) load prog.o

   GDB отобразит ответ, аналогичный этому:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   Вы также можете использовать команду 'load', чтобы заново загрузить
объектный модуль после редактирования и повторной компиляции
соответствующего исходного файла.  Заметьте, что при этом GDB удаляет
все определенные точки останова, автоматические отображения,
вспомогательные переменные и очищает историю значений.  (Это необходимо
для того, чтобы сохранить целостность структур данных отладчика, которые
ссылаются на таблицу символов целевой системы.)


File: gdb.html,  Node: Присоединение к VxWorks,  Prev: Загрузка на VxWorks,  Up: VxWorks

14.2.1.3 Запуск задач
.....................

Вы также можете присоединиться к существующей задаче, используя команду
'attach' следующим образом:

     (vxgdb) attach ЗАДАЧА

где ЗАДАЧА является шестнадцатеричным идентификатором задачи VxWorks.
Когда вы присоединяетесь к задаче, она может выполняться либо быть
приостановленной.  Выполняющаяся задача приостанавливается в момент
присоединения.


File: gdb.html,  Node: Встроенные процессоры,  Next: Архитектуры,  Prev: Встроенная ОС,  Up: Конфигурации

14.3 Встроенные процессоры
==========================

Этот раздел описывает детали, специфичные для определенных встроенных
конфигураций.

* Menu:

* Встроенный A29K::             Встроенный AMD A29K
* ARM::                         ARM
* H8/300::                      Hitachi H8/300
* H8/500::                      Hitachi H8/500
* i960::                        Intel i960
* M32R/D::                      Mitsubushi M32R/D
* M68K::                        Motorola M68K
* M88K::                        Motorola M88K
* Встроенный MIPS::             Встроенный MIPS
* PowerPC::                     PowerPC
* PA::                          Встроенный HP PA
* SH::                          Hitachi SH
* Sparclet::                    Tsqware Spacrlet
* Sparclite::                   Fujitsu Sparclite
* ST2000::                      Tandem ST2000
* Z8000::                       Zilog Z8000


File: gdb.html,  Node: Встроенный A29K,  Next: ARM,  Up: Встроенные процессоры

14.3.1 Встроенный AMD A29K
--------------------------

* Menu:

* A29K UDI::
* A29K EB29K::
* Коммуникации (EB29K)::        Установка связи
* gdb-EB29K::                   Кросс-отладка EB29K
* Удаленный журнал::            Удаленный журнал

'target adapt УСТР'
     Монитор Adapt для A29K.

'target amd-eb УСТР СКОРОСТЬ ПРОГ'
     Удаленная PC-резидентная плата AMD EB29K, присоединенная по
     последовательным линиям.  УСТР является последовательным
     устройством, так же, как для 'target remote'; СКОРОСТЬ позволяет
     вам указать скорость линии; а ПРОГ является именем программы,
     которая будет отлаживаться, так, как оно появляется в ДОС на ПК.
     *Note Протокол EBMON для AMD29K: A29K EB29K.


File: gdb.html,  Node: A29K UDI,  Next: A29K EB29K,  Up: Встроенный A29K

14.3.1.1 A29K UDI
.................

Для отладки процессоров семейства a29k, GDB поддерживает протокол AMD
UDI ("Universal Debugger Interface"(1)).  Для использования этой
конфигурации с целями AMD, на которых выполняется монитор MiniMON, вам
нужна программа 'MONTIP', доступная бесплатно у AMD. Вы можете также
использовать GDB с программой 'ISSTIP', UDI-совместимым эмулятором a29k,
также доступным у AMD.

'target udi КЛ-СЛОВО'
     Выбрать интерфейс UDI к удаленной плате a29k или эмулятору.  Здесь
     КЛ-СЛОВО является элементом в конфигурационном файле AMD 'udi_soc'.
     Этот файл содержит в качестве элементов ключевые слова, которые
     определяют параметры, используемые при соединении к целям a29k.
     Если файл 'udi_soc' не находится в вашем рабочем каталоге, вы
     должны установить путь к нему в переменной среды 'UDICONF'.

   ---------- Footnotes ----------

   (1) Универсальный отладочный интерфейс.  (Прим. переводчика)


File: gdb.html,  Node: A29K EB29K,  Next: Коммуникации (EB29K),  Prev: A29K UDI,  Up: Встроенный A29K

14.3.1.2 Протокол EBMON для AMD29K
..................................

AMD распространяет плату разработки 29K, предназначенную для помещения в
ПК, вместе с программой монитора 'EBMON', работающей в ДОС. Коротко эта
система разработки называется "EB29K". Чтобы использовать GDB из
Unix-системы для выполнения программ на плате EB29K, вы должны сперва
соединить последовательным кабелем ПК (в котором установлена плата
EB29K) и последовательный порт на Unix-системе.  Далее мы предполагаем,
что вы соединили кабелем порт ПК 'COM1' и '/dev/ttya' на Unix-системе.


File: gdb.html,  Node: Коммуникации (EB29K),  Next: gdb-EB29K,  Prev: A29K EB29K,  Up: Встроенный A29K

14.3.1.3 Установка связи
........................

Следующим шагом нужно установить параметры порта ПК, сделав в ДОС что-то
вроде этого:

     C:\> MODE com1:9600,n,8,1,none

Этот пример, выполненный в системе MS DOS 4.0, устанавливает порт ПК в
9600бит/сек, без проверки четности, восьмибитные данные, один стоп-бит и
отсутствие действия для "повтора"; вы должны использовать те же
параметры связи при установке соединения со стороны Unix.

   Чтобы передать управление с ПК стороне Unix, введите следующее в
консоли ДОС:

     C:\> CTTY com1

(Позже, если вы хотите вернуть управление консоли ДОС, вы можете
использовать команду 'CTTY con' -- но вы должны послать ее через
устройство, имевшее управление, в нашем примере через последовательную
линию 'COM1'.)

   На Unix-машине, для связи с ПК используйте коммуникационную
программу, такую как 'tip' или 'cu'.  Например

     cu -s 9600 -l /dev/ttya

Показанные ключи для 'cu' определяют, соответственно, скорость линии и
последовательный порт.  Если вместо этого вы используете 'tip', ваша
командная строка может выглядеть следующим образом:

     tip -9600 /dev/ttya

Ваша система может требовать другого имени в том месте, где мы
показываем '/dev/ttya' в качестве аргумента к 'tip'.  Параметры связи,
включая используемый порт, ассоциированы с аргументом к 'tip' в файле
описаний "remote" -- обычно это '/etc/remote'.

   Используя соединение 'tip' или 'cu', измените рабочий каталог ДОС в
тот, который содержит копию вашей программы 29K, затем запустите на ПК
программу 'EBMON' (управляющая программа EB29K, поставляемая AMD с вашей
платой).  Вы должны увидеть начальный вывод 'EBMON', аналогичный
следующему, заканчивающийся приглашением 'EBMON' '#':

     C:\> G:

     G:\> CD \usr\joe\work29k

     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.

     Enter '?' or 'H' for help

     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000

     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff

     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800

     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes

     # ~.

   Затем выйдите из программы 'cu' или 'tip' (в этом примере это сделано
при помощи ввода '~.' в приглашении 'EBMON').  'EBMON' продолжает
работать, готовый к тому, что GDB перехватит управление.

   Для этого примера, мы предположили, что существует соединение PC/NFS,
которое устанавливает файловую систему Unix-машины как "диск 'G:'" на
ПК. Это является, вероятно, самым удобным способом удостовериться, что
одна и та же программа 29K находится и на ПК, и в Unix-системе.  Если у
вас нет PC/NFS или чего-нибудь аналогичного, соединяющего две системы,
вы должны прибегнуть к другому способу передачи программы 29K из Unix на
ПК -- возможно переписать ее на дискету.  GDB _не_ загружает программы
по последовательной линии.


File: gdb.html,  Node: gdb-EB29K,  Next: Удаленный журнал,  Prev: Коммуникации (EB29K),  Up: Встроенный A29K

14.3.1.4 Кросс-отладка EB29K
............................

Наконец, перейдите в каталог, содержащий образ вашей программы 29K в
Unix-системе, и запустите GDB, указав имя программы в качестве
аргумента:

     cd /usr/joe/work29k
     gdb myfoo

   Теперь вы можете использовать команду 'target':

     target amd-eb /dev/ttya 9600 MYFOO

В этом примере мы предполагали, что ваша программа находится в файле
'myfoo'.  Заметьте, что имя файла, заданное в качестве последнего
аргумента к 'target amd-eb', должно быть таким, каким его видит ДОС. В
нашем примере, это просто 'MYFOO', но вообще оно может включать путь
ДОС, и, в зависимости от механизма передачи, может быть не похоже на имя
на Unix-машине.

   В этом месте вы можете установить желаемые точки останова; когда вы
будете готовы увидеть вашу программу выполняющейся на плате 29K,
используйте команду GDB 'run'.

   Чтобы остановить отладку удаленной программы, используйте команду GDB
'detach'.

   Чтобы возвратить управление консоли ПК, используйте 'tip' или 'cu'
снова, после завершения вашего сеанса GDB, чтобы присоединиться к
'EBMON'.  Затем вы можете ввести команду 'q', чтобы завершить работу
'EBMON', возвращая управление командному интерпретатору ДОС. Введите
'CTTY con', чтобы возвратить командный ввод основной консоли ДОС, и
введите '~.', чтобы покинуть 'tip' или 'cu'.


File: gdb.html,  Node: Удаленный журнал,  Prev: gdb-EB29K,  Up: Встроенный A29K

14.3.1.5 Удаленный журнал
.........................

Команда 'target amd-eb' создает в текущем рабочем каталоге файл
'eb.log', чтобы помочь отладить проблемы с соединением.  'eb.log'
записывает весь вывод 'EBMON', включая эхо посланных ему команд.
Выполнение 'tail -f' для этого файла в другом окне часто помогает понять
проблемы с 'EBMON' или неожиданные события на стороне ПК.


File: gdb.html,  Node: ARM,  Next: H8/300,  Prev: Встроенный A29K,  Up: Встроенные процессоры

14.3.2 ARM
----------

'target rdi УСТР'
     Монитор ARM Angel, через интерфейс библиотеки RDI к протоколу ADP.
     Вы можете использовать эту цель для взаимодействия как с платами,
     на которых выполняется монитор Angel, так и с устройством отладки
     EmbeddedICE JTAG.

'target rdp УСТР'
     Монитор ARM Demon.


File: gdb.html,  Node: H8/300,  Next: H8/500,  Prev: ARM,  Up: Встроенные процессоры

14.3.3 Hitachi H8/300
---------------------

'target hms УСТР'
     Плата Hitachi SH, H8/300 или H8/500, присоединенная через
     последовательную линию к вашей машине.  Используйте специальные
     команды 'device' и 'speed' для управления последовательной линией и
     используемой скоростью связи.

'target e7000 УСТР'
     Эмулятор E7000 для Hitachi H8 и SH.

'target sh3 УСТР'
'target sh3e УСТР'
     Целевые системы Hitachi SH-3 и SH-3E.

   Когда вы выбираете удаленную отладку для платы Hitachi SH, H8/300 или
H8/500, команда 'load' загружает вашу программу на плату Hitachi, а
также открывает ее как текущую выполняемую цель для GDB на вашей машине
(как команда 'file').

   Для общения с Hitachi SH, H8/300 или H8/500, GDB необходимо знать
следующие вещи:

  1. Что вы хотите использовать: 'target hms', удаленный отладочный
     интерфейс для микропроцессоров Hitachi, или 'target e7000',
     встроенный эмулятор для Hitachi SH и Hitachi 300H. ('target hms'
     используется по умолчанию, если GDB сконфигурирован специально для
     Hitachi SH, H8/300 или H8/500.)

  2. Какое последовательное устройство соединяет вашу машину с платой
     Hitachi (по умолчанию используется первое последовательное
     устройство, доступное на вашей машине).

  3. Какую скорость использовать для этого последовательного устройства.

* Menu:

* Платы Hitachi::            Соединение с платами Hitachi.
* Hitachi ICE::              Использование встроенного эмулятора E7000.
* Специально для Hitachi::   Специальные команды GDB для Hitachi.


File: gdb.html,  Node: Платы Hitachi,  Next: Hitachi ICE,  Up: H8/300

14.3.3.1 Соединение с платами Hitachi
.....................................

Используйте специальную команду GDB 'device ПОРТ', если вам нужно явно
установить последовательное устройство.  По умолчанию используется
первый ПОРТ, доступный на вашей машине.  Это необходимо только на
Unix-машинах, где это обычно что-то типа '/dev/ttya'.

   GDB имеет другую специальную команду для установки скорости связи:
'speed BPS'.  Эта команда также используется только на Unix-машинах; в
ДОС, устанавливайте скорость линии как обычно извне GDB командой 'mode'
(например, 'mode com2:9600,n,8,1,p' для соединения 9600бит/сек.

   Команды 'device' и 'speed' доступны для отладки программ
микропроцессора Hitachi, только если вы используете рабочую среду Unix.
Если вы используете ДОС, для взаимодействия с платой разработки через
последовательный порт ПК GDB полагается на вспомогательную резидентную
программу 'asynctsr'.  Вы также должны использовать команду ДОС 'mode',
чтобы подготовить порт со стороны ДОС.

   Следующий пример сеанса иллюстрирует шаги, необходимые для запуска
программы на H8/300 под управлением GDB. В нем используется программа
H8/300 под названием 't.x'.  Для Hitachi SH и H8/500 процедура та же
самая.

   Сперва подсоедините вашу плату разработки.  В этом примере, мы
используем плату, присоединенную к порту 'COM2'.  Если вы используете
другой последовательный порт, подставьте его имя в аргументе команды
'mode'.  Когда вы вызываете 'asynctsr', вспомогательную программу связи,
используемую отладчиком, вы передаете ей только числовую часть имени
последовательного порта; например, ниже 'asynctsr 2' запускает
'asynctsr' для 'COM2'.

     C:\H8300\TEST> asynctsr 2
     C:\H8300\TEST> mode com2:9600,n,8,1,p

     Resident portion of MODE loaded

     COM2: 9600, n, 8, 1, p


     _Предупреждение:_ Мы обнаружили ошибку в PC-NFS, которая
     конфликтует с 'asynctsr'.  Если вы также используете PC-NFS на
     вашей ДОС-машине, вам может потребоваться отключить его или даже
     загрузить машину без него, чтобы использовать 'asynctsr' для
     управления отладочной платой.

   Теперь, когда связь установлена, и плата разработки присоединена, вы
можете запустить GDB. Вызовите 'gdb' с именем вашей программы в качестве
аргумента.  GDB выводит обычное приглашение: '(gdb)'.  Используйте две
специальные команды для начала сеанса отладки: 'target hms' для задания
кросс-отладки для платы Hitachi и команду 'load' для загрузки вашей
программы на нее.  'load' выводит имена разделов программы и '*' для
каждых двух килобайт загруженных данных.  (Если вы хотите обновить
данные GDB для символов или для выполняемого файла без загрузки,
используйте команды GDB 'file' или 'symbol-file'.  Для описания этих
команд, равно как и самой команды 'load', см.  *note Команды для задания
файлов: Файлы.)

     (eg-C:\H8300\TEST) gdb t.x
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty"
     for details.
     GDB 5.0, Copyright 1992 Free Software Foundation, Inc...
     (gdb) target hms
     Connected to remote H8/300 HMS system.
     (gdb) load t.x
     .text   : 0x8000 .. 0xabde ***********
     .data   : 0xabde .. 0xad30 *
     .stack  : 0xf000 .. 0xf014 *

   Теперь вы готовы выполнять или отлаживать вашу программу.  С этого
момента вы можете использовать все обычные команды GDB. Команда 'break'
устанавливает точки останова; 'run' запускает вашу программу; 'print'
или 'x' отображает данные; команда 'continue' возобновляет выполнение
после остановки в точке останова.  Вы можете использовать команду 'help'
в любой момент, чтобы узнать больше о командах GDB.

   Помните, однако, что возможности _операционной системы_ недоступны на
вашей плате разработки; например, если ваша программа зависает, вы не
можете послать сигнал прерывания -- но можете нажать кнопку RESET!

   Используйте кнопку RESET на вашей плате разработки
   * чтобы прервать вашу программу (не используйте 'ctl-C' на машине с
     ДОС -- у нее нет способа передать сигнал прерывания на плату
     разработки); и

   * для возврата к приглашению GDB после того, как ваша программа
     нормально завершается.  Протокол связи не предусматривает другого
     способа для GDB определить, что ваша программа завершилась.

   В любом случае, GDB видит результат нажатия RESET на плате разработки
как "нормальное завершение" вашей программы.


File: gdb.html,  Node: Hitachi ICE,  Next: Специально для Hitachi,  Prev: Платы Hitachi,  Up: H8/300

14.3.3.2 Использование встроенного эмулятора E7000
..................................................

Вы можете использовать встроенный эмулятор E7000 для разработки кода
либо для Hitachi SH, либо для H8/300H. Используйте одну из этих форм
команды 'target e7000' для соединения GDB с вашей E7000:

'target e7000 ПОРТ СКОРОСТЬ'
     Используйте эту форму, если ваша E7000 присоединена к
     последовательному порту.  Аргумент ПОРТ идентифицирует, какой
     последовательный порт использовать (например, 'com2').  Третий
     аргумент является скоростью линии в битах в секунду (например,
     '9600').

'target e7000 ИМЯ-УЗЛА'
     Если ваша E7000 установлена как узел сети TCP/IP, вы можете просто
     указать его имя; GDB использует для соединения 'telnet'.


File: gdb.html,  Node: Специально для Hitachi,  Prev: Hitachi ICE,  Up: H8/300

14.3.3.3 Специальные команды GDB для Hitachi
............................................

Некоторые команды GDB доступны только для H8/300:

'set machine h8300'
'set machine h8300h'
     Настраивайте GDB на один из двух вариантов архитектур H8/300 с
     помощью 'set machine'.  Вы можете использовать 'show machine',
     чтобы проверить, какой из вариантов действует в данный момент.


File: gdb.html,  Node: H8/500,  Next: i960,  Prev: H8/300,  Up: Встроенные процессоры

14.3.4 H8/500
-------------

'set memory МОД'
'show memory'
     Укажите, какую модель памяти H8/500 (МОД) вы используете с помощью
     'set memory'; проверяйте, какая модель используется при помощи
     'show memory'.  Допустимыми значениями для МОД являются 'small',
     'big', 'medium' и 'compact'.


File: gdb.html,  Node: i960,  Next: M32R/D,  Prev: H8/500,  Up: Встроенные процессоры

14.3.5 Intel i960
-----------------

'target mon960 УСТР'
     Монитор MON960 для Intel i960.

'target nindy ИМЯ-УСТР'
     Плата Intel 960, управляемая Nindy Monitor.  ИМЯ-УСТР является
     именем последовательного устройства, которое должно использоваться
     для соединения, например '/dev/ttya'.

   "Nindy" -- это программа ROM Monitor для целевых систем Intel 960.
Когда GDB сконфигурирован для управления удаленным Intel 960 с
использованием Nindy, вы можете указать ему, как присоединиться к 960
несколькими способами:

   * Указав последовательный порт, версию протокола Nindy и скорость
     связи через ключи командной строки;

   * Ответив на запрос при старте;

   * Используя команду 'target' в любом месте вашего сеанса GDB. *Note
     Команды для управления целями: Команды для целей.

   С интерфейсом Nindy к плате Intel 960, команда 'load' загружает
ИМЯ-ФАЙЛА на 960, а также добавляет его символьные данные в GDB.

* Menu:

* Вызов Nindy::                 Вызов Nindy
* Параметры Nindy::             Параметры для Nindy
* Сброс Nindy::                 Команда сброса Nindy


File: gdb.html,  Node: Вызов Nindy,  Next: Параметры Nindy,  Up: i960

14.3.5.1 Вызов Nindy
....................

Если вы просто запустите 'gdb' без использования ключей командной
строки, у вас запросят, какой последовательный порт использовать, _до_
того, как вы получите обычное приглашение GDB:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Ответьте на запрос с любым суффиксом (после '/dev/tty'), определяющим
последовательный порт, который вы хотите использовать.  Вы можете, по
своему выбору, просто начать работу без соединения с Nindy, ответив на
приглашение пустой строкой.  Если вы сделаете это и позже захотите
присоединиться к Nindy, используйте 'target' (*note Команды для
управления целями: Команды для целей.).


File: gdb.html,  Node: Параметры Nindy,  Next: Сброс Nindy,  Prev: Вызов Nindy,  Up: i960

14.3.5.2 Параметры для Nindy
............................

Вот параметры вызова для начала вашего сеанса GDB с подключенной платой
Nindy-960:

'-r ПОРТ'
     Задайте имя порта последовательного интерфейса, который должен
     использоваться для соединения с целевой системой.  Этот ключ
     доступен, только когда GDB сконфигурирован для целевой архитектуры
     Intel 960.  Вы можете определить ПОРТ любым из следующих способов:
     полный путь (например, '-r /dev/ttya'), имя устройства в '/dev'
     (например, '-r ttya') или просто уникальный суффикс для
     определенного 'tty' (например, '-r a').

'-O'
     (Заглавная буква "O", не ноль.)  Определяет, что GDB должен
     использовать "старый" протокол монитора Nindy для соединения с
     целевой системой.  Этот ключ доступен, только когда GDB
     сконфигурирован для целевой архитектуры Intel 960.

          _Предупреждение:_ если вы определите '-O', но в
          действительности попытаетесь связаться с системой, которая
          ожидает более нового протокола, соединение не будет
          установлено, как будто не соответствуют скорости.  GDB
          неоднократно пытается соединиться снова на нескольких
          различных скоростях линии.  Вы можете остановить этот процесс
          посредством прерывания.

'-brk'
     Определяет, что GDB должен сперва послать целевой системе сигнал
     'BREAK', пытаясь сбросить ее, перед соединением с целью Nindy.

          _Предупреждение:_ Многие целевые системы не имеют требуемых
          для этого аппаратных средств; это работает только на некоторых
          платах.

   Стандартный ключ '-b' управляет скоростью линии, используемой на
последовательном порту.


File: gdb.html,  Node: Сброс Nindy,  Prev: Параметры Nindy,  Up: i960

14.3.5.3 Команда сброса Nindy
.............................

'reset'
     Для целей Nindy, эта команда посылает "break" удаленной целевой
     системе; она полезна, только если целевая система была оборудована
     схемой для выполнения аппаратного сброса (или других действий,
     представляющих интерес) при обнаружении прерывания.


File: gdb.html,  Node: M32R/D,  Next: M68K,  Prev: i960,  Up: Встроенные процессоры

14.3.6 Mitsubishi M32R/D
------------------------

'target m32r УСТР'
     Монитор ROM Mitsubishi M32R/D.


File: gdb.html,  Node: M68K,  Next: M88K,  Prev: M32R/D,  Up: Встроенные процессоры

14.3.7 M68k
-----------

Конфигурация Motorola m68k включает поддержку ColdFire и команду
'target' для следующих мониторов ROM.

'target abug УСТР'
     Монитор ABug ROM для M68K.

'target cpu32bug УСТР'
     Монитор CPU32BUG, выполняющийся на плате CPU32 (M68K).

'target dbug УСТР'
     Монитор dBUG ROM для Motorola ColdFire.

'target est УСТР'
     Монитор EST-300 ICE, выполняющийся на плате CPU32 (M68K).

'target rom68k УСТР'
     Монитор ROM 68K, выполняющийся на плате M68K IDP.

   Если GDB сконфигурирован с 'm68*-ericsson-*', то вместо этого у него
будет только одна специальная команда 'target':

'target es1800 УСТР'
     Эмулятор ES-1800 для M68K.

'target rombug УСТР'
     Монитор ROMBUG ROM для OS/9000.


File: gdb.html,  Node: M88K,  Next: Встроенный MIPS,  Prev: M68K,  Up: Встроенные процессоры

14.3.8 M88K
-----------

'target bug УСТР'
     Монитор BUG, выполняющийся на плате MVME187 (m88k).


File: gdb.html,  Node: Встроенный MIPS,  Next: PowerPC,  Prev: M88K,  Up: Встроенные процессоры

14.3.9 Встроенный MIPS
----------------------

GDB может использовать удаленный отладочный протокол MIPS для
взаимодействия с платой MIPS, присоединенной к последовательной линии.
Эта возможность доступна, если вы сконфигурировали GDB с
'--target=mips-idt-ecoff'.

   Используйте эти команды GDB для определения соединения с вашей
целевой платой:

'target mips ПОРТ'
     Для выполнения программы на плате, выполните 'gdb', задав имя
     программы в качестве аргумента.  Для соединения с платой,
     используйте команду 'target mips ПОРТ', где ПОРТ -- имя
     последовательного порта, присоединенного к плате.  Если программа
     еще не была загружена на плату, вы можете использовать команду
     'load', чтобы это сделать.  Затем вы можете использовать все
     обычные команды GDB.

     Например, эта последовательность команд устанавливает соединение к
     целевой плате через последовательный порт, загружает и начинает
     выполнение из отладчика программы с именем PROG:

          host$ gdb PROG
          GDB is free software and ...
          (gdb) target mips /dev/ttyb
          (gdb) load PROG
          (gdb) run

'target mips ИМЯ-МАШИНЫ:НОМЕР-ПОРТА'
     В некоторых рабочих конфигурациях GDB, вы можете задать
     TCP-соединение (например, к последовательной линии, управляемой
     терминальным концентратором) вместо последовательного порта,
     используя синтаксис 'ИМЯ-МАШИНЫ:НОМЕР-ПОРТА'.

'target pmon ПОРТ'
     Монитор ROM PMON.

'target ddb ПОРТ'
     NEC DDB-разновидность PMON для Vr4300.

'target lsi ПОРТ'
     LSI-разновидность PMON.

'target r3900 УСТР'
     Densan DVE-R3900 монитор ROM для Toshiba R3900 Mips.

'target array УСТР'
     Плата контроллера RAID Array Tech LSI33K.

GDB также поддерживает следующие специальные команды для целей MIPS:

'set processor АРГ'
'show processor'
     Используйте команду 'set processor' для установки типа процессора
     MIPS, когда вы хотите обратиться к регистрам, уникальным для
     данного типа процессора.  Например, 'set processor R3041' велит GDB
     использовать регистры ЦП, соответствующие микросхеме 3041.
     Используйте команду 'show processor', чтобы узнать, какой процессор
     MIPS используется GDB. Используйте команду 'info reg' чтобы узнать,
     какие регистры использует GDB.

'set mipsfpu double'
'set mipsfpu single'
'set mipsfpu none'
'show mipsfpu'
     Если ваша целевая плата не поддерживает сопроцессор MIPS для
     вычислений с плавающей точкой, вы должны использовать команду 'set
     mipsfpu none' (если вам это нужно, вы можете поместить эту команду
     в ваш файл инициализации GDB). Это говорит GDB, как найти значения
     функций, которые возвращают величины с плавающей точкой.  Это также
     позволяет GDB избежать сохранения регистров с плавающей точкой при
     вызове функций на плате.  Если вы используете сопроцессор поддержки
     вычислений с плавающей точкой с поддержкой только одинарной
     точности, как на процессоре R4650, используйте команду 'set mipsfpu
     single'.  По умолчанию используется сопроцессор поддержки
     вычислений с плавающей точкой двойной точности; этот режим может
     быть выбран с помощью 'set mipsfpu double'.

     В предыдущих версиях, единственным выбором была двойная точность
     или отсутствие поддержки вычислений с плавающей точкой, так что
     'set mipsfpu on' выберет режим двойной точности, а 'set mipsfpu
     off' отключит эту поддержку.

     Как обычно, вы можете запросить значение переменной 'mipsfpu' при
     помощи 'show mipsfpu'.

'set remotedebug N'
'show remotedebug'
     Вы можете увидеть некоторую отладочную информацию о связи с платой,
     установив переменную 'remotedebug'.  Если вы установите ее в '1'
     при помощи 'set remotedebug 1', будет отображаться каждый пакет.
     Если вы установите ее в '2', то будет отображаться каждый знак.  В
     любой момент вы можете проверить текущее значение переменной
     командой 'show remotedebug'.

'set timeout СЕКУНДЫ'
'set retransmit-timeout СЕКУНДЫ'
'show timeout'
'show retransmit-timeout'
     Вы можете управлять временем ожидания пакета, используемым в
     удаленном протоколе MIPS, при помощи команды 'set timeout СЕКУНДЫ'.
     Значение по умолчанию -- 5 секунд.  Аналогично, вы можете управлять
     временем ожидания, используемым при ожидании подтверждения пакета с
     помощью команды 'set retransmit-timeout СЕКУНДЫ'.  По умолчанию 3
     секунды.  Вы можете узнать обе эти величины с помощью 'show
     timeout' и 'show retransmit-timeout'.  (Эти команды доступны,
     _только_ если GDB сконфигурирован для цели
     '--target=mips-idt-ecoff'.)

     Время ожидания, установленное при помощи 'set timeout', не играет
     роли, когда GDB ожидает остановки вашей программы.  В этом случае
     GDB ждет бесконечно, потому что у него нет способа узнать, сколько
     программа будет выполняться, пока не остановится.


File: gdb.html,  Node: PowerPC,  Next: PA,  Prev: Встроенный MIPS,  Up: Встроенные процессоры

14.3.10 PowerPC
---------------

'target dink32 УСТР'
     Монитор ROM DINK32.

'target ppcbug УСТР'
'target ppcbug1 УСТР'
     Монитор ROM PPCBUG для PowerPC.

'target sds УСТР'
     Монитор SDS, выполняющийся на плате PowerPC (такой как Motorola
     ADS).


File: gdb.html,  Node: PA,  Next: SH,  Prev: PowerPC,  Up: Встроенные процессоры

14.3.11 Встроенный HP PA
------------------------

'target op50n УСТР'
     Монитор OP50N, выполняющийся на плате OKI HPPA.

'target w89k УСТР'
     Монитор W89K, выполняющийся на плате Winbond HPPA.


File: gdb.html,  Node: SH,  Next: Sparclet,  Prev: PA,  Up: Встроенные процессоры

14.3.12 Hitachi SH
------------------

'target hms УСТР'
     Плата Hitachi SH, присоединенная через последовательную линию к
     вашей рабочей машине.  Используйте специальные команды 'device' и
     'speed' для управления последовательной линией и используемой
     скоростью связи.

'target e7000 УСТР'
     Эмулятор E7000 для Hitachi SH.

'target sh3 УСТР'
'target sh3e УСТР'
     Целевые системы Hitachi SH-3 и SH-3E.


File: gdb.html,  Node: Sparclet,  Next: Sparclite,  Prev: SH,  Up: Встроенные процессоры

14.3.13 Tsqware Sparclet
------------------------

GDB позволяет разработчикам отлаживать с Unix-машины задачи,
выполняющиеся на целевых системах Sparclet.  GDB использует код, который
выполняется как на Unix-машине, так и на цели Sparclet.  Программа 'gdb'
устанавливается и работает на Unix-машине.

'remotetimeout АРГ'
     GDB поддерживает параметр 'remotetimeout'.  Он устанавливается
     пользователем, а АРГ представляет число секунд, в течение которых
     GDB ожидает ответы.

   При компиляции для отладки, используйте ключи '-g' для получения
отладочной информации и '-Ttext' для того, чтобы разместить программу в
том месте, в каком вы хотите загрузить ее на целевую машину.  Вы также
можете добавить ключ '-n' или '-N', чтобы уменьшить размеры разделов.
Например:

     sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N

   Чтобы проверить, что адреса в действительности являются теми, которые
вы подразумевали, можно использовать 'objdump':

     sparclet-aout-objdump --headers --syms prog

   После того, как вы установили путь поиска выполняемых файлов, в
котором присутствует GDB, вы готовы запустить отладчик.  С вашей рабочей
машины Unix выполните 'gdb' (или 'sparclet-aout-gdb', в зависимости от
вашей установки).

   GDB запустится и покажет приглашение:

     (gdbslet)

* Menu:

* Файл Sparclet::                Установка файла для отладки
* Соединение к Sparclet::        Соединение к Sparclet
* Загрузка на Sparclet::         Загрузка на Sparclet
* Выполнение Sparclet::          Выполнение и отладка


File: gdb.html,  Node: Файл Sparclet,  Next: Соединение к Sparclet,  Up: Sparclet

14.3.13.1 Установка файла для отладки
.....................................

Команда GDB 'file' позволяет вам выбрать программу для отладки.

     (gdbslet) file prog

   Затем GDB пытается прочитать таблицу символов программы 'prog'.  Он
находит файл путем поиска в каталогах, перечисленных в пути поиска
команд.  Если файл был скомпилирован с отладочной информацией (ключ
'-g'), то также будет произведен поиск исходных файлов.  GDB находит
исходные файлы, производя поиск в каталогах, перечисленных в пути поиска
каталогов (*note Рабочая среда вашей программы: Среда.).  Если ему не
удается найти файл, он выводит сообщение, подобное этому:

     prog: No such file or directory.

   Когда это случается, добавьте соответствующие каталоги в пути поиска
с помощью команд GDB 'path' и 'dir' и выполните команду 'target' снова.


File: gdb.html,  Node: Соединение к Sparclet,  Next: Загрузка на Sparclet,  Prev: Файл Sparclet,  Up: Sparclet

14.3.13.2 Соединение к Sparclet
...............................

Команда GDB 'target' позволяет вам установить соединение с целевой
машиной Sparclet.  Для соединения с последовательным портом "'ttya'",
введите:

     (gdbslet) target sparclet /dev/ttya
     Remote target sparclet connected to /dev/ttya
     main () at ../prog.c:3

   GDB выведет сообщение, подобное этому:

     Connected to ttya.


File: gdb.html,  Node: Загрузка на Sparclet,  Next: Выполнение Sparclet,  Prev: Соединение к Sparclet,  Up: Sparclet

14.3.13.3 Загрузка на Sparclet
..............................

Когда вы установили соединение к цели Sparclet, вы можете использовать
команду GDB 'load' для загрузки файла с рабочей машины на целевую.  Имя
файла и смещение загрузки должно быть задано команде 'load' в качестве
аргумента.  Поскольку это файл в формате a.out, программа должна быть
загружена по начальному адресу.  Чтобы определить, чему равна эта
величина, вы можете использовать 'objdump'.  Смещение загрузки -- это
смещение, которое добавляется к VMA (Virtual Memory Address(1)) каждого
раздела файла.  Например, если программа 'prog' была скомпонована с
адресом текста 0x1201000, сегментом данных по адресу 0x12010160 и
сегментом стека по адресу 0x12010170, введите в GDB:

     (gdbslet) load prog 0x12010000
     Loading section .text, size 0xdb0 vma 0x12010000

   Если код загружается по адресу, отличному от того, по которому
программа была скомпонована, вам может потребоваться использовать
команды 'section' и 'add-symbol-file', чтобы сообщить GDB, куда
отобразить таблицу символов.

   ---------- Footnotes ----------

   (1) Виртуальный адрес памяти (Прим. переводчика)


File: gdb.html,  Node: Выполнение Sparclet,  Prev: Загрузка на Sparclet,  Up: Sparclet

14.3.13.4 Выполнение и отладка
..............................

Теперь вы можете начать отлаживать задачу, используя команды GDB для
управления выполнением, 'b', 'step', 'run' и так далее.  Все такие
команды перечислены в этом руководстве.

     (gdbslet) b main
     Breakpoint 1 at 0x12010000: file prog.c, line 3.
     (gdbslet) run
     Starting program: prog
     Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
     3        char *symarg = 0;
     (gdbslet) step
     4        char *execarg = "hello!";
     (gdbslet)


File: gdb.html,  Node: Sparclite,  Next: ST2000,  Prev: Sparclet,  Up: Встроенные процессоры

14.3.14 Fujitsu Sparclite
-------------------------

'target sparclite УСТР'
     Платы Fujitsu sparclite, используемые только с целью загрузки.
     Чтобы отлаживать программу, вы должны использовать дополнительную
     команду.  Например, 'target remote УСТР', используя стандартный
     удаленный протокол GDB.


File: gdb.html,  Node: ST2000,  Next: Z8000,  Prev: Sparclite,  Up: Встроенные процессоры

14.3.15 Tandem ST2000
---------------------

GDB может быть использован с телефонным коммутатором Tandem ST2000,
поддерживающим протокол Tandem STDBUG.

   Чтобы узнать, как соединить ST2000 с рабочей машиной, смотрите
руководство производителя.  После того как ST2000 физически подключен,
вы можете выполнить:

     target st2000 УСТР СКОРОСТЬ

чтобы установить его как вашу отладочную среду.  УСТР -- это обычно имя
последовательного устройства, такое как '/dev/ttya', соединенного с
ST2000 через последовательную линию.  Вместо этого, вы можете указать
УСТР как TCP-соединение (например, к последовательной линии,
присоединенной через терминальный концентратор), используя синтаксис
'ИМЯ-МАШИНЫ:НОМЕР-ПОРТА'.

   Команды 'load' и 'attach' _не_ определены для этой цели; вы должны
загрузить вашу программу на ST2000 так же, как вы это обычно делаете для
автономных действий.  GDB читает отладочную информацию (например,
символы) из отдельной, отладочной версии программы, которая доступна на
вашем рабочем компьютере.

   Следующие вспомогательные команды GDB доступны для облегчения работы
в среде ST2000:

'st2000 КОМАНДА'
     Послать КОМАНДУ монитору STDBUG. Доступные команды описаны в
     руководстве производителя.

'connect'
     Соединяет управляющий терминал с командным монитором STDBUG. Когда
     вы закончили взаимодействие с STDBUG, ввод одной из двух
     последовательностей знаков возвратит вас назад к приглашению GDB:
     '<RET>~.' (Return, за которым следует тильда и точка) или
     '<RET>~<C-d>' (Return, за которым следует тильда и control-D).


File: gdb.html,  Node: Z8000,  Prev: ST2000,  Up: Встроенные процессоры

14.3.16 Zilog Z8000
-------------------

Будучи сконфигурированным для отладки целей Zilog Z8000, GDB включает
симулятор Z8000.

   Для семейства Z8000, 'target sim' имитирует либо Z8002
(несегментированный вариант архитектуры Z8000), либо Z8001
(сегментированный вариант).  Имитатор распознает подходящую архитектуру
изучая объектный код.

'target sim АРГ'
     Отладка программ на имитируемом ЦП. Если имитатор поддерживает
     параметры установки, укажите их в АРГ.

После определения этой цели, вы можете отлаживать программы для
имитированного ЦП таким же образом, как программы для вашего рабочего
компьютера; используйте команду 'file' для загрузки образа новой
программы, команду 'run' для запуска вашей программы и так далее.

   Помимо того, что доступны все обычные машинные регистры (*note
Регистры: Регистры.), имитатор Z8000 предоставляет три специально
названных регистра с дополнительной информацией:

'cycles'
     Считает тактовые импульсы в имитаторе.

'insts'
     Считает инструкции, выполненные в имитаторе.

'time'
     Время выполнения в шестидесятых долях секунды.

   Вы можете ссылаться на эти значения в выражениях GDB с помощью
обычных соглашений; например, 'b fputc if $cycles>5000' устанавливает
условную точку останова, которая срабатывает только после как минимум
5000 имитированных тактовых импульсов.


File: gdb.html,  Node: Архитектуры,  Prev: Встроенные процессоры,  Up: Конфигурации

14.4 Архитектуры
================

Этот раздел описывает свойства архитектур, которые воздействуют на все
применения GDB с данной архитектурой, как при чистой отладке, так и при
кросс-отладке.

* Menu:

* A29K::
* Alpha::
* MIPS::


File: gdb.html,  Node: A29K,  Next: Alpha,  Up: Архитектуры

14.4.1 A29K
-----------

'set rstack_high_address АДРЕС'
     В процессорах семейства AMD 29000, регистры сохраняются в отдельном
     "стеке регистров".  Для отладчика не существует способа определить
     размер этого стека.  Обычно GDB просто подразумевает, что стек
     "достаточно большой".  Это может привести к тому, что GDB
     попытается обратиться несуществующей области памяти.  В случае
     необходимости, вы можете решить эту проблему, указав конечный адрес
     стека регистров с помощью команды 'set rstack_high_address'.
     Аргумент должен быть адресом, который вы, вероятно, захотите начать
     с '0x', чтобы задать его в шестнадцатеричном виде.

'show rstack_high_address'
     Отобразить текущее ограничение на стек регистров для процессоров
     семейства AMD 29000.


File: gdb.html,  Node: Alpha,  Next: MIPS,  Prev: A29K,  Up: Архитектуры

14.4.2 Alpha
------------

Смотрите следующий раздел.


File: gdb.html,  Node: MIPS,  Prev: Alpha,  Up: Архитектуры

14.4.3 MIPS
-----------

Компьютеры, базирующиеся на архитектурах Alpha и MIPS, используют
необычный кадр стека, который иногда требует от GDB поиска в объектном
коде в обратном направлении, чтобы найти начало функции.

   Чтобы сократить время ответа (особенно для встроенных приложений, где
GDB может быть ограничен медленной последовательной линией для этого
поиска), вы можете захотеть ограничить область поиска, используя одну из
этих команд:

'set heuristic-fence-post ПРЕДЕЛ'
     Ограничить GDB для исследования не более ПРЕДЕЛА байт при поиске
     начала функции.  Значение 0 (по умолчанию) означает неограниченный
     поиск.  Однако, исключая 0, чем больше предел, тем больше байт
     'heuristic-fence-post' должен просмотреть, и, следовательно, тем
     дольше он будет выполняться.

'show heuristic-fence-post'
     Отобразить текущее значение данного предела.

Эти команды доступны, _только_ когда GDB сконфигурирован для отладки
программ на процессорах Alpha или MIPS.


File: gdb.html,  Node: Управление GDB,  Next: Последовательности,  Prev: Конфигурации,  Up: Top

15 Управление GDB
*****************

Вы можете изменять способы взаимодействия GDB с вами, используя команду
'set'.  Для команд, управляющих способами отображения данных GDB,
смотрите *note Параметры вывода: Параметры вывода.  Другие установки
описаны здесь.

* Menu:

* Приглашение::                 Приглашение
* Редактирование::              Редактирование команд
* История::                     История команд
* Размер экрана::               Размер экрана
* Числа::                       Числа
* Сообщения/предупреждения::    Необязательные предупреждения и сообщения
* Отладочный вывод::            Необязательные сообщения о внутренних событиях


File: gdb.html,  Node: Приглашение,  Next: Редактирование,  Up: Управление GDB

15.1 Приглашение
================

GDB демонстрирует свою готовность считать команду выводя строку,
называемую "приглашением".  Обычно это '(gdb)'.  Вы можете изменить
строку приглашения командой 'set prompt'.  Например, при отладке GDB с
помощью GDB, полезно изменить приглашение в одном из сеансов так, чтобы
вы всегда могли понять, с каким из них вы общаетесь.

   _Замечание:_ 'set prompt' не добавляет пробелы после установленного
вами приглашения.  Это позволяет устанавливать приглашение,
заканчивающееся пробелом или нет.

'set prompt НОВОЕ-ПРИГЛ'
     Указывает GDB, что с этого момента надо использовать в качестве
     строки приглашения НОВОЕ-ПРИГЛ.

'show prompt'
     Печатает строку в форме: 'Gdb's prompt is: ВАШЕ-ПРИГЛ'


File: gdb.html,  Node: Редактирование,  Next: История,  Prev: Приглашение,  Up: Управление GDB

15.2 Редактирование команд
==========================

GDB читает входные команды через интерфейс "readline".  Эта библиотека
GNU обеспечивает единообразное поведение для программ, которые
предоставляют пользователю интерфейс командной строки.  Преимуществами
являются стили редактирования командной строки GNU Emacs или "vi",
'csh'-подобная подстановка истории и сохранение и повторное
использование истории команд между сеансами отладки.

   Вы можете управлять поведением редактирования командной строки в GDB
командой 'set'.

'set editing'
'set editing on'
     Включает редактирование командной строки (включено по умолчанию).

'set editing off'
     Отключает редактирование командной строки.

'show editing'
     Показывает, включено редактирование командной строки или нет.


File: gdb.html,  Node: История,  Next: Размер экрана,  Prev: Редактирование,  Up: Управление GDB

15.3 История команд
===================

GDB может отслеживать команды, которые вы вводите во время сеансов
отладки, чтобы вы могли точно знать, что происходило.  Используйте
следующие команды для управления возможностями истории команд GDB.

'set history filename ИМЯ-ФАЙЛА'
     Устанавливает имя файла истории команд GDB в ИМЯ-ФАЙЛА.  Это файл,
     откуда GDB читает исходный список истории команд, и куда он
     записывает историю команд при выходе из данного сеанса.  Вы можете
     обращаться к этому списку через раскрывание истории или с помощью
     символов редактирования истории команд, перечисленных ниже.  По
     умолчанию, этот файл есть значение переменной среды 'GDBHISTFILE'
     или, если эта переменная не установлена, './.gdb_history'
     ('./_gdb_history' в MS-DOS).

'set history save'
'set history save on'
     Записать историю команд в файл, имя которого может быть определено
     командой 'set history filename'.  По умолчанию, эта возможность
     отключена.

'set history save off'
     Прекратить запись истории команд в файл.

'set history size РАЗМЕР'
     Установить число команд, которые GDB хранит в своем списке истории.
     Значение по умолчанию берется из переменной среды 'HISTSIZE' или
     приравнивается 256, если эта переменная не установлена.

   Раскрывание истории назначает специальное значение знаку '!'.

   Так как '!' является также оператором логического отрицания в Си,
раскрывание истории по умолчанию отключено.  Если вы решите включить
раскрывание истории командой 'set history expansion on', вы должны
будете снабдить '!' (когда он используется как логическое отрицание в
выражении) последующим пробелом или символом табуляции, чтобы
предохранить его от раскрывания.  Средства истории Readline не делают
попытки подстановки на строках '!=' и '!(', даже когда раскрывание
истории включено.

   Вот команды управления раскрыванием истории:

'set history expansion on'
'set history expansion'
     Включить раскрывание истории.  Раскрывание по умолчанию отключено.

'set history expansion off'
     Отключить раскрывание истории.

     Библиотека Readline поставляется вместе с более полной
     документацией по возможностям редактирования и раскрывания истории.
     Пользователи, незнакомые с GNU Emacs или 'vi', могут почитать ее.

'show history'
'show history filename'
'show history save'
'show history size'
'show history expansion'
     Эти команды отображают состояние параметров истории GDB. Просто
     'show history' показывает все четыре состояния.

'show commands'
     Отобразить последние десять команд в истории.

'show commands N'
     Вывести десять команд, расположенных вокруг команды с номером N.

'show commands +'
     Вывести десять команд, расположенных сразу после последних
     выведенных.


File: gdb.html,  Node: Размер экрана,  Next: Числа,  Prev: История,  Up: Управление GDB

15.4 Размер экрана
==================

Определенные команды GDB могут выводить большое количество информации на
экран.  Чтобы помочь вам всю ее прочитать, GDB приостанавливает вывод и
запрашивает ввод в конце каждой страницы вывода.  Нажмите <RET>, когда
вы хотите продолжить вывод, или 'q' для уничтожения оставшегося вывода.
Также, установка ширины экрана определяет, когда переносить строки
вывода.  В зависимости от того, что выводится, GDB пытается разбить
строку в удобочитаемом месте, вместо того чтобы просто продолжить ее на
следующую строчку.

   Обычно GDB узнает размер экрана из программы драйвера терминала.
Например, в Unix GDB использует базу данных termcap, вместе со значением
переменной среды 'TERM' и установками 'stty rows' и 'stty cols'.  Если
это неправильно, вы можете заменить эти установки командами 'set height'
и 'set width':

'set height LPP'
'show height'
'set width CPL'
'show width'
     Эти команды 'set' определяют высоту экрана в LPP строк и ширину в
     CPL знаков.  Соответствующие команды 'show' отображают текущие
     установки.

     Если вы определите высоту в ноль строк, GDB не будет
     останавливаться при выводе, независимо от того, насколько он
     длинный.  Это полезно, если вывод осуществляется в файл или буфер
     редактора.

     Аналогично, вы можете определить 'set width 0', чтобы запретить GDB
     переносить строки вывода.


File: gdb.html,  Node: Числа,  Next: Сообщения/предупреждения,  Prev: Размер экрана,  Up: Управление GDB

15.5 Числа
==========

Вы всегда можете вводить в GDB числа в восьмеричной, десятичной или
шестнадцатеричной системе в соответствии c обычными соглашениями:
восьмеричные числа начинаются с '0', десятичные числа оканчиваются на
'.', а шестнадцатеричные числа начинаются с '0x'.  Числа, которые не
начинаются ни c одного из этих знаков, по умолчанию считаются
десятичными; аналогично, отображение чисел по умолчанию -- если не
определен никакой конкретный формат -- осуществляется по основанию 10.
Командой 'set radix' вы можете изменять основание, устанавливаемое по
умолчанию для ввода и вывода.

'set input-radix ОСНОВАНИЕ'
     Установить основание по умолчанию для числового ввода.
     Поддерживаемые варианты для ОСНОВАНИЯ -- 8, 10 или 16.  Само
     ОСНОВАНИЕ должно быть определено либо недвусмысленно, либо с
     использованием текущего основания системы счисления по умолчанию;
     например, любая из команд

          set radix 012
          set radix 10.
          set radix 0xa

     устанавливает десятичное основание.  С другой стороны, 'set radix
     10' оставляет основание системы счисления без изменений независимо
     от того, каким оно было.

'set output-radix ОСНОВАНИЕ'
     Установить основание по умолчанию для числового вывода.
     Поддерживаемые варианты для ОСНОВАНИЯ -- 8, 10 или 16.  Само
     ОСНОВАНИЕ должно быть определено либо недвусмысленно, либо с
     использованием текущего основания системы счисления по умолчанию.

'show input-radix'
     Отобразить текущее основание по умолчанию для числового ввода.

'show output-radix'
     Отобразить текущее основание по умолчанию для числового вывода.


File: gdb.html,  Node: Сообщения/предупреждения,  Next: Отладочный вывод,  Prev: Числа,  Up: Управление GDB

15.6 Необязательные предупреждения и сообщения
==============================================

По умолчанию, GDB ничего не сообщает о своей внутренней деятельности.
Если вы работаете на медленной машине, то вы можете захотеть
использовать команду 'set verbose'.  Она велит GDB сообщать вам, когда
он выполняет длинную внутреннюю операцию, чтобы вы не думали, что он
завис.

   В настоящее время 'set verbose' управляет только сообщениями о чтении
таблиц символов исходного файла; смотрите *note Команды для задания
файлов: Файлы, описание 'symbol-file'.

'set verbose on'
     Разрешает GDB выводить некоторые информационные сообщения.

'set verbose off'
     Отключает вывод некоторых информационных сообщений.

'show verbose'
     Сообщает, установлено 'set verbose' в 'on' или 'off'.

   По умолчанию, если GDB сталкивается с ошибками в таблице символов
объектного файла, он не сообщает об этом; но если вы отлаживаете
компилятор, эта информация может вам пригодиться (*note Ошибки чтения
файлов с символами: Ошибки с символами.).

'set complaints ПРЕДЕЛ'
     Позволяет GDB выводить ПРЕДЕЛ сообщений о каждом типе необычных
     символов прежде, чем перестать сообщать о проблеме.  Установите
     ПРЕДЕЛ в ноль для подавления всех сообщений, или очень большим,
     чтобы предотвратить подавление сообщений.

'show complaints'
     Выводит ограничение GDB на вывод сообщений о символах.

   По умолчанию GDB осмотрителен и задает, как иногда кажется, множество
глупых вопросов, чтобы подтвердить некоторые команды.  Например, если вы
пытаетесь выполнить программу, которая уже выполняется:

     (gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

   Если вы неуклонно желаете сами разбираться с последствиями ваших
собственных команд, вы можете отключить эту "возможность":

'set confirm off'
     Отключает запросы подтверждений.

'set confirm on'
     Включает запросы подтверждений (по умолчанию).

'show confirm'
     Показывает, выводятся ли запросы подтверждений.


File: gdb.html,  Node: Отладочный вывод,  Prev: Сообщения/предупреждения,  Up: Управление GDB

15.7 Необязательные сообщения о внутренних событиях
===================================================

'set debug arch'
     Включает и отключает вывод отладочной информации gdbarch.  По
     умолчанию отключено.
'show debug arch'
     Отображает текущее состояние вывода отладочной информации gdbarch.
'set debug event'
     Включает и отключает вывод отладочной информации о событиях GDB. По
     умолчанию отключено.
'show debug event'
     Отображает текущее состояние вывода отладочной информации о
     событиях GDB.
'set debug expression'
     Включает и отключает вывод отладочной информации о выражениях GDB.
     По умолчанию отключено.
'show debug expression'
     Отображает текущее состояние вывода отладочной информации о
     выражениях GDB.
'set debug overload'
     Включает и выключает вывод GDB отладочной информации о
     перегруженных символах Си++.  Это включает такую информацию, как
     упорядочивание функций и тому подобное.  По умолчанию отключено.
'show debug overload'
     Отображает текущее состояние вывода GDB отладочной информации о
     перегруженных символах Си++.
'set debug remote'
     Включает и выключает вывод отчета о всех пакетах, посланных вперед
     и назад по последовательной линии удаленной машине.  Информация
     печатается в стандартный выходной поток GDB. По умолчанию
     отключено.
'show debug remote'
     Выводит состояние вывода удаленных пакетов.
'set debug serial'
     Включает и выключает вывод GDB отладочной информации о
     последовательном соединении.  По умолчанию отключено.
'show debug serial'
     Отображает текущее состояние вывода GDB отладочной информации о
     последовательном соединении.
'set debug target'
     Включает и выключает вывод GDB отладочной информации о цели.  Сюда
     входит информация о том, что происходит на уровне цели GDB. По
     умолчанию отключено.
'show debug target'
     Отображает текущее состояние вывода GDB отладочной информации о
     цели.
'set debug varobj'
     Включает и отключает вывод GDB отладочной информации о переменных
     объектах.  По умолчанию отключено.
'show debug varobj'
     Отображает текущее состояние вывода GDB отладочной информации о
     переменных объектах.


File: gdb.html,  Node: Последовательности,  Next: Emacs,  Prev: Управление GDB,  Up: Top

16 Фиксированные последовательности команд
******************************************

Кроме команд точки останова (*note Команды точки останова: Команды
останова.), GDB предоставляет два способа сохранить последовательности
команд для выполнения целиком: определяемые пользователем команды и
командные файлы.

* Menu:

* Определяемые пользователем команды::
                                Определяемые пользователем команды
* Ловушки::                     Определяемые пользователем команды-ловушки
* Командные файлы::             Командные файлы
* Вывод::                       Команды для управления выводом


File: gdb.html,  Node: Определяемые пользователем команды,  Next: Ловушки,  Up: Последовательности

16.1 Команды, определяемые пользователем
========================================

"Команда, определяемая пользователем" -- это последовательность команд
GDB, которой вы назначаете имя как новой команде.  Это осуществляется
командой 'define'.  Пользовательские команды могут иметь до 10
параметров, разделенных пробелами.  Внутри команды пользователя, доступ
к параметрам производится посредством $ARG0...$ARG9.  Вот простой
пример:

     define adder
       print $arg0 + $arg1 + $arg2

Для выполнения команды используйте:

     adder 1 2 3

Этот пример определяет команду 'adder', которая печатает сумму трех
своих параметров.  Обратите внимание, параметры являются текстовыми
подстановками, так что они могут ссылаться на переменные, использовать
сложные выражения или даже выполнять вызовы подчиненных функций.

'define ИМЯ-КОМАНДЫ'
     Определить команду с именем ИМЯ-КОМАНДЫ.  Если команда с таким
     именем уже имеется, у вас запрашивается подтверждение на ее
     переопределение.

     Определение команды состоит из других командных строк GDB, которые
     задаются после команды 'define'.  Конец этих команд отмечается
     строкой, содержащей 'end'.

'if'
     Имеет один аргумент -- вычисляемое выражение.  Команда
     сопровождается последовательностью команд, которые выполняются,
     если выражение истинно (отлично от нуля).  Затем может следовать
     необязательная строка 'else', сопровождаемая последовательностью
     команд, которые выполняются только при ложном значении данного
     выражения.  Конец списка отмечается строкой, содержащей 'end'.

'while'
     Синтаксис подобен 'if': команда имеет один параметр, который
     является вычисляемым выражением и должен сопровождаться командами,
     по одной в строке, которые завершаются 'end'.  Выполнение команд
     повторяется, пока выражение истинно.

'document ИМЯ-КОМАНДЫ'
     Документирует определенную пользователем команду ИМЯ-КОМАНДЫ, чтобы
     к ней можно было обращаться посредством 'help'.  Команда
     ИМЯ-КОМАНДЫ должна быть определена ранее.  Эта команда считывает
     строки документации точно так же, как 'define' считывает строки
     определения команды, до строки 'end'.  После завершения команды
     'document', написанная вами документация будет отображаться
     командой 'help' для команды ИМЯ-КОМАНДЫ.

     Вы можете использовать команду 'document' неоднократно, чтобы
     изменить документацию команды.  Переопределение команды посредством
     'define' не изменяет документации.

'help user-defined'
     Перечислить все определенные пользователем команды, вместе с первой
     строкой документации (если она есть).

'show user'
'show user ИМЯ-КОМАНДЫ'
     Вывести команды GDB, использовавшиеся для определения ИМЯ-КОМАНДЫ
     (но не ее документацию).  Если ИМЯ-КОМАНДЫ не задано, вывести
     содержимое всех определенных пользователем команд.

   При выполнении команд, определенных пользователем, команды
определения не печатаются.  Ошибка в любой из них останавливает
выполнение всей определенной пользователем команды.

   При использовании в интерактивном режиме, команды, обычно
запрашивающие подтверждение, выполняются без запроса, если они
используется внутри определенной пользователем команды.  Многие команды
GDB, которые обычно печатают сообщения о своих действиях, опускают их
при использовании в команде, определенной пользователем.


File: gdb.html,  Node: Ловушки,  Next: Командные файлы,  Prev: Определяемые пользователем команды,  Up: Последовательности

16.2 Определяемые пользователем команды-ловушки
===============================================

Вы можете определять "ловушки", которые являются специальным видом
определяемых пользователем команд.  Всякий раз, когда вы выполняете
команду 'foo', перед ней выполняется определенная пользователем команда
'hook-foo' (без параметров), если она существует.

   Также может быть определена ловушка, которая вызывается после
выполненной вами команды.  Когда вы выполняете команду 'foo', после нее
вызывается (без аргументов) определенная пользователем команда
'hookpost-foo', если она существует.  Ловушки, срабатывающие после
выполнения команды, могут существовать одновременно с ловушками,
вызываемыми до выполнения той же команды.

   Ловушка может вызывать ту же команду, которую она ловит.  Если это
происходит, ловушка заново не вызывается.  Тем самым избегаются
бесконечные циклы.

   Кроме того, существует псевдокоманда 'stop'.  Определение
('hook-stop') велит выполняться связанным с ней командам при каждом
останове вашей программы: перед выполнением команд точек останова, перед
выводом на экран сообщений или кадров стека.

   Например, чтобы игнорировать сигналы 'SIGALRM' во время выполнения в
пошаговом режиме, но обрабатывать их при нормальном выполнении, вы
можете определить:

     define hook-stop
     handle SIGALRM nopass
     end

     define hook-run
     handle SIGALRM pass
     end

     define hook-continue
     handle SIGLARM pass
     end

   В качестве другого примера, чтобы поймать начало и конец команды
'echo' и добавить дополнительный текст до и после сообщения, вы можете
определить:

     define hook-echo
     echo <<<---
     end

     define hookpost-echo
     echo --->>>\n
     end

     (gdb) echo Hello World
     <<<---Hello World--->>>
     (gdb)


   Вы можете определить ловушку для любой однословной команды GDB, но не
для синонимов команды; вам следует определить ловушку для базового имени
команды, например, 'backtrace', но не 'bt'.  Если во время выполнения
вашей ловушки возникает ошибка, выполнение команд GDB останавливается, и
он выдает приглашение (до того, как введенная вами команда начнет
выполняться).

   Если вы попытаетесь определить ловушку, не соответствующую никакой
известной команде, вы получите предупреждение от команды 'define'.


File: gdb.html,  Node: Командные файлы,  Next: Вывод,  Prev: Ловушки,  Up: Последовательности

16.3 Командные файлы
====================

Командный файл для GDB -- это файл, состоящий из строк с командами GDB.
Такие файлы могут также включать комментарии (строки, начинающиеся с
'#').  Пустая строка в командном файле ничего не делает; она не означает
повторение последней команды, как это было бы при вводе с терминала.

   Когда вы вызываете GDB, он автоматически выполняет команды из своих
"файлов инициализации".  Это файлы, называющиеся '.gdbinit' в Unix и
'gdb.ini' в DOS/Windows.  Во время старта, GDB делает следующее:

  1. считывает файл инициализации (если он существует) в вашем домашнем
     каталоге(1).

  2. Обрабатывает ключи и операнды командной строки.

  3. Считывает файл инициализации (если он существует) в текущем рабочем
     каталоге.

  4. Считывает командные файлы, заданные с помощью ключа '-x'.

   Файл инициализации в вашем домашнем каталоге может устанавливать
параметры (такие как 'set complaints'), которые влияют на последующую
обработку ключей и операндов командной строки.  Файлы инициализации не
выполняются, если вы используете ключ '-nx' *note Выбор режимов:
Параметры режима.

   В некоторых конфигурациях GDB, файлу инициализации присваивается
другое имя (обычно это среды, где специализированная форма GDB должна
сосуществовать с другими формами, следовательно должно быть отличное имя
для файла инициализации специализированной версии).  Следующие среды
используют специальные имена файлов инициализации:

   * VxWorks (ОС реального времени Wind River Systems): '.vxgdbinit'

   * OS68K (ОС реального времени Enea Data Systems): '.os68gdbinit'

   * ES-1800 (эмулятор Ericsson Telecom AB M68000): '.esgdbinit'

   Вы также можете запросить выполнение командного файла с помощью
команды 'source':

'source ИМЯ-ФАЙЛА'
     Выполнить командный файл ИМЯ-ФАЙЛА.

   Строки командного файла выполняются последовательно, при этом они не
выводятся.  Ошибка в любой команде завершает выполнение всего командного
файла.

   Команды, запрашивающие подтверждение в интерактивном режиме, при
выполнении в командном файле выполняются без запросов.  Многие команды
GDB, обычно выводящие сообщения о своих действиях, опускают эти
сообщения при вызове из командных файлов.

   ---------- Footnotes ----------

   (1) В системах DOS/Windows, домашним каталогом считается тот, на
который указывает переменная среды 'HOME'.


File: gdb.html,  Node: Вывод,  Prev: Командные файлы,  Up: Последовательности

16.4 Команды для управляемого вывода
====================================

Во время выполнения командного файла или определенной пользователем
команды нормальный вывод GDB подавляется; единственный появляющийся
вывод -- тот, который производится явно командами из определения.  В
этом разделе описываются три команды, полезные для получения именно
такого вывода, который вы хотите.

'echo ТЕКСТ'
     Напечатать ТЕКСТ.  Непечатные знаки могут быть включены в ТЕКСТ при
     помощи экранирующих последовательностей Си, таких как '\n' для
     перехода на новую строку.  *Переход на новую строку не печатается,
     если вы его не укажете.*  В дополнение к стандартным экранирующим
     последовательностям Си, обратная косая черта, за которой следует
     пробел, обозначает пробел.  Это полезно для отображения строки с
     пробелами в начале или конце, поскольку в противном случае
     начальные и конечные пробелы удаляются из всех аргументов.  Чтобы
     напечатать ' and foo = ', используйте команду 'echo \ and foo =
     \ '.

     Обратная косая черта в конце ТЕКСТА может использоваться, как и в
     Си, для продолжения команды на последующие строки.  Например,

          echo Вот пример текста,\n\
          который занимает\n\
          несколько строк.\n

     производит такой же вывод как

          echo Вот пример текста,\n
          echo который занимает\n
          echo несколько строк.\n

'output ВЫРАЖЕНИЕ'
     Напечатать значение ВЫРАЖЕНИЯ и ничего кроме него: никаких новых
     строк, никаких '$NN = '.  Значение также не заносится в историю
     значений.  *Note Выражения: Выражения, для дополнительной
     информации о выражениях.

'output/ФОРМАТ ВЫРАЖЕНИЕ'
     Вывести значение ВЫРАЖЕНИЯ в формате ФОРМАТ.  Вы можете
     использовать те же форматы, что и для 'print'.  *Note Форматы
     вывода: Форматы вывода, для получения большей информации.

'printf СТРОКА, ВЫРАЖЕНИЯ...'
     Напечатать значения ВЫРАЖЕНИЙ, причем формат вывода задает СТРОКА.
     ВЫРАЖЕНИЯ разделяются запятыми и могут быть либо числами, либо
     указателями.  Их значения печатаются так, как определяет СТРОКА, в
     точности, как если бы ваша программа выполняла подпрограмму Си

          printf (СТРОКА, ВЫРАЖЕНИЯ...);

     Например, вы можете напечатать два шестнадцатеричных значения:

          printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo

     Единственые экранирующие последовательности с обратной косой
     чертой, которые вы можете использовать в строке формата -- простые
     последовательности, состоящие из обратной косой черты, за которой
     следует буква.


File: gdb.html,  Node: Emacs,  Next: Примечания,  Prev: Последовательности,  Up: Top

17 Использование GDB под управлением GNU Emacs
**********************************************

Специальный интерфейс позволяет вам использовать GNU Emacs для просмотра
(и редактирования) исходных файлов программы, которую вы отлаживаете с
помощью GDB.

   Чтобы использовать этот интерфейс, используйте команду 'M-x gdb' в
Emacs.  В качестве аргумента задайте выполняемый файл, который вы хотите
отладить.  Эта команда вызывает GDB как подпроцесс Emacs с вводом и
выводом через заново созданный буфер.

   Под управлением Emacs, GDB используется точно так же, как обычно, за
исключением двух моментов:

   * Весь "терминальный" ввод и вывод происходит через буфер Emacs.

   Это относится как к командам GDB и их выводу, так и к вводу и выводу,
производимыми отлаживаемой программой.

   Это полезно, потому что вы можете копировать текст предыдущих команд
и вводить их снова; вы даже можете использовать таким образом части
вывода.

   Все средства режима оболочки Emacs доступны для взаимодействия с
вашей программой.  В частности, вы можете посылать сигналы обычным путем
-- например, 'C-c C-c' для прерывания, 'C-c C-z' для остановки.

   * GDB отображает исходный код через Emacs.

   Каждый раз, когда GDB отображает кадр стека, Emacs автоматически
находит исходный файл для него и помещает стрелку ('=>') с левого края
текущей строки.  Emacs использует отдельный буфер для отображения
исходного текста и разделяет экран, чтобы отобразить как сеанс GDB, так
и исходный текст.

   Тем не менее, явные команды GDB 'list' и 'search' производят вывод
как обычно, но у вас, скорее всего, не будет причин использовать их из
Emacs.

     _Предупреждение:_ Если каталог, в котором находится ваша программа,
     не является текущим, Emacs легко может ошибиться при определении
     местонахождения исходных файлов; в этом случае вспомогательный
     буфер с исходным текстом не появляется.  GDB может искать
     программы, используя переменную среды 'PATH', так что сеансы ввода
     и вывода происходят нормально; но Emacs не получает достаточно
     информации от GDB, чтобы найти исходные файлы в такой ситуации.
     Чтобы избежать этой проблемы, либо запускайте режим GDB из
     каталога, где находится ваша программа, либо укажите абсолютное имя
     файла, когда будет запрошен параметр для 'M-x gdb'.

     Подобная путаница может возникнуть, если вы используете команду GDB
     'file', чтобы переключиться к отладке программы, находящейся в
     каком-нибудь другом месте, из существующего буфера GDB в Emacs.

   По умолчанию, 'M-x gdb' вызывает программу с именем 'gdb'.  Если вам
нужно вызвать GDB под другим именем (например, если вы храните несколько
конфигураций под различными именами), вы можете установить переменную
Emacs 'gdb-command-name'; например, установка

     (setq gdb-command-name "mygdb")

(которой предшествует 'M-:' или 'ESC :', или если она введена в буфер
'*scratch*' или в вашем файле '.emacs'), заставит Emacs вызвать
программу "'mygdb'".

   В буфере ввода-вывода GDB, вы можете использовать следующие
специальные команды Emacs в дополнение к стандартным командам режима
оболочки:

'C-h m'
     Описывает возможности режима GDB Emacs.

'M-s'
     Выполнить до другой строки исходного текста, подобно команде GDB
     'step'; также обновляет окно отображения для показа текущего файла
     и положения в нем.

'M-n'
     Выполнить до следующей строки исходного текста в этой функции,
     пропуская все вызовы функций, подобно команде GDB 'next'.  Затем
     обновить окно отображения, чтобы показать текущий файл и положение
     в нем.

'M-i'
     Выполнить одну инструкцию, подобно команде GDB 'stepi'; обновляет
     окно отображения.

'M-x gdb-nexti'
     Выполнить до следующей инструкции, используя команду GDB 'nexti';
     обновляет окно отображения.

'C-c C-f'
     Выполнить до выхода из выбранного кадра стека, подобно команде GDB
     'finish'.

'M-c'
     Продолжить выполнение вашей программы, подобно команде GDB
     'continue'.

     _Предупреждение:_ В Emacs версии 19, эта команда вызывается
     посредством 'C-c C-p'.

'M-u'
     Подняться вверх по стеку на число кадров, заданное числовым
     параметром, подобно команде GDB 'up' (*note Числовые аргументы:
     (Emacs)Аргументы.).

     _Предупреждение:_ В Emacs версии 19, эта команда вызывается
     посредством 'C-c C-u'.

'M-d'
     Спуститься вниз по стеку на число кадров, заданное числовым
     параметром, аналогично команде GDB 'down'.

     _Предупреждение:_ В Emacs версии 19, эта команда вызывается
     посредством 'C-c C-d'.

'C-x &'
     Прочитать число в позиции курсора и вставить его в конец буфера
     ввода-вывода GDB. Например, если вы хотите дисассемблировать код по
     адресу, отображенному ранее, наберите 'disassemble'; затем
     переместите курсор на изображение адреса и задайте аргумент для
     'disassemble', набрав 'C-x &'.

     Вы можете и дальше настраивать это, определяя элементы списка
     'gdb-print-command'; если он определен, вы можете форматировать или
     как-либо иначе обрабатывать числа, задаваемые 'C-x &', перед их
     вставкой в буфер.  Числовой аргумент к 'C-x &' показывает, что вам
     нужно специальное форматирование, а также действует как индекс для
     выбора элемента из списка.  Если элемент списка является строкой,
     то вставляемое число форматируется с использованием функции Emacs
     'format'; в противном случае, число передается как параметр
     соответствующему элементу списка.

   В любом исходном файле, команда Emacs 'C-x SPC' ('gdb-break') велит
GDB установить точку останова на строке исходного текста, в которой
находится точка.

   Если вы случайно удалите буфер отображения исходного текста, его
можно легко вернуть обратно, введя команду 'f' в буфере GDB, чтобы
запросить отображение кадра; когда выполнение происходит под управлением
Emacs, это при необходимости создает исходный буфер заново, чтобы
показать вам текущий кадр.

   Исходные файлы, отображаемые в Emacs, находятся в обычных буферах
Emacs, которые получают доступ к исходным файлам обычным способом.  При
желании вы можете редактировать файлы в этих буферах; но помните, что
GDB взаимодействует с Emacs в терминах номеров строк.  Если вы добавите
или удалите строки из текста, известные GDB номера строк больше не будут
соответствовать коду.


File: gdb.html,  Node: Примечания,  Next: GDB/MI,  Prev: Emacs,  Up: Top

18 Примечания GDB
*****************

Эта глава описывает примечания в GDB. Примечания разработаны для
согласования GDB с графическими интерфейсами пользователя или другими
аналогичными программами, которые хотят взаимодействовать с GDB на
относительно высоком уровне.

* Menu:

* Обзор примечаний::    Что такое примечания; общий синтаксис.
* Префикс server::      Подача команды без воздействия на состояние пользователя.
* Примечания к значениям::   Значения явно помечаются.
* Примечания к кадрам:: Примечания к кадрам стека.
* Отображения::         GDB может отображать что-то периодически.
* Приглашения::         Примечания, отмечающие потребность GDB во вводе.
* Ошибки::              Примечания к сообщениям об ошибках.
* Информация о точке останова::     Информация о точках останова.
* Недостоверность::     Некоторые примечания, описывающие недостоверные вещи.
* Примечания к выполнению::
                        Выполняется ли программа, как она остановилась, и т.д.
* Примечания к исходному тексту::  Примечания, описывающие исходный код.
* Дальнейшие планы::    Примечания, которые могут понадобиться в будущем.


File: gdb.html,  Node: Обзор примечаний,  Next: Префикс server,  Up: Примечания

18.1 Что такое примечание?
==========================

Чтобы создавать примечания, запустите GDB с ключом '--annotate=2'.

   Примечания начинаются со знака новой строки, двух знаков 'control-z'
и имени примечания.  Если нет дополнительной информации, связанной с
примечанием, непосредственно за его именем следует знак новой строки.
Если дополнительная информация есть, за именем примечания следует
пропуск, дополнительная информация и знак новой строки.  Дополнительная
информация не может содержать знаков новой строки.

   Любой вывод, не начинающийся с новой строки и двух 'control-z',
означает буквальный вывод GDB. В настоящее время GDB не нужно выводить
два 'control-z' вслед за знаком новой строки, но если это понадобится,
примечания могут быть расширены 'экранирующим' примечанием, которое
означает вывод этих трех знаков.

   Вот простой пример запуска GDB с примечаниями:

     $ gdb --annotate=2
     GNU GDB 5.0
     Copyright 2000 Free Software Foundation, Inc.
     GDB is free software, covered by the GNU General Public License,
     and you are welcome to change it and/or distribute copies of it
     under certain conditions.
     Type "show copying" to see the conditions.
     There is absolutely no warranty for GDB.  Type "show warranty"
     for details.
     This GDB was configured as "sparc-sun-sunos4.1.3"

     ^Z^Zpre-prompt
     (gdb)
     ^Z^Zprompt
     quit

     ^Z^Zpost-prompt
     $

   Здесь 'quit' является для GDB вводом; остальное -- вывод GDB. Три
строки, начинающиеся с '^Z^Z' (где '^Z' означает знак 'control-z'), суть
примечания; остальное является выводом GDB.


File: gdb.html,  Node: Префикс server,  Next: Примечания к значениям,  Prev: Обзор примечаний,  Up: Примечания

18.2 Префикс server
===================

Чтобы подать команду GDB, не оказывая влияния на определенные аспекты
состояния, видимые для пользователей, начните ее с 'server '.  Это
означает, что данная команда не воздействует на историю команд, а также
не влияет на представление GDB о том, какую команду повторять, если в
пустой строке нажата клавиша <RET>.

   Префикс server не влияет на запись значений в историю значений; чтобы
напечатать значение, не занося его в историю, используйте команду
'output' вместо 'print'.


File: gdb.html,  Node: Примечания к значениям,  Next: Примечания к кадрам,  Prev: Префикс server,  Up: Примечания

18.3 Значения
=============

Когда значение выводится в различных контекстах, GDB использует
примечания, чтобы отделить его от окружающего текста.

   Если значение выводится с помощью 'print' и добавляется в историю
значений, примечание выглядит так:

     ^Z^Zvalue-history-begin НОМЕР-В-ИСТОРИИ ФЛАГИ-ЗНАЧЕНИЯ
     СТРОКА-ИСТОРИИ
     ^Z^Zvalue-history-value
     ЗНАЧЕНИЕ
     ^Z^Zvalue-history-end

где НОМЕР-В-ИСТОРИИ -- номер, который значение получает в истории,
СТРОКА-ИСТОРИИ -- строка, такая как '$5 = ', которая представляет
значение пользователю, ЗНАЧЕНИЕ является выводом, соответствующим самому
значению, а ФЛАГИ-ЗНАЧЕНИЯ -- '*' для значения, которое может быть
разыменовано, и '-', если нет.

   Если значение не добавляется в историю значений (это может быть или
неверное число с плавающей точкой, или оно выводится командой 'output'),
примечание выглядит похожим образом:

     ^Z^Zvalue-begin ФЛАГИ-ЗНАЧЕНИЯ
     ЗНАЧЕНИЕ
     ^Z^Zvalue-end

   Когда GDB выводит аргумент функции (например, в выводе команды
'backtrace'), он делает такие примечания:

     ^Z^Zarg-begin
     ИМЯ-АРГУМЕНТА
     ^Z^Zarg-name-end
     СТРОКА-РАЗДЕЛИТЕЛЬ
     ^Z^Zarg-value ФЛАГИ-ЗНАЧЕНИЯ
     ЗНАЧЕНИЕ
     ^Z^Zarg-end

где ИМЯ-АРГУМЕНТА есть имя аргумента, СТРОКА-РАЗДЕЛИТЕЛЬ -- текст (такой
как '='), который отделяет имя от значения для удобства пользователя, а
ФЛАГИ-ЗНАЧЕНИЯ и ЗНАЧЕНИЕ имеют такой же смысл, что и в примечании
'value-history-begin'.

   При выводе структуры, GDB делает следующие примечания:

     ^Z^Zfield-begin ФЛАГИ-ЗНАЧЕНИЯ
     ИМЯ-ПОЛЯ
     ^Z^Zfield-name-end
     СТРОКА-РАЗДЕЛИТЕЛЬ
     ^Z^Zfield-value
     ЗНАЧЕНИЕ
     ^Z^Zfield-end

где ИМЯ-ПОЛЯ есть имя поля, СТРОКА-РАЗДЕЛИТЕЛЬ -- текст (такой как '='),
который отделяет имя от значения для удобства пользователя, а
ФЛАГИ-ЗНАЧЕНИЯ и ЗНАЧЕНИЕ имеют тот же смысл, что и в примечании
'value-history-begin'.

   При выводе массива, GDB делает следующие примечания:

     ^Z^Zarray-section-begin ИНДЕКС-В-МАССИВЕ ФЛАГИ-ЗНАЧЕНИЯ

где ИНДЕКС-В-МАССИВЕ -- индекс первого аннотируемого элемента, а
ФЛАГИ-ЗНАЧЕНИЯ имеют такой же смысл, что и в примечании
'value-history-begin'.  За этим следует произвольное число элементов.
Элемент может быть либо одиночным

     ',' ПРОПУСК           ; опускается для первого элемента
     ЗНАЧЕНИЕ
     ^Z^Zelt

   либо повторяющимся

     ',' ПРОПУСК           ; опускается для первого элемента
     ЗНАЧЕНИЕ
     ^Z^Zelt-rep ЧИСЛО-ПОВТОРЕНИЙ
     СТРОКА-ПОВТОРЕНИЙ
     ^Z^Zelt-rep-end

   В обоих случаях ЗНАЧЕНИЕ является выводом значения элемента, а
ПРОПУСК может содержать пробелы, знаки табуляции и новой строки.  В
случае повторяющихся элементов, ЧИСЛО-ПОВТОРЕНИЙ представляет число
последовательных элементов массива, которые содержат данное значение, а
СТРОКА-ПОВТОРЕНИЙ является строкой, которая предназначена для
уведомления пользователя о том, что выводятся повторяющиеся элементы.

   После того как выведены все элементы массива, примечание к массиву
заканчивается так:

     ^Z^Zarray-section-end


File: gdb.html,  Node: Примечания к кадрам,  Next: Отображения,  Prev: Примечания к значениям,  Up: Примечания

18.4 Кадры
==========

Когда GDB печатает кадр, он делает к нему примечания.  Например, это
применяется к кадрам, выводимым при остановке GDB, к результатам вывода
таких команд, как 'backtrace' или 'up', и так далее.

   Примечания к кадру начинаются с

     ^Z^Zframe-begin УРОВЕНЬ АДРЕС
     СТРОКА-УРОВНЯ

где УРОВЕНЬ -- это номер кадра (0 для самого внутреннего кадра, другие
кадры имеют положительные номера), АДРЕС -- это адрес кода,
выполняющегося в данном кадре, а СТРОКА-УРОВНЯ -- строка,
предназначенная для передачи уровня пользователю.  АДРЕС имеет форму
'0x', за которым следует одна или более шестнадцатеричных цифр в нижнем
регистре (заметьте, что это не зависит от языка).  Кадр заканчивается
так:

     ^Z^Zframe-end

   Между этими комментариями находится основное тело кадра, которое
может состоять из

   *      ^Z^Zfunction-call
          СТРОКА-ВЫЗОВА-ФУНКЦИИ

     где СТРОКА-ВЫЗОВА-ФУНКЦИИ является текстом, предназначенным для
     уведомления пользователя, что этот кадр связан с вызовом функции,
     который GDB сделал в отлаживаемой программе.

   *      ^Z^Zsignal-handler-caller
          СТРОКА-ВЫЗОВА-ОБРАБОТЧИКА-СИГНАЛА

     где СТРОКА-ВЫЗОВА-ОБРАБОТЧИКА-СИГНАЛА -- текст, предназначенный для
     уведомления пользователя, что этот кадр связан с тем механизмом,
     который использовался операционной системой при вызове обработчика
     сигнала (это тот кадр, из которого произошел вызов обработчика, а
     не кадр для самого обработчика).

   * Обычный кадр.

     Это может (в зависимости от того, считается ли это информацией,
     интересной для пользователя) начинаться с

          ^Z^Zframe-address
          АДРЕС
          ^Z^Zframe-address-end
          СТРОКА-РАЗДЕЛИТЕЛЬ

     здесь АДРЕС -- это адрес, где происходит выполнение в кадре (тот же
     адрес, что и в примечании 'frame-begin', но выведенный в форме,
     предназначенной для пользователя -- в частности, синтаксис
     различается в зависимости от языка), а СТРОКА-РАЗДЕЛИТЕЛЬ является
     строкой, предназначенной для отделения этого адреса от того, что за
     ним следует для удобства пользователя.

     Затем идет

          ^Z^Zframe-function-name
          ИМЯ-ФУНКЦИИ
          ^Z^Zframe-args
          АРГУМЕНТЫ

     где ИМЯ-ФУНКЦИИ есть имя функции, выполняющейся в кадре, или '??',
     если оно не известно, а АРГУМЕНТЫ -- это аргументы к кадру, со
     скобками вокруг них (каждый аргумент аннотируется также
     индивидуально, *note Примечания к значениям::).

     Если доступна информация об исходных текстах, печатается ссылка на
     них:

          ^Z^Zframe-source-begin
          ВВОДНАЯ-ИСХОДНАЯ-СТРОКА
          ^Z^Zframe-source-file
          ИМЯ-ФАЙЛА
          ^Z^Zframe-source-file-end
          :
          ^Z^Zframe-source-line
          НОМЕР-СТРОКИ
          ^Z^Zframe-source-end

     где ВВОДНАЯ-ИСХОДНАЯ-СТРОКА отделяет ссылку от предшествующего ей
     текста, для удобства пользователя, ИМЯ-ФАЙЛА -- это имя исходного
     файла, НОМЕР-СТРОКИ -- номер строки в этом файле (первая строка
     имеет номер 1).

     Если GDB печатает некоторую информацию о том, откуда появился этот
     кадр (какая библиотека, какой сегмент загрузки и так далее; в
     настоящее время реализовано только на RS/6000), он делает такие
     примечания:

          ^Z^Zframe-where
          ИНФОРМАЦИЯ

     Затем, если исходный текст действительно должен быть отображен для
     этого кадра (это неверно, например, для вывода от команды
     'backtrace'), тогда выводится примечание 'source' (*note Примечания
     к исходному тексту::).  В отличие от большинства примечаний, этот
     вывод производится вместо обычного текста, который был бы
     напечатан, а не в дополнение к нему.


File: gdb.html,  Node: Отображения,  Next: Приглашения,  Prev: Примечания к кадрам,  Up: Примечания

18.5 Отображения
================

Когда GDB велят отобразить что-то с помощью команды 'display', к
результату отображения делаются примечания:

     ^Z^Zdisplay-begin
     НОМЕР
     ^Z^Zdisplay-number-end
     РАЗДЕЛИТЕЛЬ-НОМЕРОВ
     ^Z^Zdisplay-format
     ФОРМАТ
     ^Z^Zdisplay-expression
     ВЫРАЖЕНИЕ
     ^Z^Zdisplay-expression-end
     РАЗДЕЛИТЕЛЬ-ВЫРАЖЕНИЙ
     ^Z^Zdisplay-value
     ЗНАЧЕНИЕ
     ^Z^Zdisplay-end

здесь НОМЕР -- это номер отображения, РАЗДЕЛИТЕЛЬ-НОМЕРОВ предназначен
для отделения номеров от того, что следует затем для пользователя,
ФОРМАТ включает информацию о том, как отображается значение, такую как
размер, формат и так далее, ВЫРАЖЕНИЕ -- это отображаемое выражение,
РАЗДЕЛИТЕЛЬ-ВЫРАЖЕНИЙ предназначен для отделения выражения от следующего
за ним текста для пользователя, и ЗНАЧЕНИЕ -- это действительное
значение, которое отображается.


File: gdb.html,  Node: Приглашения,  Next: Ошибки,  Prev: Отображения,  Up: Примечания

18.6 Примечания ко вводу GDB
============================

Когда GDB выводит приглашение для ввода, он делает к этому примечания,
так что становится возможным узнать, когда посылать данные, когда
закончен вывод от данной команды, и так далее.

   Каждый из различных видов ввода имеет различный "тип ввода".  Каждый
тип ввода имеет три примечания: примечание 'pre-', обозначающее начало
каждого выводимого приглашения, простое примечание, обозначающее конец
приглашения, и затем примечание 'post-', обозначающее конец любого эхо,
которое может быть ассоциировано (а может и не быть) со вводом.
Например, характерной чертой типа ввода 'prompt' являются следующие
примечания:

     ^Z^Zpre-prompt
     ^Z^Zprompt
     ^Z^Zpost-prompt

   Существуют следующие типы ввода:

'prompt'
     Когда GDB запрашивает команду (главное приглашение GDB).

'commands'
     Когда GDB запрашивает набор команд, как в команде 'commands'.
     Примечания повторяются для каждой введенной команды.

'overload-choice'
     Когда GDB хочет, чтобы пользователь выбрал одну из нескольких
     перегруженных функций.

'query'
     Когда GDB хочет, чтобы пользователь подтвердил потенциально опасное
     действие.

'prompt-for-continue'
     Когда GDB запрашивает у пользователя нажатие ввода для продолжения.
     Замечание: не ожидайте, что это будет работать хорошо; используйте
     вместо этого 'set height 0' для отключения приглашений.  Это
     происходит потому, что при наличии примечаний подсчет строк
     происходит неверно.


File: gdb.html,  Node: Ошибки,  Next: Информация о точке останова,  Prev: Приглашения,  Up: Примечания

18.7 Ошибки
===========

     ^Z^Zquit

   Это примечание появляется непосредственно перед тем, как GDB отвечает
на прерывание.

     ^Z^Zerror

   Это примечание появляется сразу перед тем, как GDB отвечает на
ошибку.

   Примечания выхода и ошибки обозначают, что любое примечание, в
середине которого находился GDB, могут внезапно оборваться.  Например,
если за примечанием 'value-history-begin' следует 'error', то не нужно
ожидать соответствующий 'value-history-end'.  Однако, не следует также
ожидать, что его точно не будет; примечание об ошибке не обязательно
означает, что GDB немедленно возвращается в начало на самый верхний
уровень.

   Примечанию к ошибке или выходу может предшествовать

     ^Z^Zerror-begin

   Весь вывод между этим и примечанием к ошибке или выходу является
сообщением об ошибке.

   Пока примечаний к предупреждающим сообщениям не делается.


File: gdb.html,  Node: Информация о точке останова,  Next: Недостоверность,  Prev: Ошибки,  Up: Примечания

18.8 Информация о точке останова
================================

К выводу, производимому командой 'info breakpoints', делаются следующие
примечания:

     ^Z^Zbreakpoints-headers
     ЭЛЕМЕНТ-ЗАГОЛОВКА
     ^Z^Zbreakpoints-table

где ЭЛЕМЕНТ-ЗАГОЛОВКА имеет тот же синтаксис, что и элемент (смотрите
ниже), но вместо данных он содержит строки, которые предназначены для
разъяснения пользователю значений каждого поля.  Затем следует
произвольное число элементов.  Если поле не подходит к этому элементу,
оно опускается.  Поля могут содержать завершающие пропуски.  Каждое поле
состоит из:

     ^Z^Zrecord
     ^Z^Zfield 0
     НОМЕР
     ^Z^Zfield 1
     ТИП
     ^Z^Zfield 2
     ПОЛОЖЕНИЕ
     ^Z^Zfield 3
     ВКЛЮЧЕНА
     ^Z^Zfield 4
     АДРЕС
     ^Z^Zfield 5
     ЧТО
     ^Z^Zfield 6
     КАДР
     ^Z^Zfield 7
     УСЛОВИЕ
     ^Z^Zfield 8
     СЧЕТЧИК-ИГНОРИРОВАНИЙ
     ^Z^Zfield 9
     КОМАНДЫ

   Заметьте, что АДРЕС предназначен для использования пользователем --
синтаксис различается в зависимости от языка.

   Вывод заканчивается так:

     ^Z^Zbreakpoints-table-end


File: gdb.html,  Node: Недостоверность,  Next: Примечания к выполнению,  Prev: Информация о точке останова,  Up: Примечания

18.9 Сообщения о недостоверности
================================

Следующие примечания говорят о том, что определенные куски информации,
описывающие состояние, могли измениться.

'^Z^Zframes-invalid'

     Кадры (например, вывод команды 'backtrace') могли измениться.

'^Z^Zbreakpoints-invalid'

     Точки останова могли измениться.  Например, пользователь только что
     добавил или удалил точку останова.


File: gdb.html,  Node: Примечания к выполнению,  Next: Примечания к исходному тексту,  Prev: Недостоверность,  Up: Примечания

18.10 Выполнение программы
==========================

Когда программа начинает выполняться вследствие команды GDB, такой как
'step' или 'continue', выводится

     ^Z^Zstarting

   Когда программа останавливается, выводится

     ^Z^Zstopped

   Перед примечанием 'stopped', множество примечаний описывают, как
программа остановилась.

'^Z^Zexited КОД-ВЫХОДА'
     Программа завершилась, и КОД-ВЫХОДА является кодом выхода (ноль при
     успешном завершении, в противном случае не ноль).

'^Z^Zsignalled'
     Программа завершилась по сигналу.  После '^Z^Zsignalled',
     примечания продолжаются:

          ВСТУПИТЕЛЬНЫЙ-ТЕКСТ
          ^Z^Zsignal-name
          ИМЯ
          ^Z^Zsignal-name-end
          ТЕКСТ-В-СЕРЕДИНЕ
          ^Z^Zsignal-string
          СТРОКА
          ^Z^Zsignal-string-end
          ЗАКЛЮЧИТЕЛЬНЫЙ-ТЕКСТ

     где ИМЯ является именем сигнала, таким как 'SIGILL' или 'SIGSEGV',
     а СТРОКА представляет объяснение сигнала, например 'Illegal
     Instruction' или 'Segmentation fault'.  ВСТУПИТЕЛЬНЫЙ-ТЕКСТ,
     ТЕКСТ-В-СЕРЕДИНЕ и ЗАКЛЮЧИТЕЛЬНЫЙ-ТЕКСТ используются для удобства
     пользователя и не имеют определенного формата.

'^Z^Zsignal'
     Синтаксис этого примечания такой же, как для 'signalled', но GDB
     сообщает, что программа лишь получила сигнал, а не то, что она
     остановилась из-за него.

'^Z^Zbreakpoint НОМЕР'
     Программа достигла точки останова с номером НОМЕР.

'^Z^Zwatchpoint НОМЕР'
     Программа достигла точки наблюдения с номером НОМЕР.


File: gdb.html,  Node: Примечания к исходному тексту,  Next: Дальнейшие планы,  Prev: Примечания к выполнению,  Up: Примечания

18.11 Вывод исходного текста
============================

Следующие примечания используются вместо вывода исходного текста:

     ^Z^Zsource ИМЯ-ФАЙЛА:СТРОКА:ЗНАК:СЕРЕДИНА:АДРЕС

где ИМЯ-ФАЙЛА указывает абсолютное имя файла, СТРОКА -- это номер строки
в этом файле (первая строка имеет номер 1), ЗНАК -- позиция знака в
файле (первый знак в исходном файле имеет номер 0) (для большинства
отладочных форматов это будет обязательно указывать на начало строки),
СЕРЕДИНА есть 'middle', если АДРЕС находится в середине строки, или
'beg', если АДРЕС находится в начале строки, а АДРЕС является адресом в
целевой программе, ассоциированным с выводимым исходным текстом.  АДРЕС
записывается в форме '0x', за которым следует одна или несколько
шестнадцатеричных цифр в нижнем регистре (заметьте, что это не зависит
от языка).


File: gdb.html,  Node: Дальнейшие планы,  Prev: Примечания к исходному тексту,  Up: Примечания

18.12 Примечания, которые могут понадобиться в будущем
======================================================

    - target-invalid
      цель могла измениться (регистры, содержимое памяти или статус
      выполнения).  Для эффективности выполнения, мы можем захотеть
      определять 'register-invalid' и 'all-register-invalid' с большей
      точностью

    - систематические примечания к параметрам set/show (включая
      сообщения о недостоверности).

    - аналогично, 'info' возвращает список кандидатов на сообщение о
      недостоверности.


File: gdb.html,  Node: GDB/MI,  Next: Ошибки в GDB,  Prev: Примечания,  Up: Top

19 Интерфейс GDB/MI
*******************

* Menu:

* Синтаксис команд GDB/MI::
* Совместимость GDB/MI с CLI::
* Выходные записи GDB/MI::
* Формат описания команд GDB/MI::
* Команды GDB/MI для таблицы точек останова::
* Управление данными GDB/MI::
* Управление программой GDB/MI::
* Разные команды GDB/MI::
* Управление стеком GDB/MI::
* Запросы GDB/MI о символах::
* Управление целью GDB/MI::
* Команды GDB/MI для нитей::
* Команды GDB/MI для точек трассировки::
* Изменяемые объекты GDB/MI::

Назначение и цель
=================

GDB/MI -- это построчный машинно-ориентированный текстовый интерфейс к
GDB. Он предназначен специально для поддержки разработки систем, которые
используют отладчик лишь как одну маленькую компоненту большой системы.

   Эта глава является спецификацией интерфейса GDB/MI.  Она написана в
форме справочного руководства.

   Заметьте, что GDB/MI все еще находится в стадии разработки, так что
некоторые описанные ниже возможности являются неполными и могут быть
изменены.

Система обозначений и терминология
==================================

Эта глава использует следующую систему обозначений:

   * '|' разделяет две альтернативы.

   * '[ НЕЧТО ]' указывает, что НЕЧТО является необязательным: оно может
     быть задано, а может и нет.

   * '( ГРУППА )*' означает, что ГРУППА в скобках может повторяться ноль
     и более раз.

   * '( ГРУППА )+' означает, что ГРУППА в скобках может повторяться один
     и более раз.

   * '"СТРОКА"' обозначает текст СТРОКА.

Выражения признательности
=========================

В алфавитном порядке: Елена Заннони, Эндрю Кагни, Фернандо Нассер и Стан
Шебс.

* Menu:

* Синтаксис команд GDB/MI::
* Совместимость GDB/MI с CLI::
* Выходные записи GDB/MI::
* Формат описания команд GDB/MI::
* Команды GDB/MI для таблицы точек останова::
* Управление данными GDB/MI::
* Управление программой GDB/MI::
* Разные команды GDB/MI::
* Управление стеком GDB/MI::
* Запросы GDB/MI о символах::
* Управление целью GDB/MI::
* Команды GDB/MI для нитей::
* Команды GDB/MI для точек трассировки::
* Изменяемые объекты GDB/MI::


File: gdb.html,  Node: Синтаксис команд GDB/MI,  Next: Совместимость GDB/MI с CLI,  Up: GDB/MI

19.1 Синтаксис команд GDB/MI
============================

* Menu:

* Входной синтаксис GDB/MI::
* Выходной синтаксис GDB/MI::
* Простые примеры GDB/MI::


File: gdb.html,  Node: Входной синтаксис GDB/MI,  Next: Выходной синтаксис GDB/MI,  Up: Синтаксис команд GDB/MI

19.1.1 Входной синтаксис GDB/MI
-------------------------------

'КОМАНДА ==>'
     'КОМАНДА-CLI | КОМАНДА-MI'

'КОМАНДА-CLI ==>'
     '[ ЛЕКСЕМА ] КОМАНДА-CLI NL', где КОМАНДА-CLI есть любая
     существующая команда GDB CLI.

'КОМАНДА-MI ==>'
     '[ ЛЕКСЕМА ] "-" ДЕЙСТВИЕ ( " " КЛЮЧ )* [ " --" ] ( " " ПАРАМЕТР )*
     NL'

'ЛЕКСЕМА ==>'
     "любая последовательность цифр"

'КЛЮЧ ==>'
     '"-" ПАРАМЕТР [ " " ПАРАМЕТР ]'

'ПАРАМЕТР ==>'
     'НЕПУСТАЯ-ПОСЛЕДОВАТЕЛЬНОСТЬ | СТРОКА-СИ'

'ДЕЙСТВИЕ ==>'
     _любое из действий, описанных в этой главе_

'НЕПУСТАЯ-ПОСЛЕДОВАТЕЛЬНОСТЬ ==>'
     _все что угодно, не содержащее специальных знаков, таких как "-",
     NL, """ и, конечно, " "_

'СТРОКА-СИ ==>'
     '""" СОДЕРЖИМОЕ-СЕМИБИТНОЙ-СТРОКИ-ISO-СИ """'

'NL ==>'
     'CR | CR-LF'

Замечания:

   * Команды CLI все еще обрабатываются интерпретатором MI; их вывод
     описан ниже.

   * 'ЛЕКСЕМА', если присутствует, передается назад, когда выполнение
     команды завершается.

   * Некоторые команды MI допускают необязательные аргументы как часть
     списка параметров.  Каждый ключ идентифицируется предшествующей ему
     чертой '-', и за ним может следовать в качестве параметра
     необязательный аргумент.  Ключи появляются в начале списка
     параметров и могут быть отделены от обычных параметров при помощи
     '--' (это полезно, когда некоторые параметры начинаются с черты).

   Прагматические соображения:

   * Мы хотим получить простой доступ к существующему синтаксису CLI
     (для отладки).

   * Мы хотим, чтобы работа MI была легко заметна.


File: gdb.html,  Node: Выходной синтаксис GDB/MI,  Next: Простые примеры GDB/MI,  Prev: Входной синтаксис GDB/MI,  Up: Синтаксис команд GDB/MI

19.1.2 Выходной синтаксис GDB/MI
--------------------------------

Вывод GDB/MI состоит из нуля или более внеочередных записей, за которыми
может следовать одна результирующая запись.  Эта запись относится к
самой последней команде.  Последовательность выводимых записей
завершается '(gdb)'.

   Если входная команда начиналась с префикса 'ЛЕКСЕМА', то
соответствующий вывод для этой команды также будет начинаться с того же
префикса ЛЕКСЕМА.

'ВЫВОД ==>'
     '( ВНЕОЧЕРЕДНАЯ-ЗАПИСЬ )* [ РЕЗУЛЬТИРУЮЩАЯ-ЗАПИСЬ ] "(gdb)" NL'

'РЕЗУЛЬТИРУЮЩАЯ-ЗАПИСЬ ==>'
     ' [ ЛЕКСЕМА ] "^" РЕЗУЛЬТИРУЮЩИЙ-КЛАСС ( "," РЕЗУЛЬТАТ )* NL'

'ВНЕОЧЕРЕДНАЯ-ЗАПИСЬ ==>'
     'АСИНХР-ЗАПИСЬ | ПОТОЧН-ЗАПИСЬ'

'АСИНХР-ЗАПИСЬ ==>'
     'АСИНХР-ВЫВОД-ВЫПОЛН | АСИНХР-ВЫВОД-СТАТУСА | АСИНХР-ВЫВОД-УВЕДОМЛ'

'АСИНХР-ВЫВОД-ВЫПОЛН ==>'
     '[ ЛЕКСЕМА ] "*" АСИНХР-ВЫВОД'

'АСИНХР-ВЫВОД-СТАТУСА ==>'
     '[ ЛЕКСЕМА ] "+" АСИНХР-ВЫВОД'

'АСИНХР-ВЫВОД-УВЕДОМЛ ==>'
     '[ ЛЕКСЕМА ] "=" АСИНХР-ВЫВОД'

'АСИНХР-ВЫВОД ==>'
     'АСИНХР-КЛАСС ( "," РЕЗУЛЬТАТ )* NL'

'РЕЗУЛЬТ-КЛАСС ==>'
     '"done" | "running" | "connected" | "error" | "exit"'

'АСИНХР-КЛАСС ==>'
     '"stopped" | ДРУГОЕ' (где ДРУГОЕ будет добавлено по необходимости
     -- это все еще находится в стадии разработки).

'РЕЗУЛЬТАТ ==>'
     ' ПЕРЕМЕННАЯ "=" ЗНАЧЕНИЕ'

'ПЕРЕМЕННАЯ ==>'
     ' СТРОКА '

'ЗНАЧЕНИЕ ==>'
     ' КОНСТАНТА | НАБОР | СПИСОК '

'КОНСТАНТА ==>'
     'СТРОКА-СИ'

'НАБОР ==>'
     ' "{}" | "{" РЕЗУЛЬТАТ ( "," РЕЗУЛЬТАТ )* "}" '

'СПИСОК ==>'
     ' "[]" | "[" ЗНАЧЕНИЕ ( "," ЗНАЧЕНИЕ )* "]" | "[" РЕЗУЛЬТАТ ( ","
     РЕЗУЛЬТАТ )* "]" '

'ПОТОЧН-ЗАПИСЬ ==>'
     'КОНСОЛЬН-ПОТОЧН-ВЫВОД | ЦЕЛЕВ-ПОТОЧН-ВЫВОД | ЖУРН-ПОТОЧН-ВЫВОД'

'КОНСОЛЬН-ПОТОЧН-ВЫВОД ==>'
     '"~" СТРОКА-СИ'

'ЦЕЛЕВ-ПОТОЧН-ВЫВОД ==>'
     '"@" СТРОКА-СИ'

'ЖУРН-ПОТОЧН-ВЫВОД ==>'
     '"&" СТРОКА-СИ'

'NL ==>'
     'CR | CR-LF'

'ЛЕКСЕМА ==>'
     _любая последовательность цифр_.

Замечания:

   * Все выходные последовательности заканчиваются одной строкой,
     содержащей точку.

   * 'ЛЕКСЕМА' берется из соответствующего запроса.  Если выполнение
     команды прерывается командой '-exec-interrupt', ЛЕКСЕМА,
     ассоциированная с сообщением '*stopped', является лексемой исходной
     выполняемой команды, а не лексемой команды прерывания.

   * АСИНХР-ВЫВОД-СТАТУСА содержит последующую информацию состояния о
     выполнении медленной операции.  Она может быть отброшена.  Весь
     вывод состояния начинается с префикса '+'.

   * АСИНХР-ВЫВОД-ВЫПОЛН содержит асинхронное изменения состояния на
     цели (остановлена, запущена, исчезла).  Весь асинхронный вывод
     начинается с префикса '*'.

   * АСИНХР-ВЫВОД-УВЕДОМЛ содержит сопровождающую информацию, которую
     должен обработать клиент (например, информацию о новой точке
     останова).  Весь уведомительный вывод начинается с префикса '='.

   * КОНСОЛЬН-ПОТОЧН-ВЫВОД является выводом, который должен быть
     отображен на консоли без изменений.  Он является текстовым ответом
     на команду CLI. Весь консольный вывод начинается с префикса '~'.

   * ЦЕЛЕВ-ПОТОЧН-ВЫВОД является выводом, произведенным целевой
     программой.  Весь целевой вывод начинается с префикса '@'.

   * ЖУРН-ПОТОЧН-ВЫВОД является выходным текстом, происходящим от
     внутренней реализации GDB, например, сообщения, которые должны быть
     отображены как часть журнала ошибок.  Весь журнальный вывод
     начинается с префикса '&'.

   * Новые команды GDB/MI должны выводить только СПИСКИ, содержащие
     ЗНАЧЕНИЯ.

   *Note Поточные записи GDB/MI: Поточные записи GDB/MI, для более
подробной информации о различных выводимых записях.


File: gdb.html,  Node: Простые примеры GDB/MI,  Prev: Выходной синтаксис GDB/MI,  Up: Синтаксис команд GDB/MI

19.1.3 Простые примеры взаимодействия с GDB/MI
----------------------------------------------

Этот подраздел представляет несколько простых примеров взаимодействия с
использованием интерфейса GDB/MI.  В этих примерах, '->' означает, что
следующая строка передается GDB/MI в качестве ввода, а '<-' означает
вывод, полученный от GDB/MI.

Останов цели
............

Вот пример останова подчиненного процесса:

     -> -stop
     <- (gdb)

и затем:

     <- *stop,reason="stop",address="0x123",source="a.c:123"
     <- (gdb)

Простая команда CLI
...................

Вот пример простой команды CLI, передаваемой ему через GDB/MI.

     -> print 1+2
     <- ~3\n
     <- (gdb)

Команда с побочными эффектами
.............................

     -> -symbol-file xyz.exe
     <- *breakpoint,nr="3",address="0x123",source="a.c:123"
     <- (gdb)

Плохая команда
..............

Вот что происходит, если вы передаете несуществующую команду:

     -> -rubbish
     <- error,"Rubbish not found"
     <- (gdb)


File: gdb.html,  Node: Совместимость GDB/MI с CLI,  Next: Выходные записи GDB/MI,  Prev: Синтаксис команд GDB/MI,  Up: GDB/MI

19.2 Совместимость GDB/MI с CLI
===============================

Чтобы помочь пользователям, знакомым с существующим в GDB интерфейсом
CLI, GDB/MI принимает существующие команды CLI. Как определено
синтаксисом, такие команды могут быть непосредственно введены в
интерфейс GDB/MI, и GDB будет отвечать.

   Этот механизм предоставляется для помощи разработчикам клиентов
GDB/MI, а не как надежный интерфейс к CLI. Так как команда
интерпретируется в среде, которая подразумевает поведение GDB/MI, точные
результаты таких команд в конечном итоге скорее всего станут
неудобоваримой смесью вывода GDB/MI и CLI.


File: gdb.html,  Node: Выходные записи GDB/MI,  Next: Формат описания команд GDB/MI,  Prev: Совместимость GDB/MI с CLI,  Up: GDB/MI

19.3 Выходные записи GDB/MI
===========================

* Menu:

* Результирующие записи GDB/MI::
* Поточные записи GDB/MI::
* Внеочередные записи GDB/MI::


File: gdb.html,  Node: Результирующие записи GDB/MI,  Next: Поточные записи GDB/MI,  Up: Выходные записи GDB/MI

19.3.1 Результирующие записи GDB/MI
-----------------------------------

В дополнение к множеству внеочередных уведомлений, ответ на команду
GDB/MI включает один из следующих указателей результата:

'"^done" [ "," РЕЗУЛЬТАТЫ ]'
     Синхронная операция прошла успешно, возвращаемыми значениями
     являются 'РЕЗУЛЬТАТЫ'.

'"^running"'
     Асинхронная операция была успешно начата.  Цель выполняется.

'"^error" "," СТРОКА-СИ'
     Операция завершилась с ошибкой.  'СТРОКА-СИ' содержит
     соответствующее сообщение об ошибке.


File: gdb.html,  Node: Поточные записи GDB/MI,  Next: Внеочередные записи GDB/MI,  Prev: Результирующие записи GDB/MI,  Up: Выходные записи GDB/MI

19.3.2 Поточные записи GDB/MI
-----------------------------

GDB хранит несколько выходных потоков: консоль, цель и журнал.  Вывод,
предназначенный для этих потоков, пропускается через интерфейс GDB/MI
при помощи "поточных записей".

   Каждая поточная запись начинается с уникального "префиксного знака",
который идентифицирует свой поток (*note Выходной синтаксис GDB/MI:
Выходной синтаксис GDB/MI.). Помимо префикса, каждая поточная запись
содержит 'СТРОКУ-ВЫВОД'.  Это либо простой текст (с подразумеваемым
знаком новой строки), или Си-строка в кавычках (которая не содержит
подразумеваемого знака новой строки).

'"~" СТРОКА-ВЫВОД'
     Консольный поток вывода содержит текст, который должен быть
     отображен в консольном окне CLI. Он содержит текстовые ответы на
     команды CLI.

'"@" СТРОКА-ВЫВОД'
     Целевой поток вывода содержит произвольный текстовый вывод от
     выполняемой цели.

'"&" СТРОКА-ВЫВОД'
     Журнальный поток содержит отладочные сообщения, которые создает сам
     GDB.


File: gdb.html,  Node: Внеочередные записи GDB/MI,  Prev: Поточные записи GDB/MI,  Up: Выходные записи GDB/MI

19.3.3 Внеочередные записи GDB/MI
---------------------------------

"Внеочередные" записи используются для уведомления клиента GDB/MI о
произошедших дополнительных изменениях.  Эти изменения могут либо
исходить от GDB/MI (например, измененная точка останова), либо быть
результатом действий цели (например, цель остановилась).

   Ниже приведен предварительный список возможных внеочередных записей.

'"*" "stop"'


File: gdb.html,  Node: Формат описания команд GDB/MI,  Next: Команды GDB/MI для таблицы точек останова,  Prev: Выходные записи GDB/MI,  Up: GDB/MI

19.4 Формат описания команд GDB/MI
==================================

Оставшиеся разделы описывают блоки команд.  Каждый блок команд
схематично аналогичен этому разделу.

   Заметьте, что разбиения строк в примерах присутствуют только для
удобства чтения.  Они не появляются в реальном выводе.  Учтите также,
что команды с недоступными примерами (Н.П.) еще не реализованы.

Мотивация
---------

Мотивация для этого набора команд.

Введение
--------

Краткое введение в этот набор команд в целом.

Команды
-------

Для каждой команды в блоке, описано следующее:

Краткое описание
................

      -command АРГ...

Команда GDB
...........

Соответствующая команда CLI GDB.

Результат
.........

Внеочередные сообщения
......................

Примечания
..........

Пример
......


File: gdb.html,  Node: Команды GDB/MI для таблицы точек останова,  Next: Управление данными GDB/MI,  Prev: Формат описания команд GDB/MI,  Up: GDB/MI

19.5 Команды GDB/MI для таблицы точек останова
==============================================

Этот раздел описывает команды GDB/MI для управления точками останова.

Команда '-break-after'
----------------------

Краткое описание
................

      -break-after НОМЕР ЧИСЛО

   Точка останова с номером НОМЕР не срабатывает, пока она не будет
достигнута ЧИСЛО раз.  Чтобы увидеть, как это отражается на выводе
команды '-break-list', смотрите ниже описание команды '-break-list'.

Команда GDB
...........

Соответствующей командой GDB является 'ignore'.

Пример
......

     (gdb)
     -break-insert main
     ^done,bkpt={number="1",addr="0x000100d0",file="hello.c",line="5"}
     (gdb)
     -break-after 1 3
     ~
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0",
     ignore="3"}]}
     (gdb)

Команда '-break-condition'
--------------------------

Краткое описание
................

      -break-condition НОМЕР ВЫРАЖ

   Точка останова НОМЕР остановит программу, только если условие ВЫРАЖ
истинно.  Условие становится частью вывода '-break-list' (смотрите ниже
описание команды '-break-list').

Команда GDB
...........

Соответствующей командой GDB является 'condition'.

Пример
......

     (gdb)
     -break-condition 1 1
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",cond="1",
     times="0",ignore="3"}]}
     (gdb)

Команда '-break-delete'
-----------------------

Краткое описание
................

      -break-delete ( ТОЧКА-ОСТАНОВА )+

   Удалить точки останова, чьи номера указаны в списке аргументов.  Это
очевидным образом отражается на списке точек останова.

Команда GDB
...........

Соответствующей командой GDB является 'delete'.

Пример
......

     (gdb)
     -break-delete 1
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="0",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[]}
     (gdb)

Команда '-break-disable'
------------------------

Краткое описание
................

      -break-disable ( ТОЧКА-ОСТАНОВА )+

   Отключить перечисленные ТОЧКИ-ОСТАНОВА.  Для указанных ТОЧЕК-ОСТАНОВА
поле 'enabled' в списке точек останова теперь установлено в 'n'.

Команда GDB
...........

Соответствующей командой GDB является 'disable'.

Пример
......

     (gdb)
     -break-disable 2
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="2",type="breakpoint",disp="keep",enabled="n",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0"}]}
     (gdb)

Команда '-break-enable'
-----------------------

Краткое описание
................

      -break-enable ( ТОЧКА-ОСТАНОВА )+

   Включить (ранее отключенные) ТОЧКИ-ОСТАНОВА.

Команда GDB
...........

Соответствующей командой GDB является 'enable'.

Пример
......

     (gdb)
     -break-enable 2
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="2",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0"}]}
     (gdb)

Команда '-break-info'
---------------------

Краткое описание
................

      -break-info ТОЧКА-ОСТАНОВА

   Получить информацию об одной точке останова.

Команда GDB
...........

Соответствующей командой GDB является 'info break ТОЧКА-ОСТАНОВА'.

Пример
......

Н.П.

Команда '-break-insert'
-----------------------

Краткое описание
................

      -break-insert [ -t ] [ -h ] [ -r ]
         [ -c УСЛОВИЕ ] [ -i СЧЕТЧИК-ИГНОРИРОВАНИЙ ]
         [ -p НИТЬ ] [ СТРОКА | АДРЕС ]

СТРОКА, если указана, может быть одной из:

   * функция
   * имя-файла:номер-строки
   * имя-файла:функция
   * *адрес

   Вот возможные необязательные параметры этой команды:

'-t'
     Вставить временную точку останова.
'-h'
     Вставить аппаратную точку останова.
'-c УСЛОВИЕ'
     Сделать точку останова условной с заданным УСЛОВИЕМ.
'-i СЧЕТЧИК-ИГНОРИРОВАНИЙ'
     Инициализировать СЧЕТЧИК-ИГНОРИРОВАНИЙ.
'-r'
     Вставить обычную точку останова во всех функциях, чьи имена
     удовлетворяют данному регулярному выражению.  Другие флаги к
     регулярному выражению неприменимы.

Результат
.........

Результат имеет форму:

      ^done,bkptno="НОМЕР",func="ИМЯ-ФУНКЦИИ",
       file="ИМЯ-ФАЙЛА",line="НОМ-СТРОКИ"

где НОМЕР является номером этой точки останова в GDB, ИМЯ-ФУНКЦИИ -- имя
функции, в которой была вставлена точка останова, ИМЯ-ФАЙЛА -- имя
исходного файла, в котором находится эта функция, а НОМ-СТРОКИ является
номером строки исходного текста в этом файле.

   Замечание: этот формат может изменяться.

Команда GDB
...........

Соответствующими командами GDB являются 'break', 'tbreak', 'hbreak',
'thbreak' и 'rbreak'.

Пример
......

     (gdb)
     -break-insert main
     ^done,bkpt={number="1",addr="0x0001072c",file="recursive2.c",line="4"}
     (gdb)
     -break-insert -t foo
     ^done,bkpt={number="2",addr="0x00010774",file="recursive2.c",line="11"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x0001072c", func="main",file="recursive2.c",line="4",times="0"},
     bkpt={number="2",type="breakpoint",disp="del",enabled="y",
     addr="0x00010774",func="foo",file="recursive2.c",line="11",times="0"}]}
     (gdb)
     -break-insert -r foo.*
     ~int foo(int, int);
     ^done,bkpt={number="3",addr="0x00010774",file="recursive2.c",line="11"}
     (gdb)

Команда '-break-list'
---------------------

Краткое описание
................

      -break-list

   Отображает список установленных точек останова, показывая следующие
поля:

'Number'
     номер точки останова
'Type'
     тип точки останова: 'breakpoint' или 'watchpoint'
'Disposition'
     эта точка останова должна быть удалена или отключена при
     срабатывании: 'keep' или 'nokeep'
'Enabled'
     включена точка останова или нет: 'y' или 'n'
'Address'
     местоположение в памяти, где установлена точка останова
'What'
     логическое положение точки останова, выраженное именем функции,
     именем файла, номером строки
'Times'
     Число раз, которое точка останова срабатывала

   Если точек останова или наблюдения нет, поле 'body' 'BreakpointTable'
является пустым списком.

Команда GDB
...........

Соответствующей командой GDB является 'info break'.

Пример
......

     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0"},
     bkpt={number="2",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010114",func="foo",file="hello.c",line="13",times="0"}]}
     (gdb)

   Вот пример результата, когда точек останова нет:

     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="0",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[]}
     (gdb)

Команда '-break-watch'
----------------------

Краткое описание
................

      -break-watch [ -a | -r ]

   Создать точку наблюдения.  С ключом '-a' будет создана точка
наблюдения за "доступом", то есть такая точка наблюдения, которая
срабатывает либо при чтении, либо при записи в определенное
местоположение в памяти.  С ключом '-r' созданная точка наблюдения будет
точкой наблюдения за "чтением", то есть она будет срабатывать, только
когда к определенному местоположению в памяти осуществляется доступ на
чтение.  Без этих ключей будет создана обычная точка наблюдения, то есть
она будет срабатывать, когда к местоположению в памяти осуществляется
доступ для записи.  *Note Установка точек наблюдения: Установка точек
наблюдения.

   Заметьте, что '-break-list' выдаст единый список установленных точек
наблюдения и останова.

Комада GDB
..........

Соответствующими командами GDB являются 'watch', 'awatch' и 'rwatch'.

Пример
......

Установка точки наблюдения за переменной в функции 'main':

     (gdb)
     -break-watch x
     ^done,wpt={number="2",exp="x"}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-trigger",wpt={number="2",exp="x"},
     value={old="-268439212",new="55"},
     frame={func="main",args=[],file="recursive2.c",line="5"}
     (gdb)

   Установка точки наблюдения за локальной переменной функции.  GDB
дважды остановит выполнение программы: сначала при изменении значения
переменной, затем при выходе точки наблюдения из области видимости.

     (gdb)
     -break-watch C
     ^done,wpt={number="5",exp="C"}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-trigger",
     wpt={number="5",exp="C"},value={old="-276895068",new="3"},
     frame={func="callee4",args=[],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="13"}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-scope",wpnum="5",
     frame={func="callee3",args=[{name="strarg",
     value="0x11940 \"A string argument.\""}],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
     (gdb)

   Получение списка точек останова и наблюдения в разных местах
выполнения программы.  Заметьте, что как только точка наблюдения выходит
из области видимости, она удаляется.

     (gdb)
     -break-watch C
     ^done,wpt={number="2",exp="C"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"},
     bkpt={number="2",type="watchpoint",disp="keep",
     enabled="y",addr="",what="C",times="0"}]}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-trigger",wpt={number="2",exp="C"},
     value={old="-276895068",new="3"},
     frame={func="callee4",args=[],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="13"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"},
     bkpt={number="2",type="watchpoint",disp="keep",
     enabled="y",addr="",what="C",times="-5"}]}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-scope",wpnum="2",
     frame={func="callee3",args=[{name="strarg",
     value="0x11940 \"A string argument.\""}],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"}]}
     (gdb)


File: gdb.html,  Node: Управление данными GDB/MI,  Next: Управление программой GDB/MI,  Prev: Команды GDB/MI для таблицы точек останова,  Up: GDB/MI

19.6 Управление данными GDB/MI
==============================

Этот раздел описывает команды GDB/MI для управления данными:
исследование памяти и регистров, вычисление выражений и так далее.

Команда '-data-disassemble'
---------------------------

Краткое описание
................

      -data-disassemble
         [ -s НАЧ-АДР -e КОН-АДР ]
       | [ -f ИМЯ-ФАЙЛА -l НОМ-СТРОКИ [ -n СТ ] ]
       -- РЕЖИМ

Где:

'НАЧ-АДР'
     начальный адрес (или '$pc')
'КОН-АДР'
     конечный адрес
'ИМЯ-ФАЙЛА'
     имя файла для дисассемблирования
'НОМ-СТРОКИ'
     номер строки, в районе которой проводить дисассемблирование
'СТ'
     число строк дисассемблирования, которое необходимо произвести.
     Если равно -1 и КОН-АДР не указан, то будет дисассемблирована целая
     функция.  Если КОН-АДР указан и не равен нулю, и СТ меньше, чем
     количество строк дисассемблирования между НАЧ-АДР и КОН-АДР,
     отображаются только СТ строк.  Если СТ больше, чем число строк
     между НАЧ-АДР и КОН-АДР, отображаются только строки до КОН-АДР.
'РЕЖИМ'
     либо 0 (означает только результат дисассемблирования), либо 1
     (означает смесь исходного текста и результата дисассемблирования).

Результат
.........

Вывод для каждой инструкции состоит из четырех полей:

   * Адрес
   * Имя-Функции
   * Смещение
   * Инструкция

   Заметьте, что то, что включено в поле инструкции, не обрабатывается
непосредственно GDB/MI, то есть изменить его формат невозможно.

Команда GDB
...........

Непосредственного отображения этой команды в CLI нет.

Пример
......

Дисассемблирование от текущего значения '$pc' до '$pc + 20':

     (gdb)
     -data-disassemble -s $pc -e "$pc + 20" -- 0
     ^done,
     asm_insns=[
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov  2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi  %hi(0x11800), %o2"},
     {address="0x000107c8",func-name="main",offset="12",
     inst="or  %o2, 0x140, %o1\t! 0x11940 <_lib_version+8>"},
     {address="0x000107cc",func-name="main",offset="16",
     inst="sethi  %hi(0x11800), %o2"},
     {address="0x000107d0",func-name="main",offset="20",
     inst="or  %o2, 0x168, %o4\t! 0x11968 <_lib_version+48>"}]
     (gdb)

   Дисассемблирование всей функции 'main'.  Строка 32 является частью
'main'.

     -data-disassemble -f basics.c -l 32 -- 0
     ^done,asm_insns=[
     {address="0x000107bc",func-name="main",offset="0",
     inst="save  %sp, -112, %sp"},
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov   2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi %hi(0x11800), %o2"},
     [...]
     {address="0x0001081c",func-name="main",offset="96",inst="ret "},
     {address="0x00010820",func-name="main",offset="100",inst="restore "}]
     (gdb)

   Дисассемблирование 3 инструкций от начала 'main':

     (gdb)
     -data-disassemble -f basics.c -l 32 -n 3 -- 0
     ^done,asm_insns=[
     {address="0x000107bc",func-name="main",offset="0",
     inst="save  %sp, -112, %sp"},
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov  2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi  %hi(0x11800), %o2"}]
     (gdb)

   Дисассемблирование 3 инструкций от начала 'main' в смешаном режиме:

     (gdb)
     -data-disassemble -f basics.c -l 32 -n 3 -- 1
     ^done,asm_insns=[
     src_and_asm_line={line="31",
     file="/kwikemart/marge/ezannoni/flathead-dev/devo/gdb/ \
       testsuite/gdb.mi/basics.c",line_asm_insn=[
     {address="0x000107bc",func-name="main",offset="0",
     inst="save  %sp, -112, %sp"}]},
     src_and_asm_line={line="32",
     file="/kwikemart/marge/ezannoni/flathead-dev/devo/gdb/ \
       testsuite/gdb.mi/basics.c",line_asm_insn=[
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov  2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi  %hi(0x11800), %o2"}]}]
     (gdb)

Команда '-data-evaluate-expression'
-----------------------------------

Краткое описание
................

      -data-evaluate-expression ВЫРАЖ

   Вычислить выражение ВЫРАЖ.  Выражение может содержать подчиненный
вызов функции.  Вызов функции будет выполнен синхронно.  Если выражение
содержит пробелы, оно должно быть заключено в двойные кавычки.

Команда GDB
...........

Соответствующими командами GDB являются 'print', 'output' и 'call'.  В
'gdbtk' есть соответствующая команда 'gdb_eval'.

Пример
......

В следующем примере числа, предшествующие командам, суть "лексемы".  Для
их описания, см.  *note Синтаксис команд GDB/MI: Синтаксис команд
GDB/MI. Обратите внимание на то, как GDB/MI возвращает те же лексемы в
своем выводе.

     211-data-evaluate-expression A
     211^done,value="1"
     (gdb)
     311-data-evaluate-expression &A
     311^done,value="0xefffeb7c"
     (gdb)
     411-data-evaluate-expression A+3
     411^done,value="4"
     (gdb)
     511-data-evaluate-expression "A + 3"
     511^done,value="4"
     (gdb)

Команда '-data-list-changed-registers'
--------------------------------------

Краткое описание
................

      -data-list-changed-registers

   Выводит список регистров, которые изменились.

Команда GDB
...........

GDB не имеет прямого аналога этой команды; соответствующей командой
'gdbtk' является 'gdb_changed_register_list'.

Пример
......

На плате PPC MBX:

     (gdb)
     -exec-continue
     ^running

     (gdb)
     *stopped,reason="breakpoint-hit",bkptno="1",frame={func="main",
     args=[],file="try.c",line="5"}
     (gdb)
     -data-list-changed-registers
     ^done,changed-registers=["0","1","2","4","5","6","7","8","9",
     "10","11","13","14","15","16","17","18","19","20","21","22","23",
     "24","25","26","27","28","30","31","64","65","66","67","69"]
     (gdb)

Команда '-data-list-register-names'
-----------------------------------

Краткое описание
................

      -data-list-register-names [ ( НОМ-РЕГ )+ ]

   Показать список имен регистров текущей цели.  Если аргументы не
заданы, показывается список имен всех регистров.  Если в качестве
аргументов заданы целые числа, команда напечатает список имен регистров,
соответствующих аргументам.  Чтобы гарантировать согласованность имен
регистров и их номеров, выводимый список может содержать имена пустых
регистров.

Команда GDB
...........

В GDB нет команды, которая соответствует '-data-list-register-names'.  В
'gdbtk' соответствующей командой является 'gdb_regnames'.

Пример
......

Для платы PPC MBX:
     (gdb)
     -data-list-register-names
     ^done,register-names=["r0","r1","r2","r3","r4","r5","r6","r7",
     "r8","r9","r10","r11","r12","r13","r14","r15","r16","r17","r18",
     "r19","r20","r21","r22","r23","r24","r25","r26","r27","r28","r29",
     "r30","r31","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9",
     "f10","f11","f12","f13","f14","f15","f16","f17","f18","f19","f20",
     "f21","f22","f23","f24","f25","f26","f27","f28","f29","f30","f31",
     "", "pc","ps","cr","lr","ctr","xer"]
     (gdb)
     -data-list-register-names 1 2 3
     ^done,register-names=["r1","r2","r3"]
     (gdb)

Команда '-data-list-register-values'
------------------------------------

Краткое описание
................

      -data-list-register-values ФМТ [ ( НОМ-РЕГ )*]

   Отобразить содержимое регистров.  ФМТ является форматом, в
соответствии с которым должно быть возвращено содержимое регистров, за
которым следует необязательный список чисел, указывающих регистры,
подлежащие отображению.  Отсутствие списка чисел означает, что должно
быть возвращено содержимое всех регистров.

   Вот допустимые форматы для ФМТ:

'x'
     Шестнадцатеричный
'o'
     Восьмеричный
't'
     Двоичный
'd'
     Десятичный
'r'
     Без преобразования
'N'
     Натуральный

Команда GDB
...........

Соответствующими командами GDB являются 'info reg', 'info all-reg' и (в
'gdbtk') 'gdb_fetch_registers'.

Пример
......

Для платы PPC MBX (имейте ввиду: переносы строк даны только для удобства
чтения, они не появляются в реальном выводе):

     (gdb)
     -data-list-register-values r 64 65
     ^done,register-values=[{number="64",value="0xfe00a300"},
     {number="65",value="0x00029002"}]
     (gdb)
     -data-list-register-values x
     ^done,register-values=[{number="0",value="0xfe0043c8"},
     {number="1",value="0x3fff88"},{number="2",value="0xfffffffe"},
     {number="3",value="0x0"},{number="4",value="0xa"},
     {number="5",value="0x3fff68"},{number="6",value="0x3fff58"},
     {number="7",value="0xfe011e98"},{number="8",value="0x2"},
     {number="9",value="0xfa202820"},{number="10",value="0xfa202808"},
     {number="11",value="0x1"},{number="12",value="0x0"},
     {number="13",value="0x4544"},{number="14",value="0xffdfffff"},
     {number="15",value="0xffffffff"},{number="16",value="0xfffffeff"},
     {number="17",value="0xefffffed"},{number="18",value="0xfffffffe"},
     {number="19",value="0xffffffff"},{number="20",value="0xffffffff"},
     {number="21",value="0xffffffff"},{number="22",value="0xfffffff7"},
     {number="23",value="0xffffffff"},{number="24",value="0xffffffff"},
     {number="25",value="0xffffffff"},{number="26",value="0xfffffffb"},
     {number="27",value="0xffffffff"},{number="28",value="0xf7bfffff"},
     {number="29",value="0x0"},{number="30",value="0xfe010000"},
     {number="31",value="0x0"},{number="32",value="0x0"},
     {number="33",value="0x0"},{number="34",value="0x0"},
     {number="35",value="0x0"},{number="36",value="0x0"},
     {number="37",value="0x0"},{number="38",value="0x0"},
     {number="39",value="0x0"},{number="40",value="0x0"},
     {number="41",value="0x0"},{number="42",value="0x0"},
     {number="43",value="0x0"},{number="44",value="0x0"},
     {number="45",value="0x0"},{number="46",value="0x0"},
     {number="47",value="0x0"},{number="48",value="0x0"},
     {number="49",value="0x0"},{number="50",value="0x0"},
     {number="51",value="0x0"},{number="52",value="0x0"},
     {number="53",value="0x0"},{number="54",value="0x0"},
     {number="55",value="0x0"},{number="56",value="0x0"},
     {number="57",value="0x0"},{number="58",value="0x0"},
     {number="59",value="0x0"},{number="60",value="0x0"},
     {number="61",value="0x0"},{number="62",value="0x0"},
     {number="63",value="0x0"},{number="64",value="0xfe00a300"},
     {number="65",value="0x29002"},{number="66",value="0x202f04b5"},
     {number="67",value="0xfe0043b0"},{number="68",value="0xfe00b3e4"},
     {number="69",value="0x20002b03"}]
     (gdb)

Команда '-data-read-memory'
---------------------------

Краткое описание
................

      -data-read-memory [ -o СМЕЩЕНИЕ ]
        АДРЕС ФОРМАТ-СЛОВА РАЗМЕР-СЛОВА
        ЧИСЛО-СТРОК ЧИСЛО-КОЛОНОК [ ASЗНАК ]

где:

'АДРЕС'
     Выражение, определяющее адрес в памяти первого слова, которое надо
     прочитать.  Сложные выражения, содержащие пробельные знаки, должны
     заключаться в кавычки с использованием соглашений Си.

'ФОРМАТ-СЛОВА'
     Формат, который должен быть использован для печати слов памяти.
     Обозначения те же, что и для команды GDB 'print' (*note Форматы
     вывода: Форматы вывода.).

'РАЗМЕР-СЛОВА'
     Размер в байтах каждого слова в памяти.

'ЧИСЛО-СТРОК'
     Число строк в выходной таблице.

'ЧИСЛО-КОЛОНОК'
     Число колонок в выходной таблице.

'ASЗНАК'
     В настоящее время означает, что каждая строка должна включать
     ASCII-дамп.  Значение ASЗНАК используется в качестве заполняющего
     знака, когда байт не является элементом набора печатных знаков
     ASCII (печатные знаки ASCII это те знаки, чьи коды находятся между
     32 и 126 включительно).

'СМЕЩЕНИЕ'
     Смещение, которое надо добавить к АДРЕСУ перед тем, как начать
     извлечение из памяти.

   Эта команда отображает содержимое памяти в виде таблицы из
ЧИСЛО-СТРОК на ЧИСЛО-КОЛОНОК слов, причем каждое слово занимает
РАЗМЕР-СЛОВА байт.  В общей сложности считывается 'ЧИСЛО-СТРОК *
ЧИСЛО-КОЛОНОК * РАЗМЕР-СЛОВА' байт (возвращается как 'total-bytes').
Если цель должна возвратить меньше запрошенного числа байт,
отсутствующие слова идентифицируются при помощи 'N/A'.  Число байт,
прочитанное с цели, возвращается в 'nr-bytes', а начальный адрес,
использованный для чтении памяти, в 'addr'.

   Адрес следующей/предыдущей строки или страницы доступен в 'next-row'
и 'prev-row', 'next-page' и 'prev-page'.

Команда GDB
...........

Соответствующей командой GDB является 'x'.  'gdbtk' имеет команду чтения
памяти 'gdb_get_mem'.

Пример
......

Прочитать шесть байт памяти, начиная с 'bytes+6', но сместиться на '-6'
байт.  Форматировать в три ряда по две колонки.  Один байт на слово.
Отображать каждое слово в шестнадцатеричном виде.

     (gdb)
     9-data-read-memory -o -6 -- bytes+6 x 1 3 2
     9^done,addr="0x00001390",nr-bytes="6",total-bytes="6",
     next-row="0x00001396",prev-row="0x0000138e",next-page="0x00001396",
     prev-page="0x0000138a",memory=[
     {addr="0x00001390",data=["0x00","0x01"]},
     {addr="0x00001392",data=["0x02","0x03"]},
     {addr="0x00001394",data=["0x04","0x05"]}]
     (gdb)

   Прочитать два байта памяти, начиная с адреса 'shorts + 64' и
отобразить в виде одного слова в десятичном виде.

     (gdb)
     5-data-read-memory shorts+64 d 2 1 1
     5^done,addr="0x00001510",nr-bytes="2",total-bytes="2",
     next-row="0x00001512",prev-row="0x0000150e",
     next-page="0x00001512",prev-page="0x0000150e",memory=[
     {addr="0x00001510",data=["128"]}]
     (gdb)

   Прочитать тридцать два байта памяти, начиная с 'bytes+16', и
форматировать на восемь рядов по четыре колонки.  Включить строку,
закодированную с использованием 'x' в качестве непечатного знака.

     (gdb)
     4-data-read-memory bytes+16 x 1 8 4 x
     4^done,addr="0x000013a0",nr-bytes="32",total-bytes="32",
     next-row="0x000013c0",prev-row="0x0000139c",
     next-page="0x000013c0",prev-page="0x00001380",memory=[
     {addr="0x000013a0",data=["0x10","0x11","0x12","0x13"],ascii="xxxx"},
     {addr="0x000013a4",data=["0x14","0x15","0x16","0x17"],ascii="xxxx"},
     {addr="0x000013a8",data=["0x18","0x19","0x1a","0x1b"],ascii="xxxx"},
     {addr="0x000013ac",data=["0x1c","0x1d","0x1e","0x1f"],ascii="xxxx"},
     {addr="0x000013b0",data=["0x20","0x21","0x22","0x23"],ascii=" !\"#"},
     {addr="0x000013b4",data=["0x24","0x25","0x26","0x27"],ascii="$%&'"},
     {addr="0x000013b8",data=["0x28","0x29","0x2a","0x2b"],ascii="()*+"},
     {addr="0x000013bc",data=["0x2c","0x2d","0x2e","0x2f"],ascii=",-./"}]
     (gdb)

Команда '-display-delete'
-------------------------

Краткое описание
................

      -display-delete НОМЕР

   Удалить элемент с указанным НОМЕРОМ из списка выражений, подлежащих
отображению.

Команда GDB
...........

Соответствующей командой GDB является 'delete display'.

Пример
......

Н.П.

Команда '-display-disable'
--------------------------

Краткое описание
................

      -display-disable НОМЕР

   Отключить элемент списка выражений с указанным НОМЕРОМ.

Команда GDB
...........

Соответствующей командой GDB является 'disable display'.

Пример
......

Н.П.

Команда '-display-enable'
-------------------------

Краткое описание
................

      -display-enable НОМЕР

   Включить элемент списка выражений с указанным НОМЕРОМ.

Команда GDB
...........

Соответствующей командой GDB является 'enable display'.

Пример
......

Н.П.

Команда '-display-insert'
-------------------------

Краткое описание
................

      -display-insert ВЫРАЖЕНИЕ

   Отображать ВЫРАЖЕНИЕ всякий раз, когда программа останавливается.

Команда GDB
...........

Соответствующей командой GDB является 'display'.

Пример
......

Н.П.

Команда '-display-list'
-----------------------

Краткое описание
................

      -display-list

   Перечислить элементы списка выражений, подлежащих автоматическому
отображению.  Текущие значения не показывать.

Команда GDB
...........

Соответствующей командой GDB является 'info display'.

Пример
......

Н.П.

Команда '-environment-cd'
-------------------------

Краткое описание
................

      -environment-cd КАТ

   Установить рабочий каталог GDB.

Команда GDB
...........

Соответствующей командой GDB является 'cd'.

Пример
......

     (gdb)
     -environment-cd /kwikemart/marge/ezannoni/flathead-dev/devo/gdb
     ^done
     (gdb)

Команда '-environment-directory'
--------------------------------

Краткое описание
................

      -environment-directory КАТ

   Добавить каталог КАТ в начало пути поиска исходных файлов.

Команда GDB
...........

Соответствующей командой GDB является 'dir'.

Пример
......

     (gdb)
     -environment-directory /kwikemart/marge/ezannoni/flathead-dev/devo/gdb
     ^done
     (gdb)

Команда '-environment-path'
---------------------------

Краткое описание
................

      -environment-path ( КАТ )+

   Добавить каталоги КАТ в начало пути поиска объектных файлов.

Команда GDB
...........

Соответствующей командой GDB является 'path'.

Пример
......

     (gdb)
     -environment-path /kwikemart/marge/ezannoni/flathead-dev/ppc-eabi/gdb
     ^done
     (gdb)

Команда '-environment-pwd'
--------------------------

Краткое описание
................

      -environment-pwd

   Показать текущий рабочий каталог.

Команда GDB
...........

Соответствующей командой GDB является 'pwd'.

Пример
......

     (gdb)
     -environment-pwd
     ~Working directory /kwikemart/marge/ezannoni/flathead-dev/devo/gdb.
     ^done
     (gdb)


File: gdb.html,  Node: Управление программой GDB/MI,  Next: Разные команды GDB/MI,  Prev: Управление данными GDB/MI,  Up: GDB/MI

19.7 Управление программой GDB/MI
=================================

Завершение программы
....................

В процессе выполнения, подчиненная программа может достигнуть конца,
если она не встретит ни одной точки останова.  В этом случае вывод будет
включать код завершения, если программа завершилась ненормально.

Примеры
.......

Программа завершилась нормально:

     (gdb)
     -exec-run
     ^running
     (gdb)
     x = 55
     *stopped,reason="exited-normally"
     (gdb)

Программа завершилась ненормально:

     (gdb)
     -exec-run
     ^running
     (gdb)
     x = 55
     *stopped,reason="exited",exit-code="01"
     (gdb)

   Кроме того, программа может завершиться так, как если бы она получила
сигнал, например 'SIGINT'.  В этом случае GDB/MI отображает следующее:

     (gdb)
     *stopped,reason="exited-signalled",signal-name="SIGINT",
     signal-meaning="Interrupt"

Команда '-exec-abort'
---------------------

Краткое описание
................

      -exec-abort

   Убить выполняющуюся подчиненную программу.

Команда GDB
...........

Соответствующей командой GDB является 'kill'.

Пример
......

Н.П.

Команда '-exec-arguments'
-------------------------

Краткое описание
................

      -exec-arguments АРГ

   Установить аргументы подчиненной программы, которые должны быть
использованы при следующем '-exec-run'.

Команда GDB
...........

Соответствующей командой GDB является 'set args'.

Пример
......

Пока нет.

Команда '-exec-continue'
------------------------

Краткое описание
................

      -exec-continue

   Асинхронная команда.  Возобновляет выполнение подчиненной программы
до тех пор, пока не будет встречена точка останова, или пока подчиненная
программа не завершится.

Команда GDB
...........

Соответствующей командой GDB является 'continue'.

Пример
......

     -exec-continue
     ^running
     (gdb)
     @Hello world
     *stopped,reason="breakpoint-hit",bkptno="2",frame={func="foo",args=[],
     file="hello.c",line="13"}
     (gdb)

Команда '-exec-finish'
----------------------

Краткое описание
................

      -exec-finish

   Асинхронная команда.  Возобновляет выполнение подчиненной программы
до тех пор, пока не завершится текущая функция.  Отображает результаты,
возвращенные функцией.

Команда GDB
...........

Соответствующей командой GDB является 'finish'.

Пример
......

Функция, возвращающая 'void'.

     -exec-finish
     ^running
     (gdb)
     @hello from foo
     *stopped,reason="function-finished",frame={func="main",args=[],
     file="hello.c",line="7"}
     (gdb)

   Функция, возвращающая что-либо отличное от 'void'.  Печатается имя
внутренней переменной GDB, хранящей результат, а также и сам результат.

     -exec-finish
     ^running
     (gdb)
     *stopped,reason="function-finished",frame={addr="0x000107b0",func="foo",
     args=[{name="a",value="1"],{name="b",value="9"}},
     file="recursive2.c",line="14"},
     gdb-result-var="$1",return-value="0"
     (gdb)

Команда '-exec-interrupt'
-------------------------

Краткое описание
................

      -exec-interrupt

   Асинхронная команда.  Прерывает фоновое исполнение цели.  Заметьте,
что лексема, ассоциированная с сообщением об останове, совпадает с
лексемой для выполнения команды, которая была прервана.  Лексема для
самого прерывания появляется только в выводе '^done'.  Если пользователь
пытается прервать невыполняющуюся программу, будет выведено сообщение об
ошибке.

Команда GDB
...........

Соответствующей командой GDB является 'interrupt'.

Пример
......

     (gdb)
     111-exec-continue
     111^running

     (gdb)
     222-exec-interrupt
     222^done
     (gdb)
     111*stopped,signal-name="SIGINT",signal-meaning="Interrupt",
     frame={addr="0x00010140",func="foo",args=[],file="try.c",line="13"}
     (gdb)

     (gdb)
     -exec-interrupt
     ^error,msg="mi_cmd_exec_interrupt: Inferior not executing."
     (gdb)

Команда '-exec-next'
--------------------

Краткое описание
................

      -exec-next

   Асинхронная команда.  Возобновляет выполнение подчиненной программы,
останавливая ее, когда достигается начало следующей строки исходного
текста.

Команда GDB
...........

Соответствующей командой GDB является 'next'.

Пример
......

     -exec-next
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",line="8",file="hello.c"
     (gdb)

Команда '-exec-next-instruction'
--------------------------------

Краткое описание
................

      -exec-next-instruction

   Асинхронная команда.  Выполняет одну машинную инструкцию.  Если
инструкция является вызовом функции, выполнение продолжается до возврата
из функции.  Если программа останавливается на инструкции в середине
строки исходного текста, печатается также адрес.

Команда GDB
...........

Соответствующей командой GDB является 'nexti'.

Пример
......

     (gdb)
     -exec-next-instruction
     ^running

     (gdb)
     *stopped,reason="end-stepping-range",
     addr="0x000100d4",line="5",file="hello.c"
     (gdb)

Команда '-exec-return'
----------------------

Краткое описание
................

      -exec-return

   Велит текущей функции немедленно вернуться.  Не выполняет подчиненную
программу.  Отображает новый текущий кадр.

Команда GDB
...........

Соответствующей командой GDB является 'return'.

Пример
......

     (gdb)
     200-break-insert callee4
     200^done,bkpt={number="1",addr="0x00010734",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"}
     (gdb)
     000-exec-run
     000^running
     (gdb)
     000*stopped,reason="breakpoint-hit",bkptno="1",
     frame={func="callee4",args=[],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"}
     (gdb)
     205-break-delete
     205^done
     (gdb)
     111-exec-return
     111^done,frame={level="0 ",func="callee3",
     args=[{name="strarg",
     value="0x11940 \"A string argument.\""}],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
     (gdb)

Команда '-exec-run'
-------------------

Краткое описание
................

      -exec-run

   Асинхронная команда.  Начинает выполнение подчиненной программы с
начала.  Она выполняется до тех пор, пока либо не встретится точка
останова, либо программа не завершится.

Команда GDB
...........

Соответствующей командой GDB является 'run'.

Пример
......

     (gdb)
     -break-insert main
     ^done,bkpt={number="1",addr="0x0001072c",file="recursive2.c",line="4"}
     (gdb)
     -exec-run
     ^running
     (gdb)
     *stopped,reason="breakpoint-hit",bkptno="1",
     frame={func="main",args=[],file="recursive2.c",line="4"}
     (gdb)

Команда '-exec-show-arguments'
------------------------------

Краткое описание
................

      -exec-show-arguments

   Печатает аргументы программы.

Команда GDB
...........

Соответствующей командой GDB является 'show args'.

Пример
......

Н.П.

Команда '-exec-step'
--------------------

Краткое описание
................

      -exec-step

   Асинхронная команда.  Возобновляет выполнение подчиненной программы,
останавливая ее, когда будет достигнуто начало следующей строки
исходного файла, при условии, что она не является вызовом функции.  Если
же следующая строка является вызовом функции, программа останавливается
на первой инструкции этой функции.

Команда GDB
...........

Соответствующей командой GDB является 'step'.

Пример
......

Пошаговый вход в функцию:

     -exec-step
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",
     frame={func="foo",args=[{name="a",value="10"},
     {name="b",value="0"}],file="recursive2.c",line="11"}
     (gdb)

   Обычное пошаговое выполнение:

     -exec-step
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",line="14",file="recursive2.c"
     (gdb)

Команда '-exec-step-instruction'
--------------------------------

Краткое описание
................

      -exec-step-instruction

   Асинхронная команда.  Возобновляет выполнение подчиненной программы,
выполняя одну машинную инструкцию.  Вывод, когда GDB остановится, будет
различаться в зависимости от того, остановились мы в середине исходной
строки или нет.  В первом случае, адрес, по которому программа
остановлена, также будет напечатан.

Команда GDB
...........

Соответствующей командой GDB является 'stepi'.

Пример
......

     (gdb)
     -exec-step-instruction
     ^running

     (gdb)
     *stopped,reason="end-stepping-range",
     frame={func="foo",args=[],file="try.c",line="10"}
     (gdb)
     -exec-step-instruction
     ^running

     (gdb)
     *stopped,reason="end-stepping-range",
     frame={addr="0x000100f4",func="foo",args=[],file="try.c",line="10"}
     (gdb)

Команда '-exec-until'
---------------------

Краткое описание
................

      -exec-until [ МЕСТОПОЛОЖЕНИЕ ]

   Асинхронная команда.  Выполняет подчиненную программу до тех пор,
пока не будет достигнуто указанное в аргументе МЕСТОПОЛОЖЕНИЕ.  Если
аргумента нет, подчиненная программа выполняется, пока не будет
достигнута строка исходного текста, превышающая текущую.  В этом случае,
причиной остановки будет 'location-reached'.

Команда GDB
...........

Соответствующей командой GDB является 'until'.

Пример
......

     (gdb)
     -exec-until recursive2.c:6
     ^running
     (gdb)
     x = 55
     *stopped,reason="location-reached",frame={func="main",args=[],
     file="recursive2.c",line="6"}
     (gdb)

Команда '-file-exec-and-symbols'
--------------------------------

Краткое описание
................

      -file-exec-and-symbols ФАЙЛ

   Указать выполняемый файл для отладки.  Это тот файл, из которого
также читается таблица символов.  Если файл не указан, команда очищает
информацию о выполняемом файле и символах.  Если при использовании этой
команды без аргументов установлены точки останова, GDB выдаст сообщение
об ошибке.  В противном случае, никакого вывода не будет, за исключением
уведомления о завершении.

Команда GDB
...........

Соответствующей командой GDB является 'file'.

Пример
......

     (gdb)
     -file-exec-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
     ^done
     (gdb)

Команда '-file-exec-file'
-------------------------

Краткое описание
................

      -file-exec-file ФАЙЛ

   Указать выполняемый файл для отладки.  В отличие от
'-file-exec-and-symbols', таблица символов _не_ считывается из этого
файла.  При использовании без аргумента, GDB очищает информацию о
выполняемом файле.  Никакого вывода не производится, за исключением
уведомления о завершении.

Команда GDB
...........

Соответствующей командой GDB является 'exec-file'.

Пример
......

     (gdb)
     -file-exec-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
     ^done
     (gdb)

Команда '-file-list-exec-sections'
----------------------------------

Краткое описание
................

      -file-list-exec-sections

   Перечисляет разделы текущего выполняемого файла.

Команда GDB
...........

Команда GDB 'info file' показывает, помимо всего прочего, ту же
информацию, что и эта команда.  'gdbtk' имеет соответствующую команду
'gdb_load_info'.

Пример
......

Н.П.

Команда '-file-list-exec-source-files'
--------------------------------------

Краткое описание
................

      -file-list-exec-source-files

   Перечисляет исходные файлы для текущего выполняемого файла.

Команда GDB
...........

В GDB нет команды, непосредственно соответствующей этой.  'gdbtk' имеет
аналогичную команду 'gdb_listfiles'.

Пример
......

Н.П.

Команда '-file-list-shared-libraries'
-------------------------------------

Краткое описание
................

      -file-list-shared-libraries

   Перечисляет используемые программой разделяемые библиотеки.

Команда GDB
...........

Соответствующей командой GDB является 'info shared'.

Пример
......

Н.П.

Команда '-file-list-symbol-files'
---------------------------------

Краткое описание
................

      -file-list-symbol-files

   Перечисляет файлы символов.

Команда GDB
...........

Соответствующей командой GDB является 'info file' (ее часть).

Пример
......

Н.П.

Команда '-file-symbol-file'
---------------------------

Краткое описание
................

      -file-symbol-file ФАЙЛ

   Прочитать информацию символьной таблицы из указанного в аргументе
ФАЙЛА.  Будучи использованной без аргументов, очищает таблицу символьной
информации GDB. Никакого вывода не производится, кроме уведомления о
завершении.

Команда GDB
...........

Соответствующей командой GDB является 'symbol-file'.

Пример
......

     (gdb)
     -file-symbol-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
     ^done
     (gdb)


File: gdb.html,  Node: Разные команды GDB/MI,  Next: Управление стеком GDB/MI,  Prev: Управление программой GDB/MI,  Up: GDB/MI

19.8 Разные команды GDB в GDB/MI
================================

Команда '-gdb-exit'
-------------------

Краткое описание
................

      -gdb-exit

   Немедленно выйти из GDB.

Команда GDB
...........

Примерно соответствует команде 'quit'.

Пример
......

     (gdb)
     -gdb-exit

Команда '-gdb-set'
------------------

Краткое описание
................

      -gdb-set

   Установить внутреннюю переменную GDB.

Команда GDB
...........

Соответствующей командой GDB является 'set'.

Пример
......

     (gdb)
     -gdb-set $foo=3
     ^done
     (gdb)

Команда '-gdb-show'
-------------------

Краткое описание
................

      -gdb-show

   Показать текущее значение переменной GDB.

Команда GDB
...........

Соответствующей командой GDB является 'show'.

Пример
......

     (gdb)
     -gdb-show annotate
     ^done,value="0"
     (gdb)

Команда '-gdb-version'
----------------------

Краткое описание
................

      -gdb-version

   Вывести информацию о версии GDB. Используется преимущественно при
тестировании.

Команда GDB
...........

Эквивалентной команды GDB нет.  По умолчанию, GDB показывает эту
информацию, когда вы вызываете интерактивный сеанс.

Пример
......

     (gdb)
     -gdb-version
     ~GNU gdb 5.2.1
     ~Copyright 2000 Free Software Foundation, Inc.
     ~GDB is free software, covered by the GNU General Public License, and
     ~you are welcome to change it and/or distribute copies of it under
     ~ certain conditions.
     ~Type "show copying" to see the conditions.
     ~There is absolutely no warranty for GDB.  Type "show warranty" for
     ~ details.
     ~This GDB was configured as
      "--host=sparc-sun-solaris2.5.1 --target=ppc-eabi".
     ^done
     (gdb)


File: gdb.html,  Node: Управление стеком GDB/MI,  Next: Запросы GDB/MI о символах,  Prev: Разные команды GDB/MI,  Up: GDB/MI

19.9 Команды GDB/MI управления стеком
=====================================

Команда '-stack-info-frame'
---------------------------

Краткое описание
................

      -stack-info-frame

   Получить информацию о текущем кадре.

Команда GDB
...........

Соответствующей командой GDB является 'info frame' или 'frame' (без
аргументов).

Пример
......

Н.П.

Команда '-stack-info-depth'
---------------------------

Краткое описание
................

      -stack-info-depth [ МАКС-ГЛУБ ]

   Возвращает глубину стека.  Если указан целочисленный аргумент
МАКС-ГЛУБ, не считать более МАКС-ГЛУБ кадров.

Команда GDB
...........

Эквивалентной команды GDB нет.

Пример
......

Для стека с уровнями кадров от 0 до 11:

     (gdb)
     -stack-info-depth
     ^done,depth="12"
     (gdb)
     -stack-info-depth 4
     ^done,depth="4"
     (gdb)
     -stack-info-depth 12
     ^done,depth="12"
     (gdb)
     -stack-info-depth 11
     ^done,depth="11"
     (gdb)
     -stack-info-depth 13
     ^done,depth="12"
     (gdb)

Команда '-stack-list-arguments'
-------------------------------

Краткое описание
................

      -stack-list-arguments ПОКАЗ-ЗНАЧ
         [ НИЖН-КАДР ВЕРХН-КАДР ]

   Отобразить список аргументов для кадров от НИЖН-КАДР до ВЕРХН-КАДР
(включительно).  Если НИЖН-КАДР и ВЕРХН-КАДР не указаны, перечислить
аргументы для всего стека вызовов.

   Аргумент ПОКАЗ-ЗНАЧ должен иметь значение 0 или 1.  Значение 0
означает, что выводятся только имена аргументов, а 1 -- что печатаются
как имена, так и значения аргументов.

Команда GDB
...........

GDB не имеет эквивалентной команды.  В 'gdbtk' есть команда
'gdb_get_args', которая частично перекрывается с действием
'-stack-list-arguments'.

Пример
......

     (gdb)
     -stack-list-frames
     ^done,
     stack=[
     frame={level="0 ",addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"},
     frame={level="1 ",addr="0x0001076c",func="callee3",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="17"},
     frame={level="2 ",addr="0x0001078c",func="callee2",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="22"},
     frame={level="3 ",addr="0x000107b4",func="callee1",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="27"},
     frame={level="4 ",addr="0x000107e0",func="main",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="32"}]
     (gdb)
     -stack-list-arguments 0
     ^done,
     stack-args=[
     frame={level="0",args=[]},
     frame={level="1",args=[name="strarg"]},
     frame={level="2",args=[name="intarg",name="strarg"]},
     frame={level="3",args=[name="intarg",name="strarg",name="fltarg"]},
     frame={level="4",args=[]}]
     (gdb)
     -stack-list-arguments 1
     ^done,
     stack-args=[
     frame={level="0",args=[]},
     frame={level="1",
      args=[{name="strarg",value="0x11940 \"Строковый аргумент.\""}]},
     frame={level="2",args=[
     {name="intarg",value="2"},
     {name="strarg",value="0x11940 \"Строковый аргумент.\""}]},
     {frame={level="3",args=[
     {name="intarg",value="2"},
     {name="strarg",value="0x11940 \"Строковый аргумент.\""},
     {name="fltarg",value="3.5"}]},
     frame={level="4",args=[]}]
     (gdb)
     -stack-list-arguments 0 2 2
     ^done,stack-args=[frame={level="2",args=[name="intarg",name="strarg"]}]
     (gdb)
     -stack-list-arguments 1 2 2
     ^done,stack-args=[frame={level="2",
     args=[{name="intarg",value="2"},
     {name="strarg",value="0x11940 \"Строковый аргумент.\""}]}]
     (gdb)

Команда '-stack-list-frames'
----------------------------

Краткое описание
................

      -stack-list-frames [ НИЖН-КАДР ВЕРХН-КАДР ]

   Перечисляет кадры, находящиеся в данный момент в стеке.  Для каждого
кадра, команда отображает следующую информацию:

'LEVEL'
     Номер кадра, 0 для самого верхнего, то есть для самой внутренней
     функции.
'ADDR'
     Значение '$pc' для этого кадра.
'FUNC'
     Имя функции.
'FILE'
     Имя исходного файла, где находится функция.
'LINE'
     Номер строки, соответствующий '$pc'.

   Будучи вызванной без аргументов, эта команда печатает цепочку вызовов
для всего стека.  Если задано два целочисленных аргумента, она
показывает кадры с уровнями между этими аргументами (включительно).
Если аргументы равны, она показывает один единственный кадр
соответствующего уровня.

Команда GDB
...........

Соответствующими командами GDB являются 'backtrace' и 'where'.

Пример
......

Цепочка вызовов стека целиком:

     (gdb)
     -stack-list-frames
     ^done,stack=
     [frame={level="0 ",addr="0x0001076c",func="foo",
       file="recursive2.c",line="11"},
     frame={level="1 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="2 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="3 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="4 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="5 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="6 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="7 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="8 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="9 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="10",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="11",addr="0x00010738",func="main",
       file="recursive2.c",line="4"}]
     (gdb)

   Показать кадры между НИЖН-КАДР и ВЕРХН-КАДР:

     (gdb)
     -stack-list-frames 3 5
     ^done,stack=
     [frame={level="3 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="4 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="5 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"}]
     (gdb)

   Показать один кадр:

     (gdb)
     -stack-list-frames 3 3
     ^done,stack=
     [frame={level="3 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"}]
     (gdb)

Команда '-stack-list-locals'
----------------------------

Краткое описание
................

      -stack-list-locals ПЕЧАТАТЬ-ЗНАЧЕНИЯ

   Вывести имена локальных переменных для текущего кадра.  С параметром
0 выводит только имена переменных, с параметром 1 выводит также их
значения.

Команда GDB
...........

'info locals' в GDB, 'gdb_get_locals' в 'gdbtk'.

Пример
......

     (gdb)
     -stack-list-locals 0
     ^done,locals=[name="A",name="B",name="C"]
     (gdb)
     -stack-list-locals 1
     ^done,locals=[{name="A",value="1"},{name="B",value="2"},
       {name="C",value="3"}]
     (gdb)

Команда '-stack-select-frame'
-----------------------------

Краткое описание
................

      -stack-select-frame НОМ-КАДРА

   Изменить текущий кадр.  Выбрать другой кадр НОМ-КАДРА в стеке.

Команда GDB
...........

Соответствующими командами GDB являются 'frame', 'up', 'down',
'select-frame', 'up-silent' и 'down-silent'.

Пример
......

     (gdb)
     -stack-select-frame 2
     ^done
     (gdb)


File: gdb.html,  Node: Запросы GDB/MI о символах,  Next: Управление целью GDB/MI,  Prev: Управление стеком GDB/MI,  Up: GDB/MI

19.10 Команды GDB/MI запросов о символах
========================================

Команда '-symbol-info-address'
------------------------------

Краткое описание
................

      -symbol-info-address СИМВОЛ

   Описать, где хранится СИМВОЛ.

Команда GDB
...........

Соответствующей командой GDB является 'info address'.

Пример
......

Н.П.

Команда '-symbol-info-file'
---------------------------

Краткое описание
................

      -symbol-info-file

   Показать файл для символа.

Команда GDB
...........

Эквивалентной команды GDB нет.  В 'gdbtk' есть команда 'gdb_find_file'.

Пример
......

Н.П.

Команда '-symbol-info-function'
-------------------------------

Краткое описание
................

      -symbol-info-function

   Показать, в какой функции находится символ.

Команда GDB
...........

'gdb_get_function' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-info-line'
---------------------------

Краткое описание
................

      -symbol-info-line

   Показать адреса памяти кода для текущей строки.

Команда GDB
...........

Соответствующей командой GDB является 'info line'.  В 'gdbtk' есть
команды 'gdb_get_line' и 'gdb_get_file'.

Пример
......

Н.П.

Команда '-symbol-info-symbol'
-----------------------------

Краткое описание
................

      -symbol-info-symbol АДРЕС

   Описать, какой символ находится в местоположении АДРЕС.

Команда GDB
...........

Соответствующей командой GDB является 'info symbol'.

Пример
......

Н.П.

Команда '-symbol-list-functions'
--------------------------------

Краткое описание
................

      -symbol-list-functions

   Перечислить функции, находящиеся в выполняемом файле.

Команда GDB
...........

'info functions' в GDB, 'gdb_listfunc' и 'gdb_search' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-list-types'
----------------------------

Краткое описание
................

      -symbol-list-types

   Перечислить все имена типов.

Команда GDB
...........

Соответствующими командами являются 'info types' в GDB и 'gdb_search' в
'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-list-variables'
--------------------------------

Краткое описание
................

      -symbol-list-variables

   Перечислить имена всех глобальных и статических переменных.

Команда GDB
...........

'info variables' в GDB, 'gdb_search' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-locate'
------------------------

Краткое описание
................

      -symbol-locate

Команда GDB
...........

'gdb_loc' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-type'
----------------------

Краткое описание
................

      -symbol-type ПЕРЕМЕННАЯ

   Показать тип ПЕРЕМЕННОЙ.

Команда GDB
...........

Соответствующей командой GDB является 'ptype', в 'gdbtk' есть команда
'gdb_obj_variable'.

Пример
......

Н.П.


File: gdb.html,  Node: Управление целью GDB/MI,  Next: Команды GDB/MI для нитей,  Prev: Запросы GDB/MI о символах,  Up: GDB/MI

19.11 Команды GDB/MI управления целью
=====================================

Команда '-target-attach'
------------------------

Краткое описание
................

      -target-attach ИД-ПРОЦ | ФАЙЛ

   Присоединиться к процессу ИД-ПРОЦ или файлу ФАЙЛ вне GDB.

Команда GDB
...........

Соответствующей командой GDB является 'attach'.

Пример
......

Н.П.

Команда '-target-compare-sections'
----------------------------------

Краткое описание
................

      -target-compare-sections [ РАЗДЕЛ ]

   Сравнить данные раздела РАЗДЕЛ на цели с выполняемым файлом.  Без
аргумента сравниваются все разделы.

Команда GDB
...........

Эквивалентной командой в GDB является 'compare-sections'.

Пример
......

Н.П.

Команда '-target-detach'
------------------------

Краткое описание
................

      -target-detach

   Отсоединиться от удаленной цели.  Никакого вывода не производится.

Команда GDB
...........

Соответствующей командой GDB является 'detach'.

Пример
......

     (gdb)
     -target-detach
     ^done
     (gdb)

Команда '-target-download'
--------------------------

Краткое описание
................

      -target-download

   Загружает выполняемый файл на удаленную цель.  Команда два раза в
секунду обновляет сообщение, которое включает поля:

'section'
     Имя раздела.
'section-sent'
     Размер переданного на данный момент участка для этого раздела.
'section-size'
     Размер раздела.
'total-sent'
     Общий размер переданной на данный момент информации (текущий и
     предыдущие разделы).
'total-size'
     Размер всего выполняемого файла, подлежащего загрузке.

Каждое сообщение посылается в виде сообщения статуса (*note Выходной
синтаксис GDB/MI: Выходной синтаксис GDB/MI.).

   Кроме того, команда печатает имена и размеры разделов, по мере их
загрузки.  Эти сообщения включают следующие поля:

'section'
     Имя раздела.
'section-size'
     Размер раздела.
'total-size'
     Размер всего выполняемого файла, подлежащего загрузке.

В конце печатается суммарная информация.

Команда GDB
...........

Соответствующей командой GDB является 'load'.

Пример
......

Замечание: каждое сообщение статуса появляется на одной строке.  Здесь
сообщения были разбиты на несколько строк, чтобы они могли влезть на
страницу.

     (gdb)
     -target-download
     +download,{section=".text",section-size="6668",total-size="9880"}
     +download,{section=".text",section-sent="512",section-size="6668",
     total-sent="512",total-size="9880"}
     +download,{section=".text",section-sent="1024",section-size="6668",
     total-sent="1024",total-size="9880"}
     +download,{section=".text",section-sent="1536",section-size="6668",
     total-sent="1536",total-size="9880"}
     +download,{section=".text",section-sent="2048",section-size="6668",
     total-sent="2048",total-size="9880"}
     +download,{section=".text",section-sent="2560",section-size="6668",
     total-sent="2560",total-size="9880"}
     +download,{section=".text",section-sent="3072",section-size="6668",
     total-sent="3072",total-size="9880"}
     +download,{section=".text",section-sent="3584",section-size="6668",
     total-sent="3584",total-size="9880"}
     +download,{section=".text",section-sent="4096",section-size="6668",
     total-sent="4096",total-size="9880"}
     +download,{section=".text",section-sent="4608",section-size="6668",
     total-sent="4608",total-size="9880"}
     +download,{section=".text",section-sent="5120",section-size="6668",
     total-sent="5120",total-size="9880"}
     +download,{section=".text",section-sent="5632",section-size="6668",
     total-sent="5632",total-size="9880"}
     +download,{section=".text",section-sent="6144",section-size="6668",
     total-sent="6144",total-size="9880"}
     +download,{section=".text",section-sent="6656",section-size="6668",
     total-sent="6656",total-size="9880"}
     +download,{section=".init",section-size="28",total-size="9880"}
     +download,{section=".fini",section-size="28",total-size="9880"}
     +download,{section=".data",section-size="3156",total-size="9880"}
     +download,{section=".data",section-sent="512",section-size="3156",
     total-sent="7236",total-size="9880"}
     +download,{section=".data",section-sent="1024",section-size="3156",
     total-sent="7748",total-size="9880"}
     +download,{section=".data",section-sent="1536",section-size="3156",
     total-sent="8260",total-size="9880"}
     +download,{section=".data",section-sent="2048",section-size="3156",
     total-sent="8772",total-size="9880"}
     +download,{section=".data",section-sent="2560",section-size="3156",
     total-sent="9284",total-size="9880"}
     +download,{section=".data",section-sent="3072",section-size="3156",
     total-sent="9796",total-size="9880"}
     ^done,address="0x10004",load-size="9880",transfer-rate="6586",
     write-rate="429"
     (gdb)

Команда '-target-exec-status'
-----------------------------

Краткое описание
................

      -target-exec-status

   Предоставить информацию о состоянии цели (например, выполняется она
или нет).

Команда GDB
...........

Эквивалентной команды GDB нет.

Пример
......

Н.П.

Команда '-target-list-available-targets'
----------------------------------------

Краткое описание
................

      -target-list-available-targets

   Перечислить цели, к которым можно установить соединение.

Команда GDB
...........

Соответствующей командой GDB является 'help target'.

Пример
......

Н.П.

Команда '-target-list-current-targets'
--------------------------------------

Краткое описание
................

      -target-list-current-targets

   Описать текущую цель.

Команда GDB
...........

Соответствующая информация (вместе с другой) печатается командой 'info
file'.

Пример
......

Н.П.

Команда '-target-list-parameters'
---------------------------------

Краткое описание
................

      -target-list-parameters

Команда GDB
...........

Эквивалента нет.

Пример
......

Н.П.

Команда '-target-select'
------------------------

Краткое описание
................

      -target-select ТИП ПАРАМЕТРЫ ...

   Соединить GDB с удаленной целью.  Эта команда допускает два
аргумента:

'ТИП'
     Тип цели, например, 'async', 'remote', и т.д.
'ПАРАМЕТРЫ'
     Имена устройств, названия машин и тому подобное.  *Note Команды для
     управления целями: Команды для целей, для более полной информации.

   Результатом является уведомление о соединении, за которым следует
адрес, по которому находится целевая программа, в следующей форме:

     ^connected,addr="АДРЕС",func="ИМЯ ФУНКЦИИ",
       args=[СПИСОК АРГУМЕНТОВ]

Команда GDB
...........

Соответствующей командой GDB является 'target'.

Пример
......

     (gdb)
     -target-select async /dev/ttya
     ^connected,addr="0xfe00a300",func="??",args=[]
     (gdb)


File: gdb.html,  Node: Команды GDB/MI для нитей,  Next: Команды GDB/MI для точек трассировки,  Prev: Управление целью GDB/MI,  Up: GDB/MI

19.12 Команды GDB/MI для нитей
==============================

Команда '-thread-info'
----------------------

Краткое описание
................

      -thread-info

Команда GDB
...........

Эквивалента нет.

Пример
......

Н.П.

Команда '-thread-list-all-threads'
----------------------------------

Краткое описание
................

      -thread-list-all-threads

Команда GDB
...........

Эквивалентной командой GDB является 'info threads'.

Пример
......

Н.П.

Команда '-thread-list-ids'
--------------------------

Краткое описание
................

      -thread-list-ids

   Выводит список известных GDB в данный момент идентификаторов нитей.
В конце списка также выводится общее число таких нитей.

Команда GDB
...........

Часть 'info threads' предоставляет ту же информацию.

Пример
......

Кроме основного процесса нет ни одной нити:

     (gdb)
     -thread-list-ids
     ^done,thread-ids={},number-of-threads="0"
     (gdb)

   Несколько нитей:

     (gdb)
     -thread-list-ids
     ^done,thread-ids={thread-id="3",thread-id="2",thread-id="1"},
     number-of-threads="3"
     (gdb)

Команда '-thread-select'
------------------------

Краткое описание
................

      -thread-select НОМЕР-НИТИ

   Сделать нить НОМЕР-НИТИ текущей.  Команда выводит номер новой текущей
нити и самый верхний кадр для нее.

Команда GDB
...........

Соответствующей командой GDB является 'thread'.

Пример
......

     (gdb)
     -exec-next
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",thread-id="2",line="187",
     file="../../../devo/gdb/testsuite/gdb.threads/linux-dp.c"
     (gdb)
     -thread-list-ids
     ^done,
     thread-ids={thread-id="3",thread-id="2",thread-id="1"},
     number-of-threads="3"
     (gdb)
     -thread-select 3
     ^done,new-thread-id="3",
     frame={level="0 ",func="vprintf",
     args=[{name="format",value="0x8048e9c \"%*s%c %d %c\\n\""},
     {name="arg",value="0x2"}],file="vprintf.c",line="31"}
     (gdb)


File: gdb.html,  Node: Команды GDB/MI для точек трассировки,  Next: Изменяемые объекты GDB/MI,  Prev: Команды GDB/MI для нитей,  Up: GDB/MI

19.13 Команды GDB/MI для точек трассировки
==========================================

Команды для точек трассировки еще не реализованы.


File: gdb.html,  Node: Изменяемые объекты GDB/MI,  Prev: Команды GDB/MI для точек трассировки,  Up: GDB/MI

19.14 Изменяемые объекты GDB/MI
===============================

Обоснование для изменяемых объектов в GDB/MI
--------------------------------------------

Для реализации изменяемого отладочного окна (локальные переменные,
наблюдаемые выражения, и т.д.), мы предлагаем модификацию существующего
кода, используемого в 'Insight'.

   Вот две основные причины для этого:

  1. Он был проверен на практике (это уже его второе поколение).

  2. Это сократит время разработки (не стоит говорить, как это сейчас
     важно).

   Первоначальный интерфейс был разработан для использования из кода на
Tcl, так что он был немного изменен, чтобы его можно было использовать
через GDB/MI.  Этот раздел описывает операции GDB/MI, которые будут
доступны, и дает некоторые советы по их использованию.

   _Замечание_: В дополнение к описанному здесь набору операций, мы
ожидаем, что GUI-реализация изменяемого окна будет требовать, как
минимум, следующие операции:

   * '-gdb-show' 'output-radix'
   * '-stack-list-arguments'
   * '-stack-list-locals'
   * '-stack-select-frame'

Введение в изменяемые объекты в GDB/MI
--------------------------------------

Основной идеей изменяемых объектов является создание именованного
объекта для представления переменной, выражения, местоположения в памяти
или даже регистра ЦП. Для каждого созданного объекта существует набор
операций для изучения или изменения его свойств.

   Более того, сложные типы данных, такие как структуры Си, представлены
в древовидном формате.  Например, переменная типа 'struct' является
корнем, а потомки будут представлять элементы этой структуры.  Если
потомок сам является сложным типом, он также будет иметь своих потомков.
Соответствующие различия языков учитываются для Си, Си++ и Java.

   При возврате реальных значений объектов, эта возможность позволяет
отдельно выбирать формат отображения, используемый при создании
результата.  Формат может быть таким: двоичный, десятичный,
шестнадцатеричный, восьмеричный и обычный.  Обычный -- это формат по
умолчанию, выбираемый автоматически в зависимости от типа переменной
(например, десятичный для 'int', шестнадцатеричный для указателей, и
т.д.).

   Далее следует полный набор операций GDB/MI, определенный для доступа
к этим возможностям:

*Операция*                    *Описание*
                              
'-var-create'                 создать изменяемый объект
'-var-delete'                 удалить изменяемый объект и его потомков
'-var-set-format'             установить формат отображения для этой
                              переменной
'-var-show-format'            показать формат отображения для этой
                              переменной
'-var-info-num-children'      сообщает, сколько потомков имеет данный
                              объект
'-var-list-children'          возвращает список потомков объекта
'-var-info-type'              показать тип этого изменяемого объекта
'-var-info-expression'        напечатать, что представляет этот
                              изменяемый объект
'-var-show-attributes'        является ли эта переменная редактируемой?
                              она здесь существует?
'-var-evaluate-expression'    получить значение этой переменной
'-var-assign'                 установить значение этой переменной
'-var-update'                 скорректировать переменную и ее потомков

   В следующем подразделе мы подробно описываем каждую операцию и
предлагаем возможный способ ее использования.

Описание и использование операций для изменяемых объектов
---------------------------------------------------------

Команда '-var-create'
---------------------

Краткое описание
................

      -var-create {ИМЯ | "-"}
         {АДРЕС-КАДРА | "*"} ВЫРАЖЕНИЕ

   Данная операция создает изменяемый объект.  Это позволяет наблюдать
за переменной, результатом выражения, ячейкой памяти или регистром ЦП.

   Параметр ИМЯ является строкой, по которой можно ссылаться на объект.
Она должна быть уникальной.  Если указан '-', система изменяемых
объектов автоматически сгенерирует строку "varNNNNNN". Она будет
уникальной, при условии, что ИМЯ не будет указано в этом формате.
Команда завершается ошибкой, если найдено повторяющееся имя.

   В АДРЕСЕ-КАДРА может быть задан кадр, в котором должно быть вычислено
выражение.  '*' указывает, что должен использоваться текущий кадр.

   ВЫРАЖЕНИЕ -- это произвольное выражение, правильное в текущем наборе
языков (не должно начинаться со '*'), или одно из следующего:

   * '*АДРЕС', где АДРЕС есть адрес ячейки памяти

   * '*АДРЕС-АДРЕС' -- диапазон адресов памяти (TBD)

   * '$ИМЯ-РЕГ' -- имя регистра ЦП

Результат
.........

Эта операция возвращает имя, число потомков и тип созданного объекта.
Тип возвращается как строка, как будто она создана GDB CLI:

      name="ИМЯ",numchild="N",type="ТИП"

Команда '-var-delete'
---------------------

Краткое описание
................

      -var-delete ИМЯ

   Удаляет созданный ранее изменяемый объект и всех его потомков.

   Возвращает ошибку, если объект с именем ИМЯ не найден.

Команда '-var-set-format'
-------------------------

Краткое описание
................

      -var-set-format ИМЯ СПЕЦИФ-ФОРМАТА

   Устанавливает формат вывода в СПЕЦИФ-ФОРМАТА для значения объекта
ИМЯ.

   Синтаксис СПЕЦИФ-ФОРМАТА следующий:

      СПЕЦИФ-ФОРМАТА ==>
      {binary | decimal | hexadecimal | octal | natural}

Команда '-var-show-format'
--------------------------

Краткое описание
................

      -var-show-format ИМЯ

   Возвращает формат, используемый для отображения значений объекта ИМЯ.

      ФОРМАТ ==>
      СПЕЦИФ-ФОРМАТА

Команда '-var-info-num-children'
--------------------------------

Краткое описание
................

      -var-info-num-children ИМЯ

   Возвращает число потомков изменяемого объекта с именем ИМЯ:

      numchild=N

Команда '-var-list-children'
----------------------------

Краткое описание
................

      -var-list-children ИМЯ

   Возвращает список потомков указанного изменяемого объекта:

      numchild=N,children={{name=ИМЯ,
      numchild=N,type=ТИП},(повторяется N раз)}

Команда '-var-info-type'
------------------------

Краткое описание
................

      -var-info-type ИМЯ

   Возвращает тип указанного изменяемого объекта ИМЯ.  Тип возвращается
как строка в том же формате, в котором она выдается GDB CLI:

      type=ИМЯ-ТИПА

Команда '-var-info-expression'
------------------------------

Краткое описание
................

      -var-info-expression ИМЯ

   Возвращает то, что представляет изменяемый объект с именем ИМЯ:

      lang=СПЕЦИФ-ЯЗЫКА,exp=ВЫРАЖЕНИЕ

где СПЕЦИФ-ЯЗЫКА есть '{"C" | "C++" | "Java"}'.

Команда '-var-show-attributes'
------------------------------

Краткое описание
................

      -var-show-attributes ИМЯ

   Перечисляет атрибуты заданного изменяемого объекта ИМЯ:

      status=АТР [ ( ,АТР )* ]

где АТР есть '{ { editable | noneditable } | TBD }'.

Команда '-var-evaluate-expression'
----------------------------------

Краткое описание
................

      -var-evaluate-expression ИМЯ

   Вычисляет выражение, которое представлено указанным изменяемым
объектом и возвращает его значение в виде строки в текущем формате,
определенном для объекта:

      value=ЗНАЧЕНИЕ

Команда '-var-assign'
---------------------

Краткое описание
................

      -var-assign ИМЯ ВЫРАЖЕНИЕ

   Присваивает значение ВЫРАЖЕНИЯ изменяемому объекту, заданному ИМЕНЕМ.
Объект должен быть в состоянии 'editable'.

Команда '-var-update'
---------------------

Краткое описание
................

      -var-update {ИМЯ | "*"}

   Обновить значение изменяемого объекта с именем ИМЯ путем вычисления
его выражения, после получения всех новых значений из памяти или
регистров.  '*' приводит к обновлению всех существующих изменяемых
объектов.


File: gdb.html,  Node: Ошибки в GDB,  Next: Редактирование командной строки,  Prev: GDB/MI,  Up: Top

20 Отчеты об ошибках в GDB
**************************

Ваши отчеты об ошибках играют существенную роль в обеспечении надежности
GDB.

   Сообщение об ошибке может помочь вам найти решение вашей проблемы, а
может и не помочь.  Но в любом случае, основная функция отчета об ошибке
-- помочь всему обществу сделать следующую версию GDB лучше.  Отчеты об
ошибках -- это ваш вклад в поддержку GDB.

   Чтобы отчет об ошибке сделал свое дело, вы должны включить в него
информацию, которая даст нам возможность ее устранить.

* Menu:

* Критерий ошибки::             Вы нашли ошибку?
* Отчеты об ошибках::           Как составлять отчеты об ошибках


File: gdb.html,  Node: Критерий ошибки,  Next: Отчеты об ошибках,  Up: Ошибки в GDB

20.1 Вы нашли ошибку?
=====================

Если вы не уверены, нашли ли вы ошибку, вот несколько руководящих
принципов:

   * Если отладчик получает фатальный сигнал, то это ошибка в GDB,
     независимо от ввода.  В надежных отладчиках сбоев не бывает.

   * Если GDB выводит сообщение об ошибке для допустимого ввода -- это
     ошибка.  (Заметьте, что если вы выполняете кросс-отладку, проблема
     может возникать где-то в соединении к цели.)

   * Если GDB не выводит сообщение об ошибке для недопустимого ввода,
     это ошибка.  Однако вы должны обратить внимание, что если по вашему
     мнению что-то является "недопустимым вводом", по нашему мнению это
     может быть "расширением" или "поддержкой традиционной практики".

   * Если вы опытный пользователь средств отладки, ваши предложения по
     улучшению GDB приветствуются в любом случае.


File: gdb.html,  Node: Отчеты об ошибках,  Prev: Критерий ошибки,  Up: Ошибки в GDB

20.2 Как составлять отчеты об ошибках
=====================================

Некоторые компании и частные лица предлагают поддержку для программных
продуктов GNU.  Если вы получили GDB из организации поддержки, мы
рекомендуем вам сперва связаться с ней.

   Вы можете найти контактную информацию для многих организаций
поддержки и частных лиц в файле 'etc/SERVICE' в дистрибутиве GNU Emacs.

   В любом случае, мы также рекомендуем вам послать отчет об ошибке в
GDB по этому адресу:

     <bug-gdb@gnu.org>

   *Не посылайте отчеты об ошибках в 'info-gdb', или в 'help-gdb', или в
какую-либо группу новостей.*  Большинство пользователей GDB не хотят
получать отчеты об ошибках.  Те, кто этого действительно хочет, должны
получать 'bug-gdb'.

   Список рассылки 'bug-gdb' имеет группу новостей 'gnu.gdb.bug',
которая работает как повторитель.  Список рассылки и группа новостей
содержат в точности одинаковые сообщения.  Часто люди посылают сообщения
об ошибках в группу новостей вместо отправки по электронной почте.  Это
работает, но есть одна проблема, которая может стать решающей: сообщения
в группу новостей часто не несут информации об обратном адресе
отправителя.  Таким образом, если нам потребуется запросить
дополнительную информацию, у нас может не быть возможности связаться с
вами.  По этой причине лучше посылать отчеты об ошибках в список
рассылки.

   В крайнем случае посылайте отчеты об ошибках на бумаге по адресу:

     GNU Debugger Bugs
     Free Software Foundation Inc.
     59 Temple Place - Suite 330
     Boston, MA 02111-1307
     USA

   Основной принцип действенного составления отчетов об ошибках:
*сообщайте все факты*.  Если вы не уверены, оставить факт или исключить,
оставьте его!

   Часто люди опускают факты, потому что думают, что знают причины
проблемы, и полагают, что некоторые детали не имеют значения.  Например,
вы можете решить, что имя переменной, которую вы используете в примере,
не играет роли.  Возможно это так, но нельзя быть уверенным в этом.
Может быть, ошибкой является неверное обращение к памяти, которое
выбрало данные из ячеек, где хранилось это имя; возможно, если бы имя
было другим, содержимое этих ячеек ввело бы отладчик в заблуждение, и
ошибка не была бы замечена.  Относитесь к этому осторожно и приводите
конкретные, полные примеры.  Это самое простое, что вы можете сделать, и
наиболее полезное.

   Помните, что цель отчета об ошибке состоит в том, чтобы дать нам
возможность установить дефект.  Может случиться, что об этой ошибке нам
уже сообщали, но не вы, но мы не можем этого знать, если отчет об ошибке
не будет полным и самодостаточным.

   Иногда люди дают несколько поверхностных фактов и спрашивают, "не
говорит ли это об ошибке?".  Такие сообщения о дефектах бесполезны, и мы
убеждаем всех _отказываться отвечать на них_, за исключением того, чтобы
побудить автора отчета послать его правильно.

   Чтобы дать нам возможность устранить ошибку, вы должны включить в
сообщение следующее:

   * Версию GDB. GDB сообщает ее при вызове без параметров; вы можете
     также вывести ее в любой момент, используя 'show version'.

     Без этого мы не будем знать, имеет ли смысл поиск ошибки в текущей
     версии отладчика.

   * Тип машины, которой вы пользуетесь, название и номер версии
     операционной системы.

   * Какой компилятор (и его версия) использовался при компиляции GDB.
     Например, "gcc-2.8.1".

   * Какой компилятор (и его версия) использовался для компиляции
     отлаживаемой программы -- например "gcc-2.8.1" или "HP92453-01
     A.10.32.03 HP C Compiler".  Для gcc, вы можете использовать 'gcc
     --version', чтобы получить эту информацию; для других компиляторов,
     смотрите их документацию.

   * Параметры команды, которые вы дали компилятору для компиляции
     вашего примера, с которым вы наблюдали ошибку.  Например,
     использовали ли вы '-O'?  Для гарантии, что вы не пропустите
     что-нибудь важное, перечисляйте все.  Копии 'Makefile' (или
     результата вызова 'make') достаточно.

     Если мы должны будем угадывать аргументы, мы, возможно, сделаем это
     неправильно и можем не столкнуться с ошибкой.

   * Полный сценарий ввода и все необходимые исходные файлы, которые
     воспроизведут ошибку.

   * Описание наблюдаемого вами поведения, которое вы считаете
     ошибочным.  Например, "Это приводит к фатальному сигналу".

     Конечно, если ошибка состоит в получении GDB фатального сигнала, то
     мы, конечно, заметим это.  Но если ошибкой является некорректный
     вывод, мы можем не заметить этого, если это не бросается в глаза.
     Вы также можете не дать нам возможности ошибиться.

     Даже если ваша проблема заключается в фатальном сигнале, вы все же
     должны сообщить об этом явно.  Предположим, происходит что-то
     странное, например, ваша копия GDB рассинхронизировалась, или вы
     столкнулись с ошибкой в библиотеке Си вашей системы.  (Такое
     бывало!)  Ваша копия может завершиться аварийно, а наша нет.  Если
     вы предупредите нас об ожидаемой аварии, а в нашей системе этого не
     произойдет, мы будем знать, что ошибка произошла не из-за нас.
     Если вы нас не предупредите, мы не сможем сделать никаких выводов
     из наших наблюдений.

   * Если вы хотите предложить внести изменения в исходные тексты GDB,
     присылайте нам контекстные изменения.  Даже если вы желаете
     обсудить что-нибудь из исходных текстов, ссылайтесь по контексту, а
     не по номеру строки.

     Номера строк в наших исходных текстах разработки не будут
     соответствовать вашим.  Ваши номера строк не дадут нам никакой
     полезной информации.

   Вот некоторые вещи, не являющиеся обязательными:

   * Описание контекста ошибки.

     Часто люди, сталкивающиеся с ошибкой, тратят много времени на
     исследования, какие изменения входного файла приведут к ее
     исчезновению, а какие на нее не влияют.

     Это часто занимает много времени и приносит мало пользы, потому что
     мы найдем ошибку посредством выполнения одного примера под
     управлением отладчика с точками останова, а не чистыми выводами из
     серии примеров.  Мы рекомендуем вам сохранить это время для
     чего-нибудь другого.

     Конечно, если вы сможете найти более простой пример для отчета
     _вместо_ первоначального, это будет удобнее для нас.  Выделение
     ошибок в выводе будет проще, выполнение под управлением отладчика
     будет занимать меньше времени, и так далее.

     Однако, это упрощение не является жизненно важным; если вы не
     хотите делать этого, сообщайте об ошибке в любом случае и посылайте
     нам весь тестовый материал, который вы использовали.

   * Заплата для ошибки.

     Заплата для исправления ошибки действительно поможет нам, если это
     хорошая заплата.  Но не опускайте необходимую информацию, такую как
     тестовый пример, предполагая, что заплата это все, в чем мы
     нуждаемся.  Мы можем обнаружить проблемы с вашей заплатой и решить
     устранить ошибку другим путем, или мы можем вообще не понять смысл
     вашей заплаты.

     Иногда для такой сложной программы, как GDB, очень трудно создать
     пример, который заставит программу следовать по определенному пути
     в процессе выполнения.  Если вы не пришлете нам пример, мы не
     сможем сконструировать его сами, и таким образом не сможем
     проверить, что ошибка устранена.

     И если мы не сможем понять, какую ошибку вы пытаетесь исправить,
     или почему ваша заплата являются улучшением, мы не используем ее.
     Тестовый пример поможет нам во всем разобраться.

   * Предположения, в чем состоит ошибка, или от чего она зависит.

     Такие предположения обычно неверны.  Даже мы не можем сделать
     правильных предположений о такого рода вещах до запуска отладчика и
     выявления фактов.


File: gdb.html,  Node: Редактирование командной строки,  Next: Интерактивное использование истории,  Prev: Ошибки в GDB,  Up: Top

21 Редактирование командной строки
**********************************

Эта глава описывает основные возможности интерфейса редактирования
командной строки GNU.

* Menu:

* Введение и обозначения::         Обозначения, используемые в этом тексте.
* Взаимодействие с Readline::      Минимальный набор команд для редактирования
                                   командной строки.
* Файл инициализации Readline::    Настройка Readline с точки
                                   зрения пользователя
* Привязываемые команды Readline:: Описание большинства команд Readline,
                                   доступных для привязки.
* Режим vi Readline::              Короткое описание, как сделать поведение
                                   Readline похожим на редактор vi.


File: gdb.html,  Node: Введение и обозначения,  Next: Взаимодействие с Readline,  Up: Редактирование командной строки

21.1 Введение в редактирование строк
====================================

Следующие абзацы описывают нотацию, используемую для обозначения нажатия
клавиш.

   Текст 'C-k' читается как 'Control-K' и описывает знак, получаемый
нажатием клавиши <k> при нажатой клавише Control.

   Текст 'M-k' читается как 'Meta-K' и описывает знак, вводимый нажатием
клавиши <k> при нажатой клавише Meta (если у вас она имеется).  На
многих клавиатурах клавиша Meta надписана как <ALT>.  На клавиатурах с
двумя клавишами <ALT> (обычно по разные стороны от пробела), <ALT> на
левой стороне обычно устанавливается для работы клавишей Meta.  Правый
<ALT> также может быть сконфигурирован для работы Meta, или он может
быть сконфигурирован как другой модификатор, например как клавиша
Compose для ввода букв с акцентами.

   Если у вас нет клавиши Meta или <ALT> или другой клавиши, работающей
как Meta, идентичное нажатие клавиш можно получить нажав сначала <ESC>,
а затем <k>.  Эти процессы называются "метафикацией" клавиши <k>.

   Текст 'M-C-k' читается как 'Meta-Control-k' и описывает знак,
получаемый посредством "метафикации" 'C-k'.

   Кроме того, некоторые клавиши имеют собственные имена.  Именно,
<DEL>, <ESC>, <LFD>, <SPC>, <RET> и <TAB> в этом тексте или в файле
инициализации обозначают сами себя (*note Файл инициализации
Readline::).  Если на вашей клавиатуре нет клавиши <LFD>, нажатие 'C-j'
приведет к вводу желаемого знака.  Клавиша <RET> на некоторых
клавиатурах может быть отмечена как <Return> или <Enter>.


File: gdb.html,  Node: Взаимодействие с Readline,  Next: Файл инициализации Readline,  Prev: Введение и обозначения,  Up: Редактирование командной строки

21.2 Взаимодействие с Readline
==============================

Часто во время интерактивного сеанса вы вводите длинную строку текста и
только потом замечаете, что первое слово набрано неправильно.
Библиотека Readline дает вам набор команд для управления текстом во
время ввода, позволяя вам лишь исправить опечатку, а не набирать заново
большую часть строки.  С помощью этих команд редактирования, вы
перемещаете курсор в место, требующее исправления, и удаляете или
вставляете текст для коррекции.  Затем, когда строка полностью
исправлена, вы просто нажимаете <RET>.  Чтобы нажать <RET>, вам не
обязательно находиться в конце строки; вся строка вводится независимо от
расположения в ней курсора.

* Menu:

* Сведения первой необходимости:: Минимум, который вам необходимо
                                  знать о Readline.
* Команды перемещения Readline::  Перемещение по строке ввода.
* Команды уничтожения Readline::  Как уничтожить текст, и как его восстановить.
* Параметры команд Readline::     Задание числовых аргументов командам.
* Поиск в истории::               Поиск в предыдущих строках.


File: gdb.html,  Node: Сведения первой необходимости,  Next: Команды перемещения Readline,  Up: Взаимодействие с Readline

21.2.1 Сведения первой необходимости
------------------------------------

Для того, чтобы ввести знак в строку, просто нажмите его.  Введенный
знак появляется там, где был курсор, и затем курсор перемещается на одну
позицию вправо.  Если вы неверно набрали знак, вы можете использовать
ваш знак уничтожения, чтобы вернуться и удалить неверный знак.

   Иногда вы можете набрать знак ошибочно и не заметить ошибки, пока не
напечатаете несколько других знаков.  В этом случае, вы можете набрать
'C-b', чтобы переместить курсор влево, и затем исправить вашу ошибку.
После этого, вы можете переместить курсор вправо нажатием 'C-f'.

   Когда вы добавляете текст в середину строки, знаки справа от курсора
'сдвигаются вперед', чтобы освободить место для вставляемого текста.
Аналогично, когда вы удаляете текст за курсором, знаки справа от него
'сдвигаются назад', занимая пустое пространство, созданное в результате
удаления текста.  Ниже следует список команд первой необходимости для
редактирования вводимого текста.

'C-b'
     Переместиться назад на одну позицию.
'C-f'
     Переместиться вперед на одну позицию.
<DEL> или <Backspace>
     Удалить знак слева от курсора.
'C-d'
     Удалить знак под курсором.
Ввод знаков
     Вставить знак в строку в позицию курсора.
'C-_' или 'C-x C-u'
     Отменить последнюю команду редактирования.  Вы можете отменить все,
     вернувшись назад к пустой строке.

(В зависимости от вашей конфигурации, клавиша <Backspace> может быть
настроена удалять знак слева от курсора, а <DEL> удалять знак под
курсором, как 'C-d', вместо знака, расположенного от курсора слева.)


File: gdb.html,  Node: Команды перемещения Readline,  Next: Команды уничтожения Readline,  Prev: Сведения первой необходимости,  Up: Взаимодействие с Readline

21.2.2 Команды перемещения Readline
-----------------------------------

Приведенная выше таблица описывает только самые базовые
последовательности клавиш, которые могут вам понадобиться для
редактирования строки ввода.  Для удобства, в дополнение к 'C-b', 'C-f',
'C-d' и <DEL> были добавлены многие другие команды.  Вот некоторые из
них, предназначенные для более быстрого перемещения по строке.

'C-a'
     Переместиться в начало строки.
'C-e'
     Переместиться в конец строки.
'M-f'
     Переместиться вперед на слово.  Слово состоит из букв и цифр.
'M-b'
     Переместиться назад на слово.
'C-l'
     Очистить экран, напечатав текущую строку заново вверху экрана.

   Заметьте, что 'C-f' перемещает курсор вперед на один знак, в то время
как 'M-f' перемещает вперед на слово.  Это своего рода соглашение, что
при нажатии клавиши Сontrol производятся действия над знаками, а при
нажатии клавиши Meta -- над словами.


File: gdb.html,  Node: Команды уничтожения Readline,  Next: Параметры команд Readline,  Prev: Команды перемещения Readline,  Up: Взаимодействие с Readline

21.2.3 Команды уничтожения Readline
-----------------------------------

"Уничтожение" текста означает уничтожение текста из строки, но
сохранение его для дальнейшего использования, обычно для
"восстановления" (повторной вставки) обратно в строку.  ('Вырезать' и
'вставить' являются более современными жаргонными синонимами для
'уничтожить' и 'восстановить'.)

   Если в описании команды сказано, что она 'уничтожает' текст, то вы
можете быть уверены, что позже его можно будет получить обратно в другом
(или том же самом) месте.

   Когда вы используете команду уничтожения, текст сохраняется в
"кольцевом списке уничтожений".  Любое число последовательных
уничтожений сохраняет весь уничтоженный текст вместе, так что когда вы
восстанавливаете его назад, вы получите все.  Список уничтожений не
имеет привязки к строкам; текст, уничтоженный вами в предыдущей строке
ввода, доступен для восстановления позже, когда вы вводите другую
строку.

   Вот список команд для уничтожения текста.

'C-k'
     Уничтожить текст от текущей позиции курсора до конца строки.

'M-d'
     Уничтожить от курсора до конца текущего слова или, если курсор
     находится между словами, до конца следующего слова.  Границы слов
     такие же, как и используемые 'M-f'.

'M-<DEL>'
     Уничтожить от курсора до начала текущего слова или, если курсор
     находится между словами, до начала предыдущего слова.  Границы слов
     такие же, как и используемые 'M-b'.

'C-w'
     Уничтожить от курсора до предыдущего пробельного символа.  Это
     отличается от M-<DEL>, так как границы слова различаются.

   Вот как можно "восстановить" текст обратно в строку.  Восстановление
означает копирование последнего уничтоженного текста из буфера
уничтожений.

'C-y'
     Восстановить последний уничтоженный текст в буфер перед курсором.

'M-y'
     Циклический сдвиг по кольцевому списку уничтожений и восстановление
     новой вершины.  Вы можете использовать это, только если предыдущая
     команда была 'C-y' или 'M-y'.


File: gdb.html,  Node: Параметры команд Readline,  Next: Поиск в истории,  Prev: Команды уничтожения Readline,  Up: Взаимодействие с Readline

21.2.4 Параметры команд Readline
--------------------------------

Вы можете передавать числовые параметры командам Readline.  Иногда
параметр действует как счетчик повторений, иногда он является _знаком
минус_, если аргумент отрицателен.  Если вы передаете отрицательный
параметр команде, которая обычно действует в прямом направлении, то она
будет действовать в обратном направлении.  Например, чтобы уничтожить
текст до начала строки, вы можете набрать ''M--' 'C-k''.

   Общий способ передачи числовых параметров команде состоит в наборе
Meta-цифр перед командой.  Если первая набранная 'цифра' есть знак минус
('-'), тогда знак аргумента будет отрицательным.  Если вы набрали одну
мета-цифру для начала параметра, вы можете набрать оставшиеся цифры и
потом команду.  Например, чтобы передать команде 'C-d' параметр 10, вы
можете набрать ''M-1 0 C-d''.


File: gdb.html,  Node: Поиск в истории,  Prev: Параметры команд Readline,  Up: Взаимодействие с Readline

21.2.5 Поиск команд в истории
-----------------------------

Readline предоставляет команды для поиска в истории команд строк,
содержащих указанную подстроку.  Существует два режима поиска:
"наращиваемый" и "ненаращиваемый".

   Наращиваемый поиск начинается до того, как пользователь закончит ввод
строки поиска.  По мере ввода очередных знаков строки поиска, Readline
отображает следующий элемент из истории, соответствующий строке,
введенной на данный момент.  Наращиваемый поиск требует ровно столько
знаков, сколько требуется для нахождения желаемого элемента истории.
Для поиска определенной строки в истории в обратном направлении, введите
'C-r'.  Ввод 'C-s' производит поиск в прямом направлении.  Знаки,
присутствующие в значении переменной 'isearch-terminators', используются
для завершения наращиваемого поиска.  Если этой переменной не было
присвоено значение, знаки <ESC> и 'C-J' будут завершать наращиваемый
поиск.  'C-g' прерывает наращиваемый поиск и восстанавливает исходную
строку.  Когда поиск завершается, элемент истории, содержащий искомую
строку, становится текущей строкой.

   Для нахождения других подходящих элементов списка истории, введите
соответственно 'C-r' или 'C-s'.  Это произведет поиск вперед или назад в
истории до следующего элемента, соответствующего введенной строке
поиска.  Любая другая последовательность клавиш, привязанная к команде
Readline, завершит поиск и выполнит эту команду.  Например, <RET>
завершит поиск и примет эту строку, таким образом выполняя команду из
списка истории.

   Ненаращиваемый поиск считывает строку поиска целиком, до начала
поиска соответствующих строк истории.  Строка поиска может быть введена
пользователем или являться частью содержимого текущей строки.


File: gdb.html,  Node: Файл инициализации Readline,  Next: Привязываемые команды Readline,  Prev: Взаимодействие с Readline,  Up: Редактирование командной строки

21.3 Файл инициализации Readline
================================

Хотя библиотека Readline поставляется с установленным по умолчанию
набором привязок клавиш, аналогичному Emacs, возможно использование
другого набора привязок.  Любой пользователь может настраивать
программы, которые используют Readline, помещая команды в файл
"inputrc", обычно в своем домашнем каталоге.  Имя этого файла берется из
переменной среды 'INPUTRC'.  Если эта переменная не установлена, по
умолчанию берется файл '~/.inputrc'.

   Когда запускается программа, использующая библиотеку Readline, файл
инициализации считывается, и устанавливаются привязки клавиш.

   Кроме того, команда 'C-x C-r' считывает файл инициализации заново,
так что изменения, которые вы могли cделать к этому времени, вступают в
силу.

* Menu:

* Синтаксис файла инициализации Readline:: Синтаксис команд файла инициализации.
* Условные конструкции инициализации::     Условные привязки клавиш в
                                           файле инициализации.
* Пример файла инициализации::             Пример файла инициализации.


File: gdb.html,  Node: Синтаксис файла инициализации Readline,  Next: Условные конструкции инициализации,  Up: Файл инициализации Readline

21.3.1 Синтаксис файла инициализации Readline
---------------------------------------------

Существуют всего несколько конструкций, которые допускаются в файле
инициализации Readline.  Пустые строки игнорируются.  Строки,
начинающиеся с '#', являются комментариями.  Строки, начинающиеся с '$',
обозначают условные конструкции (*note Условные конструкции
инициализации::).  Другие строки обозначают установку переменных и
привязки клавиш.

Установка переменных
     Вы можете изменять поведение Readline во время выполнения
     посредством изменения значений переменных, используя команду 'set'
     в файле инициализации.  Вот как можно изменить привязку клавиш
     Emacs, используемую по умолчанию, для использования команд
     редактирования строки 'vi':

          set editing-mode vi

     Основная часть поведения при выполнении изменяется с помощью
     следующих переменных.

     'bell-style'
          Контролирует, что происходит, когда Readline хочет издать звук
          на терминале.  Если установлено в 'none', Readline никогда не
          издает звук.  Если установлено в 'visible', Readline
          использует визуальный звонок, если есть возможность.  Если
          установлено в 'audible' (по умолчанию), Readline пытается
          издать звук на терминале.

     'comment-begin'
          Строка для вставки в начало строки, когда выполняется команда
          'insert-comment'.  По умолчанию '"#"'.

     'completion-ignore-case'
          Если установлено в 'on', Readline производит проверку
          совпадений и завершение имени файла без учета регистра.  По
          умолчанию 'off'.

     'completion-query-items'
          Количество возможных завершений, определяющее, когда у
          пользователя запрашивается, хочет ли он увидеть список
          возможных вариантов.  Если число возможных завершений больше
          этого значения, Readline спросит у пользователя, хочет он их
          просмотреть или нет; в противном случае, они просто
          отображаются.  По умолчанию устанавливается предел '100'.

     'convert-meta'
          Если установлено в 'on', Readline будет преобразовывать знаки
          с установленным восьмым битом в последовательность клавиш
          ASCII, удаляя восьмой бит и подставляя в качестве префикса
          знак <ESC>, тем самым преобразовывая их в последовательность
          клавиш с Meta-префиксом.  По умолчанию 'on'.

     'disable-completion'
          Если установлено в 'on', Readline будет препятствовать
          завершению слов.  Знаки завершения будут вставляться в строку
          так, как если бы они отображались в 'self-insert'.  По
          умолчанию 'off'.

     'editing-mode'
          Переменная 'editing-mode' контролирует, какой набор привязок
          клавиш используется.  По умолчанию, Readline запускается в
          режиме редактирования Emacs, где нажатия клавиш очень похожи
          на Emacs.  Эта переменная может быть установлена или в
          'emacs', или в 'vi'.

     'enable-keypad'
          Когда установлено в 'on', Readline будет пытаться
          активизировать малую клавиатуру приложения, когда она
          вызывается.  Это требуется некоторым системам для активации
          клавиш со стрелками.  По умолчанию 'off'.

     'expand-tilde'
          Если установлено в 'on', производится раскрывание тильды,
          когда Readline осуществляет завершение слова.  По умолчанию
          'off'.

     'horizontal-scroll-mode'
          Эта переменная может быть установлена в 'on' или 'off'.
          Установка в 'on' означает, что текст в редактируемых строках
          будет прокручиваться горизонтально в одной строке экрана,
          когда ширина строки становится больше ширины экрана, вместо
          переноса на новую строку.  По умолчанию, эта переменная
          установлена в 'off'.

     'input-meta'
          Если установлено в 'on', Readline включит восьмибитный ввод
          (восьмой бит не будет удаляться из считываемых знаков)
          независимо от того, поддерживает ли это терминал.  Значение по
          умолчанию 'off'.  Имя 'meta-flag' является синонимом для этой
          переменной.

     'isearch-terminators'
          Строка из знаков, которые должны прекращать наращиваемый поиск
          без последующего выполнения знака как команды (*note Поиск в
          истории::).  Если этой переменной не присвоено значение,
          наращиваемый поиск прекращают знаки <ESC> и 'C-J'.

     'keymap'
          Устанавливает текущую раскладку клавиатуры Readline для
          привязок команд к клавишам.  Возможные имена для 'keymap':
          'emacs', 'emacs-standard', 'emacs-meta', 'emacs-ctlx', 'vi',
          'vi-command' и 'vi-insert'.  'vi' эквивалентно 'vi-command';
          'emacs' эквивалентно 'emacs-standard'.  Значение по умолчанию
          'emacs'.  Значение переменной 'editing-mode' также влияет на
          раскладку по умолчанию.

     'mark-directories'
          Если установлено в 'on', к именам каталогов после завершения
          добавляется косая черта.  По умолчанию 'on'.

     'mark-modified-lines'
          Эта переменная, будучи установлена в 'on', велит Readline
          отображать звездочку ('*') в начале тех строк истории, которые
          были модифицированы.  По умолчанию, эта переменная установлена
          в 'off'.

     'output-meta'
          Если установлено в 'on', Readline будет отображать знаки с
          установленным восьмым битом непосредственно, а не в виде
          экранирующих последовательностей с Meta-префиксом.  По
          умолчанию 'off'.

     'print-completions-horizontally'
          Если установлено в 'on', Readline будет отображать завершения,
          отсортированные горизонтально в алфавитном порядке, а не вниз
          по экрану.  По умолчанию 'off'.

     'show-all-if-ambiguous'
          Это изменяет поведение по умолчанию функций завершения.  При
          установке в 'on', если слово имеет более одного возможного
          завершения, они будут выводиться немедленно, вместо подачи
          сигнала.  По умолчанию 'off'.

     'visible-stats'
          Если установлено в 'on', при выводе возможных завершений, к
          имени файла добавляется знак, обозначающий тип файла.  По
          умолчанию 'off'.

Привязки клавиш
     Синтаксис для управления привязками клавиш в файле инициализации
     прост.  Во-первых, вы должны найти имя команды, которую вы хотите
     изменить.  Следующий раздел содержит таблицы с именем команды,
     привязкой клавиш по умолчанию, если таковые есть, и коротким
     описанием, что делает команда.

     Если вы знаете имя команды, просто поместите в строке файла
     инициализации название клавиши, к которой вы хотите привязать
     команду, двоеточие и затем имя команды.  Название клавиши может
     быть выражено различными способами, в зависимости от того, как вам
     удобнее.

     НАЗВ-КЛАВИШИ: ИМЯ-ФУНКЦИИ или МАКРОС
          НАЗВ-КЛАВИШИ -- это название клавиши, записанное по-английски.
          Например:
               Control-u: universal-argument
               Meta-Rubout: backward-kill-word
               Control-o: "> output"

          В этом примере, 'C-u' привязана к функции
          'universal-argument', а 'C-o' привязана к выполнению
          макрокоманды, записанной с правой стороны (то есть, вставить
          текст '> output' в строку).

     "ПОСЛЕД-КЛАВИШ": ИМЯ-ФУНКЦИИ или МАКРО
          ПОСЛЕД-КЛАВИШ отличается от вышеупомянутого НАЗВ-КЛАВИШИ тем,
          что позволяет определять строки, обозначающие целую
          последовательность клавиш, посредством ее заключения в двойные
          кавычки.  Могут быть использованы некоторые экранирующие
          последовательности в стиле GNU Emacs, как в следующем примере,
          но имена специальных знаков не распознаются.

               "\C-u": universal-argument
               "\C-x\C-r": re-read-init-file
               "\e[11~": "Function Key 1"

          В этом примере, 'C-u' привязывается к функции
          'universal-argument' (как это было в первом примере), ''C-x'
          'C-r'' привязывается к функции 're-read-init-file' и '<ESC> '[
          1 1 ~'' привязывается к вставке текста 'Function Key 1'.

     Следующие экранирующие последовательности в стиле GNU Emacs
     доступны при определении последовательности клавиш:

     '\C-'
          префикс Control
     '\M-'
          префикс Meta
     '\e'
          префикс экранирующего знака
     '\\'
          обратная косая черта
     '\"'
          <">, знак двойных кавычек
     '\''
          <'>, одинарная кавычка или апостроф

     В дополнение к экранирующим последовательностям стиля GNU Emacs,
     доступен второй набор последовательностей с обратной косой чертой:

     '\a'
          тревога (звуковой сигнал)
     '\b'
          переместиться назад на одну позицию
     '\d'
          удаление
     '\f'
          перевод страницы
     '\n'
          новая строка
     '\r'
          возврат каретки
     '\t'
          горизонтальная табуляция
     '\v'
          вертикальная табуляция
     '\NNN'
          знак, восьмеричное значение кода 'ASCII' которого есть NNN (от
          одной до трех цифр)
     '\xNNN'
          знак, шестнадцатеричное значение кода 'ASCII' которого есть
          NNN (от одной до трех цифр)

     При вводе текста макрокоманды, для обозначения ее определения
     должны использоваться одиночные или двойные кавычки.
     Предполагается, что текст без кавычек является именем функции.  В
     теле макрокоманды, экранирующие последовательности с обратной косой
     чертой раскрываются.  Обратная косая черта будет экранировать любой
     другой знак в тексте макрокоманды, включая '"' и '''.  Например,
     следующая привязка велит ''C-x' \' вставлять одиночную '\' в
     строку:
          "\C-x\\": "\\"


File: gdb.html,  Node: Условные конструкции инициализации,  Next: Пример файла инициализации,  Prev: Синтаксис файла инициализации Readline,  Up: Файл инициализации Readline

21.3.2 Условные конструкции инициализации
-----------------------------------------

Readline реализует возможности, аналогичные по смыслу возможностям
условной компиляции препроцессора Си, позволяющие производить привязки
клавиш и установку переменных в результате тестов.  Вот четыре
директивы, используемые анализатором.

'$if'
     Конструкция '$if' позволяет производить привязки в зависимости от
     режима редактирования, используемого терминала, или приложения,
     использующего Readline.  Содержимое теста продолжается до конца
     строки; для его ограничения не требуются никакие знаки.

     'mode'
          Форма 'mode=' директивы '$if' используется для проверки в
          каком из режимов находится Readline: 'emacs' или 'vi'.  Это
          может быть использовано, например, вместе с командой 'set
          keymap' для установки привязок в наборы 'emacs-standard' и
          'emacs-ctlx', только если Readline запускается в режиме
          'emacs'.

     'term'
          Форма 'term=' может использоваться для включения привязок
          клавиш, уникальных для какого-либо терминала, возможно для
          привязки вывода последовательности клавиш к функциональным
          клавишам терминала.  Слово, стоящее справа от '=',
          сравнивается как с полным названием терминала, так и с частью
          названия, идущей до первого '-'.  Это позволяет, например,
          опознавать как 'sun', так и 'sun-cmd'.

     'application'
          Конструкция APPLICATION используется для включения установок,
          уникальных для какого-либо приложения.  Каждая программа,
          использующая библиотеку Readline, устанавливает APPLICATION
          NAME, и вы можете проверить его.  Это может быть использовано
          для привязки последовательностей клавиш к функциям, полезным в
          конкретной программе.  Например, следующая команда добавляет
          последовательность, которая заключает в кавычки текущее или
          предыдущее слово в Bash:
               $if Bash
               # Quote the current or previous word
               "\C-xq": "\eb\"\ef\""
               $endif

'$endif'
     Эта команда, как показано в предыдущем примере, заканчивает команду
     '$if'.

'$else'
     Команды этой ветви директивы '$if' выполняются, если проверка
     заканчивается неудачей.

'$include'
     Эта директива принимает в качестве аргумента одно имя файла и
     считывает из него команды и привязки клавиш.
          $include /etc/inputrc


File: gdb.html,  Node: Пример файла инициализации,  Prev: Условные конструкции инициализации,  Up: Файл инициализации Readline

21.3.3 Пример файла инициализации
---------------------------------

Вот пример файла INPUTRC.  Он иллюстрирует привязки клавиш, присвоение
значений переменным и синтаксис условий.

     # Этот файл управляет поведением редактирования строки ввода в
     # программах, использующих библиотеку Gnu Readline.  Среди таких программ
     # FTP, Bash и Gdb.
     #
     # Вы можете заново считать файл inputrc с помощью C-x C-r.
     # Строки, начинающиеся с '#', являются комментариями.
     #
     # Сначала, включим все общесистемные привязки и переменные из
     # /etc/Inputrc
     $include /etc/Inputrc

     #
     # Установка различных привязок для режима emacs.

     set editing-mode emacs

     $if mode=emacs

     Meta-Control-h:	backward-kill-word	Текст после имени функции игнорируется

     #
     # Стрелки в режиме малой клавиатуры
     #
     #"\M-OD":        backward-char
     #"\M-OC":        forward-char
     #"\M-OA":        previous-history
     #"\M-OB":        next-history
     #
     # Стрелки в режиме ANSI
     #
     "\M-[D":        backward-char
     "\M-[C":        forward-char
     "\M-[A":        previous-history
     "\M-[B":        next-history
     #
     # Стрелки в восьмибитном режиме малой клавиатуры
     #
     #"\M-\C-OD":       backward-char
     #"\M-\C-OC":       forward-char
     #"\M-\C-OA":       previous-history
     #"\M-\C-OB":       next-history
     #
     # Стрелки в восьмибитном режиме ANSI
     #
     #"\M-\C-[D":       backward-char
     #"\M-\C-[C":       forward-char
     #"\M-\C-[A":       previous-history
     #"\M-\C-[B":       next-history

     C-q: quoted-insert

     $endif

     # Привязки старого стиля.  Устанавливается по умолчанию.
     TAB: complete

     # Макрокоманды, удобные при взаимодействии с оболочкой
     $if Bash
     # редактирование пути
     "\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
     # Подготовка к вводу слова в кавычках -- вставляет открывающуюся и
     # закрывающуюся двойные кавычки и помещает курсор сразу за открывающей
     "\C-x\"": "\"\"\C-b"
     # вставляет обратную косую черту (testing backslash escapes in sequences
     # and macros)  "\C-x\\": "\\"
     # Заключает в кавычки текущее или предыдущее слово
     "\C-xq": "\eb\"\ef\""
     # Добавляет привязку для обновления строки
     "\C-xr": redraw-current-line
     # Редактирование переменной в текущей строке
     "\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
     $endif

     # использовать визуальный звонок, если он доступен
     set bell-style visible

     # не урезать знаки при чтении до 7 бит
     set input-meta on

     # позволяет ввод знаков iso-latin1 вместо их преобразования к
     # последовательностям с Meta-префиксом
     # prefix-meta sequences
     set convert-meta off

     # отображает знаки непосредственно с установленным восьмым битом, а не
     # в виде знаков с Meta-префиксом
     set output-meta on

     # если существует более 150 возможных завершений слова, запросить
     # пользователя, хочет ли он видеть их все
     set completion-query-items 150

     # Для FTP
     $if Ftp
     "\C-xg": "get \M-?"
     "\C-xt": "put \M-?"
     "\M-.": yank-last-arg
     $endif


File: gdb.html,  Node: Привязываемые команды Readline,  Next: Режим vi Readline,  Prev: Файл инициализации Readline,  Up: Редактирование командной строки

21.4 Привязываемые команды Readline
===================================

* Menu:

* Команды для перемещения::     Перемещение по строке.
* Команды для истории::         Вызов предыдущих строк.
* Команды для текста::          Команды для изменения текста.
* Команды для уничтожения::     Команды для уничтожения и восстановления.
* Числовые параметры::          Задание числовых параметров,
                                счетчиков повторений.
* Команды для завершения::      Readline вводит за вас.
* Клавиатурные макросы::        Сохранений и повторное выполнений
                                введенных символов.
* Разные команды::              Прочие разные команды.

Этот раздел описывает команды Readline, которые могут быть привязаны к
последовательностям клавиш.


File: gdb.html,  Node: Команды для перемещения,  Next: Команды для истории,  Up: Привязываемые команды Readline

21.4.1 Команды для перемещения
------------------------------

'beginning-of-line (C-a)'
     Переместиться в начало текущей строки.

'end-of-line (C-e)'
     Переместиться в конец строки.

'forward-char (C-f)'
     Переместиться на один знак вперед.

'backward-char (C-b)'
     Переместиться назад на один знак.

'forward-word (M-f)'
     Переместиться вперед до конца следующего слова.  Слова составляются
     из букв и цифр.

'backward-word (M-b)'
     Переместиться назад к началу текущего или предыдущего слова.  Слова
     составляются из букв и цифр.

'clear-screen (C-l)'
     Очистить экран и перерисовать текущую строку, оставляя ее наверху
     экрана.

'redraw-current-line ()'
     Обновить текущую строку.  По умолчанию не привязана.


File: gdb.html,  Node: Команды для истории,  Next: Команды для текста,  Prev: Команды для перемещения,  Up: Привязываемые команды Readline

21.4.2 Команды для манипуляции историей
---------------------------------------

'accept-line (Newline, Return)'
     Ввод строки независимо от положения курсора.  Если строка непуста,
     добавить ее к списку истории.  Если эта строка была строкой
     истории, то восстановить строку истории до ее первоначального
     состояния.

'previous-history (C-p)'
     Переместиться 'вверх' по списку истории.

'next-history (C-n)'
     Переместиться 'вниз' по списку истории.

'beginning-of-history (M-<)'
     Переместиться к первой строке истории.

'end-of-history (M->)'
     Переместиться в конец истории ввода, то есть к строке, которая
     сейчас редактируется.

'reverse-search-history (C-r)'
     Обратный поиск начиная с текущей строки и перемещаясь по мере
     необходимости 'вверх' по истории.  Это наращиваемый поиск.

'forward-search-history (C-s)'
     Прямой поиск начиная с текущей строки и перемещаясь по мере
     необходимости 'вниз' по истории.  Это наращиваемый поиск.

'non-incremental-reverse-search-history (M-p)'
     Обратный поиск начиная с текущей строки и перемещаясь по мере
     необходимости 'вверх' по истории, используя ненаращиваемый поиск
     строки, заданной пользователем.

'non-incremental-forward-search-history (M-n)'
     Прямой поиск начиная с текущей строки и перемещаясь по мере
     необходимости 'вниз' по истории, используя ненаращиваемый поиск
     строки, заданной пользователем.

'history-search-forward ()'
     Прямой поиск в истории строки, состоящей из знаков между началом
     текущей строки и точкой.  Это ненаращиваемый поиск.  По умолчанию
     эта команда не привязана.

'history-search-backward ()'
     Обратный поиск в истории строки, состоящей из знаков между началом
     текущей строки и точкой.  Это ненаращиваемый поиск.  По умолчанию
     эта команда не привязана.

'yank-nth-arg (M-C-y)'
     Вставить первый аргумент предыдущей команды (обычно второе слово
     предыдущей строки).  С аргументом N, вставляет N-ное слово из
     предыдущей команды (слова в предыдущей команде начинаются со слова
     0).  Отрицательный аргумент вставляет N-ное с конца слово
     предыдущей команды.

'yank-last-arg (M-., M-_)'
     Вставить последний аргумент предыдущей команды (последнее слово
     предыдущего элемента истории).  С аргументом, ведет себя точно так
     же, как 'yank-nth-arg'.  Последовательные вызовы 'yank-last-arg'
     перемещают назад по списку истории, вставляя последний аргумент
     каждой строки по очереди.


File: gdb.html,  Node: Команды для текста,  Next: Команды для уничтожения,  Prev: Команды для истории,  Up: Привязываемые команды Readline

21.4.3 Команды для изменения текста
-----------------------------------

'delete-char (C-d)'
     Удалить знак в позиции курсора.  Если курсор находится в начале
     строки, в строке нет знаков и последний набранный знак не был
     привязан к 'delete-char', возвращает EOF.

'backward-delete-char (Rubout)'
     Удалить знак за курсором.  Числовой параметр предписывает
     уничтожать знаки, а не удалять их.

'forward-backward-delete-char ()'
     Удалить знак под курсором, если не находится в конце строки, в этом
     случае удаляется знак за курсором.  По умолчанию, эта функция не
     привязана к какой-либо клавише.

'quoted-insert (C-q, C-v)'
     Добавить в строку следующий введенный знак, каким бы он ни был.
     Таким образом можно вставить последовательность клавиш, например
     'C-q'.

'tab-insert (M-TAB)'
     Вставить знак табуляции.

'self-insert (a, b, A, 1, !, ...)'
     Эти знаки вставляют сами себя.

'transpose-chars (C-t)'
     Переместить знак перед курсором вперед за знак под курсором, также
     перемещая курсор вперед.  Если точка вставки находится в конце
     строки, то переставить последние два знака в строке.  Отрицательные
     аргументы не оказывают действия.

'transpose-words (M-t)'
     Переместить слово перед точкой за слово после точки.  Также
     перемещает точку за это слово.

'upcase-word (M-u)'
     Перевести в верхний регистр текущее (или следующее) слово.  С
     отрицательным аргументом, переводит в верхний регистр предыдущее
     слово, но не перемещает курсор.

'downcase-word (M-l)'
     Перевести в нижний регистр текущее (или следующее) слово.  С
     отрицательным аргументом переводит в нижний регистр предыдущее
     слово, но не перемещает курсор.

'capitalize-word (M-c)'
     Перевести текущее (или предыдущее) слово в нижний регистр с первой
     заглавной буквой.  С отрицательным аргументом, действует на
     предыдущее слово, но не перемещает курсор.


File: gdb.html,  Node: Команды для уничтожения,  Next: Числовые параметры,  Prev: Команды для текста,  Up: Привязываемые команды Readline

21.4.4 Уничтожение и восстановление
-----------------------------------

'kill-line (C-k)'
     Уничтожить текст от точки до конца строки.

'backward-kill-line (C-x Rubout)'
     Уничтожить назад до начала строки.

'unix-line-discard (C-u)'
     Уничтожить назад от курсора до начала текущей строки.

'kill-whole-line ()'
     Уничтожить все знаки в текущей строке, независимо от позиции точки.
     По умолчанию эта функция не привязана.

'kill-word (M-d)'
     Уничтожить от точки до конца текущего слова или, если курсор
     находится между словами, до конца следующего слова.  Границы слова
     такие же, как для 'forward-word'.

'backward-kill-word (M-DEL)'
     Уничтожить слово за точкой.  Границы слова такие же, как для
     'backward-word'.

'unix-word-rubout (C-w)'
     Уничтожает слово за точкой, используя в качестве границы слова
     пробелы.  Уничтоженный текст сохраняется в кольцевом списке
     уничтожений.

'delete-horizontal-space ()'
     Удалить все пробелы и знаки табуляции вокруг точки.  По умолчанию
     эта функция не привязана.

'kill-region ()'
     Уничтожить текст в текущей области.  Эта функция по умолчанию не
     привязана.

'copy-region-as-kill ()'
     Копировать текст области в буфер уничтожения, так что он может быть
     сразу восстановлен.  Эта команда по умолчанию не привязана.

'copy-backward-word ()'
     Копировать слово перед точкой в буфер уничтожений.  Границы слова
     такие же, как для 'backward-word'.  Эта команда по умолчанию не
     привязана.

'copy-forward-word ()'
     Копировать слово, следующее за точкой, в буфер уничтожений.
     Границы слова такие же, как для 'forward-word'.  Эта команда по
     умолчанию не привязана.

'yank (C-y)'
     Восстановить вершину кольцевого списка уничтожений в буфер в
     текущую позицию курсора.

'yank-pop (M-y)'
     Циклический сдвиг кольцевого списка уничтожений и восстановление
     новой вершины.  Вы можете использовать эту команду, только если
     предыдущей командой была 'yank' или 'yank-pop'.


File: gdb.html,  Node: Числовые параметры,  Next: Команды для завершения,  Prev: Команды для уничтожения,  Up: Привязываемые команды Readline

21.4.5 Определение числовых параметров
--------------------------------------

'digit-argument (M-0, M-1, ... M--)'
     Добавить эту цифру к вводимому аргументу или начать новый аргумент.
     'M--' начинает отрицательный аргумент.

'universal-argument ()'
     Это другой способ задать аргумент.  Если за этой командой следуют
     одна или несколько цифр, возможно со знаком минус в начале, то они
     определяют аргумент.  Если за командой следуют цифры, повторное
     выполнение 'universal-argument' заканчивает числовой аргумент, а в
     противном случае он игнорируется.  В особом случае, если
     непосредственно за этой командой следует или цифра, или знак минус,
     аргумент для следующей команды умножается на четыре.  Изначально
     аргумент равен единице, так что выполнение этой функции первый раз
     делает его равным четырем, второй раз -- шестнадцати, и так далее.
     По умолчанию эта функция не привязана к клавише.


File: gdb.html,  Node: Команды для завершения,  Next: Клавиатурные макросы,  Prev: Числовые параметры,  Up: Привязываемые команды Readline

21.4.6 Readline вводит за вас
-----------------------------

'complete (<TAB>)'
     Пытается завершить текст перед курсором.  Действие функции зависит
     от приложения.  Обычно, если вы вводите имя файла, вы можете
     выполнить завершение имени файла; если вы вводите команду, вы
     можете завершить команду; если вводите символ для GDB, можете
     выполнить завершение имени символа; если вы вводите переменную для
     Bash, можете завершить имя переменной, и так далее.

'possible-completions (M-?)'
     Перечислить возможные завершения текста перед курсором.

'insert-completions (M-*)'
     Вставить все завершения текста перед точкой, которые были бы
     созданы 'possible-completions'.

'menu-complete ()'
     Аналогично 'complete', но замещает завершаемое слово одним
     совпадением из списка возможных завершений.  Повторяемое выполнение
     'menu-complete' обходит список возможных завершений, вставляя
     каждое совпадение по очереди.  В конце списка завершений издается
     звуковой сигнал и восстанавливается исходный текст.  Аргумент N
     перемещает на N позиций вперед в списке совпадений; отрицательный
     аргумент может использоваться для перемещения по списку назад.  Эта
     команда предназначается для привязки к <TAB>, но по умолчанию не
     привязана.

'delete-char-or-list ()'
     Удаляет знак в позиции курсора, если он не находится в начале или
     конце строки (как 'delete-char').  Если курсор находится в конце
     строки, поведение аналогично 'possible-completions'.  Эта команда
     по умолчанию не привязана.


File: gdb.html,  Node: Клавиатурные макросы,  Next: Разные команды,  Prev: Команды для завершения,  Up: Привязываемые команды Readline

21.4.7 Клавиатурные макросы
---------------------------

'start-kbd-macro (C-x ()'
     Начать сохранение вводимых знаков в текущий клавиатурный макрос.

'end-kbd-macro (C-x ))'
     Прекратить сохранение вводимых знаков в текущий клавиатурный макрос
     и запомнить его определение.

'call-last-kbd-macro (C-x e)'
     Выполнить последний определенный клавиатурный макрос, выводя знаки
     макроса так, как если бы он набирался на клавиатуре.


File: gdb.html,  Node: Разные команды,  Prev: Клавиатурные макросы,  Up: Привязываемые команды Readline

21.4.8 Некоторые другие команды
-------------------------------

're-read-init-file (C-x C-r)'
     Считать содержимое файла INPUTRC и подключить любые найденные там
     привязки клавиш и присвоения переменных.

'abort (C-g)'
     Прервать текущую команду редактирования и издать звук на терминале
     (зависит от установки 'bell-style').

'do-uppercase-version (M-a, M-b, M-X, ...)'
     Если метафицированный знак X находится в нижнем регистре, выполнить
     команду, привязанную к соответствующему знаку в верхнем регистре.

'prefix-meta (<ESC>)'
     Метафицировать следующий введенный вами знак.  Это для клавиатур,
     не имеющих клавиши Meta.  Ввод '<ESC> f' эквивалентен вводу 'M-f'.

'undo (C-_, C-x C-u)'
     Наращиваемая отмена, запоминаемая отдельно для каждой строки.

'revert-line (M-r)'
     Отменить все изменения, сделанные в этой строке.  Это аналогично
     выполнению достаточного числа раз команды 'undo', чтобы вернуться в
     начало.

'tilde-expand (M-~)'
     Выполнить раскрывание знака тильды для текущего слова.

'set-mark (C-@)'
     Установить отметку в текущей точке.  Если задан числовой аргумент,
     отметка устанавливается в указанной позиции.

'exchange-point-and-mark (C-x C-x)'
     Поменять местами точку и отметку.  Текущая позиция курсора
     устанавливается в сохраненную позицию, а старое положение курсора
     запоминается как отметка.

'character-search (C-])'
     Считывается знак, и точка перемещается к следующему появлению этого
     знака.  Отрицательный аргумент производит поиск вхождения знака в
     обратном направлении.

'character-search-backward (M-C-])'
     Считывается знак, и точка перемещается к предыдущему появлению
     этого знака.  Отрицательный аргумент производит поиск последующих
     вхождений знака.

'insert-comment (M-#)'
     В начало текущей строки вставляется значение переменной
     'comment-begin', и эта строка вводится, как если бы был введен знак
     новой строки.

'dump-functions ()'
     Напечатать все функции и их привязки к клавишам в выходной поток
     Readline.  Если задан числовой аргумент, вывод форматируется так,
     чтобы его можно было вставить в файл INPUTRC.  По умолчанию эта
     команда не привязана.

'dump-variables ()'
     Напечатать все устанавливаемые переменные и их значения в выходной
     поток Readline.  Если задан числовой аргумент, вывод форматируется
     так, чтобы его можно было вставить в файл INPUTRC.  Эта команда по
     умолчанию не привязана.

'dump-macros ()'
     Напечатать все последовательности клавиш Readline, привязанные к
     макросам, и выводимые ими строки.  Если задан числовой аргумент,
     вывод форматируется так, чтобы его можно было вставить в файл
     INPUTRC.  Эта команда по умолчанию не привязана.


File: gdb.html,  Node: Режим vi Readline,  Prev: Привязываемые команды Readline,  Up: Редактирование командной строки

21.5 Режим vi Readline
======================

Хотя библиотека Readline не имеет полного набора функций редактирования
'vi', она все же содержит достаточно для простого редактирования строки.
Режим 'vi' Readline функционирует так, как определено в стандарте POSIX
1003.2.

   Для интерактивного переключения между режимами редактирования 'emacs'
и 'vi', используйте команду 'M-C-j' ('toggle-editing-mode').  По
умолчанию, Readline использует режим 'emacs'.

   Когда вы вводите строку в режиме 'vi', вы уже находитесь в режиме
'вставки', как если бы вы набрали 'i'.  Нажатие <ESC> переключает вас в
'командный' режим, в котором вы можете редактировать текст строки
стандартными клавишами перемещения 'vi', перемещаться к предыдущим
строкам истории посредством 'k' и к последующим строкам посредством 'j',
и так далее.


File: gdb.html,  Node: Интерактивное использование истории,  Next: Форматирование документации,  Prev: Редактирование командной строки,  Up: Top

22 Использование истории в интерактивном режиме
***********************************************

Эта глава описывает, как использовать библиотеку GNU History
интерактивно, c точки зрения пользователя.  Она должна рассматриваться
как руководство пользователя.

* Menu:

* Взаимодействие с историей::        Как выглядит использование истории с
                                     точки зрения пользователя.


File: gdb.html,  Node: Взаимодействие с историей,  Up: Интерактивное использование истории

22.1 Раскрывание истории
========================

Библиотека History обеспечивает средства раскрывания истории, подобные
предоставляемым 'csh'.  Этот раздел описывает синтаксис, использующийся
для управления информацией истории.

   Раскрывание истории вводит слова из списка истории во входной поток,
облегчая повторение команд, вставку аргументов предыдущей команды в
текущую строку ввода или быстрое устранение ошибок в предыдущей команде.

   Раскрывание истории происходит в два этапа.  Первый заключается в
определении, какая из строк списка истории должна использоваться в
процессе замены.  На втором этапе выбираются части этой строки для
включения в текущую.  Строка, выбранная из истории, называется
"событием", а использованные части называются "словами".  Существуют
различные "модификаторы" для манипулирования выбранными словами.  Строка
разбивается на слова так же, как это делает Bash, так что несколько
слов, заключенных в кавычки, рассматриваются как одно слово.
Раскрывания истории вводятся появлением специального знака, по умолчанию
это '!'.

* Menu:

* Указатели событий::   Как указать, какую строку истории использовать.
* Указатели слов::      Определение интересующих слов.
* Модификаторы::        Изменение результатов подстановки.


File: gdb.html,  Node: Указатели событий,  Next: Указатели слов,  Up: Взаимодействие с историей

22.1.1 Указатели событий
------------------------

Указатель событий является ссылкой на запись командной строки в списке
истории.

'!'
     Начать подстановку истории, если только за '!' не следует пробел,
     знак табуляции, знак конца строки, '=' или '('.

'!N'
     Сослаться на командную строку с номером N.

'!-N'
     Сослаться на командную строку, отстоящую на N строк назад.

'!!'
     Сослаться на предыдущую команду.  Это синоним для '!-1'.

'!СТРОКА'
     Сослаться на самую последнюю команду, начинающуюся со СТРОКИ.

'!?СТРОКА[?]'
     Сослаться на самую последнюю команду, содержащую СТРОКУ.  '?' в
     конце может быть опущен, если знак новой строки следует немедленно
     за СТРОКОЙ.

'^СТРОКА1^СТРОКА2^'
     Быстрая подстановка.  Повторяет последнюю команду, заменяя СТРОКУ1
     на СТРОКУ2.  Эквивалентно '!!:s/СТРОКА1/СТРОКА2/'.

'!#'
     Вся командная строка, введенная до этого момента.


File: gdb.html,  Node: Указатели слов,  Next: Модификаторы,  Prev: Указатели событий,  Up: Взаимодействие с историей

22.1.2 Указатели слов
---------------------

Указатели слов используются для выбора желаемых слов из события.
Спецификация события отделяется от указателя слова двоеточием.  Его
можно опустить, если указатель слова начинается с '^', '$', '*', '-' или
'%'.  Слова нумеруются от начала строки, причем первому слову
присваивается номер 0 (ноль).  Слова вставляются в текущую строку,
разделенные одиночными пробелами.

   Например,

'!!'
     обозначает предыдущую команду.  Когда вы это вводите, предыдущая
     команда повторяется один к одному.

'!!:$'
     обозначает последний аргумент предыдущей команды.  Это может быть
     сокращено как '!$'.

'!fi:2'
     обозначает второй аргумент самой последней команды, начинавшейся с
     букв 'fi'.

   Вот указатели слов:

'0 (ноль)'
     Нулевое слово.  Для многих приложений, это командное слово.

'N'
     N-ное слово.

'^'
     Первый аргумент, то есть слово 1.

'$'
     Последний аргумент.

'%'
     Слово, соответствующее самому последнему поиску '?СТРОКА?'.

'X-Y'
     Диапазон слов; '0-Y' сокращается как '-Y'.

'*'
     Все слова, за исключением нулевого.  Это синоним для '1-$'.  Даже
     если в событии имеется только одно слово, использование '*' не
     является ошибкой; в этом случае возвращается пустая строка.

'X*'
     Сокращение для 'X-$'

'X-'
     Сокращает 'X-$' как 'X*', но опускает последнее слово.

   Если указатель слова задается без указания события, в качестве
события используется предыдущая команда.


File: gdb.html,  Node: Модификаторы,  Prev: Указатели слов,  Up: Взаимодействие с историей

22.1.3 Модификаторы
-------------------

После необязательного указателя слова вы можете добавить
последовательность из одного или более следующих модификаторов, перед
каждым из которых ставится двоеточие.

'h'
     Удалить заключительную компоненту имени пути, оставляя только
     начальную.

'r'
     Удалить заключительный суффикс, имеющий форму '.СУФФИКС', оставляя
     базовое имя.

'e'
     Удалить все, кроме заключительного суффикса.

'p'
     Напечатать новую команду, но не выполнять ее.

's/СТАРОЕ/НОВОЕ/'
     Заменить первое появление СТАРОЕ на НОВОЕ в строке события.  На
     месте '/' может использоваться любой разделитель.  Разделитель
     может быть включен в СТАРОЕ или НОВОЕ с помощью обратной косой
     черты.  Если в НОВОЕ появляется знак '&', он заменяется на СТАРОЕ.
     Одиночная обратная косая черта экранирует '&'.  Заключительный
     разделитель необязателен, если он является последним знаком во
     входной строке.

'&'
     Повторить предыдущую подстановку.

'g'
     Велит применить изменения ко всей строке события.  Используется
     вместе с 's', как в 'gs/СТАРОЕ/НОВОЕ/', или с '&'.


File: gdb.html,  Node: Форматирование документации,  Next: Установка GDB,  Prev: Интерактивное использование истории,  Up: Top

Appendix A Форматирование документации
**************************************

Выпуск 4 GDB содержит уже отформатированную справочную карточку, готовую
к печати с PostScript или Ghostscript, в подкаталоге 'gdb' главного
исходного каталога(1).  Если вы можете использовать PostScript или
Ghostscript с вашим принтером, вы можете сразу распечатать справочную
карточку из 'refcard.ps'.

   Выпуск также включает исходный текст справочной карточки.  Вы можете
отформатировать ее при помощи TeX, набрав:

     make refcard.dvi

   Справочная карточка GDB разработана для печати в режиме "landscape"
на бумаге американского размера "letter"; то есть на листе шириной 11 и
высотой 8.5 дюймов.  Вы должны будете указать этот формат печати в
качестве ключа к вашей программе вывода DVI.

   Вся документация для GDB поставляется как часть машинно-читаемого
дистрибутива.  Документация написана в формате Texinfo, который является
системой построения документации, использующей один исходный файл для
создания как интерактивного, так и печатного руководства.  Вы можете
использовать одну из команд форматирования Info, чтобы создать
интерактивную версию документации, и TeX (или 'texi2roff') для создания
печатной версии.

   GDB включает уже отформатированную копию интерактивной версии Info
этого руководства в подкаталоге 'gdb'.  Основной файл Info --
'gdb-5.0/gdb/gdb.info', он ссылается на подчиненные файлы 'gdb.info*' в
том же каталоге.  В случае необходимости, вы можете распечатать эти
файлы или прочитать их в любом редакторе; но их легче прочитать,
используя подсистему 'info' в GNU Emacs или автономную программу 'info',
доступную как часть дистрибутива GNU Texinfo.

   Если вы хотите форматировать эти Info-файлы самостоятельно, вам нужна
одна из программ форматирования Info, например 'texinfo-format-buffer'
или 'makeinfo'.

   Если у вас установлена программа 'makeinfo', и вы находитесь на
верхнем уровне иерархии каталогов GDB ('gdb-5.0' в случае версии 5.0),
вы можете создать Info-файл, набрав:

     cd gdb
     make gdb.info

   Если вы хотите сформировать и распечатать копии этого руководства,
вам нужен TeX, программа печати его выходных DVI-файлов и файл
определений Texinfo 'texinfo.tex'.

   TeX -- это программа форматирования; она не печатает файлы
непосредственно, а создает выходные файлы, называемые DVI-файлами.
Чтобы напечатать сформатированный документ, вам нужна программа печати
DVI-файлов.  Если в вашей системе установлен TeX, в ней, скорее всего,
есть такая программа.  Какую точно команду нужно использовать зависит от
вашей системы; часто это 'lpr -d'; другая программа (для
PostScript-устройств) -- это 'dvips'.  Команда печати DVI-файлов может
требовать имя файла без расширения или с расширением '.dvi'.

   TeX также требует файл макроопределений 'texinfo.tex'.  Этот файл
сообщает TeX, как форматировать документ, написанный в формате Texinfo.
Сам по себе TeX не может читать или форматировать файл Texinfo.
'texinfo.tex' распространяется с GDB и размещается в каталоге
'gdb-НОМЕР-ВЕРСИИ/texinfo'.

   Если у вас установлены TeX и программа печати DVI, вы можете
отформатировать и распечатать это руководство.  Сначала перейдите в
подкаталог 'gdb' главного исходного каталога (например, в
'gdb-5.0/gdb'), и наберите:

     make gdb.dvi

   Это передаст 'gdb.dvi' вашей программе печати DVI.

   ---------- Footnotes ----------

   (1) В 'gdb-5.0/gdb/refcard.ps' в версии 5.0 выпуска.


File: gdb.html,  Node: Установка GDB,  Next: Алфавитный указатель,  Prev: Форматирование документации,  Up: Top

Appendix B Установка GDB
************************

GDB поставляется вместе со сценарием 'configure', который автоматизирует
процесс подготовки GDB к установке; затем вы можете использовать 'make'
для построения программы 'gdb'.

   Дистрибутив GDB включает весь исходный код, который вам понадобится
для GDB, в одном каталоге, имя которого обычно составляется добавлением
номера версии к 'gdb'.

   Например, дистрибутив GDB версии 5.0 находится в каталоге 'gdb-5.0'.
Этот каталог содержит:

'gdb-5.0/configure (и файлы поддержки)'
     сценарий для конфигурации GDB и всех поддерживаемых библиотек

'gdb-5.0/gdb'
     исходные тексты, специфичные для самого GDB

'gdb-5.0/bfd'
     исходные тексты для библиотеки описания двоичных файлов (Binary
     File Descriptor)

'gdb-5.0/include'
     включаемые файлы GNU

'gdb-5.0/libiberty'
     исходные тексты для библиотеки свободного программного обеспечения
     '-liberty'

'gdb-5.0/opcodes'
     исходные тексты библиотеки таблиц кодов операций и дисассемблеров

'gdb-5.0/readline'
     исходные тексты интерфейса командной строки GNU

'gdb-5.0/glob'
     исходные тексты подпрограммы GNU сопоставления с образцом имени
     файла

'gdb-5.0/mmalloc'
     исходные тексты пакета GNU для выделения памяти

   Простейший способ сконфигурировать и собрать GDB состоит в выполнении
'configure' из исходного каталога 'gdb-НОМЕР-ВЕРСИИ', который в этом
примере есть 'gdb-5.0'.

   Сперва перейдите в исходный каталог 'gdb-НОМЕР-ВЕРСИИ', если вы еще
не находитесь в нем; затем запустите 'configure'.  Передайте в качестве
аргумента идентификатор платформы, на которой будет выполняться GDB.

   Например:

     cd gdb-5.0
     ./configure ПЛАТФОРМА
     make

где ПЛАТФОРМА -- идентификатор, такой как 'sun4' или 'decstation',
задающий платформу, на которой будет выполняться GDB. (Часто вы можете
опустить ПЛАТФОРМУ; 'configure' пытается определить корректное значение,
изучая вашу систему.)

   Выполнение 'configure ПЛАТФОРМА' и затем 'make' строит библиотеки
'bfd', 'readline', 'mmalloc' и 'libiberty', а затем сам 'gdb'.
Сконфигурированные исходные файлы, а также двоичные файлы, остаются в
соответствующих исходных каталогах.

   'configure' является сценарием оболочки Bourne ('/bin/sh'); если ваша
система не распознает это автоматически, когда вы находитесь в другой
оболочке, вам может потребоваться выполнить 'sh' явно:

     sh configure ПЛАТФОРМА

   Если вы выполните 'configure' из каталога, содержащего исходные
каталоги для нескольких библиотек или программ, например 'gdb-5.0' для
версии 5.0, 'configure' создает файлы конфигурации для всех подкаталогов
низшего уровня (если вы не велите ему не этого делать ключом
'--norecursion').

   Вы можете выполнить сценарий 'configure' из любого подкаталога из
поставки GDB, если вы хотите сконфигурировать только этот подкаталог, но
убедитесь, что указали путь к нему.

   Например, для версии 5.0, чтобы сконфигурировать только подкаталог
'bfd', введите:

     cd gdb-5.0/bfd
     ../configure ПЛАТФОРМА

   Вы можете установить 'gdb' куда угодно; он не имеет никаких жестко
заданных путей.  Однако, вы должны удостовериться, что ваша оболочка
(определяемая переменной среды 'SHELL') доступна всем для чтения.
Помните, что GDB использует оболочку для запуска вашей программы --
некоторые системы не позволяют GDB отлаживать дочерние процессы, чьи
программы недоступны для чтения.

* Menu:

* Отдельный объектный каталог:: Компиляция GDB в другом каталоге
* Имена конфигураций::          Определение имен рабочих и целевых машин
* Ключи configure::             Обзор ключей для configure


File: gdb.html,  Node: Отдельный объектный каталог,  Next: Имена конфигураций,  Up: Установка GDB

B.1 Компиляция GDB в другом каталоге
====================================

Если вы хотите запускать версии GDB на нескольких рабочих или целевых
машинах, вам нужны различные 'gdb', скомпилированные для каждой
комбинации рабочей и целевой машины.  'configure' разработан так, чтобы
облегчить это, позволяя вам создавать каждую конфигурацию в отдельном
подкаталоге, а не в исходном каталоге.  Если ваша программа 'make'
поддерживает возможности 'VPATH' (GNU 'make' поддерживает), вызов 'make'
в каждом из этих каталогов строит программу 'gdb', определенную там.

   Чтобы построить 'gdb' в отдельном каталоге, запустите 'configure' с
ключом '--srcdir', для определения, где искать исходники.  (Вам также
нужно определить путь для поиска 'configure' из вашего рабочего
каталога.  Если путь к 'configure' совпадает с параметром '--srcdir',
ключ '--srcdir' можно опустить; он подразумевается.)

   Например, в версии 5.0, вы можете построить GDB в отдельном каталоге
для Sun 4 так:

     cd gdb-5.0
     mkdir ../gdb-sun4
     cd ../gdb-sun4
     ../gdb-5.0/configure sun4
     make

   Когда 'configure' строит конфигурацию, используя удаленный каталог с
исходниками, он создает дерево для двоичных файлов с той же структурой
(и используя те же имена), что и дерево каталогов с исходными текстами.
В этом примере, вы бы нашли библиотеку Sun 4 'libiberty.a' в каталоге
'gdb-sun4/libiberty', а сам GDB -- в 'gdb-sun4/gdb'.

   Одна из распространенных причин построения нескольких конфигураций
GDB в отдельных каталогах состоит в том, чтобы конфигурировать GDB для
кросс-компиляции (где GDB запускается на одной машине -- "рабочей", в то
время как отлаживаемые программы выполняются на другой машине --
"целевой").  Вы определяете целевую машину кросс-отладки ключом
'configure' '--target=ЦЕЛЬ'.

   Когда вы выполняете 'make' для построения программы или библиотеки,
вы должны выполнять ее из сконфигурированного каталога -- того каталога,
из которого вы вызывали 'configure' (или из одного из его подкаталогов).

   'Makefile', который создает 'configure' в каждом исходном каталоге,
также выполняется рекурсивно.  Если вы ввели 'make' в каталоге с
исходными файлами, например в 'gdb-5.0' (или в каталоге,
сконфигурированном отдельно посредством
'--srcdir=ИМЯ-КАТАЛОГА/gdb-5.0'), вы построите все требуемые библиотеки
и затем GDB.

   Когда у вас имеется несколько рабочих или целевых конфигураций в
отдельных каталогах, вы можете запустить 'make' для них параллельно
(например, если они смонтированы по NFS на каждой рабочей машине); они
не будут конфликтовать друг с другом.


File: gdb.html,  Node: Имена конфигураций,  Next: Ключи configure,  Prev: Отдельный объектный каталог,  Up: Установка GDB

B.2 Определение имен рабочих и целевых машин
============================================

Спецификации, использованные для рабочих и целевых машин в сценарии
'configure', именуются в соответствии со схемой именования, состоящей из
трех частей, но поддерживаются также некоторые короткие предопределенные
синонимы.  Полная схема именования кодирует три фрагмента информации по
следующему образцу:

     АРХИТЕКТУРА-ПРОИЗВОДИТЕЛЬ-ОС

   Например, вы можете использовать синоним 'sun4' как параметр
ПЛАТФОРМА или как значение ЦЕЛЬ в ключе '--target=ЦЕЛЬ'.  Эквивалентное
полное имя -- 'sparc-sun-sunos4'.

   Сценарий 'configure', сопровождающий GDB, не предоставляет никаких
средств для запроса вывода всех поддерживаемых имен рабочих и целевых
машин или их сокращений.  'configure' вызывает сценарий оболочки Bourne
'config.sub' для отображения сокращений в полные имена; при желании, вы
можете посмотреть сценарий или использовать его для проверки ваших
предположений о сокращениях.  Например:

     % sh config.sub i386-linux
     i386-pc-linux-gnu
     % sh config.sub alpha-linux
     alpha-unknown-linux-gnu
     % sh config.sub hp9k700
     hppa1.1-hp-hpux
     % sh config.sub sun4
     sparc-sun-sunos4.1.1
     % sh config.sub sun3
     m68k-sun-sunos4.1.1
     % sh config.sub i986v
     Invalid configuration `i986v': machine `i986v' not recognized

'config.sub' также распространяется в исходном каталоге GDB ('gdb-5.0',
для версии 5.0).


File: gdb.html,  Node: Ключи configure,  Prev: Имена конфигураций,  Up: Установка GDB

B.3 Ключи 'configure'
=====================

Здесь приводится обзор ключей и параметров 'configure', которые наиболее
часто используются для построения GDB. 'configure' также имеет несколько
других ключей, не представленных здесь.  *note (configure.info)What
Configure Does::, для полного объяснения 'configure'.

     configure [--help]
               [--prefix=КАТАЛОГ]
               [--exec-prefix=КАТАЛОГ]
               [--srcdir=ИМЯ-КАТАЛОГА]
               [--norecursion] [--rm]
               [--target=ЦЕЛЬ]
               ПЛАТФОРМА

Если хотите, можете вводить ключи с одним '-', а не с '--'; но если вы
используете '--', вы можете сокращать имена ключей.

'--help'
     Отображает краткий обзор, как вызывать 'configure'.

'--prefix=КАТАЛОГ'
     Конфигурировать исходник для установки программ и файлов в
     подкаталогах 'КАТАЛОГА'.

'--exec-prefix=КАТАЛОГ'
     Конфигурировать исходник для установки программ в каталог
     'КАТАЛОГ'.

'--srcdir=ИМЯ-КАТАЛОГА'
     *Предупреждение: использование этого ключа требует GNU 'make' или
     другой программы 'make', реализующей возможности 'VPATH'.*
     Используйте этот ключ для создания конфигураций в каталогах,
     отдельных от исходного каталога GDB. Кроме всего прочего, вы можете
     использовать его для построения (или поддержки) нескольких
     конфигураций одновременно в отдельных каталогах.  'configure'
     записывает файлы, относящиеся к конфигурации, в текущий каталог, но
     принимает меры, чтобы можно было использовать исходники в каталоге
     ИМЯ-КАТАЛОГА.  'configure' создает каталоги внутри рабочего
     каталога параллельно с исходными каталогами внутри ИМЯ-КАТАЛОГА.

'--norecursion'
     Конфигурировать только тот уровень каталогов, где выполняется
     'configure'; не распространять конфигурацию на подкаталоги.

'--target=ЦЕЛЬ'
     Конфигурировать GDB для кросс-отладки программ, выполняемых на
     указанной ЦЕЛИ.  Без этого ключа GDB конфигурируется для отладки
     программ, выполняемых на той же машине (ПЛАТФОРМЕ), что и сам GDB.

     Нет никакого удобного способа сгенерировать список всех доступных
     целей.

'ПЛАТФОРМА ...'
     Конфигуровать GDB для выполнения на указанной ПЛАТФОРМЕ.

     Нет никакого удобного способа сгенерировать список всех допустимых
     платформ.

   Существует также много других ключей, но обычно они требуются только
для специальных целей.


File: gdb.html,  Node: Алфавитный указатель,  Prev: Установка GDB,  Up: Top

Алфавитный указатель
********************

 [index ]
* Menu:

* "No symbol "foo" in current context":  Переменные.          (line  78)
* #:                                     Синтаксис команд.    (line  36)
* # (комментарий):                       Синтаксис команд.    (line  36)
* # в Модуле-2:                          GDB и Модула-2.      (line  19)
* $:                                     История значений.    (line  14)
* $$:                                    История значений.    (line  14)
* $bpnum, вспомогательная переменная:    Установка точек останова.
                                                              (line   6)
* $cdir, вспомогательная переменная:     Пути для исходных файлов.
                                                              (line  40)
* $cwd, вспомогательная переменная:      Пути для исходных файлов.
                                                              (line  40)
* $_ и info breakpoints:                 Установка точек останова.
                                                              (line 137)
* $_ и info line:                        Машинный код.        (line  32)
* $_, $__ и история значений:            Память.              (line  91)
* $_, вспомогательная переменная:        Вспомогательные переменные.
                                                              (line  55)
* $_exitcode, вспомогательная переменная: Вспомогательные переменные.
                                                              (line  71)
* $__, вспомогательная переменная:       Вспомогательные переменные.
                                                              (line  64)
* --annotate:                            Параметры режима.    (line  73)
* --async:                               Параметры режима.    (line  83)
* --batch:                               Параметры режима.    (line  23)
* --baud:                                Параметры режима.    (line 102)
* --cd:                                  Параметры режима.    (line  51)
* --command:                             Параметры файлов.    (line  48)
* --core:                                Параметры файлов.    (line  38)
* --directory:                           Параметры файлов.    (line  53)
* --epoch:                               Параметры режима.    (line  67)
* --exec:                                Параметры файлов.    (line  29)
* --fullname:                            Параметры режима.    (line  56)
* --interpreter:                         Параметры режима.    (line 112)
* --mapped:                              Параметры файлов.    (line  57)
* --noasync:                             Параметры режима.    (line  98)
* --nowindows:                           Параметры режима.    (line  40)
* --nx:                                  Параметры режима.    (line  11)
* --quiet:                               Параметры режима.    (line  19)
* --readnow:                             Параметры файлов.    (line  75)
* --se:                                  Параметры файлов.    (line  33)
* --silent:                              Параметры режима.    (line  19)
* --statistics:                          Параметры режима.    (line 125)
* --symbols:                             Параметры файлов.    (line  25)
* --tty:                                 Параметры режима.    (line 108)
* --version:                             Параметры режима.    (line 129)
* --windows:                             Параметры режима.    (line  47)
* --write:                               Параметры режима.    (line 120)
* -b:                                    Параметры режима.    (line 102)
* -break-after:                          Команды GDB/MI для таблицы точек останова.
                                                              (line  11)
* -break-condition:                      Команды GDB/MI для таблицы точек останова.
                                                              (line  52)
* -break-delete:                         Команды GDB/MI для таблицы точек останова.
                                                              (line  89)
* -break-disable:                        Команды GDB/MI для таблицы точек останова.
                                                              (line 123)
* -break-enable:                         Команды GDB/MI для таблицы точек останова.
                                                              (line 158)
* -break-info:                           Команды GDB/MI для таблицы точек останова.
                                                              (line 192)
* -break-insert:                         Команды GDB/MI для таблицы точек останова.
                                                              (line 212)
* -break-list:                           Команды GDB/MI для таблицы точек останова.
                                                              (line 293)
* -break-watch:                          Команды GDB/MI для таблицы точек останова.
                                                              (line 361)
* -c:                                    Параметры файлов.    (line  38)
* -d:                                    Параметры файлов.    (line  53)
* -data-disassemble:                     Управление данными GDB/MI.
                                                              (line  12)
* -data-evaluate-expression:             Управление данными GDB/MI.
                                                              (line 131)
* -data-list-changed-registers:          Управление данными GDB/MI.
                                                              (line 170)
* -data-list-register-names:             Управление данными GDB/MI.
                                                              (line 205)
* -data-list-register-values:            Управление данными GDB/MI.
                                                              (line 244)
* -data-read-memory:                     Управление данными GDB/MI.
                                                              (line 329)
* -display-delete:                       Управление данными GDB/MI.
                                                              (line 436)
* -display-disable:                      Управление данными GDB/MI.
                                                              (line 457)
* -display-enable:                       Управление данными GDB/MI.
                                                              (line 477)
* -display-insert:                       Управление данными GDB/MI.
                                                              (line 497)
* -display-list:                         Управление данными GDB/MI.
                                                              (line 517)
* -e:                                    Параметры файлов.    (line  29)
* -environment-cd:                       Управление данными GDB/MI.
                                                              (line 538)
* -environment-directory:                Управление данными GDB/MI.
                                                              (line 561)
* -environment-path:                     Управление данными GDB/MI.
                                                              (line 584)
* -environment-pwd:                      Управление данными GDB/MI.
                                                              (line 607)
* -exec-abort:                           Управление программой GDB/MI.
                                                              (line  46)
* -exec-arguments:                       Управление программой GDB/MI.
                                                              (line  66)
* -exec-continue:                        Управление программой GDB/MI.
                                                              (line  87)
* -exec-finish:                          Управление программой GDB/MI.
                                                              (line 115)
* -exec-interrupt:                       Управление программой GDB/MI.
                                                              (line 157)
* -exec-next:                            Управление программой GDB/MI.
                                                              (line 197)
* -exec-next-instruction:                Управление программой GDB/MI.
                                                              (line 223)
* -exec-return:                          Управление программой GDB/MI.
                                                              (line 253)
* -exec-run:                             Управление программой GDB/MI.
                                                              (line 294)
* -exec-show-arguments:                  Управление программой GDB/MI.
                                                              (line 325)
* -exec-step:                            Управление программой GDB/MI.
                                                              (line 345)
* -exec-step-instruction:                Управление программой GDB/MI.
                                                              (line 385)
* -exec-until:                           Управление программой GDB/MI.
                                                              (line 423)
* -f:                                    Параметры режима.    (line  56)
* -file-exec-and-symbols:                Управление программой GDB/MI.
                                                              (line 454)
* -file-exec-file:                       Управление программой GDB/MI.
                                                              (line 482)
* -file-list-exec-sections:              Управление программой GDB/MI.
                                                              (line 509)
* -file-list-exec-source-files:          Управление программой GDB/MI.
                                                              (line 531)
* -file-list-shared-libraries:           Управление программой GDB/MI.
                                                              (line 552)
* -file-list-symbol-files:               Управление программой GDB/MI.
                                                              (line 572)
* -file-symbol-file:                     Управление программой GDB/MI.
                                                              (line 592)
* -gdb-exit:                             Разные команды GDB/MI.
                                                              (line   9)
* -gdb-set:                              Разные команды GDB/MI.
                                                              (line  30)
* -gdb-show:                             Разные команды GDB/MI.
                                                              (line  53)
* -gdb-version:                          Разные команды GDB/MI.
                                                              (line  76)
* -m:                                    Параметры файлов.    (line  57)
* -n:                                    Параметры режима.    (line  11)
* -nw:                                   Параметры режима.    (line  40)
* -q:                                    Параметры режима.    (line  19)
* -r:                                    Параметры файлов.    (line  75)
* -s:                                    Параметры файлов.    (line  25)
* -stack-info-depth:                     Управление стеком GDB/MI.
                                                              (line  30)
* -stack-info-frame:                     Управление стеком GDB/MI.
                                                              (line   9)
* -stack-list-arguments:                 Управление стеком GDB/MI.
                                                              (line  68)
* -stack-list-frames:                    Управление стеком GDB/MI.
                                                              (line 143)
* -stack-list-locals:                    Управление стеком GDB/MI.
                                                              (line 233)
* -stack-select-frame:                   Управление стеком GDB/MI.
                                                              (line 262)
* -symbol-info-address:                  Запросы GDB/MI о символах.
                                                              (line   9)
* -symbol-info-file:                     Запросы GDB/MI о символах.
                                                              (line  29)
* -symbol-info-function:                 Запросы GDB/MI о символах.
                                                              (line  49)
* -symbol-info-line:                     Запросы GDB/MI о символах.
                                                              (line  69)
* -symbol-info-symbol:                   Запросы GDB/MI о символах.
                                                              (line  90)
* -symbol-list-functions:                Запросы GDB/MI о символах.
                                                              (line 110)
* -symbol-list-types:                    Запросы GDB/MI о символах.
                                                              (line 130)
* -symbol-list-variables:                Запросы GDB/MI о символах.
                                                              (line 151)
* -symbol-locate:                        Запросы GDB/MI о символах.
                                                              (line 171)
* -symbol-type:                          Запросы GDB/MI о символах.
                                                              (line 189)
* -t:                                    Параметры режима.    (line 108)
* -target-attach:                        Управление целью GDB/MI.
                                                              (line   9)
* -target-compare-sections:              Управление целью GDB/MI.
                                                              (line  29)
* -target-detach:                        Управление целью GDB/MI.
                                                              (line  50)
* -target-download:                      Управление целью GDB/MI.
                                                              (line  73)
* -target-exec-status:                   Управление целью GDB/MI.
                                                              (line 171)
* -target-list-available-targets:        Управление целью GDB/MI.
                                                              (line 192)
* -target-list-current-targets:          Управление целью GDB/MI.
                                                              (line 212)
* -target-list-parameters:               Управление целью GDB/MI.
                                                              (line 233)
* -target-select:                        Управление целью GDB/MI.
                                                              (line 251)
* -thread-info:                          Команды GDB/MI для нитей.
                                                              (line   9)
* -thread-list-all-threads:              Команды GDB/MI для нитей.
                                                              (line  27)
* -thread-list-ids:                      Команды GDB/MI для нитей.
                                                              (line  45)
* -thread-select:                        Команды GDB/MI для нитей.
                                                              (line  79)
* -var-assign:                           Изменяемые объекты GDB/MI.
                                                              (line 247)
* -var-create:                           Изменяемые объекты GDB/MI.
                                                              (line  88)
* -var-delete:                           Изменяемые объекты GDB/MI.
                                                              (line 126)
* -var-evaluate-expression:              Изменяемые объекты GDB/MI.
                                                              (line 233)
* -var-info-expression:                  Изменяемые объекты GDB/MI.
                                                              (line 205)
* -var-info-num-children:                Изменяемые объекты GDB/MI.
                                                              (line 167)
* -var-info-type:                        Изменяемые объекты GDB/MI.
                                                              (line 192)
* -var-list-children:                    Изменяемые объекты GDB/MI.
                                                              (line 179)
* -var-set-format:                       Изменяемые объекты GDB/MI.
                                                              (line 138)
* -var-show-attributes:                  Изменяемые объекты GDB/MI.
                                                              (line 219)
* -var-show-format:                      Изменяемые объекты GDB/MI.
                                                              (line 154)
* -var-update:                           Изменяемые объекты GDB/MI.
                                                              (line 258)
* -w:                                    Параметры режима.    (line  47)
* -x:                                    Параметры файлов.    (line  48)
* ., оператор области видимости Модулы-2: Область видимости в Модуле-2.
                                                              (line   6)
* .esgdbinit:                            Командные файлы.     (line  41)
* .gdbinit:                              Командные файлы.     (line  11)
* .os68gdbinit:                          Командные файлы.     (line  39)
* .vxgdbinit:                            Командные файлы.     (line  37)
* /proc:                                 Информация о процессах SVR4.
                                                              (line   6)
* @, ссылка на память как на массив:     Массивы.             (line   6)
* ^done:                                 Результирующие записи GDB/MI.
                                                              (line   9)
* ^error:                                Результирующие записи GDB/MI.
                                                              (line  17)
* ^running:                              Результирующие записи GDB/MI.
                                                              (line  14)
* {ТИП}:                                 Выражения.           (line  46)
* a.out и Си++:                          Выражения Си++.      (line   9)
* abort (C-g):                           Разные команды.      (line  10)
* accept-line (Newline, Return):         Команды для истории. (line   6)
* add-shared-symbol-file:                Файлы.               (line 168)
* add-symbol-file:                       Файлы.               (line 142)
* Alpha, стек:                           MIPS.                (line   6)
* AMD EB29K:                             Встроенный A29K.     (line  18)
* AMD29K через UDI:                      A29K UDI.            (line   6)
* AMD29K, стек регистров:                A29K.                (line   6)
* apropos:                               Справка.             (line  62)
* arg-begin:                             Примечания к значениям.
                                                              (line  32)
* arg-end:                               Примечания к значениям.
                                                              (line  32)
* arg-name-end:                          Примечания к значениям.
                                                              (line  32)
* arg-value:                             Примечания к значениям.
                                                              (line  32)
* array-section-end:                     Примечания к значениям.
                                                              (line  91)
* attach:                                Присоединение.       (line   6)
* awatch:                                Установка точек наблюдения.
                                                              (line  31)
* b (break):                             Установка точек останова.
                                                              (line   6)
* backtrace:                             Цепочки вызовов.     (line  12)
* backward-char (C-b):                   Команды для перемещения.
                                                              (line  15)
* backward-delete-char (Rubout):         Команды для текста.  (line  11)
* backward-kill-line (C-x Rubout):       Команды для уничтожения.
                                                              (line   9)
* backward-kill-word (M-DEL):            Команды для уничтожения.
                                                              (line  24)
* backward-word (M-b):                   Команды для перемещения.
                                                              (line  22)
* beginning-of-history (M-<):            Команды для истории. (line  18)
* beginning-of-line (C-a):               Команды для перемещения.
                                                              (line   6)
* bell-style:                            Синтаксис файла инициализации Readline.
                                                              (line  26)
* break:                                 Установка точек останова.
                                                              (line   6)
* break ... thread НОМЕР-НИТИ:           Остановка нитей.     (line  10)
* breakpoint:                            Примечания к выполнению.
                                                              (line  47)
* breakpoints-headers:                   Информация о точке останова.
                                                              (line   9)
* breakpoints-invalid:                   Недостоверность.     (line  13)
* breakpoints-table:                     Информация о точке останова.
                                                              (line   9)
* breakpoints-table-end:                 Информация о точке останова.
                                                              (line  47)
* bt (backtrace):                        Цепочки вызовов.     (line  12)
* c (продолжить):                        Продолжение и пошаговое выполнение.
                                                              (line  16)
* call:                                  Вызовы.              (line   6)
* call-last-kbd-macro (C-x e):           Клавиатурные макросы.
                                                              (line  13)
* capitalize-word (M-c):                 Команды для текста.  (line  51)
* catch:                                 Установка точек перехвата.
                                                              (line  11)
* catch catch:                           Установка точек перехвата.
                                                              (line  18)
* catch exec:                            Установка точек перехвата.
                                                              (line  21)
* catch fork:                            Установка точек перехвата.
                                                              (line  24)
* catch load:                            Установка точек перехвата.
                                                              (line  32)
* catch throw:                           Установка точек перехвата.
                                                              (line  15)
* catch unload:                          Установка точек перехвата.
                                                              (line  38)
* catch vfork:                           Установка точек перехвата.
                                                              (line  27)
* cd:                                    Рабочий каталог.     (line  16)
* cdir:                                  Пути для исходных файлов.
                                                              (line  40)
* character-search (C-]):                Разные команды.      (line  42)
* character-search-backward (M-C-]):     Разные команды.      (line  47)
* Chill:                                 Обзор.               (line  28)
* clear:                                 Удаление точек останова.
                                                              (line  22)
* clear-screen (C-l):                    Команды для перемещения.
                                                              (line  26)
* COFF и Си++:                           Выражения Си++.      (line   9)
* commands:                              Приглашения.         (line  27)
* commands <1>:                          Команды останова.    (line  11)
* comment-begin:                         Синтаксис файла инициализации Readline.
                                                              (line  34)
* complete:                              Справка.             (line  76)
* complete (<TAB>):                      Команды для завершения.
                                                              (line   6)
* completion-query-items:                Синтаксис файла инициализации Readline.
                                                              (line  43)
* condition:                             Условия.             (line  48)
* continue:                              Продолжение и пошаговое выполнение.
                                                              (line  16)
* control C и удаленная отладка:         Начальная загрузка.  (line  25)
* convert-meta:                          Синтаксис файла инициализации Readline.
                                                              (line  51)
* copy-backward-word ():                 Команды для уничтожения.
                                                              (line  45)
* copy-forward-word ():                  Команды для уничтожения.
                                                              (line  50)
* copy-region-as-kill ():                Команды для уничтожения.
                                                              (line  41)
* core:                                  Файлы.               (line 125)
* core-file:                             Файлы.               (line 125)
* cwd:                                   Пути для исходных файлов.
                                                              (line  40)
* d (delete):                            Удаление точек останова.
                                                              (line  38)
* define:                                Определяемые пользователем команды.
                                                              (line  25)
* delete:                                Удаление точек останова.
                                                              (line  38)
* delete display:                        Автоматическое отображение.
                                                              (line  52)
* delete-char (C-d):                     Команды для текста.  (line   6)
* delete-char-or-list ():                Команды для завершения.
                                                              (line  32)
* delete-horizontal-space ():            Команды для уничтожения.
                                                              (line  33)
* detach:                                Присоединение.       (line  38)
* device:                                Платы Hitachi.       (line   6)
* digit-argument (M-0, M-1, ... M--):    Числовые параметры.  (line   6)
* dir:                                   Пути для исходных файлов.
                                                              (line  27)
* directory:                             Пути для исходных файлов.
                                                              (line  27)
* dis (disable):                         Отключение.          (line  35)
* disable:                               Отключение.          (line  35)
* disable breakpoints:                   Отключение.          (line   6)
* disable breakpoints <1>:               Отключение.          (line  35)
* disable display:                       Автоматическое отображение.
                                                              (line  60)
* disable-completion:                    Синтаксис файла инициализации Readline.
                                                              (line  58)
* disassemble:                           Машинный код.        (line  38)
* display:                               Автоматическое отображение.
                                                              (line  26)
* display-begin:                         Отображения.         (line   6)
* display-end:                           Отображения.         (line   6)
* display-expression:                    Отображения.         (line   6)
* display-expression-end:                Отображения.         (line   6)
* display-format:                        Отображения.         (line   6)
* display-number-end:                    Отображения.         (line   6)
* display-value:                         Отображения.         (line   6)
* do (down):                             Выбор.               (line  43)
* do-uppercase-version (M-a, M-b, M-X, ...): Разные команды.  (line  14)
* document:                              Определяемые пользователем команды.
                                                              (line  48)
* down:                                  Выбор.               (line  43)
* down-silently:                         Выбор.               (line  66)
* downcase-word (M-l):                   Команды для текста.  (line  46)
* dump-functions ():                     Разные команды.      (line  57)
* dump-macros ():                        Разные команды.      (line  69)
* dump-variables ():                     Разные команды.      (line  63)
* eb.log, журнальный файл для EB29K:     Удаленный журнал.    (line   6)
* EBMON:                                 Коммуникации (EB29K).
                                                              (line  42)
* echo:                                  Вывод.               (line  12)
* ECOFF и Си++:                          Выражения Си++.      (line   9)
* editing-mode:                          Синтаксис файла инициализации Readline.
                                                              (line  64)
* ELF/DWARF и Си++:                      Выражения Си++.      (line   9)
* ELF/stabs и Си++:                      Выражения Си++.      (line   9)
* else:                                  Определяемые пользователем команды.
                                                              (line  34)
* elt:                                   Примечания к значениям.
                                                              (line  72)
* elt-rep:                               Примечания к значениям.
                                                              (line  78)
* elt-rep-end:                           Примечания к значениям.
                                                              (line  78)
* Emacs:                                 Emacs.               (line   6)
* enable:                                Отключение.          (line  43)
* enable breakpoints:                    Отключение.          (line   6)
* enable breakpoints <1>:                Отключение.          (line  43)
* enable display:                        Автоматическое отображение.
                                                              (line  65)
* enable-keypad:                         Синтаксис файла инициализации Readline.
                                                              (line  71)
* end:                                   Команды останова.    (line  11)
* end-kbd-macro (C-x )):                 Клавиатурные макросы.
                                                              (line   9)
* end-of-history (M->):                  Команды для истории. (line  21)
* end-of-line (C-e):                     Команды для перемещения.
                                                              (line   9)
* error:                                 Ошибки.              (line  11)
* error-begin:                           Ошибки.              (line  24)
* exceptionHandler:                      Начальная загрузка.  (line  40)
* exchange-point-and-mark (C-x C-x):     Разные команды.      (line  37)
* exec-file:                             Файлы.               (line  39)
* exited:                                Примечания к выполнению.
                                                              (line  18)
* expand-tilde:                          Синтаксис файла инициализации Readline.
                                                              (line  77)
* f (frame):                             Выбор.               (line  11)
* fg (продолжить выполнение в фоновом режиме): Продолжение и пошаговое выполнение.
                                                              (line  16)
* field:                                 Информация о точке останова.
                                                              (line  20)
* field-begin:                           Примечания к значениям.
                                                              (line  48)
* field-end:                             Примечания к значениям.
                                                              (line  48)
* field-name-end:                        Примечания к значениям.
                                                              (line  48)
* field-value:                           Примечания к значениям.
                                                              (line  48)
* file:                                  Файлы.               (line  15)
* finish:                                Продолжение и пошаговое выполнение.
                                                              (line 111)
* flush_i_cache:                         Начальная загрузка.  (line  63)
* foo:                                   Ошибки с символами.  (line  57)
* fork, отладка программ, использующих этот вызов: Процессы.  (line   6)
* forward-backward-delete-char ():       Команды для текста.  (line  15)
* forward-char (C-f):                    Команды для перемещения.
                                                              (line  12)
* forward-search:                        Поиск.               (line   9)
* forward-search-history (C-s):          Команды для истории. (line  29)
* forward-word (M-f):                    Команды для перемещения.
                                                              (line  18)
* frame, command:                        Кадры.               (line  44)
* frame, selecting:                      Выбор.               (line  11)
* frame-address:                         Примечания к кадрам. (line  46)
* frame-address-end:                     Примечания к кадрам. (line  46)
* frame-args:                            Примечания к кадрам. (line  61)
* frame-begin:                           Примечания к кадрам. (line  10)
* frame-end:                             Примечания к кадрам. (line  23)
* frame-function-name:                   Примечания к кадрам. (line  61)
* frame-source-begin:                    Примечания к кадрам. (line  73)
* frame-source-end:                      Примечания к кадрам. (line  73)
* frame-source-file:                     Примечания к кадрам. (line  73)
* frame-source-file-end:                 Примечания к кадрам. (line  73)
* frame-source-line:                     Примечания к кадрам. (line  73)
* frame-where:                           Примечания к кадрам. (line  91)
* frames-invalid:                        Недостоверность.     (line   9)
* Fujitsu:                               Удаленный.           (line  64)
* function-call:                         Примечания к кадрам. (line  28)
* g++, компилятор GNU Си++:              Си.                  (line   9)
* gdb.ini:                               Командные файлы.     (line  11)
* GDB/MI, внеочередные записи:           Внеочередные записи GDB/MI.
                                                              (line   6)
* GDB/MI, входной синтаксис:             Входной синтаксис GDB/MI.
                                                              (line   6)
* GDB/MI, выходной синтаксис:            Выходной синтаксис GDB/MI.
                                                              (line   6)
* GDB/MI, его назначение:                GDB/MI.              (line  26)
* GDB/MI, команды точки останова:        Команды GDB/MI для таблицы точек останова.
                                                              (line   6)
* GDB/MI, поточные записи:               Поточные записи GDB/MI.
                                                              (line   6)
* GDB/MI, простые примеры:               Простые примеры GDB/MI.
                                                              (line   6)
* GDB/MI, результирующие записи:         Результирующие записи GDB/MI.
                                                              (line   6)
* GDB/MI, совместимость с CLI:           Совместимость GDB/MI с CLI.
                                                              (line   6)
* GDB/MI, управление данными:            Управление данными GDB/MI.
                                                              (line   6)
* GDBHISTFILE:                           История.             (line  10)
* gdbserve.nlm:                          NetWare.             (line   6)
* gdbserver:                             Сервер.              (line   6)
* getDebugChar:                          Начальная загрузка.  (line  14)
* GNU Emacs:                             Emacs.               (line   6)
* GNU Си++:                              Си.                  (line   9)
* h (help):                              Справка.             (line   9)
* H8/300 или H8/500, загрузка на:        H8/300.              (line  19)
* handle:                                Сигналы.             (line  40)
* handle_exception:                      Содержимое заглушки. (line  15)
* hbreak:                                Установка точек останова.
                                                              (line  85)
* help:                                  Справка.             (line   6)
* help target:                           Команды для целей.   (line  19)
* help user-defined:                     Определяемые пользователем команды.
                                                              (line  61)
* heuristic-fence-post (Alpha, MIPS):    MIPS.                (line  15)
* history-search-backward ():            Команды для истории. (line  48)
* history-search-forward ():             Команды для истории. (line  43)
* Hitachi:                               Удаленный.           (line  58)
* Hitachi SH, загрузка на:               H8/300.              (line  19)
* hook:                                  Ловушки.             (line   6)
* hook-:                                 Ловушки.             (line   6)
* hookpost:                              Ловушки.             (line  11)
* hookpost-:                             Ловушки.             (line  11)
* horizontal-scroll-mode:                Синтаксис файла инициализации Readline.
                                                              (line  82)
* i (info):                              Справка.             (line  99)
* i386:                                  Удаленный.           (line  52)
* i386-stub.c:                           Удаленный.           (line  52)
* i960:                                  i960.                (line  14)
* if:                                    Определяемые пользователем команды.
                                                              (line  34)
* ignore:                                Условия.             (line  82)
* INCLUDE_RDB:                           VxWorks.             (line  34)
* info:                                  Справка.             (line  99)
* info address:                          Символы.             (line  27)
* info all-registers:                    Регистры.            (line  15)
* info args:                             Информация о кадре.  (line  45)
* info breakpoints:                      Установка точек останова.
                                                              (line 137)
* info catch:                            Информация о кадре.  (line  54)
* info display:                          Автоматическое отображение.
                                                              (line  74)
* info extensions:                       Отображение языка.   (line  29)
* info f (info frame):                   Информация о кадре.  (line  17)
* info files:                            Файлы.               (line 183)
* info float:                            Вычисления с плавающей точкой.
                                                              (line   9)
* info frame:                            Информация о кадре.  (line  17)
* info frame, показать исходный язык:    Отображение языка.   (line   9)
* info functions:                        Символы.             (line 100)
* info line:                             Машинный код.        (line  13)
* info locals:                           Информация о кадре.  (line  49)
* info proc:                             Информация о процессах SVR4.
                                                              (line  15)
* info proc id:                          Информация о процессах SVR4.
                                                              (line  27)
* info proc mappings:                    Информация о процессах SVR4.
                                                              (line  18)
* info proc status:                      Информация о процессах SVR4.
                                                              (line  32)
* info proc times:                       Информация о процессах SVR4.
                                                              (line  23)
* info program:                          Остановка.           (line  18)
* info registers:                        Регистры.            (line  11)
* info s (info stack):                   Цепочки вызовов.     (line  28)
* info set:                              Справка.             (line 121)
* info share:                            Файлы.               (line 208)
* info sharedlibrary:                    Файлы.               (line 208)
* info signals:                          Сигналы.             (line  32)
* info source:                           Символы.             (line  89)
* info source, показать исходный язык:   Отображение языка.   (line   9)
* info sources:                          Символы.             (line  94)
* info stack:                            Цепочки вызовов.     (line  28)
* info target:                           Файлы.               (line 183)
* info terminal:                         Ввод-вывод.          (line  13)
* info threads:                          Нити.                (line  57)
* info threads <1>:                      Нити.                (line  92)
* info types:                            Символы.             (line  75)
* info variables:                        Символы.             (line 109)
* info watchpoints:                      Установка точек наблюдения.
                                                              (line  35)
* input-meta:                            Синтаксис файла инициализации Readline.
                                                              (line  90)
* insert-comment (M-#):                  Разные команды.      (line  52)
* insert-completions (M-*):              Команды для завершения.
                                                              (line  17)
* inspect:                               Данные.              (line   6)
* Intel:                                 Удаленный.           (line  52)
* isearch-terminators:                   Синтаксис файла инициализации Readline.
                                                              (line  97)
* jump:                                  Переходы.            (line  11)
* keymap:                                Синтаксис файла инициализации Readline.
                                                              (line 103)
* kill:                                  Уничтожение процесса.
                                                              (line   6)
* kill-line (C-k):                       Команды для уничтожения.
                                                              (line   6)
* kill-region ():                        Команды для уничтожения.
                                                              (line  37)
* kill-whole-line ():                    Команды для уничтожения.
                                                              (line  15)
* kill-word (M-d):                       Команды для уничтожения.
                                                              (line  19)
* l (info list):                         Вывод строк.         (line   6)
* list:                                  Вывод строк.         (line   6)
* load ИМЯ-ФАЙЛА:                        Команды для целей.   (line  93)
* m680x0:                                Удаленный.           (line  55)
* m68k-stub.c:                           Удаленный.           (line  55)
* maint info breakpoints:                Установка точек останова.
                                                              (line 191)
* maint print psymbols:                  Символы.             (line 161)
* maint print symbols:                   Символы.             (line 161)
* make:                                  Команды оболочки.    (line  21)
* mapped:                                Файлы.               (line  93)
* mark-modified-lines:                   Синтаксис файла инициализации Readline.
                                                              (line 116)
* memset:                                Начальная загрузка.  (line  75)
* menu-complete ():                      Команды для завершения.
                                                              (line  21)
* meta-flag:                             Синтаксис файла инициализации Readline.
                                                              (line  90)
* MIPS:                                  Встроенный MIPS.     (line   6)
* MIPS, стек:                            MIPS.                (line   6)
* Motorola 680x0:                        Удаленный.           (line  55)
* n (next):                              Продолжение и пошаговое выполнение.
                                                              (line  82)
* next:                                  Продолжение и пошаговое выполнение.
                                                              (line  82)
* next-history (C-n):                    Команды для истории. (line  15)
* nexti:                                 Продолжение и пошаговое выполнение.
                                                              (line 184)
* ni (nexti):                            Продолжение и пошаговое выполнение.
                                                              (line 184)
* Nindy:                                 i960.                (line  14)
* non-incremental-forward-search-history (M-n): Команды для истории.
                                                              (line  38)
* non-incremental-reverse-search-history (M-p): Команды для истории.
                                                              (line  33)
* output:                                Вывод.               (line  37)
* output-meta:                           Синтаксис файла инициализации Readline.
                                                              (line 122)
* overload-choice:                       Приглашения.         (line  31)
* path:                                  Среда.               (line  14)
* possible-completions (M-?):            Команды для завершения.
                                                              (line  14)
* post-commands:                         Приглашения.         (line  27)
* post-overload-choice:                  Приглашения.         (line  31)
* post-prompt:                           Приглашения.         (line  24)
* post-prompt-for-continue:              Приглашения.         (line  39)
* post-query:                            Приглашения.         (line  35)
* pre-commands:                          Приглашения.         (line  27)
* pre-overload-choice:                   Приглашения.         (line  31)
* pre-prompt:                            Приглашения.         (line  24)
* pre-prompt-for-continue:               Приглашения.         (line  39)
* pre-query:                             Приглашения.         (line  35)
* prefix-meta (<ESC>):                   Разные команды.      (line  18)
* previous-history (C-p):                Команды для истории. (line  12)
* print:                                 Данные.              (line   6)
* printf:                                Вывод.               (line  48)
* prompt:                                Приглашения.         (line  24)
* prompt-for-continue:                   Приглашения.         (line  39)
* ptype:                                 Символы.             (line  46)
* putDebugChar:                          Начальная загрузка.  (line  20)
* pwd:                                   Рабочий каталог.     (line  19)
* q (quit):                              Выход из GDB.        (line   6)
* query:                                 Приглашения.         (line  35)
* quit:                                  Ошибки.              (line   6)
* quit [ВЫРАЖЕНИЕ]:                      Выход из GDB.        (line   6)
* quoted-insert (C-q, C-v):              Команды для текста.  (line  20)
* r (run):                               Начало выполнения.   (line   6)
* rbreak:                                Установка точек останова.
                                                              (line 115)
* re-read-init-file (C-x C-r):           Разные команды.      (line   6)
* readline:                              Редактирование.      (line   6)
* readnow:                               Файлы.               (line  93)
* record:                                Информация о точке останова.
                                                              (line  20)
* redraw-current-line ():                Команды для перемещения.
                                                              (line  30)
* remotedebug, протокол MIPS:            Встроенный MIPS.     (line  93)
* remotetimeout:                         Sparclet.            (line  12)
* reset:                                 Сброс Nindy.         (line   7)
* RET:                                   Синтаксис команд.    (line  21)
* RET (повторить последнюю команду):     Синтаксис команд.    (line  21)
* retransmit-timeout, протокол MIPS:     Встроенный MIPS.     (line 104)
* return:                                Возврат.             (line   6)
* reverse-search:                        Поиск.               (line   6)
* reverse-search-history (C-r):          Команды для истории. (line  25)
* revert-line (M-r):                     Разные команды.      (line  25)
* run:                                   Начало выполнения.   (line   6)
* rwatch:                                Установка точек наблюдения.
                                                              (line  27)
* s (step):                              Продолжение и пошаговое выполнение.
                                                              (line  47)
* search:                                Поиск.               (line   9)
* section:                               Файлы.               (line 175)
* select-frame:                          Кадры.               (line  50)
* self-insert (a, b, A, 1, !, ...):      Команды для текста.  (line  28)
* set:                                   Справка.             (line 108)
* set args:                              Аргументы.           (line  22)
* set auto-solib-add:                    Файлы.               (line 234)
* set check range:                       Проверка диапазона.  (line  33)
* set check type:                        Проверка типов.      (line  42)
* set check, диапазон:                   Проверка диапазона.  (line  33)
* set check, тип:                        Проверка типов.      (line  42)
* set complaints:                        Сообщения/предупреждения.
                                                              (line  30)
* set confirm:                           Сообщения/предупреждения.
                                                              (line  50)
* set debug arch:                        Отладочный вывод.    (line   6)
* set debug event:                       Отладочный вывод.    (line  10)
* set debug expression:                  Отладочный вывод.    (line  16)
* set debug overload:                    Отладочный вывод.    (line  22)
* set debug remote:                      Отладочный вывод.    (line  29)
* set debug serial:                      Отладочный вывод.    (line  36)
* set debug target:                      Отладочный вывод.    (line  42)
* set debug varobj:                      Отладочный вывод.    (line  49)
* set demangle-style:                    Параметры вывода.    (line 229)
* set disassembly-flavour:               Машинный код.        (line  65)
* set editing:                           Редактирование.      (line  16)
* set endian auto:                       Порядок байтов.      (line  20)
* set endian big:                        Порядок байтов.      (line  14)
* set endian little:                     Порядок байтов.      (line  17)
* set environment:                       Среда.               (line  40)
* set extension-language:                Отображение языка.   (line  29)
* set follow-fork-mode:                  Процессы.            (line  40)
* set gnutarget:                         Команды для целей.   (line  28)
* set height:                            Размер экрана.       (line  21)
* set history expansion:                 История.             (line  47)
* set history filename:                  История.             (line  10)
* set history save:                      История.             (line  20)
* set history size:                      История.             (line  29)
* set input-radix:                       Числа.               (line  16)
* set language:                          Установка рабочего языка.
                                                              (line   9)
* set listsize:                          Вывод строк.         (line  36)
* set machine:                           Специально для Hitachi.
                                                              (line   8)
* set memory МОД:                        H8/500.              (line   6)
* set mipsfpu:                           Встроенный MIPS.     (line  70)
* set opaque-type-resolution:            Символы.             (line 142)
* set overload-resolution:               Отладка Си++.        (line  50)
* set print address:                     Параметры вывода.    (line  11)
* set print array:                       Параметры вывода.    (line 100)
* set print asm-demangle:                Параметры вывода.    (line 219)
* set print demangle:                    Параметры вывода.    (line 208)
* set print elements:                    Параметры вывода.    (line 112)
* set print max-symbolic-offset:         Параметры вывода.    (line  71)
* set print null-stop:                   Параметры вывода.    (line 125)
* set print object:                      Параметры вывода.    (line 263)
* set print pretty on:                   Параметры вывода.    (line 131)
* set print sevenbit-strings:            Параметры вывода.    (line 155)
* set print static-members:              Параметры вывода.    (line 276)
* set print symbol-filename:             Параметры вывода.    (line  51)
* set print union:                       Параметры вывода.    (line 170)
* set print vtbl:                        Параметры вывода.    (line 287)
* set processor АРГ:                     Встроенный MIPS.     (line  58)
* set prompt:                            Приглашение.         (line  16)
* set remotedebug, протокол MIPS:        Встроенный MIPS.     (line  93)
* set retransmit-timeout:                Встроенный MIPS.     (line 104)
* set rstack_high_address:               A29K.                (line   6)
* set step-mode:                         Продолжение и пошаговое выполнение.
                                                              (line  96)
* set symbol-reloading:                  Символы.             (line 124)
* set timeout:                           Встроенный MIPS.     (line 104)
* set variable:                          Присваивание.        (line  16)
* set verbose:                           Сообщения/предупреждения.
                                                              (line  16)
* set width:                             Размер экрана.       (line  21)
* set write:                             Внесение изменений.  (line  17)
* set-mark (C-@):                        Разные команды.      (line  33)
* set_debug_traps:                       Содержимое заглушки. (line  10)
* SH:                                    Удаленный.           (line  58)
* sh-stub.c:                             Удаленный.           (line  58)
* share:                                 Файлы.               (line 212)
* sharedlibrary:                         Файлы.               (line 212)
* shell:                                 Команды оболочки.    (line  10)
* show:                                  Справка.             (line 113)
* show args:                             Аргументы.           (line  30)
* show auto-solib-add:                   Файлы.               (line 244)
* show check range:                      Проверка диапазона.  (line  33)
* show check type:                       Проверка типов.      (line  42)
* show complaints:                       Сообщения/предупреждения.
                                                              (line  36)
* show confirm:                          Сообщения/предупреждения.
                                                              (line  56)
* show convenience:                      Вспомогательные переменные.
                                                              (line  38)
* show copying:                          Справка.             (line 139)
* show debug arch:                       Отладочный вывод.    (line   8)
* show debug event:                      Отладочный вывод.    (line  13)
* show debug expression:                 Отладочный вывод.    (line  19)
* show debug overload:                   Отладочный вывод.    (line  26)
* show debug remote:                     Отладочный вывод.    (line  34)
* show debug serial:                     Отладочный вывод.    (line  39)
* show debug target:                     Отладочный вывод.    (line  46)
* show debug varobj:                     Отладочный вывод.    (line  52)
* show demangle-style:                   Параметры вывода.    (line 259)
* show directories:                      Пути для исходных файлов.
                                                              (line  53)
* show editing:                          Редактирование.      (line  23)
* show environment:                      Среда.               (line  34)
* show gnutarget:                        Команды для целей.   (line  41)
* show history:                          История.             (line  58)
* show input-radix:                      Числа.               (line  37)
* show language:                         Отображение языка.   (line   9)
* show listsize:                         Вывод строк.         (line  40)
* show machine:                          Специально для Hitachi.
                                                              (line   8)
* show mipsfpu:                          Встроенный MIPS.     (line  70)
* show opaque-type-resolution:           Символы.             (line 158)
* show output-radix:                     Числа.               (line  31)
* show output-radix <1>:                 Числа.               (line  40)
* show paths:                            Среда.               (line  30)
* show print address:                    Параметры вывода.    (line  40)
* show print array:                      Параметры вывода.    (line 108)
* show print asm-demangle:               Параметры вывода.    (line 225)
* show print demangle:                   Параметры вывода.    (line 215)
* show print elements:                   Параметры вывода.    (line 121)
* show print max-symbolic-offset:        Параметры вывода.    (line  78)
* show print object:                     Параметры вывода.    (line 273)
* show print pretty:                     Параметры вывода.    (line 152)
* show print sevenbit-strings:           Параметры вывода.    (line 167)
* show print static-members:             Параметры вывода.    (line 284)
* show print symbol-filename:            Параметры вывода.    (line  59)
* show print union:                      Параметры вывода.    (line 177)
* show print vtbl:                       Параметры вывода.    (line 296)
* show processor:                        Встроенный MIPS.     (line  58)
* show prompt:                           Приглашение.         (line  20)
* show remotedebug, протокол MIPS:       Встроенный MIPS.     (line  93)
* show retransmit-timeout:               Встроенный MIPS.     (line 104)
* show rstack_high_address:              A29K.                (line  17)
* show symbol-reloading:                 Символы.             (line 139)
* show timeout:                          Встроенный MIPS.     (line 104)
* show user:                             Определяемые пользователем команды.
                                                              (line  65)
* show values:                           История значений.    (line  50)
* show verbose:                          Сообщения/предупреждения.
                                                              (line  22)
* show version:                          Справка.             (line 129)
* show warranty:                         Справка.             (line 142)
* show width:                            Размер экрана.       (line  21)
* show wight:                            Размер экрана.       (line  21)
* show write:                            Внесение изменений.  (line  29)
* show-all-if-ambiguous:                 Синтаксис файла инициализации Readline.
                                                              (line 133)
* shows:                                 История.             (line  66)
* si (stepi):                            Продолжение и пошаговое выполнение.
                                                              (line 170)
* signal:                                Примечания к выполнению.
                                                              (line  42)
* signal <1>:                            Подача сигналов.     (line   6)
* signal-handler-caller:                 Примечания к кадрам. (line  35)
* signal-name:                           Примечания к выполнению.
                                                              (line  22)
* signal-name-end:                       Примечания к выполнению.
                                                              (line  22)
* signal-string:                         Примечания к выполнению.
                                                              (line  22)
* signal-string-end:                     Примечания к выполнению.
                                                              (line  22)
* signalled:                             Примечания к выполнению.
                                                              (line  22)
* silent:                                Команды останова.    (line  40)
* sim:                                   Z8000.               (line  15)
* source:                                Примечания к исходному тексту.
                                                              (line   6)
* source <1>:                            Командные файлы.     (line  46)
* Sparc:                                 Удаленный.           (line  61)
* sparc-stub.c:                          Удаленный.           (line  61)
* sparcl-stub.c:                         Удаленный.           (line  64)
* Sparclet:                              Sparclet.            (line   6)
* SparcLite:                             Удаленный.           (line  64)
* speed:                                 Платы Hitachi.       (line  11)
* st2000 КОМ:                            ST2000.              (line  32)
* start-kbd-macro (C-x ():               Клавиатурные макросы.
                                                              (line   6)
* starting:                              Примечания к выполнению.
                                                              (line   6)
* step:                                  Продолжение и пошаговое выполнение.
                                                              (line  47)
* stepi:                                 Продолжение и пошаговое выполнение.
                                                              (line 170)
* stop, псевдокоманда:                   Ловушки.             (line  22)
* stopping:                              Примечания к выполнению.
                                                              (line   6)
* symbol-file:                           Файлы.               (line  46)
* tab-insert (M-TAB):                    Команды для текста.  (line  25)
* target:                                Отладочные цели.     (line   6)
* target abug:                           M68K.                (line   9)
* target adapt:                          Встроенный A29K.     (line  14)
* target amd-eb:                         Встроенный A29K.     (line  17)
* target array:                          Встроенный MIPS.     (line  51)
* target bug:                            M88K.                (line   6)
* target core:                           Команды для целей.   (line  55)
* target cpu32bug:                       M68K.                (line  12)
* target dbug:                           M68K.                (line  15)
* target ddb ПОРТ:                       Встроенный MIPS.     (line  43)
* target dink32:                         PowerPC.             (line   6)
* target e7000, c Hitachi ICE:           Hitachi ICE.         (line   6)
* target e7000, с H8/300:                H8/300.              (line  12)
* target e7000, с Hitachi SH:            SH.                  (line  12)
* target es1800:                         M68K.                (line  27)
* target est:                            M68K.                (line  18)
* target exec:                           Команды для целей.   (line  51)
* target hms и последовательный протокол: Платы Hitachi.      (line  51)
* target hms, с H8/300:                  H8/300.              (line   6)
* target hms, с Hitachi SH:              SH.                  (line   6)
* target lsi ПОРТ:                       Встроенный MIPS.     (line  46)
* target m32r:                           M32R/D.              (line   6)
* target mips ПОРТ:                      Встроенный MIPS.     (line  15)
* target mon960:                         i960.                (line   6)
* target nindy:                          i960.                (line   9)
* target nrom:                           Команды для целей.   (line  84)
* target op50n:                          PA.                  (line   6)
* target pmon ПОРТ:                      Встроенный MIPS.     (line  40)
* target ppcbug:                         PowerPC.             (line   9)
* target ppcbug1:                        PowerPC.             (line  10)
* target r3900:                          Встроенный MIPS.     (line  48)
* target rdi:                            ARM.                 (line   6)
* target rdp:                            ARM.                 (line  12)
* target remote:                         Команды для целей.   (line  59)
* target rom68k:                         M68K.                (line  21)
* target rombug:                         M68K.                (line  30)
* target sds:                            PowerPC.             (line  13)
* target sh3, с H8/300:                  H8/300.              (line  15)
* target sh3, с SH:                      SH.                  (line  15)
* target sh3e, с H8/300:                 H8/300.              (line  15)
* target sh3e, с SH:                     SH.                  (line  15)
* target sim:                            Команды для целей.   (line  69)
* target sim, с Z8000:                   Z8000.               (line  15)
* target sparclite:                      Sparclite.           (line   6)
* target vxworks:                        VxWorks.             (line   6)
* target w89k:                           PA.                  (line   9)
* tbreak:                                Установка точек останова.
                                                              (line  78)
* TCP-порт, target remote:               Сеанс отладки.       (line  57)
* thbreak:                               Установка точек останова.
                                                              (line 104)
* this, внутри функций-членов Си++:      Выражения Си++.      (line  25)
* thread НОМЕР-НИТИ:                     Нити.                (line 118)
* threads apply:                         Нити.                (line 131)
* tilde-expand (M-~):                    Разные команды.      (line  30)
* timeout, протокол MIPS:                Встроенный MIPS.     (line 104)
* transpose-chars (C-t):                 Команды для текста.  (line  31)
* transpose-words (M-t):                 Команды для текста.  (line  37)
* tty:                                   Ввод-вывод.          (line  24)
* u (until):                             Продолжение и пошаговое выполнение.
                                                              (line 118)
* udi:                                   A29K UDI.            (line  14)
* UDI:                                   A29K UDI.            (line   6)
* undisplay:                             Автоматическое отображение.
                                                              (line  52)
* undo (C-_, C-x C-u):                   Разные команды.      (line  22)
* universal-argument ():                 Числовые параметры.  (line  10)
* unix-line-discard (C-u):               Команды для уничтожения.
                                                              (line  12)
* unix-word-rubout (C-w):                Команды для уничтожения.
                                                              (line  28)
* unset environment:                     Среда.               (line  57)
* until:                                 Продолжение и пошаговое выполнение.
                                                              (line 118)
* up:                                    Выбор.               (line  37)
* up-silently:                           Выбор.               (line  66)
* upcase-word (M-u):                     Команды для текста.  (line  41)
* value-begin:                           Примечания к значениям.
                                                              (line  24)
* value-end:                             Примечания к значениям.
                                                              (line  24)
* value-history-begin:                   Примечания к значениям.
                                                              (line   9)
* value-history-end:                     Примечания к значениям.
                                                              (line   9)
* value-history-value:                   Примечания к значениям.
                                                              (line   9)
* visible-stats:                         Синтаксис файла инициализации Readline.
                                                              (line 139)
* VxWorks:                               VxWorks.             (line   6)
* vxworks-timeout:                       VxWorks.             (line  22)
* watch:                                 Установка точек наблюдения.
                                                              (line  22)
* watchpoint:                            Примечания к выполнению.
                                                              (line  50)
* whatis:                                Символы.             (line  37)
* where:                                 Цепочки вызовов.     (line  28)
* while:                                 Определяемые пользователем команды.
                                                              (line  42)
* x (исследование памяти):               Память.              (line  10)
* x(исследовать) и info line:            Машинный код.        (line  32)
* XCOFF и Си++:                          Выражения Си++.      (line   9)
* yank (C-y):                            Команды для уничтожения.
                                                              (line  55)
* yank-last-arg (M-., M-_):              Команды для истории. (line  60)
* yank-nth-arg (M-C-y):                  Команды для истории. (line  53)
* yank-pop (M-y):                        Команды для уничтожения.
                                                              (line  59)
* Z8000:                                 Z8000.               (line   6)
* Zilog Z8000, имитатор:                 Z8000.               (line   6)
* автоматический выбор нити:             Нити.                (line 139)
* автоматическое отображение:            Автоматическое отображение.
                                                              (line   6)
* автоматическое переключение между нитями: Нити.             (line 139)
* активные цели:                         Активные цели.       (line   6)
* аппаратные точки наблюдения:           Установка точек наблюдения.
                                                              (line   6)
* аргументы (вашей программы):           Аргументы.           (line   6)
* асинхронный вывод в GDB/MI:            Выходной синтаксис GDB/MI.
                                                              (line  97)
* ассемблерные инструкции:               Машинный код.        (line  38)
* ассемблерные инструкции <1>:           Машинный код.        (line  65)
* ввод чисел:                            Числа.               (line   6)
* ввод-вывод:                            Ввод-вывод.          (line   6)
* взаимодействие с readline:             Взаимодействие с Readline.
                                                              (line   6)
* внеочередные записи в GDB/MI:          Внеочередные записи GDB/MI.
                                                              (line   6)
* внесение изменений в двоичные файлы:   Внесение изменений.  (line   6)
* внешний кадр:                          Кадры.               (line  12)
* внутренние точки останова GDB:         Установка точек останова.
                                                              (line 182)
* внутренний кадр:                       Кадры.               (line  12)
* возбуждение исключений:                Установка точек перехвата.
                                                              (line  67)
* возврат из функции:                    Возврат.             (line   6)
* возобновление выполнения:              Продолжение и пошаговое выполнение.
                                                              (line   6)
* восстановление:                        Параметры вывода.    (line 208)
* восстановление текста:                 Команды уничтожения Readline.
                                                              (line   6)
* время ответа, отладка MIPS:            MIPS.                (line  10)
* вспомогательные команды ST2000:        ST2000.              (line  28)
* вспомогательные переменные:            Вспомогательные переменные.
                                                              (line   6)
* встроенные функции Модулы-2:           Встроенные функции/процедуры.
                                                              (line   6)
* входной синтаксис для GDB/MI:          Входной синтаксис GDB/MI.
                                                              (line   6)
* выбор целевого порядка байтов:         Порядок байтов.      (line   6)
* выбранный кадр:                        Стек.                (line  19)
* вывод данных:                          Данные.              (line   6)
* вывод машинных инструкций:             Машинный код.        (line  38)
* вывод машинных инструкций <1>:         Машинный код.        (line  65)
* вывод состояния в GDB/MI:              Выходной синтаксис GDB/MI.
                                                              (line  93)
* вызов make:                            Команды оболочки.    (line  21)
* вызов перегруженных функций:           Выражения Си++.      (line  30)
* вызов функций:                         Вызовы.              (line   6)
* выполнение:                            Начало выполнения.   (line   6)
* выполнение без кадров:                 Кадры.               (line  33)
* выполнение и отладка программ Sparclet: Выполнение Sparclet.
                                                              (line   6)
* выполнение, на Sparclet:               Sparclet.            (line  29)
* выполняемый файл:                      Файлы.               (line  15)
* выражения:                             Выражения.           (line   6)
* выражения в Модуле-2:                  Модула-2.            (line  13)
* выражения в Си и Си++:                 Си.                  (line   6)
* выражения в Си++:                      Выражения Си++.      (line   6)
* выход в оболочку:                      Команды оболочки.    (line  10)
* выход из GDB:                          Выход из GDB.        (line   6)
* выходной синтаксис GDB/MI:             Выходной синтаксис GDB/MI.
                                                              (line   6)
* глупые вопросы:                        Сообщения/предупреждения.
                                                              (line  50)
* дамп символов:                         Символы.             (line 161)
* двоеточие-двоеточие, в Модуле-2:       Область видимости в Модуле-2.
                                                              (line   6)
* двойное двоеточие как оператор области видимости: Область видимости в Модуле-2.
                                                              (line   6)
* двойное двоеточие, контекст для переменных/функций: Переменные.
                                                              (line  45)
* диалект дисассемблирования AT&T:       Машинный код.        (line  65)
* диалект дисассемблирования Intel:      Машинный код.        (line  65)
* диапазон, проверка:                    Проверка типов.      (line  65)
* диапазоны для точек останова:          Точки останова.      (line  53)
* диапазоны точек останова:              Точки останова.      (line  53)
* динамическая сборка:                   Файлы.               (line 142)
* документация:                          Справка.             (line   6)
* документация <1>:                      Форматирование документации.
                                                              (line  22)
* журнальный вывод в GDB/MI:             Выходной синтаксис GDB/MI.
                                                              (line 112)
* журнальный файл для EB29K:             Удаленный журнал.    (line   6)
* завершение:                            Завершение.          (line   6)
* завершение слов:                       Завершение.          (line   6)
* завершение строк, заключенных в кавычки: Завершение.        (line  57)
* загрузка на H8/300 или H8/500:         H8/300.              (line  19)
* загрузка на Hitachi SH:                H8/300.              (line  19)
* загрузка на Nindy-960:                 i960.                (line  27)
* загрузка на Sparclet:                  Загрузка на Sparclet.
                                                              (line   6)
* загрузка на VxWorks:                   Загрузка на VxWorks. (line   6)
* запись в выполняемые файлы:            Внесение изменений.  (line   6)
* запись в файлы дампа:                  Внесение изменений.  (line   6)
* запуск:                                Начало выполнения.   (line   6)
* запуск задач VxWorks:                  Присоединение к VxWorks.
                                                              (line   6)
* запуск программ 29K:                   A29K EB29K.          (line   6)
* значения переменных, неверные:         Переменные.          (line  59)
* значения Си и Си++ по умолчанию:       Значения Си по умолчанию.
                                                              (line   6)
* идентификатор нити (GDB):              Нити.                (line  54)
* идентификатор нити (GDB) <1>:          Нити.                (line  80)
* идентификатор нити (системный):        Нити.                (line  43)
* идентификатор нити (системный), в HP-UX: Нити.              (line  84)
* идентификатор последовательности, для удаленного GDB: Протокол.
                                                              (line  37)
* изменяемые объекты в GDB/MI:           Изменяемые объекты GDB/MI.
                                                              (line  37)
* имена в кавычках:                      Символы.             (line  14)
* имена символов:                        Символы.             (line  14)
* имитатор, Z8000:                       Z8000.               (line   6)
* имя файла инициализации:               Командные файлы.     (line  31)
* инструкции ассемблера:                 Машинный код.        (line  38)
* инструкции ассемблера <1>:             Машинный код.        (line  65)
* искусственные массивы:                 Массивы.             (line   6)
* исследование данных:                   Данные.              (line   6)
* исследование памяти:                   Память.              (line  10)
* история значений:                      История значений.    (line   6)
* кавычки в командах:                    Завершение.          (line  57)
* кадр стека:                            Кадры.               (line   6)
* кадр, определение:                     Кадры.               (line   6)
* каналы:                                Начало выполнения.   (line  54)
* каталог компиляции:                    Пути для исходных файлов.
                                                              (line  40)
* каталог, текущий:                      Пути для исходных файлов.
                                                              (line  40)
* каталоги с исходными файлами:          Пути для исходных файлов.
                                                              (line   6)
* кольцевой список уничтожений:          Команды уничтожения Readline.
                                                              (line  22)
* командные файлы:                       Командные файлы.     (line   6)
* команды STDBUG (ST2000):               ST2000.              (line  32)
* команды для STDBUG (ST2000):           ST2000.              (line  32)
* команды для Си++:                      Отладка Си++.        (line   6)
* команды для точек останова:            Команды останова.    (line   6)
* команды точки останова для GDB/MI:     Команды GDB/MI для таблицы точек останова.
                                                              (line   6)
* команды-ловушки:                       Ловушки.             (line   6)
* комментарий:                           Синтаксис команд.    (line  36)
* компиляции, каталог:                   Пути для исходных файлов.
                                                              (line  40)
* компиляция, на Sparclet:               Sparclet.            (line  16)
* консольный вывод в GDB/MI:             Выходной синтаксис GDB/MI.
                                                              (line 105)
* константы Модулы-2:                    Встроенные функции/процедуры.
                                                              (line 108)
* константы Си и Си++:                   Константы Си.        (line   6)
* контрольная сумма, для удаленного GDB: Протокол.            (line  28)
* конфигурация GDB:                      Установка GDB.       (line   6)
* конфликт имен переменных:              Переменные.          (line  36)
* критерий ошибки:                       Критерий ошибки.     (line   6)
* ловушки для команд:                    Ловушки.             (line   6)
* ловушки, до команды:                   Ловушки.             (line   6)
* ловушки, после команды:                Ловушки.             (line  11)
* машинные инструкции:                   Машинный код.        (line  38)
* машинные инструкции <1>:               Машинный код.        (line  65)
* многие процессы:                       Процессы.            (line   6)
* множественные цели:                    Активные цели.       (line   6)
* модели памяти, H8/500:                 H8/500.              (line   6)
* Модула-2:                              Обзор.               (line  28)
* Модула-2, отклонения от стандарта:     Отклонения.          (line   6)
* Модула-2, поддержка GDB:               Модула-2.            (line   6)
* наложение целей:                       Активные цели.       (line   6)
* наследование:                          Отладка Си++.        (line  26)
* начальный кадр:                        Кадры.               (line  12)
* неверные значения:                     Переменные.          (line  59)
* недопустимые входные данные:           Критерий ошибки.     (line  16)
* неизвестный адрес, нахождение:         Форматы вывода.      (line  35)
* немедленное чтение символов:           Файлы.               (line  93)
* нити выполнения:                       Нити.                (line   6)
* нити и точки наблюдения:               Установка точек наблюдения.
                                                              (line 117)
* нити, автоматическое переключение:     Нити.                (line 139)
* нити, остановленные:                   Остановка нитей.     (line  32)
* нити, продолжение:                     Остановка нитей.     (line  37)
* нить, выделенная для отладки:          Нити.                (line  37)
* номер версии:                          Справка.             (line 129)
* номер кадра:                           Кадры.               (line  27)
* номер нити:                            Нити.                (line  54)
* номер нити <1>:                        Нити.                (line  80)
* номера в истории:                      История значений.    (line  14)
* номера для точек останова:             Точки останова.      (line  44)
* номера точек останова:                 Точки останова.      (line  44)
* обзор удаленной последовательной отладки: Сеанс отладки.    (line   6)
* область видимости:                     Область видимости в Модуле-2.
                                                              (line   6)
* обозначения, readline:                 Сведения первой необходимости.
                                                              (line   6)
* обработка исключений Си++:             Отладка Си++.        (line  21)
* обработка сигналов:                    Сигналы.             (line  26)
* обработка событий:                     Установка точек перехвата.
                                                              (line   6)
* обработчики исключений:                Установка точек перехвата.
                                                              (line   6)
* обработчики исключений, как их просмотреть: Информация о кадре.
                                                              (line  54)
* образ процесса:                        Информация о процессах SVR4.
                                                              (line   6)
* объект ядра:                           Отображение объектов ядра.
                                                              (line   6)
* объектные форматы и Си++:              Выражения Си++.      (line   9)
* объявление ссылок:                     Выражения Си++.      (line  56)
* одиночный указатель, интерпретация:    Параметры вывода.    (line  82)
* операторы Модулы-2:                    Операторы Модулы-2.  (line   6)
* операторы Си и Си++:                   Операторы Си.        (line   6)
* определение области видимости в Си++:  Переменные.          (line  55)
* определяемые пользователем команды:    Определяемые пользователем команды.
                                                              (line   6)
* оптимизированный код, отладка:         Компиляция.          (line  25)
* останов в перегруженных функциях:      Отладка Си++.        (line  10)
* остановленные нити:                    Остановка нитей.     (line  32)
* отладка оптимизированного кода:        Компиляция.          (line  25)
* отладочная заглушка, пример:           Протокол.            (line   6)
* отладочная цель:                       Отладочные цели.     (line   6)
* отображение выражений:                 Автоматическое отображение.
                                                              (line   6)
* отображение объектов ядра:             Отображение объектов ядра.
                                                              (line   6)
* отображение символов Си++:             Отладка Си++.        (line  30)
* отрицательные номера точек останова:   Установка точек останова.
                                                              (line 182)
* отчеты об ошибках:                     Отчеты об ошибках.   (line   6)
* отчеты об ошибках в GDB:               Ошибки в GDB.        (line   6)
* очистка точек останова, наблюдения, перехвата: Удаление точек останова.
                                                              (line   6)
* ошибка при правильных входных данных:  Критерий ошибки.     (line  12)
* ошибки в GDB:                          Ошибки в GDB.        (line   6)
* ошибки в GDB, отчеты:                  Отчеты об ошибках.   (line   6)
* пакеты, отчет на стандартный вывод:    Отладочный вывод.    (line  29)
* память, просмотр в виде типизированного объекта: Выражения. (line  46)
* параметры формата:                     Параметры вывода.    (line   6)
* Паскаль:                               Обзор.               (line  32)
* паузы при выводе:                      Размер экрана.       (line   6)
* перегруженные функции, вызов:          Выражения Си++.      (line  30)
* перегруженные функции, разрешение перегруженных имен: Отладка Си++.
                                                              (line  50)
* перегрузка:                            Меню точки останова. (line   6)
* перегрузка в Си++:                     Отладка Си++.        (line  15)
* перегрузка символов:                   Меню точки останова. (line   6)
* переключение между нитями:             Нити.                (line   6)
* переменные, присваивание значений:     Присваивание.        (line  16)
* перенаправление:                       Ввод-вывод.          (line   6)
* перехват исключений, список активных обработчиков: Информация о кадре.
                                                              (line  54)
* плавающая точка:                       Вычисления с плавающей точкой.
                                                              (line   6)
* плавающая точка, удаленный MIPS:       Встроенный MIPS.     (line  70)
* плата EB29K:                           A29K EB29K.          (line   6)
* повтор команд:                         Синтаксис команд.    (line  21)
* повторная загрузка символов:           Символы.             (line 117)
* поддержка Си++, без COFF:              Выражения Си++.      (line   9)
* подпрограмма breakpoint, удаленная:    Содержимое заглушки. (line  31)
* подстановка истории:                   История.             (line  10)
* подтверждение:                         Сообщения/предупреждения.
                                                              (line  50)
* подтверждение, для удаленного GDB:     Протокол.            (line  41)
* поиск:                                 Поиск.               (line   6)
* последняя точка останова:              Установка точек останова.
                                                              (line   6)
* последовательная линия, target remote: Сеанс отладки.       (line  47)
* последовательное устройство, микропроцессоры Hitachi: Платы Hitachi.
                                                              (line   6)
* последовательные соединения, отладка:  Отладочный вывод.    (line  29)
* последовательный протокол, удаленный GDB: Протокол.         (line  22)
* поточные записи в GDB/MI:              Поточные записи GDB/MI.
                                                              (line   6)
* пошаговое выполнение:                  Продолжение и пошаговое выполнение.
                                                              (line   6)
* пошаговый вход в функции без информации о строках: Продолжение и пошаговое выполнение.
                                                              (line  97)
* представление чисел:                   Числа.               (line   6)
* преобразование типов в Си++:           Выражения Си++.      (line  30)
* прерывание:                            Выход из GDB.        (line  13)
* прерывание удаленной программы:        Сеанс отладки.       (line  70)
* прерывание удаленных целей:            Начальная загрузка.  (line  25)
* префикс server для примечаний:         Префикс server.      (line   6)
* приведение области памяти к типу:      Выражения.           (line  46)
* приведение, для просмотра памяти:      Выражения.           (line  46)
* приглашение:                           Приглашение.         (line   6)
* пример заглушки, удаленная отладка:    Протокол.            (line   6)
* примечания:                            Обзор примечаний.    (line   6)
* примечания к выполняющимся программам: Примечания к выполнению.
                                                              (line   6)
* примечания к значениям:                Примечания к значениям.
                                                              (line   6)
* примечания к кадрам:                   Примечания к кадрам. (line   6)
* примечания к отображению исходного текста: Примечания к исходному тексту.
                                                              (line   6)
* примечания к отображениям:             Отображения.         (line   6)
* примечания к ошибкам, предупреждениям и прерываниям: Ошибки.
                                                              (line   6)
* примечания к приглашениям:             Приглашения.         (line   6)
* примечания к сообщениям о недостоверности: Недостоверность. (line   6)
* примечания к точкам останова:          Информация о точке останова.
                                                              (line   6)
* присваивание:                          Присваивание.        (line   6)
* присоединение:                         Присоединение.       (line   6)
* проверка диапазона:                    Проверка типов.      (line  66)
* проверка типов:                        Проверка.            (line  32)
* проверки в Си и Си++:                  Проверки в Си.       (line   6)
* проверки Модулы-2:                     Проверки Модулы-2.   (line   6)
* программные точки наблюдения:          Установка точек наблюдения.
                                                              (line   6)
* продолжение:                           Продолжение и пошаговое выполнение.
                                                              (line   6)
* продолжение с нитями:                  Остановка нитей.     (line  37)
* пространство имен в Си++:              Выражения Си++.      (line  25)
* протокол MIPS remotedebug:             Встроенный MIPS.     (line  93)
* протокол, удаленный последовательный GDB: Протокол.         (line  22)
* пути для исходных файлов:              Пути для исходных файлов.
                                                              (line   6)
* рабочий каталог:                       Пути для исходных файлов.
                                                              (line  40)
* рабочий каталог (вашей программы):     Рабочий каталог.     (line   6)
* рабочий язык:                          Языки.               (line  13)
* разделяемые библиотеки:                Файлы.               (line 196)
* размер истории:                        История.             (line  29)
* размер экрана:                         Размер экрана.       (line   6)
* раскрывание истории:                   История.             (line  34)
* раскрывание истории <1>:               Взаимодействие с историей.
                                                              (line   6)
* регистры:                              Регистры.            (line   6)
* регистры с плавающей точкой:           Регистры.            (line  15)
* регулярное выражение:                  Установка точек останова.
                                                              (line 115)
* редактирование:                        Редактирование.      (line  16)
* редактирование команд:                 Сведения первой необходимости.
                                                              (line   6)
* редактирование командной строки:       Редактирование.      (line   6)
* редактирование командных строк:        Сведения первой необходимости.
                                                              (line   6)
* результирующие записи в GDB/MI:        Результирующие записи GDB/MI.
                                                              (line   6)
* сбой отладчика:                        Критерий ошибки.     (line   9)
* Си и Си++:                             Си.                  (line   6)
* Си++:                                  Си.                  (line   9)
* Си++ и объектные форматы:              Выражения Си++.      (line   9)
* сигналы:                               Сигналы.             (line   6)
* символы, немедленное чтение:           Файлы.               (line  93)
* скорость последовательной линии, микропроцессоры Hitachi: Платы Hitachi.
                                                              (line  11)
* события истории:                       Указатели событий.   (line   7)
* совместимость, GDB/MI и CLI:           Совместимость GDB/MI с CLI.
                                                              (line   6)
* соглашения, используемые в системе обозначений, для GDB/MI: GDB/MI.
                                                              (line  40)
* соединение (с STDBUG):                 ST2000.              (line  36)
* сокращения:                            Синтаксис команд.    (line  13)
* сообщение о новом СИСТ-ТЕГЕ:           Нити.                (line  43)
* сообщение о новом СИСТ-ТЕГЕ, в HP-UX:  Нити.                (line  84)
* сохранение истории:                    История.             (line  20)
* сохранение таблицы символов:           Файлы.               (line  93)
* список удаленных последовательных заглушек: Удаленный.      (line  48)
* списочный вывод в GDB/MI:              Выходной синтаксис GDB/MI.
                                                              (line 117)
* справочная карточка:                   Форматирование документации.
                                                              (line   6)
* справочная карточка по GDB:            Форматирование документации.
                                                              (line   6)
* среда (вашей программы):               Среда.               (line   6)
* стек вызовов:                          Стек.                (line   9)
* стек вызовов <1>:                      Цепочки вызовов.     (line   6)
* стек на Alpha:                         MIPS.                (line   6)
* стек на MIPS:                          MIPS.                (line   6)
* стек регистров, AMD 29K:               A29K.                (line   6)
* стиль декодирования символов Си++:     Параметры вывода.    (line 229)
* счетчик игнорирований (точек останова): Условия.            (line  70)
* таблица символов:                      Файлы.               (line   6)
* текущая нить:                          Нити.                (line  37)
* текущий кадр стека:                    Кадры.               (line  44)
* текущий каталог:                       Пути для исходных файлов.
                                                              (line  40)
* терминал:                              Ввод-вывод.          (line   6)
* типы, проверка:                        Проверка.            (line  31)
* тихий выбор стека:                     Кадры.               (line  50)
* точка останова по адресу памяти:       Точки останова.      (line  22)
* точка останова по изменению переменной: Точки останова.     (line  22)
* точка останова по событию:             Точки останова.      (line  34)
* точки наблюдения:                      Точки останова.      (line  22)
* точки наблюдения и нити:               Установка точек наблюдения.
                                                              (line 117)
* точки останова:                        Точки останова.      (line   6)
* точки останова в нитях:                Остановка нитей.     (line  10)
* точки останова и нити:                 Остановка нитей.     (line  10)
* точки перехвата:                       Точки останова.      (line  34)
* точки перехвата, установка:            Установка точек перехвата.
                                                              (line   6)
* трассировка памяти:                    Точки останова.      (line  22)
* уведомительный вывод в GDB/MI:         Выходной синтаксис GDB/MI.
                                                              (line 101)
* удаленная заглушка, подпрограммы поддержки: Начальная загрузка.
                                                              (line   6)
* удаленная заглушка, пример:            Протокол.            (line   6)
* удаленная отладка:                     Удаленная отладка.   (line   6)
* удаленная последовательная заглушка:   Содержимое заглушки. (line   6)
* удаленная последовательная заглушка, главная подпрограмма: Содержимое заглушки.
                                                              (line  15)
* удаленная последовательная заглушка, инициализация: Содержимое заглушки.
                                                              (line  10)
* удаленная последовательная отладка, обзор: Удаленный.       (line   6)
* удаленное соединение без заглушек:     Сервер.              (line   6)
* удаленные программы, прерывание:       Сеанс отладки.       (line  70)
* удаленный последовательный протокол:   Протокол.            (line  22)
* указатели событий:                     Указатели событий.   (line   6)
* указатели строк:                       Вывод строк.         (line  49)
* указатель кадра:                       Кадры.               (line  20)
* указатель, нахождение объекта ссылки:  Параметры вывода.    (line  82)
* уничтожение текста:                    Команды уничтожения Readline.
                                                              (line   6)
* уничтожение точек останова:            Удаление точек останова.
                                                              (line  38)
* уничтожение точек останова, наблюдения, перехвата: Удаление точек останова.
                                                              (line   6)
* управление данными, в GDB/MI:          Управление данными GDB/MI.
                                                              (line   6)
* управляющий терминал:                  Ввод-вывод.          (line  24)
* условия и точки останова:              Условия.             (line   6)
* условные точки останова:               Условия.             (line   6)
* установка:                             Установка GDB.       (line   6)
* установка значений переменных:         Присваивание.        (line   6)
* установка точек наблюдения:            Установка точек наблюдения.
                                                              (line   6)
* установки вывода:                      Параметры вывода.    (line   6)
* установки по умолчанию Модулы-2:       Установки по умолчанию М-2.
                                                              (line   6)
* файл дампа памяти:                     Файлы.               (line   6)
* файл инициализации:                    Командные файлы.     (line  11)
* файл инициализации, readline:          Файл инициализации Readline.
                                                              (line   6)
* файл истории:                          История.             (line  10)
* файлы символов, отображаемые в память: Файлы.               (line  93)
* фатальные сигналы:                     Сигналы.             (line  15)
* фатальный сигнал:                      Критерий ошибки.     (line   9)
* форматированный вывод:                 Форматы вывода.      (line   6)
* форматы вывода:                        Форматы вывода.      (line   6)
* Фортран:                               Обзор.               (line  37)
* функции без информации о строках, и пошаговое выполнение: Продолжение и пошаговое выполнение.
                                                              (line  97)
* функции-члены:                         Выражения Си++.      (line  20)
* целевой вывод в GDB/MI:                Выходной синтаксис GDB/MI.
                                                              (line 109)
* целевой порядок байтов:                Порядок байтов.      (line   6)
* цепочки вызовов:                       Цепочки вызовов.     (line   6)
* частичный дамп символов:               Символы.             (line 161)
* языки программирования:                Языки.               (line   6)



Tag Table:
Node: Top1077
Node: Обзор7069
Node: Свободные программы8823
Node: Выражение признательности9659
Ref: Выражение признательности-Footnote-115830
Node: Пример сеанса17175
Ref: Пример сеанса-Footnote-124496
Ref: Пример сеанса-Footnote-224575
Node: Вызов24637
Node: Вызов GDB25120
Node: Параметры файлов27301
Node: Параметры режима30805
Ref: Параметры режима-Footnote-136129
Node: Выход из GDB36312
Node: Команды оболочки37197
Node: Команды38082
Node: Синтаксис команд38721
Node: Завершение40597
Node: Справка45076
Node: Выполнение50503
Node: Компиляция51697
Node: Начало выполнения53654
Node: Аргументы56947
Node: Среда58352
Node: Рабочий каталог61752
Node: Ввод-вывод62470
Node: Присоединение64205
Node: Уничтожение процесса66885
Node: Нити67951
Ref: Нити-Footnote-174120
Node: Процессы74270
Node: Остановка77655
Node: Точки останова78916
Node: Установка точек останова82677
Node: Установка точек наблюдения92901
Ref: Установка точек наблюдения-Footnote-199917
Ref: Установка точек наблюдения-Footnote-2100025
Node: Установка точек перехвата100126
Node: Удаление точек останова103974
Node: Отключение105837
Node: Условия108894
Ref: Условия-Footnote-1114513
Node: Команды останова114581
Node: Меню точки останова117678
Node: Ошибки в точках останова119497
Ref: Ошибки в точках останова-Footnote-1121341
Ref: Ошибки в точках останова-Footnote-2121463
Node: Продолжение и пошаговое выполнение121634
Node: Сигналы130533
Node: Остановка нитей134563
Node: Стек138350
Node: Кадры139769
Node: Цепочки вызовов142422
Node: Выбор144221
Node: Информация о кадре147172
Node: Исходные файлы149490
Node: Вывод строк150600
Node: Поиск154680
Node: Пути для исходных файлов155571
Node: Машинный код158742
Node: Данные162021
Node: Выражения164048
Node: Переменные166287
Node: Массивы170371
Node: Форматы вывода173047
Ref: Форматы вывода-Footnote-1175153
Node: Память175328
Node: Автоматическое отображение180150
Node: Параметры вывода184379
Node: История значений195190
Node: Вспомогательные переменные197782
Node: Регистры201157
Ref: Регистры-Footnote-1205102
Node: Вычисления с плавающей точкой205489
Node: Языки206143
Node: Переход от одного языка к другому207345
Node: Имена файлов209166
Node: Установка рабочего языка210051
Node: Автоматическое211257
Node: Отображение языка212400
Node: Проверка213765
Node: Проверка типов215234
Node: Проверка диапазона218117
Node: Поддержка220653
Node: Си221640
Node: Операторы Си222843
Node: Константы Си227511
Node: Выражения Си++230137
Node: Значения Си по умолчанию234064
Node: Проверки в Си234871
Node: Отладка Си235721
Node: Отладка Си++236223
Node: Модула-2239479
Node: Операторы Модулы-2240507
Node: Встроенные функции/процедуры243808
Node: Константы Модулы-2246709
Node: Установки по умолчанию М-2248435
Node: Отклонения249143
Node: Проверки Модулы-2250353
Node: Область видимости в Модуле-2251297
Node: GDB и Модула-2252361
Node: Chill253344
Node: Как отображаются режимы254123
Node: Местоположения258242
Node: Значения и операции с ними260603
Ref: Значения и операции с ними-Footnote-1265661
Node: Проверка диапазона и типов в Chill265855
Node: Установки по умолчанию Chill266947
Node: Символы267616
Node: Изменения275496
Node: Присваивание276500
Node: Переходы279719
Node: Подача сигналов282012
Node: Возврат283135
Node: Вызовы284389
Node: Внесение изменений285203
Node: Файлы GDB286433
Node: Файлы286908
Node: Ошибки с символами298895
Node: Отладочные цели302674
Node: Активные цели303708
Node: Команды для целей305411
Ref: Команды для целей-Footnote-1310165
Node: Порядок байтов310261
Node: Удаленная отладка311383
Node: Удаленный312540
Node: Содержимое заглушки315406
Node: Начальная загрузка317652
Node: Сеанс отладки321840
Node: Протокол325328
Node: Сервер364792
Ref: Сервер-Footnote-1369057
Node: NetWare369195
Node: Отображение объектов ядра371368
Node: Конфигурации372726
Node: Чистая373470
Node: HP-UX373784
Node: Информация о процессах SVR4374082
Node: Встроенная ОС375605
Node: VxWorks376117
Node: Соединение к VxWorks378620
Node: Загрузка на VxWorks379578
Node: Присоединение к VxWorks381399
Node: Встроенные процессоры381886
Node: Встроенный A29K382881
Node: A29K UDI383675
Ref: A29K UDI-Footnote-1384634
Node: A29K EB29K384699
Node: Коммуникации (EB29K)385366
Node: gdb-EB29K388632
Node: Удаленный журнал390086
Node: ARM390549
Node: H8/300390968
Node: Платы Hitachi392599
Node: Hitachi ICE397169
Node: Специально для Hitachi398037
Node: H8/500398507
Node: i960398901
Node: Вызов Nindy400086
Node: Параметры Nindy400828
Node: Сброс Nindy402610
Node: M32R/D403019
Node: M68K403213
Node: M88K404023
Node: Встроенный MIPS404220
Node: PowerPC409205
Node: PA409562
Node: SH409847
Node: Sparclet410357
Node: Файл Sparclet411985
Node: Соединение к Sparclet412899
Node: Загрузка на Sparclet413414
Ref: Загрузка на Sparclet-Footnote-1414630
Node: Выполнение Sparclet414683
Node: Sparclite415306
Node: ST2000415717
Node: Z8000417383
Node: Архитектуры418796
Node: A29K419115
Node: Alpha419972
Node: MIPS420103
Node: Управление GDB421153
Node: Приглашение421904
Node: Редактирование422724
Node: История423605
Node: Размер экрана426485
Node: Числа427964
Node: Сообщения/предупреждения429711
Node: Отладочный вывод431859
Node: Последовательности434161
Node: Определяемые пользователем команды434866
Node: Ловушки438334
Node: Командные файлы440761
Ref: Командные файлы-Footnote-1443101
Node: Вывод443213
Node: Emacs445890
Node: Примечания452288
Node: Обзор примечаний453491
Node: Префикс server455186
Node: Примечания к значениям455822
Node: Примечания к кадрам458967
Node: Отображения462803
Node: Приглашения463784
Node: Ошибки465388
Node: Информация о точке останова466371
Node: Недостоверность467571
Node: Примечания к выполнению468109
Node: Примечания к исходному тексту469745
Node: Дальнейшие планы470695
Node: GDB/MI471343
Node: Синтаксис команд GDB/MI473507
Node: Входной синтаксис GDB/MI473760
Node: Выходной синтаксис GDB/MI475449
Node: Простые примеры GDB/MI479220
Node: Совместимость GDB/MI с CLI480332
Node: Выходные записи GDB/MI481068
Node: Результирующие записи GDB/MI481361
Node: Поточные записи GDB/MI482006
Node: Внеочередные записи GDB/MI483160
Node: Формат описания команд GDB/MI483689
Node: Команды GDB/MI для таблицы точек останова484625
Node: Управление данными GDB/MI500130
Node: Управление программой GDB/MI517695
Node: Разные команды GDB/MI530396
Node: Управление стеком GDB/MI532260
Node: Запросы GDB/MI о символах539666
Node: Управление целью GDB/MI542610
Node: Команды GDB/MI для нитей549530
Node: Команды GDB/MI для точек трассировки551641
Node: Изменяемые объекты GDB/MI551922
Node: Ошибки в GDB559835
Node: Критерий ошибки560582
Node: Отчеты об ошибках561528
Node: Редактирование командной строки569384
Node: Введение и обозначения570289
Node: Взаимодействие с Readline571921
Node: Сведения первой необходимости573182
Node: Команды перемещения Readline574914
Node: Команды уничтожения Readline575997
Node: Параметры команд Readline578150
Node: Поиск в истории579153
Node: Файл инициализации Readline580995
Node: Синтаксис файла инициализации Readline582246
Node: Условные конструкции инициализации592232
Node: Пример файла инициализации594901
Node: Привязываемые команды Readline598205
Node: Команды для перемещения599136
Node: Команды для истории600001
Node: Команды для текста602638
Node: Команды для уничтожения604712
Node: Числовые параметры606872
Node: Команды для завершения607963
Node: Клавиатурные макросы609673
Node: Разные команды610258
Node: Режим vi Readline613129
Node: Интерактивное использование истории614069
Node: Взаимодействие с историей614625
Node: Указатели событий615980
Node: Указатели слов616994
Node: Модификаторы618598
Node: Форматирование документации619820
Ref: Форматирование документации-Footnote-1623317
Node: Установка GDB623374
Node: Отдельный объектный каталог627082
Node: Имена конфигураций629757
Node: Ключи configure631333
Node: Алфавитный указатель633809

End Tag Table


Local Variables:
coding: koi8-r
End:
