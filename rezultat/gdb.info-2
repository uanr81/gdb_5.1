This is gdb.info, produced by texi2any version 6.7 from gdb.texinfo.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* Gdb-ru: (gdb-ru).                  Отладчик GNU.
END-INFO-DIR-ENTRY

Этот файл описывает отладчик GNU GDB.

   'Отладка с помощью GDB: отладчик GNU уровня исходного кода', Восьмая
Редакция, Март 2000, для GDB версии 5.0.

   Copyright (C) 1988-2000 Free Software Foundation, Inc.
Перевод Copyright (C) 1999-2001 Дмитрий Сиваченко.  Под редакцией Олега
Тихонова.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: gdb.info,  Node: Отладочные цели,  Next: Конфигурации,  Prev: Файлы GDB,  Up: Top

13 Определение отладочной цели
******************************

"Цель" -- это среда выполнения, занятая вашей программой.

   Часто GDB выполняется в той же рабочей среде, что и ваша программа; в
этом случае отладочная цель задается неявно в момент использования
команд 'file' или 'core'.  Когда вам нужна большая гибкость -- например,
выполнение GDB на другой машине, или управление автономной системой
через последовательный порт или системой реального времени через
соединение TCP/IP -- вы можете использовать команду 'target' для
определения цели одного из типов, сконфигурированных для GDB (*note
Команды для управления целями: Команды для целей.).

* Menu:

* Активные цели::               Активные цели
* Команды для целей::           Команды для управления целями
* Порядок байтов::              Выбор целевого порядка байтов
* Удаленная отладка::           Удаленная отладка
* Отображение объектов ядра::    Отображение объектов ядра


File: gdb.info,  Node: Активные цели,  Next: Команды для целей,  Up: Отладочные цели

13.1 Активные цели
==================

Существует три класса целей: процессы, файлы дампов памяти и выполняемые
файлы.  GDB может обрабатывать одновременно до трех активных целей, по
одной в каждом классе.  Это позволяет вам (например) запустить процесс и
проверять его действия, не прерывая вашу работу над файлом дампа.

   Например, если вы выполняете 'gdb a.out', то исполняемый файл 'a.out'
является единственной активной целью.  Если вы назначите также файл
дампа -- возможно, от предыдущего выполнения, завершившегося ошибкой и
создавшего дамп, -- тогда GDB имеет две активные цели и использует их
вместе, просматривая сначала файл дампа, а затем исполняемый файл, для
выполнения запросов к адресам памяти.  (Обычно эти два класса целей
дополняют друг друга, так как файлы дампа памяти содержат только память
программы, доступную для чтения и записи (переменные и тому подобное), и
машинное состояние, в то время как исполняемые файлы содержат только
текст программы и инициализированные данные.)

   Когда вы вводите 'run', ваш исполняемый файл становится также
активным целевым процессом.  Когда целевой процесс активен, все команды
GDB, запрашивающие адреса памяти, относятся к этой цели; адреса в
активной цели файла дампа или выполняемого файла неизвестны, пока
активен целевой процесс.

   Используйте команды 'core-file' и 'exec-file' для выбора новой цели
файла дампа памяти или выполняемого файла (*note Команды для задания
файлов: Файлы.).  Для определения в качестве цели процесса, который уже
выполняется, используйте команду 'attach' (*note Отладка запущенного
ранее процесса: Присоединение.).


File: gdb.info,  Node: Команды для целей,  Next: Порядок байтов,  Prev: Активные цели,  Up: Отладочные цели

13.2 Команды для управления целями
==================================

'target ТИП ПАРАМЕТРЫ'
     Соединяет рабочую среду GDB с целевой машиной или процессом.  Целью
     обычно является протокол для взаимодействия со средствами отладки.
     Параметр ТИП используется, чтобы определить тип или протокол
     целевой машины.

     Дальнейшие ПАРАМЕТРЫ интерпретируются целевым протоколом, но обычно
     включают такие вещи, как имена устройств или имена рабочих машин, с
     которыми осуществляется связь, номера процессов и скорости в бодах.

     Команда 'target' не повторяется при повторном нажатии <RET> после
     ее выполнения.

'help target'
     Отображает имена всех доступных целей.  Чтобы отобразить выбранные
     в данный момент цели, используйте либо 'info target', либо 'info
     files' (*note Команды для задания файлов: Файлы.).

'help target ИМЯ'
     Описывает определенную цель, включая любые параметры, необходимые
     для ее выбора.

'set gnutarget АРГ'
     GDB использует свою собственную библиотеку BFD(1) для чтения ваших
     файлов.  GDB знает, читает ли он "выполняемый файл", "файл дампа
     памяти" или "объектный (.o)" файл; однако вы можете определить
     формат файла командой 'set gnutarget'.  В отличие от большинства
     команд 'target', в команде 'gnutarget' слово 'target' относится к
     программе, а не к машине.

          _Предупреждение:_ Для определения формата файла посредством
          'set gnutarget', вы должны знать фактическое имя BFD.

     *Note Команды для задания файлов: Файлы.

'show gnutarget'
     Используйте команду 'show gnutarget' для отображения, какого
     формата файлы 'gnutarget' установлен считывать.  Если вы не
     установили 'gnutarget', GDB определит формат для каждого файла
     автоматически, и 'show gnutarget' выведет 'The current BFD target
     is "auto"'.

   Ниже приведены некоторые наиболее распространенные цели (доступные
или нет, в зависимоси от конфигурации GDB):

'target exec ПРОГРАММА'
     Выполняемый файл.  'target exec ПРОГРАММА' -- это то же самое, что
     и 'exec-file ПРОГРАММА'.

'target core ИМЯ-ФАЙЛА'
     Файл дампа памяти.  'target core ИМЯ-ФАЙЛА' -- это то же самое, что
     и 'core-file ИМЯ-ФАЙЛА'.

'target remote УСТР'
     Удаленная последовательная цель является уникальным для GDB
     протоколом.  Параметр УСТР определяет, какое последовательное
     устройство использовать для соединения (например, '/dev/ttya').
     *Note Удаленная отладка: Удаленная отладка.  'target remote'
     поддерживает команду 'load'.  Это полезно, только если вы можете
     получить заглушку для целевой системы каким-нибудь другим способом
     и можете разместить ее в памяти, где она не будет затерта
     загрузкой.

'target sim'
     Встроенный эмулятор ЦП. GDB включает эмуляторы для большинства
     архитектур.  Вообще,
                  target sim
                  load
                  run
     работает; однако, вы не можете предполагать, что доступны какое-то
     отображение памяти, драйверы устройств или даже элементарные
     функции ввода-вывода, хотя некоторые эмуляторы действительно
     предоставляют это.  Для информации о деталях эмуляторов для
     конкретного процессора, смотрите соответствующий *note Встроенные
     процессоры: Встроенные процессоры.

   Некоторые конфигурации могут также включать такие цели:

'target nrom УСТР'
     Эмулятор NetROM ROM. Эта цель поддерживает только загрузку.

   Для различных конфигураций GDB доступны различные цели; ваша
конфигурация может иметь больше или меньше целей.

   Многие удаленные цели требуют, чтобы вы загрузили код выполняемого
файла после того как успешно установили соединение.

'load ИМЯ-ФАЙЛА'
     В зависимости от того, какие возможности удаленной отладки
     сконфигурированы в GDB, может быть доступна команда 'load'.  Если
     она существует, ее задачей является сделать ИМЯ-ФАЙЛА (выполняемый
     файл) доступным для отладки на удаленной системе -- например, путем
     загрузки или динамической сборки.  'load' также записывает таблицу
     символов ИМЯ-ФАЙЛА в GDB, как команда 'add-symbol-file'.

     Если ваш GDB не имеет команды 'load', попытка выполнить ее выдает
     сообщение об ошибке "'You can't do that when your target is ...'".

     Файл загружается по адресу, указанному в выполняемом файле.  Для
     некоторых форматов объектных файлов вы можете задать адрес загрузки
     при сборке программы; для других форматов, таких как a.out, формат
     объектного файла задает фиксированный адрес.

     'load' не повторяется, если вы нажимаете <RET> снова после ее
     использования.

   ---------- Footnotes ----------

   (1) от 'Binary File Descriptor' (библиотека описания двоичных
файлов).  (Прим. переводчика)


File: gdb.info,  Node: Порядок байтов,  Next: Удаленная отладка,  Prev: Команды для целей,  Up: Отладочные цели

13.3 Выбор целевого порядка байтов
==================================

Некоторые типы процессоров, такие как MIPS, PowerPC и Hitachi SH,
предоставляют возможность выполнения либо с порядком байтов от старшего,
либо с порядком байтов от младшего.  Обычно выполняемый файл или таблица
символов содержат информацию для определения используемого порядка
байтов, и вам не нужно об этом заботиться.  Однако, иногда вам все же
может пригодиться вручную изменить порядок байтов процессора,
определенный GDB.

'set endian big'
     Велит GDB считать, что целевой порядок байтов от старшего.

'set endian little'
     Велит GDB считать, что целевой порядок байтов от младшего.

'set endian auto'
     Велит GDB использовать порядок байтов, указанный в выполняемом
     файле.

'show endian'
     Отображает текущую установку GDB для целевого порядка байтов.

   Заметьте, что эти команды управляют только интерпретацией символьных
данных в рабочей системе, и они совершенно не оказывают действия на
целевую систему.


File: gdb.info,  Node: Удаленная отладка,  Next: Отображение объектов ядра,  Prev: Порядок байтов,  Up: Отладочные цели

13.4 Удаленная отладка
======================

Если вы пытаетесь отлаживать программу, выполняющуюся на машине, которая
не может запустить GDB обычным способом, часто бывает полезна удаленная
отладка.  Например, вы можете использовать удаленную отладку для ядра
операционной системы или для малой системы, которая не имеет достаточно
мощной операционной системы общего назначения для вызова отладчика со
всеми возможностями.

   Некоторые конфигурации GDB имеют специальный последовательный или
TCP/IP-интерфейсы для того, чтобы это работало с конкретными отладочными
целями.  Кроме того, GDB распространяется с общим последовательным
протоколом (уникальным для GDB, но не для конкретной целевой системы),
который вы можете использовать, если пишете удаленные заглушки -- код,
выполняемый в удаленной системе для связи с GDB.

   В вашей конфигурации GDB могут быть доступны другие удаленные цели;
используете 'help target', чтобы получить их список.

* Menu:

* Удаленный::                   Удаленный последовательный протокол GDB


File: gdb.info,  Node: Удаленный,  Up: Удаленная отладка

13.4.1 Удаленный последовательный протокол GDB
----------------------------------------------

Для отладки программы, выполняемой на другой машине (отладочной
"целевой" машине), вы сперва должны создать все обычные предпосылки для
самостоятельного выполнения программы.  Например, для программы на Си
вам нужны:

  1. Процедура запуска для установки среды выполнения Си; она обычно
     имеет имя типа 'crt0'.  Процедура запуска может быть обеспечена
     аппаратными средствами, или вы должны написать свою собственную.

  2. Библиотека подпрограмм Си для поддержки вызовов подпрограмм вашей
     программы, особенно для управления вводом и выводом.

  3. Способ установки вашей программы на другую машину -- например,
     программа загрузки.  Такие программы часто предоставляются
     поставщиками аппаратных средств, но вам может потребоваться
     написать вашу собственную, пользуясь документацией к аппаратному
     обеспечению.

   Следующим шагом будет принятие мер по использованию вашей программой
последовательного порта для связи с машиной, где выполняется GDB
("рабочей" машиной).  В общих чертах, схема выглядит следующим образом:

_На рабочей машине_
     GDB уже понимает, как использовать этот протокол; после установки
     всего остального, вы можете просто использовать команду 'target
     remote' (*note Определение отладочной цели: Отладочные цели.).

_На целевой машине_
     вы должны скомпоновать вместе с вашей программой несколько
     подпрограмм специального назначения, которые реализуют удаленный
     последовательный протокол GDB. Файл, содержащий эти подпрограммы,
     называется "отладочной заглушкой".

     На некоторых удаленных целях, вы можете использовать
     вспомогательную программу 'gdbserver' вместо компоновки заглушки
     вместе с вашей программой.  *Note Использование программы
     'gdbserver': Сервер, для детального изучения.

   Отладочная заглушка специфична для архитектуры удаленной машины;
например, используйте 'sparc-stub.c' для отладки программ на машинах
SPARC.

   Следующие работающие удаленные заглушки распространяются вместе с
GDB:

'i386-stub.c'
     Для Intel 386 и совместимых архитектур.

'm68k-stub.c'
     Для архитектур Motorola 680x0.

'sh-stub.c'
     Для архитектур Hitachi SH.

'sparc-stub.c'
     Для архитектур SPARC.

'sparcl-stub.c'
     Для архитектур Fujitsu SPACRLITE.

   Файл 'README' в поставке GDB может содержать другие недавно
добавленные заглушки.

* Menu:

* Содержимое заглушки::   Что заглушка может сделать для вас
* Начальная загрузка::    Что вы должны сделать для заглушки
* Сеанс отладки::         Собираем все вместе
* Протокол::              Определение протокола связи
* Сервер::                Использование программы 'gdbserver'
* NetWare::               Использование программы 'gdbserve.nlm'


File: gdb.info,  Node: Содержимое заглушки,  Next: Начальная загрузка,  Up: Удаленный

13.4.1.1 Что заглушка может сделать для вас
...........................................

Отладочная заглушка для вашей архитектуры содержит следующие три
подпрограммы:

'set_debug_traps'
     Когда ваша программа останавливается, эта подпрограмма организует
     выполнение 'handle_exception'.  Вы должны явно вызвать эту
     подпрограмму в начале вашей программы.

'handle_exception'
     Это главная рабочая лошадка, но ваша программа никогда не вызывает
     ее явно -- установочный код организует запуск 'handle_exception',
     когда вызывается ловушка.

     'handle_exception' получает управление, когда ваша программа
     останавливается во время выполнения (например, в точке останова), и
     организует связь с GDB на рабочей машине.  Именно здесь реализуется
     протокол связи; 'handle_exception' действует как представитель GDB
     на целевой машине.  Сперва она посылает суммарную информацию о
     состоянии вашей программы, затем продолжает выполняться, извлекая и
     передавая любую информацию, требующуюся GDB, пока вы не выполните
     команду GDB, возобновляющую выполнение вашей программы; в этом
     месте 'handle_exception' возвращает управление вашему коду на
     целевой машине.

'breakpoint'
     Используйте эту вспомогательную подпрограмму для установки в вашей
     программе точек останова.  В зависимости от конкретной ситуации,
     это может быть единственным способом для GDB получить управление.
     Например, если ваша целевая машина имеет некую клавишу прерывания,
     вам не нужно вызывать эту подпрограмму; нажатие клавиши прерывания
     передаст управление 'handle_exception' -- в действительности, GDB.
     На некоторых машинах простое получение знаков на последовательный
     порт может также вызвать ловушку; опять, в этой ситуации вам не
     нужно вызывать 'breakpoint' из вашей программы -- простое
     выполнение 'target remote' из рабочего сеанса GDB передаст
     управление.

     Вызывайте 'breakpoint', если ни одно из этих предположений не
     верно, или вы просто хотите быть уверенным, что ваша программа
     остановится в предопределенной точке от начала вашего сеанса
     отладки.


File: gdb.info,  Node: Начальная загрузка,  Next: Сеанс отладки,  Prev: Содержимое заглушки,  Up: Удаленный

13.4.1.2 Что вы должны сделать для заглушки
...........................................

Отладочные заглушки, поставляемые с GDB, ориентированы на
микропроцессоры определенной архитектуры, но они не имеют информации об
остальной части вашей целевой отладочной машины.

   В первую очередь, вам нужно сообщить заглушке, как связаться с
последовательным портом.

'int getDebugChar()'
     Напишите эту подпрограмму для чтения одного знака из
     последовательного порта.  Она может быть идентична 'getchar' для
     вашей целевой системы; разные имена используются, чтобы позволить
     вам их различать, если вы этого хотите.

'void putDebugChar(int)'
     Напишите эту подпрограмму для записи одного знака в
     последовательный порт.  Она может быть идентична 'putchar' для
     вашей целевой системы; разные имена используются, чтобы позволить
     вам их различать, если вы этого хотите.

   Если вы хотите, чтобы GDB мог остановить вашу программу во время ее
выполнения, вам нужно использовать управляемый прерываниями
последовательный драйвер и настроить его для остановки при получении
'^C' ('\003', знак control-C). Это тот знак, который GDB использует для
указания удаленной системе остановиться.

   Указание отладочной цели вернуть GDB правильный статус, вероятно,
потребует изменений в стандартной заглушке; один быстрый и неаккуратный
способ состоит в выполнении лишь инструкции точки останова
("неаккуратность" состоит в том, что GDB выдает 'SIGTRAP' вместо
'SIGINT').

   Вот другие процедуры, которые вы должны обеспечить:

'void exceptionHandler (int НОМЕР-ИСКЛЮЧЕНИЯ, void *АДРЕС-ИСКЛЮЧЕНИЯ)'
     Напишите эту функцию для установки АДРЕСА-ИСКЛЮЧЕНИЯ в таблицы
     обработки исключительных ситуаций.  Вам нужно сделать это, потому
     что у заглушки нет способа узнать, как устроены таблицы обработки
     исключений в вашей целевой системе (например, процессорная таблица
     может находиться в ПЗУ и содержать элементы, указывающие на таблицу
     в ОЗУ).  НОМЕР-ИСКЛЮЧЕНИЯ -- это номер исключительной ситуации,
     которая должна быть изменена; его значение зависит от архитектуры
     (например, различные номера могут представлять деление на ноль,
     доступ с нарушением выравнивания и так далее).  Когда это
     исключение возникает, управление должно быть передано
     непосредственно АДРЕСУ-ИСКЛЮЧЕНИЯ, и процессорное состояние (стек,
     регистры и так далее) должно быть таким же, как во время
     возникновения процессорного исключения.  Так что если вы хотите
     использовать инструкцию перехода для достижения АДРЕСА-ИСКЛЮЧЕНИЯ,
     это должен быть простой переход, не переход к подпрограмме.

     Для 386, АДРЕС-ИСКЛЮЧЕНИЯ должен быть установлен как обработчик
     затвора вызова прерывания, чтобы во время его выполнения остальные
     прерывания маскировались.  Он должен иметь уровень полномочий 0
     (наибольшие полномочия).  Заглушки SPARC и 68k могут маскировать
     прерывания самостоятельно без помощи 'exceptionHandler'.

'void flush_i_cache()'
     Только для SPARC и SPARCLITE.  Напишите эту подпрограмму для
     очистки кеша инструкций на вашей целевой машине, если он есть.
     Если кеша инструкций нет, эта подпрограмма может ничего не делать.

     На целевых машинах, имеющих кеш инструкций, GDB требует эту
     функцию, чтобы удостовериться, что состояние вашей программы
     стабильно.

Вы должны также удостовериться, что доступна такая библиотечная
процедура:

'void *memset(void *, int, int)'
     Это стандартная библиотечная функция 'memset', которая
     устанавливает область памяти в заданное значение.  Если у вас есть
     одна из свободных версий 'libc.a', 'memset' может быть найдена там;
     иначе вы должны или получить ее от изготовителя аппаратного
     обеспечения, или написать свою собственную.

   Если вы не используете компилятор GNU Си, вам также могут
понадобиться другие стандартные библиотечные подпрограммы; это меняется
от одной заглушки к другой, но в общем, заглушки часто используют
различные общие библиотечные подпрограммы, которые 'gcc' генерирует как
встроенный код.


File: gdb.info,  Node: Сеанс отладки,  Next: Протокол,  Prev: Начальная загрузка,  Up: Удаленный

13.4.1.3 Собираем все вместе
............................

Вкратце, когда ваша программа готова к отладке, вы должны проделать
следующие шаги.

  1. Убедитесь, что вы определили поддерживающие процедуры низкого
     уровня (*note Что вы должны сделать для заглушки: Начальная
     загрузка.):
          'getDebugChar', 'putDebugChar',
          'flush_i_cache', 'memset', 'exceptionHandler'.

  2. Вставьте следующие строки в начале вашей программы:

          set_debug_traps();
          breakpoint();

  3. Для заглушки 680x0, вы должны предоставить переменную
     'exceptionHook'.  Обычно вы используете просто

          void (*exceptionHook)() = 0;

     если до вызова 'set_debug_traps' вы установили ее для указания на
     функцию в вашей программе.  Эта функция вызывается, когда GDB
     продолжает выполнение после останова на ловушке (например, ошибка
     шины).  Функция, указанная 'exceptionHook', вызывается с одним
     параметром типа 'int', который является номером исключения.

  4. Откомпилируйте и скомпонуйте вместе: вашу программу, отладочную
     заглушку GDB для вашей целевой архитектуры и подпрограммы
     поддержки.

  5. Убедитесь, что у вас есть последовательное соединение между вашей
     целевой и рабочей машинами, и идентифицируйте последовательный порт
     на рабочей машине.

  6. Загрузите вашу программу на целевую машину (или поместите ее туда
     любыми средствами, предоставляемыми производителем) и запустите ее.

  7. Для начала удаленной отладки, запустите GDB на рабочей машине и
     укажите в качестве выполняемого файла программу, которая
     выполняется на удаленной машине.  Это сообщает GDB, как найти
     символы и содержание неизменяемых областей вашей программы.

  8. Установите связь, используя команду 'target remote'.  Ее аргументы
     определяют, как взаимодействовать с целевой машиной -- либо через
     устройство, подключенное к последовательной линии, либо через порт
     TCP (обычно подключенный к терминальному серверу, который, в свою
     очередь, имеет последовательную линию до цели).  Например, чтобы
     использовать последовательную линию, присоединенную к устройству
     '/dev/ttyb', выполните:

          target remote /dev/ttyb

     Чтобы использовать TCP-соединение, используйте аргумент в форме
     'МАШИНА:порт'.  Например, для соединения с портом 2828 на
     терминальном сервере 'manyfarms':

          target remote manyfarms:2828

   Теперь вы можете использовать все обычные команды для исследования и
изменения данных, пошагового выполнения и продолжения исполнения
удаленной программы.

   Для возобновления выполнения удаленной программы и прекращения ее
отладки, используйте команду 'detach'.

   Всякий раз, когда GDB ожидает удаленную программу, если вы вводите
знак прерывания (часто 'C-C'), GDB пытается остановить программу.  Это
может привести или не привести к успеху, частично в зависимости от
аппаратных средств и последовательных драйверов, которые использует
удаленная система.  Если вы снова введете знак прерывания, GDB выведет
такое приглашение:

     Interrupted while waiting for the program.
     Give up (and stop debugging it)?  (y or n)

   Если вы введете 'y', GDB прекратит сеанс удаленной отладки.  (Если вы
позже решите попытаться снова, вы можете вновь использовать 'target
remote', чтобы соединиться еще раз.)  Если вы введете 'n', GDB вернется
к ожиданию.


File: gdb.info,  Node: Протокол,  Next: Сервер,  Prev: Сеанс отладки,  Up: Удаленный

13.4.1.4 Коммуникационный протокол
..................................

Файлы заглушек, поставляемые с GDB, реализуют коммуникационный протокол
со стороны целевой машины, а со стороны GDB он реализуется в исходном
файле GDB 'remote.c'.  Обычно вы можете просто позволить этим программам
взаимодействовать и не вдаваться в детали.  (Если вы разрабатываете свой
собственный файл заглушки, вы также можете игнорировать детали: начните
с одного из существующих файлов заглушки.  'sparc-stub.c' организован
наилучшим образом, и потому его легче всего читать.)

   Однако, бывают случаи, когда вам необходимо кое-что знать о протоколе
-- например, если существует только один последовательный порт на вашей
целевой машине, вы можете захотеть, чтобы ваша программа делала
что-нибудь особенное, если она распознает предназначенный для GDB пакет.

   В следующих примерах, '<-' и '->' используются для обозначения
переданных и полученных данных соответственно.

   Все команды и ответы GDB (не подтверждения) посылаются в виде ПАКЕТА.
ПАКЕТ представлен знаком '$', реальными ДАННЫМИ-ПАКЕТА и завершающим
знаком '#', за которым следуют две цифры КОНТРОЛЬНОЙ-СУММЫ:

     $ДАННЫЕ-ПАКЕТА#КОНТРОЛЬНАЯ-СУММА

Двузначная КОНТРОЛЬНАЯ-СУММА вычисляется как сумма по модулю 256 всех
знаков между начальным '$' и конечным '#' (восьмибитная беззнаковая
контрольная сумма).

   Разработчикам следует учесть, что до GDB версии 5.0 спецификация
протокола также включала необязательный двузначный ИД-ПОСЛЕДОВ:

     $ИД-ПОСЛЕДОВ:ДАННЫЕ-ПАКЕТА#КОНТРОЛЬНАЯ-СУММА

Этот ИД-ПОСЛЕДОВ добавлялся к подтверждению.  GDB никогда не генерировал
ИД-ПОСЛЕДОВ.  Заглушки, занимающиеся обработкой пакетов, добавленные в
GDB начиная с версии 5.0, не должны принимать пакеты с ИД-ПОСЛЕДОВ.

   Когда или рабочая, или целевая машина получает пакет, первым
ожидаемым ответом является подтверждение: или '+' (для указания, что
пакет получен корректно), или '-' (чтобы запросить повторную передачу):

     <- $ДАННЫЕ-ПАКЕТА#КОНТРОЛЬНАЯ-СУММА
     -> +

   Рабочая машина (GDB) посылает КОМАНДЫ, а целевая (отладочная
заглушка, включенная в вашу программу) посылает ОТВЕТ.  В случае КОМАНД
пошагового выполнения и продолжения, ответ посылается только тогда,
когда операция закончена (цель снова остановлена).

   ДАННЫЕ-ПАКЕТА состоят из последовательности знаков, за исключением
'#' и '$' (для дополнительных исключений, смотрите пакет 'X').

   Поля внутри пакета должны разделяться при помощи ',', ';' или ':'.
Если не оговорено противное, все числа представлены в шестнадцатеричном
виде без начальных нулей.

   Разработчикам следует учесть, что до GDB версии 5.0, знак ':' не мог
появляться третьим знаком в пакете (так как потенциально это могло
привести к конфликту с ИД-ПОСЛЕДОВ).

   ДАННЫЕ ответа могут быть для экономии закодированы методом длины
серий.  '*' означает, что следующий знак является ASCII-кодом, который
обозначает количество повторений знака, предшествующего '*'.  Кодировкой
является 'n+29', что дает печатный знак для 'n >=3' (когда кодировка
переменной длины начинает давать преимущество).  Печатные знаки '$',
'#', '+', '-' или знаки с номерами, большими 126, использоваться не
должны.

   Некоторые удаленные системы использовали другой механизм кодировки с
переменной длиной, иногда называемый cisco-кодировкой.  За '*' следуют
две шестнадцатеричные цифры, обозначающие размер пакета.

   Итак:
     "0* "
означает то же, что и "0000".

   При ошибке, ответ, возвращаемый для некоторых пакетов, включает
двузначный номер ошибки.  Этот номер определен смутно.

   Для любой КОМАНДЫ, не поддерживаемой заглушкой, должен быть возвращен
пустой ответ ('$#00').  Таким образом, протокол можно расширять.  По
этому ответу новые версии GDB могут определить, поддерживается тот или
иной пакет.

   От заглушки требуется поддержка КОМАНД 'g', 'G', 'm', 'M', 'c' и 's'.
Все остальные КОМАНДЫ являются необязательными.

   Вот полный список всех определенных на данный момент КОМАНД и
соответствующих им ответов ДАННЫЕ:
Пакет                  Запрос                 Описание
                                              
расширенные операции   '!'                    Использовать расширенный
                                              удаленный протокол.  Имеет
                                              постоянное действие --
                                              требует установки только
                                              один раз.  Расширенный
                                              удаленный протокол
                                              поддерживает пакеты 'R'.
                       ответ ''               Заглушки, поддерживающие
                                              расширенный удаленный
                                              протокол, возвращают '',
                                              что, к сожалению, совпадает
                                              с ответом, возвращаемым
                                              заглушками, которые не
                                              поддерживают расширения
                                              протокола.
                                              
последний сигнал       '?'                    Указывает причину, по
                                              которой цель остановилась.
                                              Ответ такой же, как для
                                              пошагового выполнения и
                                              продолжения.
                       ответ                  смотрите ниже
                                              
зарезервировано        'a'                    Зарезервировано для
                                              использования в будущем
                                              
установить аргументы   'A'ДЛИНА-АРГ','ЧИСЛО-АРГ','АРГ',...'
программы
*(зарезервировано)*
                                              В программу передается
                                              инициализированный массив
                                              'argv[]'.  ДЛИНА-АРГ задает
                                              число байт в закодированном
                                              в шестнадцатеричный вид
                                              потоке байт АРГ.  Смотрите
                                              'gdbserver' для
                                              дополнительной информации.
                       ответ 'OK'
                       ответ 'E'NN
                       
установить скорость    'b'БОД                 Установить скорость
*(не рекомендовано)*                          последовательной линии в
                                              БОД.
                                              
установить точку       'B'АДРЕС,РЕЖИМ         Установить (РЕЖИМ 'S') или
останова *(не                                 удалить (РЕЖИМ 'C') точку
рекомендовано)*                               останова по адресу АДРЕС.
                                              _Это было замещено пакетами
                                              'Z' и 'z'._
                                              
продолжить             'c'АДРЕС               АДРЕС -- это адрес для
                                              возобновления выполнения.
                                              Если он опущен, возобновить
                                              с текущего адреса.
                       ответ                  смотрите ниже
                                              
продолжить с           'C'СИГ';'АДРЕС         Продолжить с сигналом СИГ
сигналом                                      (шестнадцатеричный номер
                                              сигнала).  Если '';'АДРЕС'
                                              опущено, выполнение
                                              возобновляется с прежнего
                                              адреса.
                       ответ                  смотрите ниже
                                              
переключить режим      'd'                    переключить флаг отладки.
отладки *(не                                  
рекомендовано)*
отсоединиться          'D'                    Отсоединить GDB от
                                              удаленной системы.
                                              Посылается удаленной
                                              системе перед тем, как GDB
                                              отсоединится.
                       ответ _нет ответа_     GDB не ждет никакого ответа
                                              после посылки этого пакета.
                                              
зарезервировано        'e'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'E'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'f'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'F'                    Зарезервировано для
                                              использования в будущем
                                              
чтение регистров       'g'                    Чтение регистров общего
                                              назначения.
                       ответ XX...            Каждый байт данных регистра
                                              описывается двумя
                                              шестнадцатеричными цифрами.
                                              Они передаются с целевым
                                              порядком байтов.  Размер
                                              каждого регистра и его
                                              позиция внутри ПАКЕТА 'g'
                                              определяются внутренними
                                              макросами GDB
                                              REGISTER_RAW_SIZE и
                                              REGISTER_NAME.
                                              Спецификация нескольких
                                              стандартных пакетов 'g'
                                              приведена ниже.
                       'E'NN                  в случае ошибки.
                                              
запись в регистры      'G'XX...               Смотрите 'g' для описания
                                              данных XX... .
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            в случае ошибки
                                              
зарезервировано        'h'                    Зарезервировано для
                                              использования в будущем
                                              
выбрать нить           'H'CT...               Установить нить для
                                              последующих операций ('m',
                                              'M', 'g', 'G' и других).  C
                                              = 'c' для нитей,
                                              используемых при пошаговом
                                              выполнении и продолжении;
                                              T... может быть -1 для всех
                                              нитей.  C = 'g' для нитей,
                                              используемых в других
                                              операциях.  Если ноль --
                                              выбрать любую нить.
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            в случае ошибки
                                              
пошаговое выполнение   'i'АДРЕС','NNN         Выполнить один тактовый
по тактовому циклу                            цикл на удаленной машине.
*(черновик)*                                  Если '','NNN' указано,
                                              выполнить NNN циклов.  Если
                                              указан АДРЕС, пошаговое
                                              выполнение по одному
                                              тактовому циклу начинается
                                              этого адреса.
                                              
сигнал, затем          'I'                    Смотрите 'i' и 'S', там
выполнение по                                 аналогичный синтаксис и
тактовым циклам                               семантика.
*(зарезервировано)*                           
зарезервировано        'j'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'J'                    Зарезервировано для
                                              использования в будущем
                                              
убить                  'k'                    FIXME: _Нет описания, как
                                              действовать в случае, если
                                              был выбран контекст
                                              определенной нити (то есть
                                              'k' убивает только эту
                                              нить?)_.
                                              
зарезервировано        'l'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'L'                    Зарезервировано для
                                              использования в будущем
                                              
чтение памяти          'm'АДРЕС','ДЛИНА       Прочитать ДЛИНУ байт
                                              памяти, начиная с адреса
                                              АДРЕС.  Ни GDB, ни заглушка
                                              не предполагают, что
                                              передача области памяти
                                              происходит по адресам,
                                              выровненным по границе
                                              слова.  FIXME: _Нужен
                                              механизм передачи области
                                              памяти, выровненной по
                                              границе слова._
                       ответ XX...            XX... представляет собой
                                              содержимое памяти.  Может
                                              содержать меньше
                                              запрошенного числа байт,
                                              если удалось прочитать
                                              только часть данных.  Ни
                                              GDB, ни заглушка не
                                              предполагают, что передача
                                              области памяти происходит
                                              по адресам, выровненным по
                                              границе слова.  FIXME:
                                              _Нужен механизм передачи
                                              области памяти, выровненной
                                              по границе слова._
                       ответ 'E'NN            NN представляет номер
                                              ошибки
                                              
запись в память        'M'АДРЕС,ДЛИНА':'XX... Записать ДЛИНУ байт памяти,
                                              начиная с адреса АДРЕС.
                                              XX... -- это данные.
                       ответ 'OK'             при успехе
                       ответ 'E'NN            при ошибке (это включает
                                              случай, когда была записана
                                              только часть данных).
                                              
зарезервировано        'n'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'N'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'o'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'O'                    Зарезервировано для
                                              использования в будущем
                                              
чтение регистров       'p'N...                Смотрите запись регистров.
*(зарезервировано)*
                       возврат R....          Значение регистра в целевом
                                              порядке байт,
                                              закодированное в
                                              шестнадцатеричном виде.
                                              
запись регистров       'P'N...'='R...         Записать в регистр N...
                                              значение R..., которое
                                              содержит две
                                              шестнадцатеричные цифры для
                                              каждого байта в регистре
                                              (целевой порядок байтов).
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            при ошибке
                                              
общий запрос           'q'ЗАПРОС              Запросить информацию о
                                              ЗАПРОСЕ.  Вообще, запросы
                                              GDB начинаются с заглавной
                                              буквы.  Специальные запросы
                                              от производителей должны
                                              использовать приставку
                                              компании (из маленьких
                                              букв).  Например:
                                              'qfsf.var'.  За ЗАПРОСОМ
                                              может следовать
                                              необязательный список,
                                              разделенный ',' или ';'.
                                              Заглушки должны проверять,
                                              что они производят
                                              сравнение с полным именем
                                              ЗАПРОСА.
                       ответ 'XX...'          Данные от запроса,
                                              закодированные
                                              шестнадцатеричными цифрами.
                                              Ответ не может быть пустым.
                       ответ 'E'NN            ответ при ошибке
                       ответ ''               Указывает на нераспознанный
                                              ЗАПРОС.
                                              
общая установка        'Q'ПЕРЕМ'='ЗНАЧ        Установить значение ПЕРЕМ в
                                              ЗНАЧ.  Смотрите 'q' для
                                              обсуждения соглашений,
                                              касающихся имен.
                                              
сброс *(не             'r'                    Установка всей системы в
рекомендовано)*                               исходное состояние.
                                              
удаленная              'R'XX                  Перезапустить удаленный
перезагрузка                                  сервер.  XX не имеет ясного
                                              определения, хотя оно
                                              нужно.  FIXME: _Нужен
                                              пример взаимодействия,
                                              объясняющий как эти пакеты
                                              используются в расширенном
                                              удаленном режиме_.
                                              
пошаговое выполнение   's'АДРЕС               АДРЕС -- это адрес для
                                              возобновления выполнения.
                                              Если АДРЕС опущен,
                                              возобновить выполнение с
                                              того же адреса.
                       ответ                  смотрите ниже
                                              
пошаговое выполнение   'S'СИГ';'АДРЕС         Как 'C', но разница такая
с сигналом                                    же, как между 'step' и
                                              'continue'.
                       ответ                  смотрите ниже
                                              
поиск                  't'АДРЕС':'PP','MM     Поиск совпадения с шаблоном
                                              PP и маской MM в обратном
                                              направлении, начиная с
                                              АДРЕСА.  PP и MM -- 4
                                              байта.  В АДРЕСЕ должно
                                              быть не менее трех цифр.
                                              
жива ли нить           'T'XX                  Определить, жива ли нить
                                              XX.
                       ответ 'OK'             нить все еще жива
                       ответ 'E'NN            нить мертва
                                              
зарезервировано        'u'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'U'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'v'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'V'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'w'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'W'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'x'                    Зарезервировано для
                                              использования в будущем
                                              
запись в память        'X'АДРЕС','ДЛИНА:XX... АДРЕС -- это адрес, ДЛИНА
(двоичная)                                    -- это число байт, XX... --
                                              это двоичные данные.  Знаки
                                              '$', '#' и '0x7d'
                                              экранируются с помощью
                                              '0x7d'.
                       ответ 'OK'             в случае успеха
                       ответ 'E'NN            в случае ошибки
                                              
зарезервировано        'y'                    Зарезервировано для
                                              использования в будущем
                                              
зарезервировано        'Y'                    Зарезервировано для
                                              использования в будущем
                                              
удалить точку          'z'T','АДРЕС','ДЛИНА   Смотрите 'Z'.
останова или                                  
наблюдения
*(черновик)*
поместить точку        'Z'T','АДРЕС','ДЛИНА   T представляет тип: '0' в
останова или                                  случае программной точки
наблюдения                                    останова, '1' -- аппаратная
*(черновик)*                                  точка останова, '2' --
                                              точка наблюдения за
                                              записью, '3' -- точка
                                              наблюдения за чтением, '4'
                                              -- точка наблюдения за
                                              доступом; АДРЕС -- это
                                              адрес; ДЛИНА задается в
                                              байтах.  Для программной
                                              точки останова, ДЛИНА
                                              задает размер инструкции,
                                              на которую надо поместить
                                              заплату.  Для аппаратных
                                              точек останова и
                                              наблюдения, ДЛИНА указывает
                                              размер области памяти для
                                              наблюдения.  Чтобы избежать
                                              потенциальных проблем с
                                              повторными пакетами,
                                              операции должны быть
                                              реализованы идемпотентным
                                              образом.
                       ответ 'E'NN            в случае ошибки
                       ответ 'OK'             в случае успеха
                       ''                     Если не поддерживается.
                                              
зарезервировано        <другое>               Зарезервировано для
                                              использования в будущем
                                              

   Пакеты 'C', 'c', 'S', 's' и '?' могут получить в качестве ответа все
нижеперечисленное.  В случае пакетов 'C', 'c', 'S' и 's', этот ответ
возвращается только тогда, когда цель останавливается.  Ниже, точное
значение 'номера сигнала' определено нечетко.  Вообще, используется одно
из соглашений UNIX о номерах сигналов.

'S'AA                         AA -- это номер сигнала
                              
'T'AAN...':'R...';'N...':'R...';'N...':'R...';'AA = две шестнадцатеричные цифры номера
                              сигнала; N... = (шестнадцатеричный) номер
                              регистра, R... = содержимое регистра в
                              целевом порядке байт, размер определяется
                              'REGISTER_RAW_SIZE'; N... = 'thread',
                              R... = идентификатор процесса нити, это
                              шестнадцатеричное целое; N... = другая
                              строка, не начинающаяся с
                              шестнадцатеричной цифры.  GDB должен
                              игнорировать эту пару N..., R... и
                              переходить к следующей.  Таким образом мы
                              можем расширять протокол.
                              
'W'AA                         Процесс завершается с кодом выхода AA.
                              Это применимо только к определенным типам
                              целей.
                              
'X'AA                         Процесс завершается с сигналом AA.
                              
'N'AA';'T...';'D...';'B...    AA = номер сигнала; T... = адрес символа
*(устарело)*                  "_start"; D... = база раздела данных;
                              B... = база раздела bss.  _Примечание:
                              используется только целями Cisco Systems.
                              Разница между этим ответом и запросом
                              "qOffsets" заключается в том, что пакет
                              'N' может прибыть самопроизвольно, тогда
                              как запрос 'qOffsets' инициируется
                              рабочим отладчиком._
                              
'O'XX...                      XX... -- шестнадцатеричное представление
                              ASCII-данных.  Это может произойти в
                              любой момент, пока программа выполняется
                              и отладчик должен продолжать ждать 'W',
                              'T' и тому подобное.
                              

   Следующие пакеты для установок и запросов уже были определены.

текущая нить   'q''C'         Возвратить идентификатор текущей нити.
               ответ          Где ИДЕНТ-ПРОЦ -- 16-битный идентификатор
               'QC'ИДЕНТ-ПРОЦ процесса, представленный
                              шестнадцатеричными цифрами.
               ответ *        Любой другой ответ подразумевает старый
                              идентификатор процесса.
                              
идентификаторы 'q''fThreadInfo'
всех нитей
               'q''sThreadInfo'Получить список идентификаторов активных
                              нитей от целевой ОС. Так как число
                              активных нитей может оказаться слишком
                              большим и не поместиться в пакет ответа,
                              этот запрос работает итерациями: для
                              получения полного списка нитей может
                              потребоваться более одной
                              последовательности запрос/ответ.  Первым
                              запросом последовательности будет
                              'qf''ThreadInfo'; последующими запросами
                              последовательности будут запросы
                              'qs''ThreadInfo'.
                              Замечание: замещает запрос 'qL' (смотрите
                              ниже).
               ответ          Идентификатор одной нити
               'm'<ИД>
               ответ          список идентификаторов нитей, разделенных
               'm'<ИД>,<ИД>...запятыми
               ответ 'l'      (буква 'l' в нижнем регистре) обозначает
                              конец списка.
                              В ответ на каждый запрос, цель будет
                              отвечать списком из разделенных запятыми
                              идентификаторов нитей, в
                              шестнадцатеричном представлении, с
                              порядком байт от старшего.  GDB будет
                              отвечать на каждый ответ запросом других
                              идентификаторов (используя форму 'qs'
                              запроса), пока цель не ответит 'l' (буква
                              'l' в нижнем регистре, от английского
                              слова ''last'').
                              
дополнительная 'q''ThreadExtraInfo'','ИД
информация о
нити
                              Здесь ИД является идентификатором нити в
                              шестнадцатеричном представлении, в
                              порядке байт от старшего.  Получает
                              печатаемое описание строки атрибутов нити
                              от целевой ОС. Эта строка может содержать
                              все что угодно, что целевая ОС сочтет
                              интересным для GDB сообщить пользователю
                              о нити.  Эта строка выводится в
                              отображении GDB 'info threads'.
                              Примерами возможной дополнительной
                              информации являются "Runnable" или
                              "Blocked on Mutex".
               ответ XX...    Где XX... -- ASCII-данные в
                              шестнадцатеричном представлении,
                              содержащие печатную строку с
                              дополнительной информацией об атрибутах
                              нити.
                              
запрос         'q''L'НАЧ-ФЛАГЧИСЛО-НИТЕЙСЛЕД-НИТЬ
СПИСОК или
СПИСОК-НИТЕЙ
*(не
рекомендовано)*
                              Получить информацию о нити от
                              операционной системы, где происходит
                              выполнение.  Здесь: НАЧ-ФЛАГ (одна
                              шестнадцатеричная цифра) есть единица,
                              что указывает на первый запрос, или ноль,
                              что определяет последующий запрос;
                              ЧИСЛО-НИТЕЙ (две шестнадцатеричные цифры)
                              -- максимальное число нитей, которое
                              может содержать пакет ответа; и СЛЕД-НИТЬ
                              (восемь шестнадцатеричных цифр), для
                              последующих запросов (НАЧ-ФЛАГ равен
                              нулю), возвращается в ответ как АРГ-НИТЬ.
                              Замечание: этот запрос был замещен
                              запросом 'q''fThreadInfo' (смотрите
                              выше).
               ответ
               'q''M'ЧИСЛОКОНЕЦАРГ-НИТЬНИТЬ...
                              Здесь: ЧИСЛО (две шестнадцатеричные
                              цифры) -- число возвращаемых нитей; КОНЕЦ
                              (одна шестнадцатеричная цифра), есть
                              ноль, который определяет, что есть еще
                              нити, и единица, определяющая, что больше
                              нитей нет; АРГ-НИТЬ (восемь
                              шестнадцатеричных цифр) представляет
                              собой СЛЕД-НИТЬ из пакета запроса;
                              НИТЬ... -- это последовательность
                              идентификаторов нитей от цели.
                              ИДЕНТ-НИТИ (восемь шестнадцатеричных
                              цифр).  Смотрите
                              'remote.c:parse_threadlist_response()'.
                              
вычислить      'q''CRC:'АДРЕС','ДЛИНА
CRC блока
памяти
               ответ 'E'NN    Ошибка (например, ошибка доступа к
                              памяти)
               ответ          Лишняя 32-битная циклическая проверка
               'C'CRC32       указанной области памяти.
                              
запросить      'q''Offsets'   Получить смещения разделов, которые
смещения                      целевая машина использовала при повторном
разделов                      размещении загруженного образа.
                              _Замечание: если смещение 'Bss' включено
                              в ответ, GDB это игнорирует и вместо
                              этого применяет к разделу 'Bss' смещение
                              'Data'._
               ответ
               'Text='XXX';Data='YYY';Bss='ZZZ
               
запросить      'q''P'РЕЖИМИДЕНТ-НИТИ
информацию о
нити
                              Возвращает информацию об ИДЕНТ-НИТИ.
                              Здесь: РЕЖИМ является 32-битным режимом в
                              шестнадцатеричном представлении;
                              ИДЕНТ-НИТИ -- 64-битный идентификатор
                              нити в шестнадцатеричном представлении.
               ответ *        Смотрите
                              'remote.c:remote_unpack_thread_info_response()'.
                              
удаленная      'q''Rcmd,'КОМАНДА
команда
                              КОМАНДА (в шестнадцатеричном
                              представлении) передается для выполнения
                              локальному интерпретатору.  Неверные
                              команды должны сообщаться при помощи
                              выходной строки.  Перед конечным
                              результирующим пакетом, целевая машина
                              может также ответить некоторым
                              количеством промежуточных 'O'ВЫВОД
                              пакетов вывода на консоль.  _Разработчики
                              должны учесть, что предоставление доступа
                              к интерпретатору заглушки может иметь
                              последствия для безопасности_.
               ответ 'OK'     Ответ на команду без вывода.
               ответ ВЫВОД    Ответ на команду со строкой вывода ВЫВОД,
                              в шестнадцатеричном представлении.
               ответ 'E'NN    Указывает на неправильно сформированный
                              запрос.
                              
               reply ''       Когда 'q''Rcmd' не распознана.
                              

   Следующие пакеты 'g'/'G' были определены раньше.  Ниже, некоторые
32-битные регистры передаются в виде 64 бит.  Эти регистры должны быть
расширены нулем/знаком (как?), чтобы заполнять выделенное место.  Байты
регистра передаются в целевом порядке байтов.  Две части в байте
регистра передаются от более значимого к менее значимому.

MIPS32                               Все регистры передаются как
                                     32-битные величины в таком
                                     порядке: 32 общего назначения; sr;
                                     lo; hi; bad; cause; pc; 32
                                     регистра с плавающей точкой; fsr;
                                     fir; fp.
                                     
MIPS64                               Все регистры передаются как
                                     64-битные величины (включая такие
                                     32-битные регистры, как 'sr').
                                     Порядок такой же, как для
                                     'MIPS32'.
                                     

   Вот пример последовательности для перезапускаемой цели.  Заметьте,
что перезапуск не получает никакого непосредственного вывода:

     <- R00
     -> +
     _target restarts_
     <- ?
     -> +
     -> T001:1234123412341234
     <- +

   Пример последовательности при при пошаговом выполнении цели по одной
инструкции:

     <- G1445...
     -> +
     <- s
     -> +
     _time passes_
     -> T001:1234123412341234
     <- +
     <- g
     -> +
     -> 1455...
     <- +


File: gdb.info,  Node: Сервер,  Next: NetWare,  Prev: Протокол,  Up: Удаленный

13.4.1.5 Использование программы 'gdbserver'
............................................

'gdbserver' является управляющей программой для Unix-подобных систем,
которая позволяет вам установить соединение вашей программы с удаленным
GDB посредством 'target remote', но без компоновки с обычной отладочной
заглушкой.

   'gdbserver' не является полной заменой отладочных заглушек, потому
что требует по существу тех же средств операционной системы, что и сам
GDB. Фактически, система, на которой может выполняться 'gdbserver' для
соединения с удаленным GDB, может также выполнять GDB локально!  Тем не
менее, 'gdbserver' иногда полезен, так как по размеру эта программа
гораздо меньше, чем GDB. 'gdbserver' также легче переносить, чем весь
GDB, так что вы сможете быстрее начать работать в новой системе,
используя его.  Наконец, если вы разрабатываете программы для систем
реального времени, вы можете обнаружить, что накладные расходы,
связанные с операциями реального времени, делают более удобным
проведение всей возможной разработки на другой системе, например, с
помощью кросс-компиляции.  Вы можете использовать 'gdbserver', чтобы
реализовать аналогичный выбор для отладки.

   GDB и 'gdbserver' общаются или через последовательную линию, или
через TCP-соединение, используя стандартный удаленный последовательный
протокол GDB.

_На целевой машине_
     вам необходимо иметь копию программы, которую вы хотите отладить.
     'gdbserver' не нуждается в таблице символов вашей программы, так
     что вы можете ее исключить, если необходимо сэкономить
     пространство.  Всю обработку символов осуществляет GDB на рабочей
     машине.

     Чтобы использовать сервер, вы должны сообщить ему, как
     взаимодействовать с GDB, имя вашей программы и ее аргументы.
     Синтаксис следующий:

          target> gdbserver COMM ПРОГРАММА [ АРГ ... ]

     COMM -- это или имя устройства (для использования последовательной
     линии), или имя рабочей машины и номер порта TCP. Например, для
     отладки Emacs с параметром 'foo.txt' и взаимодействия с GDB через
     последовательный порт '/dev/com1':

          target> gdbserver /dev/com1 emacs foo.txt

     'gdbserver' пассивно ждет рабочего GDB для связи с ним.

     При использовании TCP-соединения вместо последовательной линии:

          target> gdbserver host:2345 emacs foo.txt

     Единственное отличие от предыдущего примера состоит в первом
     параметре, определяющем, что вы связываетесь с рабочим GDB через
     TCP. Параметр 'host:2345' означает, что 'gdbserver' должен ожидать
     TCP-соединение от машины 'host' к локальному порту TCP 2345.  (В
     настоящее время часть 'host' игнорируется.)  Вы можете выбрать
     любой номер порта, какой захотите, если при этом он не конфликтует
     с какими-либо портами TCP, уже использующимися на целевой системе
     (например, '23' зарезервирован для 'telnet').(1)  Вы должны
     использовать тот же номер порта с командой рабочего GDB 'target
     remote'.

_На рабочей машине GDB_
     вам нужна копия вашей программы с символьными данными, так как GDB
     нужна информация о символах и отладочная информация.  Запустите GDB
     как обычно, используя имя локальной копии вашей программы в
     качестве первого аргумента.  (Вам также может понадобиться ключ
     '--baud', если последовательная линия работает на скорости,
     отличной от 9600бит/сек.)  После этого, используйте 'target
     remote', чтобы установить связь с 'gdbserver'.  Ее параметры --
     либо имя устройства (обычно последовательного устройства, такого
     как '/dev/ttyb'), либо дескриптор порта TCP в форме 'МАШИНА:ПОРТ'.
     Например:

          (gdb) target remote /dev/ttyb

     взаимодействует с сервером через последовательную линию
     '/dev/ttyb', а

          (gdb) target remote the-target:2345

     взаимодействует через TCP-соединение с портом 2345 на рабочей
     машине 'the-target'.  Для TCP-соединения, вы должны запустить
     'gdbserver' до использования команды 'target remote'.  Иначе вы
     можете получить ошибку, текст которой зависит от рабочей системы,
     но обычно он выглядит примерно так: 'Connection refused'.

   ---------- Footnotes ----------

   (1) Если вы выберете номер порта, который конфликтует с другим
сервисом, 'gdbserver' печатает сообщение об ошибке и завершает работу.


File: gdb.info,  Node: NetWare,  Prev: Сервер,  Up: Удаленный

13.4.1.6 Использование программы 'gdbserve.nlm'
...............................................

'gdbserve.nlm' -- это управляющая программа для систем NetWare, которая
позволяет вам установить соединение вашей программы с удаленным GDB
посредством 'target remote'.

   GDB и 'gdbserve.nlm' общаются через последовательную линию, используя
стандартный удаленный последовательный протокол GDB.

_На целевой машине_
     вам необходимо иметь копию программы, которую вы хотите отладить.
     'gdbserve.nlm' не нуждается в таблице символов вашей программы, так
     что вы можете ее исключить, если необходимо сэкономить
     пространство.  GDB осуществляет всю обработку символов на рабочей
     машине.

     Чтобы использовать сервер, вы должны сообщить ему, как
     взаимодействовать с GDB, имя вашей программы и ее аргументы.
     Синтаксис следующий:

          load gdbserve [ BOARD=ПЛАТА ] [ PORT=ПОРТ ]
                        [ BAUD=БОД ] ПРОГРАММА [ АРГ ... ]

     ПЛАТА и ПОРТ определяют последовательную линию; БОД определяет
     скорость в бодах, используемую соединением.  Значения ПОРТ и NODE
     по умолчанию равны 0, БОД по умолчанию 9600бит/сек.

     Например, для отладки Emacs с параметром 'foo.txt' и взаимодействия
     с GDB через последовательный порт номер 2 на плате 1, используя
     соединение 19200бит/сек:

          load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt

_На рабочей машине GDB_
     вам нужна копия вашей программы с символьными данными, так как GDB
     требуется символьная и отладочная информация.  Запустите GDB как
     обычно, используя имя локальной копии вашей программы в качестве
     первого параметра.  (Вам также может понадобиться ключ '--baud',
     если последовательная линия работает на скорости, отличной от
     9600бит/сек.)  После этого, используйте 'target remote' для
     установки связи с 'gdbserve.nlm'.  Ее аргумент -- имя устройства
     (обычно последовательного устройства, такого как '/dev/ttyb').
     Например:

          (gdb) target remote /dev/ttyb

     соединение с сервером через последовательную линию '/dev/ttyb'.


File: gdb.info,  Node: Отображение объектов ядра,  Prev: Удаленная отладка,  Up: Отладочные цели

13.5 Отображение объектов ядра
==============================

Некоторые цели поддерживают отображение объектов ядра.  При помощи этих
возможностей, GDB взаимодействует непосредственно с операционной
системой и может выводить информацию об объектах уровня операционной
системы, например, о блокировках и других объектах синхронизации.  Какие
именно объекты могут быть отображены, определяется в зависимости от
конкретной ОС.

   Используйте команду 'set os', чтобы установить тип операционной
системы.  Это говорит GDB, какой модуль отображения объектов ядра
инициализировать:

     (gdb) set os cisco

   Если команда 'set os' выполнится успешно, GDB выведет некоторую
информацию об операционной системе и создаст новую команду 'info',
которая может быть использована для посылки запросов на целевую машину.
Название команды 'info' выбирается в зависимости от операционной
системы:

     (gdb) info cisco
     List of Cisco Kernel Objects
     Object     Description
     any        Any and all objects

   Дальнейшие подкоманды могут использоваться для запросов о конкретных
объектах, информация о которых есть в ядре.

   В настоящее время не существует другого способа определить,
поддерживается та или иная операционная система, кроме как попробовать.


File: gdb.info,  Node: Конфигурации,  Next: Управление GDB,  Prev: Отладочные цели,  Up: Top

14 Информация о конфигурации
****************************

В то время как почти все команды GDB доступны для всех чистых и
кросс-версий отладчика, существуют некоторые исключения.  Эта глава
описывает вещи, доступные только в определенных конфигурациях.

   Существует три основные категории конфигураций: чистые конфигурации,
где рабочая и целевая машины совпадают, конфигурации для встроенных
операционных систем, которые обычно совпадают для нескольких различных
архитектур процессоров, и отдельные встроенные процессоры, которые
сильно отличаются друг от друга.

* Menu:

* Чистая::
* Встроенная ОС::
* Встроенные процессоры::
* Архитектуры::


File: gdb.info,  Node: Чистая,  Next: Встроенная ОС,  Up: Конфигурации

14.1 Чистая конфигурация
========================

Этот раздел описывает детали, специфичные для определенных чистых
конфигураций.

* Menu:

* HP-UX::                       HP-UX
* Информация о процессах SVR4:: Информация о процессах SVR4


File: gdb.info,  Node: HP-UX,  Next: Информация о процессах SVR4,  Up: Чистая

14.1.1 HP-UX
------------

В системах HP-UX, если вы ссылаетесь на функцию или переменную, имя
которой начинается со знака доллара, GDB сперва ищет имя пользователя
или системы, до поиска вспомогательной переменной.


File: gdb.info,  Node: Информация о процессах SVR4,  Prev: HP-UX,  Up: Чистая

14.1.2 Информация о процессах SVR4
----------------------------------

Многие версии SVR4 предоставляют средства, называемые '/proc', которые
могут быть использованы для исследования образа выполняемого процесса,
задействуя подпрограммы файловой системы.  Если GDB сконфигурирован для
операционной системы, поддерживающей эти средства, команда 'info proc'
доступна для получения отчета по некоторым видам информации о процессе,
выполняющем вашу программу.  'info proc' работает только на системах
SVR4, которые включают код 'procfs'.  Среди этих систем: OSF/1 (Digital
Unix), Solaris, Irix и Unixware, но не HP-UX или Linux, к примеру.

'info proc'
     Выдает доступную суммарную информацию о процессе.

'info proc mappings'
     Сообщает диапазоны адресов, доступных в программе, с информацией,
     может ли ваша программа читать, записывать или исполнять каждый из
     диапазонов.

'info proc times'
     Время запуска, время пользовательского и системного ЦП для вашей
     программы и ее потомков.

'info proc id'
     Сообщает информацию об идентификаторах процессов, относящихся к
     вашей программе: ее собственный идентификатор, идентификатор ее
     родителя, группы процесса и сеанса.

'info proc status'
     Общая информация о состоянии процесса.  Если процесс остановлен, то
     этот отчет включает причину останова и любые полученные сигналы.

'info proc all'
     Показывает всю вышеперечисленную информацию о процессе.


File: gdb.info,  Node: Встроенная ОС,  Next: Встроенные процессоры,  Prev: Чистая,  Up: Конфигурации

14.2 Встроенные операционные системы
====================================

Этот раздел описывает конфигурации, задействующие отладку встроенных
операционных систем, которые доступны для нескольких различных
архитектур.

* Menu:

* VxWorks::                     Использование GDB с VxWorks

   GDB включает возможность отлаживать программы, выполняющиеся в
различных операционных системах реального времени.


File: gdb.info,  Node: VxWorks,  Up: Встроенная ОС

14.2.1 Использование GDB с VxWorks
----------------------------------

'target vxworks ИМЯ-МАШИНЫ'
     Система VxWorks, присоединенная посредством TCP/IP. Аргумент
     ИМЯ-МАШИНЫ есть имя или IP-адрес машины целевой системы.

   На VxWorks, 'load' компонует ИМЯ-ФАЙЛА динамически на текущей целевой
системе и добавляет ее символьную информацию в GDB.

   GDB позволяет разработчикам запускать и отлаживать с Unix-машин
задачи, выполняющиеся на сетевых целях VxWorks.  Уже выполняющиеся
задачи, запущенные из оболочки VxWorks, также могут быть отлажены.  GDB
использует код, который может выполняться как на машине Unix, так и на
целевой машине VxWorks.  Программа 'gdb' устанавливается и выполняется
на Unix-машине.  (Она может быть установлена под именем 'vxgdb', чтобы
отличать ее от GDB для отладки программ на рабочей машине.)

'VxWorks-timeout АРГ'
     Сейчас все цели, базирующиеся на VxWorks, поддерживают параметр
     'vxworks-timeout'.  Этот параметр устанавливается пользователем, и
     АРГ представляют число секунд, в течение которых GDB ожидает ответы
     на вызовы удаленных процедур.  Вы можете использовать это, если
     ваша целевая машина VxWorks является медленным программным
     эмулятором или находится далеко на другом конце медленного сетевого
     соединения.

   Следующая информация о соединении к VxWorks была свежей, когда это
руководство было написано; более новые выпуски VxWorks могут
использовать обновленные процедуры.

   Для использования GDB с VxWorks, вы должны пересобрать ваше ядро
VxWorks, чтобы включить подпрограммы интерфейса удаленной отладки в
библиотеку VxWorks 'rdb.a'.  Чтобы это сделать, определите 'INCLUDE_RDB'
в конфигурационном файле VxWorks 'configAll.h' и пересоберите ядро
VxWorks.  Получившееся ядро содержит 'rdb.a' и порождает задачу отладки
исходного кода 'tRdbTask', когда VxWorks загружается.  Для большей
информации по конфигурированию и сборке VxWorks, смотрите руководство
изготовителя.

   Когда вы включили 'rdb.a' в образ вашей системы VxWorks и так
установили ваши пути поиска выполняемых файлов, чтобы можно было найти
GDB, вы готовы к вызову отладчика.  Из вашей рабочей Unix-машины,
выполните 'gdb' (или 'vxgdb', в зависимости от вашей установки).

   GDB появляется и показывает приглашение:

     (vxgdb)

* Menu:

* Соединение к VxWorks::        Соединение к VxWorks
* Загрузка на VxWorks::         Загрузка на VxWorks
* Присоединение к VxWorks::     Запуск задач


File: gdb.info,  Node: Соединение к VxWorks,  Next: Загрузка на VxWorks,  Up: VxWorks

14.2.1.1 Соединение к VxWorks
.............................

Команда GDB 'target' позволяет вам соединяться с целевой машиной VxWorks
в сети.  Для соединения с целью по имени "'tt'" введите:

     (vxgdb) target vxworks tt

   GDB покажет сообщения, аналогичные этим:

     Attaching remote machine across net...
     Connected to tt.

   Затем GDB пытается считать таблицы символов всех объектных модулей,
загруженных на целевой машине VxWorks с того момента, как она была
включена.  GDB находит эти файлы путем поиска в каталогах, перечисленных
в путях поиска команд (*note Рабочая среда вашей программы: Среда.);
если ему не удается найти объектный файл, он выводит подобное сообщение:

     prog.o: No such file or directory.

   Если это происходит, добавьте соответствующий каталог к путям поиска
с помощью команды GDB 'path' и выполните команду 'target' снова.


File: gdb.info,  Node: Загрузка на VxWorks,  Next: Присоединение к VxWorks,  Prev: Соединение к VxWorks,  Up: VxWorks

14.2.1.2 Загрузка на VxWorks
............................

Если вы соединились с целевой машиной VxWorks и хотите отладить объект,
который еще не был загружен, вы можете использовать команду GDB 'load',
чтобы загрузить файл из Unix в VxWorks.  Объектный файл, заданный в
качестве аргумента к 'load', в действительности открывается дважды:
сначала целевой машиной VxWorks, чтобы загрузить код, а затем GDB, чтобы
считать таблицу символов.  Это может привести к проблемам, если текущие
рабочие каталоги в этих системах различаются.  Если обе системы
монтируют по NFS одни и те же файловые системы, вы можете избежать этих
проблем, используя абсолютные пути.  В противном случае, проще всего
установить рабочий каталог на обеих системах в тот, в котором расположен
объектный файл, и затем ссылаться на него по имени, без пути.  Например,
программа 'prog.o' может находиться в 'VXPATH/vw/demo/rdb' на VxWorks и
в 'HOSTPATH/vw/demo/rdb' на рабочей машине.  Для загрузки этой
программы, введите в VxWorks следующее:

     -> cd "VXPATH/vw/demo/rdb"

Затем, в GDB, введите:

     (vxgdb) cd HOSTPATH/vw/demo/rdb
     (vxgdb) load prog.o

   GDB отобразит ответ, аналогичный этому:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   Вы также можете использовать команду 'load', чтобы заново загрузить
объектный модуль после редактирования и повторной компиляции
соответствующего исходного файла.  Заметьте, что при этом GDB удаляет
все определенные точки останова, автоматические отображения,
вспомогательные переменные и очищает историю значений.  (Это необходимо
для того, чтобы сохранить целостность структур данных отладчика, которые
ссылаются на таблицу символов целевой системы.)


File: gdb.info,  Node: Присоединение к VxWorks,  Prev: Загрузка на VxWorks,  Up: VxWorks

14.2.1.3 Запуск задач
.....................

Вы также можете присоединиться к существующей задаче, используя команду
'attach' следующим образом:

     (vxgdb) attach ЗАДАЧА

где ЗАДАЧА является шестнадцатеричным идентификатором задачи VxWorks.
Когда вы присоединяетесь к задаче, она может выполняться либо быть
приостановленной.  Выполняющаяся задача приостанавливается в момент
присоединения.


File: gdb.info,  Node: Встроенные процессоры,  Next: Архитектуры,  Prev: Встроенная ОС,  Up: Конфигурации

14.3 Встроенные процессоры
==========================

Этот раздел описывает детали, специфичные для определенных встроенных
конфигураций.

* Menu:

* Встроенный A29K::             Встроенный AMD A29K
* ARM::                         ARM
* H8/300::                      Hitachi H8/300
* H8/500::                      Hitachi H8/500
* i960::                        Intel i960
* M32R/D::                      Mitsubushi M32R/D
* M68K::                        Motorola M68K
* M88K::                        Motorola M88K
* Встроенный MIPS::             Встроенный MIPS
* PowerPC::                     PowerPC
* PA::                          Встроенный HP PA
* SH::                          Hitachi SH
* Sparclet::                    Tsqware Spacrlet
* Sparclite::                   Fujitsu Sparclite
* ST2000::                      Tandem ST2000
* Z8000::                       Zilog Z8000


File: gdb.info,  Node: Встроенный A29K,  Next: ARM,  Up: Встроенные процессоры

14.3.1 Встроенный AMD A29K
--------------------------

* Menu:

* A29K UDI::
* A29K EB29K::
* Коммуникации (EB29K)::        Установка связи
* gdb-EB29K::                   Кросс-отладка EB29K
* Удаленный журнал::            Удаленный журнал

'target adapt УСТР'
     Монитор Adapt для A29K.

'target amd-eb УСТР СКОРОСТЬ ПРОГ'
     Удаленная PC-резидентная плата AMD EB29K, присоединенная по
     последовательным линиям.  УСТР является последовательным
     устройством, так же, как для 'target remote'; СКОРОСТЬ позволяет
     вам указать скорость линии; а ПРОГ является именем программы,
     которая будет отлаживаться, так, как оно появляется в ДОС на ПК.
     *Note Протокол EBMON для AMD29K: A29K EB29K.


File: gdb.info,  Node: A29K UDI,  Next: A29K EB29K,  Up: Встроенный A29K

14.3.1.1 A29K UDI
.................

Для отладки процессоров семейства a29k, GDB поддерживает протокол AMD
UDI ("Universal Debugger Interface"(1)).  Для использования этой
конфигурации с целями AMD, на которых выполняется монитор MiniMON, вам
нужна программа 'MONTIP', доступная бесплатно у AMD. Вы можете также
использовать GDB с программой 'ISSTIP', UDI-совместимым эмулятором a29k,
также доступным у AMD.

'target udi КЛ-СЛОВО'
     Выбрать интерфейс UDI к удаленной плате a29k или эмулятору.  Здесь
     КЛ-СЛОВО является элементом в конфигурационном файле AMD 'udi_soc'.
     Этот файл содержит в качестве элементов ключевые слова, которые
     определяют параметры, используемые при соединении к целям a29k.
     Если файл 'udi_soc' не находится в вашем рабочем каталоге, вы
     должны установить путь к нему в переменной среды 'UDICONF'.

   ---------- Footnotes ----------

   (1) Универсальный отладочный интерфейс.  (Прим. переводчика)


File: gdb.info,  Node: A29K EB29K,  Next: Коммуникации (EB29K),  Prev: A29K UDI,  Up: Встроенный A29K

14.3.1.2 Протокол EBMON для AMD29K
..................................

AMD распространяет плату разработки 29K, предназначенную для помещения в
ПК, вместе с программой монитора 'EBMON', работающей в ДОС. Коротко эта
система разработки называется "EB29K". Чтобы использовать GDB из
Unix-системы для выполнения программ на плате EB29K, вы должны сперва
соединить последовательным кабелем ПК (в котором установлена плата
EB29K) и последовательный порт на Unix-системе.  Далее мы предполагаем,
что вы соединили кабелем порт ПК 'COM1' и '/dev/ttya' на Unix-системе.


File: gdb.info,  Node: Коммуникации (EB29K),  Next: gdb-EB29K,  Prev: A29K EB29K,  Up: Встроенный A29K

14.3.1.3 Установка связи
........................

Следующим шагом нужно установить параметры порта ПК, сделав в ДОС что-то
вроде этого:

     C:\> MODE com1:9600,n,8,1,none

Этот пример, выполненный в системе MS DOS 4.0, устанавливает порт ПК в
9600бит/сек, без проверки четности, восьмибитные данные, один стоп-бит и
отсутствие действия для "повтора"; вы должны использовать те же
параметры связи при установке соединения со стороны Unix.

   Чтобы передать управление с ПК стороне Unix, введите следующее в
консоли ДОС:

     C:\> CTTY com1

(Позже, если вы хотите вернуть управление консоли ДОС, вы можете
использовать команду 'CTTY con' -- но вы должны послать ее через
устройство, имевшее управление, в нашем примере через последовательную
линию 'COM1'.)

   На Unix-машине, для связи с ПК используйте коммуникационную
программу, такую как 'tip' или 'cu'.  Например

     cu -s 9600 -l /dev/ttya

Показанные ключи для 'cu' определяют, соответственно, скорость линии и
последовательный порт.  Если вместо этого вы используете 'tip', ваша
командная строка может выглядеть следующим образом:

     tip -9600 /dev/ttya

Ваша система может требовать другого имени в том месте, где мы
показываем '/dev/ttya' в качестве аргумента к 'tip'.  Параметры связи,
включая используемый порт, ассоциированы с аргументом к 'tip' в файле
описаний "remote" -- обычно это '/etc/remote'.

   Используя соединение 'tip' или 'cu', измените рабочий каталог ДОС в
тот, который содержит копию вашей программы 29K, затем запустите на ПК
программу 'EBMON' (управляющая программа EB29K, поставляемая AMD с вашей
платой).  Вы должны увидеть начальный вывод 'EBMON', аналогичный
следующему, заканчивающийся приглашением 'EBMON' '#':

     C:\> G:

     G:\> CD \usr\joe\work29k

     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.

     Enter '?' or 'H' for help

     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000

     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff

     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800

     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes

     # ~.

   Затем выйдите из программы 'cu' или 'tip' (в этом примере это сделано
при помощи ввода '~.' в приглашении 'EBMON').  'EBMON' продолжает
работать, готовый к тому, что GDB перехватит управление.

   Для этого примера, мы предположили, что существует соединение PC/NFS,
которое устанавливает файловую систему Unix-машины как "диск 'G:'" на
ПК. Это является, вероятно, самым удобным способом удостовериться, что
одна и та же программа 29K находится и на ПК, и в Unix-системе.  Если у
вас нет PC/NFS или чего-нибудь аналогичного, соединяющего две системы,
вы должны прибегнуть к другому способу передачи программы 29K из Unix на
ПК -- возможно переписать ее на дискету.  GDB _не_ загружает программы
по последовательной линии.


File: gdb.info,  Node: gdb-EB29K,  Next: Удаленный журнал,  Prev: Коммуникации (EB29K),  Up: Встроенный A29K

14.3.1.4 Кросс-отладка EB29K
............................

Наконец, перейдите в каталог, содержащий образ вашей программы 29K в
Unix-системе, и запустите GDB, указав имя программы в качестве
аргумента:

     cd /usr/joe/work29k
     gdb myfoo

   Теперь вы можете использовать команду 'target':

     target amd-eb /dev/ttya 9600 MYFOO

В этом примере мы предполагали, что ваша программа находится в файле
'myfoo'.  Заметьте, что имя файла, заданное в качестве последнего
аргумента к 'target amd-eb', должно быть таким, каким его видит ДОС. В
нашем примере, это просто 'MYFOO', но вообще оно может включать путь
ДОС, и, в зависимости от механизма передачи, может быть не похоже на имя
на Unix-машине.

   В этом месте вы можете установить желаемые точки останова; когда вы
будете готовы увидеть вашу программу выполняющейся на плате 29K,
используйте команду GDB 'run'.

   Чтобы остановить отладку удаленной программы, используйте команду GDB
'detach'.

   Чтобы возвратить управление консоли ПК, используйте 'tip' или 'cu'
снова, после завершения вашего сеанса GDB, чтобы присоединиться к
'EBMON'.  Затем вы можете ввести команду 'q', чтобы завершить работу
'EBMON', возвращая управление командному интерпретатору ДОС. Введите
'CTTY con', чтобы возвратить командный ввод основной консоли ДОС, и
введите '~.', чтобы покинуть 'tip' или 'cu'.


File: gdb.info,  Node: Удаленный журнал,  Prev: gdb-EB29K,  Up: Встроенный A29K

14.3.1.5 Удаленный журнал
.........................

Команда 'target amd-eb' создает в текущем рабочем каталоге файл
'eb.log', чтобы помочь отладить проблемы с соединением.  'eb.log'
записывает весь вывод 'EBMON', включая эхо посланных ему команд.
Выполнение 'tail -f' для этого файла в другом окне часто помогает понять
проблемы с 'EBMON' или неожиданные события на стороне ПК.


File: gdb.info,  Node: ARM,  Next: H8/300,  Prev: Встроенный A29K,  Up: Встроенные процессоры

14.3.2 ARM
----------

'target rdi УСТР'
     Монитор ARM Angel, через интерфейс библиотеки RDI к протоколу ADP.
     Вы можете использовать эту цель для взаимодействия как с платами,
     на которых выполняется монитор Angel, так и с устройством отладки
     EmbeddedICE JTAG.

'target rdp УСТР'
     Монитор ARM Demon.


File: gdb.info,  Node: H8/300,  Next: H8/500,  Prev: ARM,  Up: Встроенные процессоры

14.3.3 Hitachi H8/300
---------------------

'target hms УСТР'
     Плата Hitachi SH, H8/300 или H8/500, присоединенная через
     последовательную линию к вашей машине.  Используйте специальные
     команды 'device' и 'speed' для управления последовательной линией и
     используемой скоростью связи.

'target e7000 УСТР'
     Эмулятор E7000 для Hitachi H8 и SH.

'target sh3 УСТР'
'target sh3e УСТР'
     Целевые системы Hitachi SH-3 и SH-3E.

   Когда вы выбираете удаленную отладку для платы Hitachi SH, H8/300 или
H8/500, команда 'load' загружает вашу программу на плату Hitachi, а
также открывает ее как текущую выполняемую цель для GDB на вашей машине
(как команда 'file').

   Для общения с Hitachi SH, H8/300 или H8/500, GDB необходимо знать
следующие вещи:

  1. Что вы хотите использовать: 'target hms', удаленный отладочный
     интерфейс для микропроцессоров Hitachi, или 'target e7000',
     встроенный эмулятор для Hitachi SH и Hitachi 300H. ('target hms'
     используется по умолчанию, если GDB сконфигурирован специально для
     Hitachi SH, H8/300 или H8/500.)

  2. Какое последовательное устройство соединяет вашу машину с платой
     Hitachi (по умолчанию используется первое последовательное
     устройство, доступное на вашей машине).

  3. Какую скорость использовать для этого последовательного устройства.

* Menu:

* Платы Hitachi::            Соединение с платами Hitachi.
* Hitachi ICE::              Использование встроенного эмулятора E7000.
* Специально для Hitachi::   Специальные команды GDB для Hitachi.


File: gdb.info,  Node: Платы Hitachi,  Next: Hitachi ICE,  Up: H8/300

14.3.3.1 Соединение с платами Hitachi
.....................................

Используйте специальную команду GDB 'device ПОРТ', если вам нужно явно
установить последовательное устройство.  По умолчанию используется
первый ПОРТ, доступный на вашей машине.  Это необходимо только на
Unix-машинах, где это обычно что-то типа '/dev/ttya'.

   GDB имеет другую специальную команду для установки скорости связи:
'speed BPS'.  Эта команда также используется только на Unix-машинах; в
ДОС, устанавливайте скорость линии как обычно извне GDB командой 'mode'
(например, 'mode com2:9600,n,8,1,p' для соединения 9600бит/сек.

   Команды 'device' и 'speed' доступны для отладки программ
микропроцессора Hitachi, только если вы используете рабочую среду Unix.
Если вы используете ДОС, для взаимодействия с платой разработки через
последовательный порт ПК GDB полагается на вспомогательную резидентную
программу 'asynctsr'.  Вы также должны использовать команду ДОС 'mode',
чтобы подготовить порт со стороны ДОС.

   Следующий пример сеанса иллюстрирует шаги, необходимые для запуска
программы на H8/300 под управлением GDB. В нем используется программа
H8/300 под названием 't.x'.  Для Hitachi SH и H8/500 процедура та же
самая.

   Сперва подсоедините вашу плату разработки.  В этом примере, мы
используем плату, присоединенную к порту 'COM2'.  Если вы используете
другой последовательный порт, подставьте его имя в аргументе команды
'mode'.  Когда вы вызываете 'asynctsr', вспомогательную программу связи,
используемую отладчиком, вы передаете ей только числовую часть имени
последовательного порта; например, ниже 'asynctsr 2' запускает
'asynctsr' для 'COM2'.

     C:\H8300\TEST> asynctsr 2
     C:\H8300\TEST> mode com2:9600,n,8,1,p

     Resident portion of MODE loaded

     COM2: 9600, n, 8, 1, p


     _Предупреждение:_ Мы обнаружили ошибку в PC-NFS, которая
     конфликтует с 'asynctsr'.  Если вы также используете PC-NFS на
     вашей ДОС-машине, вам может потребоваться отключить его или даже
     загрузить машину без него, чтобы использовать 'asynctsr' для
     управления отладочной платой.

   Теперь, когда связь установлена, и плата разработки присоединена, вы
можете запустить GDB. Вызовите 'gdb' с именем вашей программы в качестве
аргумента.  GDB выводит обычное приглашение: '(gdb)'.  Используйте две
специальные команды для начала сеанса отладки: 'target hms' для задания
кросс-отладки для платы Hitachi и команду 'load' для загрузки вашей
программы на нее.  'load' выводит имена разделов программы и '*' для
каждых двух килобайт загруженных данных.  (Если вы хотите обновить
данные GDB для символов или для выполняемого файла без загрузки,
используйте команды GDB 'file' или 'symbol-file'.  Для описания этих
команд, равно как и самой команды 'load', см.  *note Команды для задания
файлов: Файлы.)

     (eg-C:\H8300\TEST) gdb t.x
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty"
     for details.
     GDB 5.0, Copyright 1992 Free Software Foundation, Inc...
     (gdb) target hms
     Connected to remote H8/300 HMS system.
     (gdb) load t.x
     .text   : 0x8000 .. 0xabde ***********
     .data   : 0xabde .. 0xad30 *
     .stack  : 0xf000 .. 0xf014 *

   Теперь вы готовы выполнять или отлаживать вашу программу.  С этого
момента вы можете использовать все обычные команды GDB. Команда 'break'
устанавливает точки останова; 'run' запускает вашу программу; 'print'
или 'x' отображает данные; команда 'continue' возобновляет выполнение
после остановки в точке останова.  Вы можете использовать команду 'help'
в любой момент, чтобы узнать больше о командах GDB.

   Помните, однако, что возможности _операционной системы_ недоступны на
вашей плате разработки; например, если ваша программа зависает, вы не
можете послать сигнал прерывания -- но можете нажать кнопку RESET!

   Используйте кнопку RESET на вашей плате разработки
   * чтобы прервать вашу программу (не используйте 'ctl-C' на машине с
     ДОС -- у нее нет способа передать сигнал прерывания на плату
     разработки); и

   * для возврата к приглашению GDB после того, как ваша программа
     нормально завершается.  Протокол связи не предусматривает другого
     способа для GDB определить, что ваша программа завершилась.

   В любом случае, GDB видит результат нажатия RESET на плате разработки
как "нормальное завершение" вашей программы.


File: gdb.info,  Node: Hitachi ICE,  Next: Специально для Hitachi,  Prev: Платы Hitachi,  Up: H8/300

14.3.3.2 Использование встроенного эмулятора E7000
..................................................

Вы можете использовать встроенный эмулятор E7000 для разработки кода
либо для Hitachi SH, либо для H8/300H. Используйте одну из этих форм
команды 'target e7000' для соединения GDB с вашей E7000:

'target e7000 ПОРТ СКОРОСТЬ'
     Используйте эту форму, если ваша E7000 присоединена к
     последовательному порту.  Аргумент ПОРТ идентифицирует, какой
     последовательный порт использовать (например, 'com2').  Третий
     аргумент является скоростью линии в битах в секунду (например,
     '9600').

'target e7000 ИМЯ-УЗЛА'
     Если ваша E7000 установлена как узел сети TCP/IP, вы можете просто
     указать его имя; GDB использует для соединения 'telnet'.


File: gdb.info,  Node: Специально для Hitachi,  Prev: Hitachi ICE,  Up: H8/300

14.3.3.3 Специальные команды GDB для Hitachi
............................................

Некоторые команды GDB доступны только для H8/300:

'set machine h8300'
'set machine h8300h'
     Настраивайте GDB на один из двух вариантов архитектур H8/300 с
     помощью 'set machine'.  Вы можете использовать 'show machine',
     чтобы проверить, какой из вариантов действует в данный момент.


File: gdb.info,  Node: H8/500,  Next: i960,  Prev: H8/300,  Up: Встроенные процессоры

14.3.4 H8/500
-------------

'set memory МОД'
'show memory'
     Укажите, какую модель памяти H8/500 (МОД) вы используете с помощью
     'set memory'; проверяйте, какая модель используется при помощи
     'show memory'.  Допустимыми значениями для МОД являются 'small',
     'big', 'medium' и 'compact'.


File: gdb.info,  Node: i960,  Next: M32R/D,  Prev: H8/500,  Up: Встроенные процессоры

14.3.5 Intel i960
-----------------

'target mon960 УСТР'
     Монитор MON960 для Intel i960.

'target nindy ИМЯ-УСТР'
     Плата Intel 960, управляемая Nindy Monitor.  ИМЯ-УСТР является
     именем последовательного устройства, которое должно использоваться
     для соединения, например '/dev/ttya'.

   "Nindy" -- это программа ROM Monitor для целевых систем Intel 960.
Когда GDB сконфигурирован для управления удаленным Intel 960 с
использованием Nindy, вы можете указать ему, как присоединиться к 960
несколькими способами:

   * Указав последовательный порт, версию протокола Nindy и скорость
     связи через ключи командной строки;

   * Ответив на запрос при старте;

   * Используя команду 'target' в любом месте вашего сеанса GDB. *Note
     Команды для управления целями: Команды для целей.

   С интерфейсом Nindy к плате Intel 960, команда 'load' загружает
ИМЯ-ФАЙЛА на 960, а также добавляет его символьные данные в GDB.

* Menu:

* Вызов Nindy::                 Вызов Nindy
* Параметры Nindy::             Параметры для Nindy
* Сброс Nindy::                 Команда сброса Nindy


File: gdb.info,  Node: Вызов Nindy,  Next: Параметры Nindy,  Up: i960

14.3.5.1 Вызов Nindy
....................

Если вы просто запустите 'gdb' без использования ключей командной
строки, у вас запросят, какой последовательный порт использовать, _до_
того, как вы получите обычное приглашение GDB:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Ответьте на запрос с любым суффиксом (после '/dev/tty'), определяющим
последовательный порт, который вы хотите использовать.  Вы можете, по
своему выбору, просто начать работу без соединения с Nindy, ответив на
приглашение пустой строкой.  Если вы сделаете это и позже захотите
присоединиться к Nindy, используйте 'target' (*note Команды для
управления целями: Команды для целей.).


File: gdb.info,  Node: Параметры Nindy,  Next: Сброс Nindy,  Prev: Вызов Nindy,  Up: i960

14.3.5.2 Параметры для Nindy
............................

Вот параметры вызова для начала вашего сеанса GDB с подключенной платой
Nindy-960:

'-r ПОРТ'
     Задайте имя порта последовательного интерфейса, который должен
     использоваться для соединения с целевой системой.  Этот ключ
     доступен, только когда GDB сконфигурирован для целевой архитектуры
     Intel 960.  Вы можете определить ПОРТ любым из следующих способов:
     полный путь (например, '-r /dev/ttya'), имя устройства в '/dev'
     (например, '-r ttya') или просто уникальный суффикс для
     определенного 'tty' (например, '-r a').

'-O'
     (Заглавная буква "O", не ноль.)  Определяет, что GDB должен
     использовать "старый" протокол монитора Nindy для соединения с
     целевой системой.  Этот ключ доступен, только когда GDB
     сконфигурирован для целевой архитектуры Intel 960.

          _Предупреждение:_ если вы определите '-O', но в
          действительности попытаетесь связаться с системой, которая
          ожидает более нового протокола, соединение не будет
          установлено, как будто не соответствуют скорости.  GDB
          неоднократно пытается соединиться снова на нескольких
          различных скоростях линии.  Вы можете остановить этот процесс
          посредством прерывания.

'-brk'
     Определяет, что GDB должен сперва послать целевой системе сигнал
     'BREAK', пытаясь сбросить ее, перед соединением с целью Nindy.

          _Предупреждение:_ Многие целевые системы не имеют требуемых
          для этого аппаратных средств; это работает только на некоторых
          платах.

   Стандартный ключ '-b' управляет скоростью линии, используемой на
последовательном порту.


File: gdb.info,  Node: Сброс Nindy,  Prev: Параметры Nindy,  Up: i960

14.3.5.3 Команда сброса Nindy
.............................

'reset'
     Для целей Nindy, эта команда посылает "break" удаленной целевой
     системе; она полезна, только если целевая система была оборудована
     схемой для выполнения аппаратного сброса (или других действий,
     представляющих интерес) при обнаружении прерывания.


File: gdb.info,  Node: M32R/D,  Next: M68K,  Prev: i960,  Up: Встроенные процессоры

14.3.6 Mitsubishi M32R/D
------------------------

'target m32r УСТР'
     Монитор ROM Mitsubishi M32R/D.


File: gdb.info,  Node: M68K,  Next: M88K,  Prev: M32R/D,  Up: Встроенные процессоры

14.3.7 M68k
-----------

Конфигурация Motorola m68k включает поддержку ColdFire и команду
'target' для следующих мониторов ROM.

'target abug УСТР'
     Монитор ABug ROM для M68K.

'target cpu32bug УСТР'
     Монитор CPU32BUG, выполняющийся на плате CPU32 (M68K).

'target dbug УСТР'
     Монитор dBUG ROM для Motorola ColdFire.

'target est УСТР'
     Монитор EST-300 ICE, выполняющийся на плате CPU32 (M68K).

'target rom68k УСТР'
     Монитор ROM 68K, выполняющийся на плате M68K IDP.

   Если GDB сконфигурирован с 'm68*-ericsson-*', то вместо этого у него
будет только одна специальная команда 'target':

'target es1800 УСТР'
     Эмулятор ES-1800 для M68K.

'target rombug УСТР'
     Монитор ROMBUG ROM для OS/9000.


File: gdb.info,  Node: M88K,  Next: Встроенный MIPS,  Prev: M68K,  Up: Встроенные процессоры

14.3.8 M88K
-----------

'target bug УСТР'
     Монитор BUG, выполняющийся на плате MVME187 (m88k).


File: gdb.info,  Node: Встроенный MIPS,  Next: PowerPC,  Prev: M88K,  Up: Встроенные процессоры

14.3.9 Встроенный MIPS
----------------------

GDB может использовать удаленный отладочный протокол MIPS для
взаимодействия с платой MIPS, присоединенной к последовательной линии.
Эта возможность доступна, если вы сконфигурировали GDB с
'--target=mips-idt-ecoff'.

   Используйте эти команды GDB для определения соединения с вашей
целевой платой:

'target mips ПОРТ'
     Для выполнения программы на плате, выполните 'gdb', задав имя
     программы в качестве аргумента.  Для соединения с платой,
     используйте команду 'target mips ПОРТ', где ПОРТ -- имя
     последовательного порта, присоединенного к плате.  Если программа
     еще не была загружена на плату, вы можете использовать команду
     'load', чтобы это сделать.  Затем вы можете использовать все
     обычные команды GDB.

     Например, эта последовательность команд устанавливает соединение к
     целевой плате через последовательный порт, загружает и начинает
     выполнение из отладчика программы с именем PROG:

          host$ gdb PROG
          GDB is free software and ...
          (gdb) target mips /dev/ttyb
          (gdb) load PROG
          (gdb) run

'target mips ИМЯ-МАШИНЫ:НОМЕР-ПОРТА'
     В некоторых рабочих конфигурациях GDB, вы можете задать
     TCP-соединение (например, к последовательной линии, управляемой
     терминальным концентратором) вместо последовательного порта,
     используя синтаксис 'ИМЯ-МАШИНЫ:НОМЕР-ПОРТА'.

'target pmon ПОРТ'
     Монитор ROM PMON.

'target ddb ПОРТ'
     NEC DDB-разновидность PMON для Vr4300.

'target lsi ПОРТ'
     LSI-разновидность PMON.

'target r3900 УСТР'
     Densan DVE-R3900 монитор ROM для Toshiba R3900 Mips.

'target array УСТР'
     Плата контроллера RAID Array Tech LSI33K.

GDB также поддерживает следующие специальные команды для целей MIPS:

'set processor АРГ'
'show processor'
     Используйте команду 'set processor' для установки типа процессора
     MIPS, когда вы хотите обратиться к регистрам, уникальным для
     данного типа процессора.  Например, 'set processor R3041' велит GDB
     использовать регистры ЦП, соответствующие микросхеме 3041.
     Используйте команду 'show processor', чтобы узнать, какой процессор
     MIPS используется GDB. Используйте команду 'info reg' чтобы узнать,
     какие регистры использует GDB.

'set mipsfpu double'
'set mipsfpu single'
'set mipsfpu none'
'show mipsfpu'
     Если ваша целевая плата не поддерживает сопроцессор MIPS для
     вычислений с плавающей точкой, вы должны использовать команду 'set
     mipsfpu none' (если вам это нужно, вы можете поместить эту команду
     в ваш файл инициализации GDB). Это говорит GDB, как найти значения
     функций, которые возвращают величины с плавающей точкой.  Это также
     позволяет GDB избежать сохранения регистров с плавающей точкой при
     вызове функций на плате.  Если вы используете сопроцессор поддержки
     вычислений с плавающей точкой с поддержкой только одинарной
     точности, как на процессоре R4650, используйте команду 'set mipsfpu
     single'.  По умолчанию используется сопроцессор поддержки
     вычислений с плавающей точкой двойной точности; этот режим может
     быть выбран с помощью 'set mipsfpu double'.

     В предыдущих версиях, единственным выбором была двойная точность
     или отсутствие поддержки вычислений с плавающей точкой, так что
     'set mipsfpu on' выберет режим двойной точности, а 'set mipsfpu
     off' отключит эту поддержку.

     Как обычно, вы можете запросить значение переменной 'mipsfpu' при
     помощи 'show mipsfpu'.

'set remotedebug N'
'show remotedebug'
     Вы можете увидеть некоторую отладочную информацию о связи с платой,
     установив переменную 'remotedebug'.  Если вы установите ее в '1'
     при помощи 'set remotedebug 1', будет отображаться каждый пакет.
     Если вы установите ее в '2', то будет отображаться каждый знак.  В
     любой момент вы можете проверить текущее значение переменной
     командой 'show remotedebug'.

'set timeout СЕКУНДЫ'
'set retransmit-timeout СЕКУНДЫ'
'show timeout'
'show retransmit-timeout'
     Вы можете управлять временем ожидания пакета, используемым в
     удаленном протоколе MIPS, при помощи команды 'set timeout СЕКУНДЫ'.
     Значение по умолчанию -- 5 секунд.  Аналогично, вы можете управлять
     временем ожидания, используемым при ожидании подтверждения пакета с
     помощью команды 'set retransmit-timeout СЕКУНДЫ'.  По умолчанию 3
     секунды.  Вы можете узнать обе эти величины с помощью 'show
     timeout' и 'show retransmit-timeout'.  (Эти команды доступны,
     _только_ если GDB сконфигурирован для цели
     '--target=mips-idt-ecoff'.)

     Время ожидания, установленное при помощи 'set timeout', не играет
     роли, когда GDB ожидает остановки вашей программы.  В этом случае
     GDB ждет бесконечно, потому что у него нет способа узнать, сколько
     программа будет выполняться, пока не остановится.


File: gdb.info,  Node: PowerPC,  Next: PA,  Prev: Встроенный MIPS,  Up: Встроенные процессоры

14.3.10 PowerPC
---------------

'target dink32 УСТР'
     Монитор ROM DINK32.

'target ppcbug УСТР'
'target ppcbug1 УСТР'
     Монитор ROM PPCBUG для PowerPC.

'target sds УСТР'
     Монитор SDS, выполняющийся на плате PowerPC (такой как Motorola
     ADS).


File: gdb.info,  Node: PA,  Next: SH,  Prev: PowerPC,  Up: Встроенные процессоры

14.3.11 Встроенный HP PA
------------------------

'target op50n УСТР'
     Монитор OP50N, выполняющийся на плате OKI HPPA.

'target w89k УСТР'
     Монитор W89K, выполняющийся на плате Winbond HPPA.


File: gdb.info,  Node: SH,  Next: Sparclet,  Prev: PA,  Up: Встроенные процессоры

14.3.12 Hitachi SH
------------------

'target hms УСТР'
     Плата Hitachi SH, присоединенная через последовательную линию к
     вашей рабочей машине.  Используйте специальные команды 'device' и
     'speed' для управления последовательной линией и используемой
     скоростью связи.

'target e7000 УСТР'
     Эмулятор E7000 для Hitachi SH.

'target sh3 УСТР'
'target sh3e УСТР'
     Целевые системы Hitachi SH-3 и SH-3E.


File: gdb.info,  Node: Sparclet,  Next: Sparclite,  Prev: SH,  Up: Встроенные процессоры

14.3.13 Tsqware Sparclet
------------------------

GDB позволяет разработчикам отлаживать с Unix-машины задачи,
выполняющиеся на целевых системах Sparclet.  GDB использует код, который
выполняется как на Unix-машине, так и на цели Sparclet.  Программа 'gdb'
устанавливается и работает на Unix-машине.

'remotetimeout АРГ'
     GDB поддерживает параметр 'remotetimeout'.  Он устанавливается
     пользователем, а АРГ представляет число секунд, в течение которых
     GDB ожидает ответы.

   При компиляции для отладки, используйте ключи '-g' для получения
отладочной информации и '-Ttext' для того, чтобы разместить программу в
том месте, в каком вы хотите загрузить ее на целевую машину.  Вы также
можете добавить ключ '-n' или '-N', чтобы уменьшить размеры разделов.
Например:

     sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N

   Чтобы проверить, что адреса в действительности являются теми, которые
вы подразумевали, можно использовать 'objdump':

     sparclet-aout-objdump --headers --syms prog

   После того, как вы установили путь поиска выполняемых файлов, в
котором присутствует GDB, вы готовы запустить отладчик.  С вашей рабочей
машины Unix выполните 'gdb' (или 'sparclet-aout-gdb', в зависимости от
вашей установки).

   GDB запустится и покажет приглашение:

     (gdbslet)

* Menu:

* Файл Sparclet::                Установка файла для отладки
* Соединение к Sparclet::        Соединение к Sparclet
* Загрузка на Sparclet::         Загрузка на Sparclet
* Выполнение Sparclet::          Выполнение и отладка


File: gdb.info,  Node: Файл Sparclet,  Next: Соединение к Sparclet,  Up: Sparclet

14.3.13.1 Установка файла для отладки
.....................................

Команда GDB 'file' позволяет вам выбрать программу для отладки.

     (gdbslet) file prog

   Затем GDB пытается прочитать таблицу символов программы 'prog'.  Он
находит файл путем поиска в каталогах, перечисленных в пути поиска
команд.  Если файл был скомпилирован с отладочной информацией (ключ
'-g'), то также будет произведен поиск исходных файлов.  GDB находит
исходные файлы, производя поиск в каталогах, перечисленных в пути поиска
каталогов (*note Рабочая среда вашей программы: Среда.).  Если ему не
удается найти файл, он выводит сообщение, подобное этому:

     prog: No such file or directory.

   Когда это случается, добавьте соответствующие каталоги в пути поиска
с помощью команд GDB 'path' и 'dir' и выполните команду 'target' снова.


File: gdb.info,  Node: Соединение к Sparclet,  Next: Загрузка на Sparclet,  Prev: Файл Sparclet,  Up: Sparclet

14.3.13.2 Соединение к Sparclet
...............................

Команда GDB 'target' позволяет вам установить соединение с целевой
машиной Sparclet.  Для соединения с последовательным портом "'ttya'",
введите:

     (gdbslet) target sparclet /dev/ttya
     Remote target sparclet connected to /dev/ttya
     main () at ../prog.c:3

   GDB выведет сообщение, подобное этому:

     Connected to ttya.


File: gdb.info,  Node: Загрузка на Sparclet,  Next: Выполнение Sparclet,  Prev: Соединение к Sparclet,  Up: Sparclet

14.3.13.3 Загрузка на Sparclet
..............................

Когда вы установили соединение к цели Sparclet, вы можете использовать
команду GDB 'load' для загрузки файла с рабочей машины на целевую.  Имя
файла и смещение загрузки должно быть задано команде 'load' в качестве
аргумента.  Поскольку это файл в формате a.out, программа должна быть
загружена по начальному адресу.  Чтобы определить, чему равна эта
величина, вы можете использовать 'objdump'.  Смещение загрузки -- это
смещение, которое добавляется к VMA (Virtual Memory Address(1)) каждого
раздела файла.  Например, если программа 'prog' была скомпонована с
адресом текста 0x1201000, сегментом данных по адресу 0x12010160 и
сегментом стека по адресу 0x12010170, введите в GDB:

     (gdbslet) load prog 0x12010000
     Loading section .text, size 0xdb0 vma 0x12010000

   Если код загружается по адресу, отличному от того, по которому
программа была скомпонована, вам может потребоваться использовать
команды 'section' и 'add-symbol-file', чтобы сообщить GDB, куда
отобразить таблицу символов.

   ---------- Footnotes ----------

   (1) Виртуальный адрес памяти (Прим. переводчика)


File: gdb.info,  Node: Выполнение Sparclet,  Prev: Загрузка на Sparclet,  Up: Sparclet

14.3.13.4 Выполнение и отладка
..............................

Теперь вы можете начать отлаживать задачу, используя команды GDB для
управления выполнением, 'b', 'step', 'run' и так далее.  Все такие
команды перечислены в этом руководстве.

     (gdbslet) b main
     Breakpoint 1 at 0x12010000: file prog.c, line 3.
     (gdbslet) run
     Starting program: prog
     Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
     3        char *symarg = 0;
     (gdbslet) step
     4        char *execarg = "hello!";
     (gdbslet)


File: gdb.info,  Node: Sparclite,  Next: ST2000,  Prev: Sparclet,  Up: Встроенные процессоры

14.3.14 Fujitsu Sparclite
-------------------------

'target sparclite УСТР'
     Платы Fujitsu sparclite, используемые только с целью загрузки.
     Чтобы отлаживать программу, вы должны использовать дополнительную
     команду.  Например, 'target remote УСТР', используя стандартный
     удаленный протокол GDB.


File: gdb.info,  Node: ST2000,  Next: Z8000,  Prev: Sparclite,  Up: Встроенные процессоры

14.3.15 Tandem ST2000
---------------------

GDB может быть использован с телефонным коммутатором Tandem ST2000,
поддерживающим протокол Tandem STDBUG.

   Чтобы узнать, как соединить ST2000 с рабочей машиной, смотрите
руководство производителя.  После того как ST2000 физически подключен,
вы можете выполнить:

     target st2000 УСТР СКОРОСТЬ

чтобы установить его как вашу отладочную среду.  УСТР -- это обычно имя
последовательного устройства, такое как '/dev/ttya', соединенного с
ST2000 через последовательную линию.  Вместо этого, вы можете указать
УСТР как TCP-соединение (например, к последовательной линии,
присоединенной через терминальный концентратор), используя синтаксис
'ИМЯ-МАШИНЫ:НОМЕР-ПОРТА'.

   Команды 'load' и 'attach' _не_ определены для этой цели; вы должны
загрузить вашу программу на ST2000 так же, как вы это обычно делаете для
автономных действий.  GDB читает отладочную информацию (например,
символы) из отдельной, отладочной версии программы, которая доступна на
вашем рабочем компьютере.

   Следующие вспомогательные команды GDB доступны для облегчения работы
в среде ST2000:

'st2000 КОМАНДА'
     Послать КОМАНДУ монитору STDBUG. Доступные команды описаны в
     руководстве производителя.

'connect'
     Соединяет управляющий терминал с командным монитором STDBUG. Когда
     вы закончили взаимодействие с STDBUG, ввод одной из двух
     последовательностей знаков возвратит вас назад к приглашению GDB:
     '<RET>~.' (Return, за которым следует тильда и точка) или
     '<RET>~<C-d>' (Return, за которым следует тильда и control-D).


File: gdb.info,  Node: Z8000,  Prev: ST2000,  Up: Встроенные процессоры

14.3.16 Zilog Z8000
-------------------

Будучи сконфигурированным для отладки целей Zilog Z8000, GDB включает
симулятор Z8000.

   Для семейства Z8000, 'target sim' имитирует либо Z8002
(несегментированный вариант архитектуры Z8000), либо Z8001
(сегментированный вариант).  Имитатор распознает подходящую архитектуру
изучая объектный код.

'target sim АРГ'
     Отладка программ на имитируемом ЦП. Если имитатор поддерживает
     параметры установки, укажите их в АРГ.

После определения этой цели, вы можете отлаживать программы для
имитированного ЦП таким же образом, как программы для вашего рабочего
компьютера; используйте команду 'file' для загрузки образа новой
программы, команду 'run' для запуска вашей программы и так далее.

   Помимо того, что доступны все обычные машинные регистры (*note
Регистры: Регистры.), имитатор Z8000 предоставляет три специально
названных регистра с дополнительной информацией:

'cycles'
     Считает тактовые импульсы в имитаторе.

'insts'
     Считает инструкции, выполненные в имитаторе.

'time'
     Время выполнения в шестидесятых долях секунды.

   Вы можете ссылаться на эти значения в выражениях GDB с помощью
обычных соглашений; например, 'b fputc if $cycles>5000' устанавливает
условную точку останова, которая срабатывает только после как минимум
5000 имитированных тактовых импульсов.


File: gdb.info,  Node: Архитектуры,  Prev: Встроенные процессоры,  Up: Конфигурации

14.4 Архитектуры
================

Этот раздел описывает свойства архитектур, которые воздействуют на все
применения GDB с данной архитектурой, как при чистой отладке, так и при
кросс-отладке.

* Menu:

* A29K::
* Alpha::
* MIPS::


File: gdb.info,  Node: A29K,  Next: Alpha,  Up: Архитектуры

14.4.1 A29K
-----------

'set rstack_high_address АДРЕС'
     В процессорах семейства AMD 29000, регистры сохраняются в отдельном
     "стеке регистров".  Для отладчика не существует способа определить
     размер этого стека.  Обычно GDB просто подразумевает, что стек
     "достаточно большой".  Это может привести к тому, что GDB
     попытается обратиться несуществующей области памяти.  В случае
     необходимости, вы можете решить эту проблему, указав конечный адрес
     стека регистров с помощью команды 'set rstack_high_address'.
     Аргумент должен быть адресом, который вы, вероятно, захотите начать
     с '0x', чтобы задать его в шестнадцатеричном виде.

'show rstack_high_address'
     Отобразить текущее ограничение на стек регистров для процессоров
     семейства AMD 29000.


File: gdb.info,  Node: Alpha,  Next: MIPS,  Prev: A29K,  Up: Архитектуры

14.4.2 Alpha
------------

Смотрите следующий раздел.


File: gdb.info,  Node: MIPS,  Prev: Alpha,  Up: Архитектуры

14.4.3 MIPS
-----------

Компьютеры, базирующиеся на архитектурах Alpha и MIPS, используют
необычный кадр стека, который иногда требует от GDB поиска в объектном
коде в обратном направлении, чтобы найти начало функции.

   Чтобы сократить время ответа (особенно для встроенных приложений, где
GDB может быть ограничен медленной последовательной линией для этого
поиска), вы можете захотеть ограничить область поиска, используя одну из
этих команд:

'set heuristic-fence-post ПРЕДЕЛ'
     Ограничить GDB для исследования не более ПРЕДЕЛА байт при поиске
     начала функции.  Значение 0 (по умолчанию) означает неограниченный
     поиск.  Однако, исключая 0, чем больше предел, тем больше байт
     'heuristic-fence-post' должен просмотреть, и, следовательно, тем
     дольше он будет выполняться.

'show heuristic-fence-post'
     Отобразить текущее значение данного предела.

Эти команды доступны, _только_ когда GDB сконфигурирован для отладки
программ на процессорах Alpha или MIPS.


File: gdb.info,  Node: Управление GDB,  Next: Последовательности,  Prev: Конфигурации,  Up: Top

15 Управление GDB
*****************

Вы можете изменять способы взаимодействия GDB с вами, используя команду
'set'.  Для команд, управляющих способами отображения данных GDB,
смотрите *note Параметры вывода: Параметры вывода.  Другие установки
описаны здесь.

* Menu:

* Приглашение::                 Приглашение
* Редактирование::              Редактирование команд
* История::                     История команд
* Размер экрана::               Размер экрана
* Числа::                       Числа
* Сообщения/предупреждения::    Необязательные предупреждения и сообщения
* Отладочный вывод::            Необязательные сообщения о внутренних событиях


File: gdb.info,  Node: Приглашение,  Next: Редактирование,  Up: Управление GDB

15.1 Приглашение
================

GDB демонстрирует свою готовность считать команду выводя строку,
называемую "приглашением".  Обычно это '(gdb)'.  Вы можете изменить
строку приглашения командой 'set prompt'.  Например, при отладке GDB с
помощью GDB, полезно изменить приглашение в одном из сеансов так, чтобы
вы всегда могли понять, с каким из них вы общаетесь.

   _Замечание:_ 'set prompt' не добавляет пробелы после установленного
вами приглашения.  Это позволяет устанавливать приглашение,
заканчивающееся пробелом или нет.

'set prompt НОВОЕ-ПРИГЛ'
     Указывает GDB, что с этого момента надо использовать в качестве
     строки приглашения НОВОЕ-ПРИГЛ.

'show prompt'
     Печатает строку в форме: 'Gdb's prompt is: ВАШЕ-ПРИГЛ'


File: gdb.info,  Node: Редактирование,  Next: История,  Prev: Приглашение,  Up: Управление GDB

15.2 Редактирование команд
==========================

GDB читает входные команды через интерфейс "readline".  Эта библиотека
GNU обеспечивает единообразное поведение для программ, которые
предоставляют пользователю интерфейс командной строки.  Преимуществами
являются стили редактирования командной строки GNU Emacs или "vi",
'csh'-подобная подстановка истории и сохранение и повторное
использование истории команд между сеансами отладки.

   Вы можете управлять поведением редактирования командной строки в GDB
командой 'set'.

'set editing'
'set editing on'
     Включает редактирование командной строки (включено по умолчанию).

'set editing off'
     Отключает редактирование командной строки.

'show editing'
     Показывает, включено редактирование командной строки или нет.


File: gdb.info,  Node: История,  Next: Размер экрана,  Prev: Редактирование,  Up: Управление GDB

15.3 История команд
===================

GDB может отслеживать команды, которые вы вводите во время сеансов
отладки, чтобы вы могли точно знать, что происходило.  Используйте
следующие команды для управления возможностями истории команд GDB.

'set history filename ИМЯ-ФАЙЛА'
     Устанавливает имя файла истории команд GDB в ИМЯ-ФАЙЛА.  Это файл,
     откуда GDB читает исходный список истории команд, и куда он
     записывает историю команд при выходе из данного сеанса.  Вы можете
     обращаться к этому списку через раскрывание истории или с помощью
     символов редактирования истории команд, перечисленных ниже.  По
     умолчанию, этот файл есть значение переменной среды 'GDBHISTFILE'
     или, если эта переменная не установлена, './.gdb_history'
     ('./_gdb_history' в MS-DOS).

'set history save'
'set history save on'
     Записать историю команд в файл, имя которого может быть определено
     командой 'set history filename'.  По умолчанию, эта возможность
     отключена.

'set history save off'
     Прекратить запись истории команд в файл.

'set history size РАЗМЕР'
     Установить число команд, которые GDB хранит в своем списке истории.
     Значение по умолчанию берется из переменной среды 'HISTSIZE' или
     приравнивается 256, если эта переменная не установлена.

   Раскрывание истории назначает специальное значение знаку '!'.

   Так как '!' является также оператором логического отрицания в Си,
раскрывание истории по умолчанию отключено.  Если вы решите включить
раскрывание истории командой 'set history expansion on', вы должны
будете снабдить '!' (когда он используется как логическое отрицание в
выражении) последующим пробелом или символом табуляции, чтобы
предохранить его от раскрывания.  Средства истории Readline не делают
попытки подстановки на строках '!=' и '!(', даже когда раскрывание
истории включено.

   Вот команды управления раскрыванием истории:

'set history expansion on'
'set history expansion'
     Включить раскрывание истории.  Раскрывание по умолчанию отключено.

'set history expansion off'
     Отключить раскрывание истории.

     Библиотека Readline поставляется вместе с более полной
     документацией по возможностям редактирования и раскрывания истории.
     Пользователи, незнакомые с GNU Emacs или 'vi', могут почитать ее.

'show history'
'show history filename'
'show history save'
'show history size'
'show history expansion'
     Эти команды отображают состояние параметров истории GDB. Просто
     'show history' показывает все четыре состояния.

'show commands'
     Отобразить последние десять команд в истории.

'show commands N'
     Вывести десять команд, расположенных вокруг команды с номером N.

'show commands +'
     Вывести десять команд, расположенных сразу после последних
     выведенных.


File: gdb.info,  Node: Размер экрана,  Next: Числа,  Prev: История,  Up: Управление GDB

15.4 Размер экрана
==================

Определенные команды GDB могут выводить большое количество информации на
экран.  Чтобы помочь вам всю ее прочитать, GDB приостанавливает вывод и
запрашивает ввод в конце каждой страницы вывода.  Нажмите <RET>, когда
вы хотите продолжить вывод, или 'q' для уничтожения оставшегося вывода.
Также, установка ширины экрана определяет, когда переносить строки
вывода.  В зависимости от того, что выводится, GDB пытается разбить
строку в удобочитаемом месте, вместо того чтобы просто продолжить ее на
следующую строчку.

   Обычно GDB узнает размер экрана из программы драйвера терминала.
Например, в Unix GDB использует базу данных termcap, вместе со значением
переменной среды 'TERM' и установками 'stty rows' и 'stty cols'.  Если
это неправильно, вы можете заменить эти установки командами 'set height'
и 'set width':

'set height LPP'
'show height'
'set width CPL'
'show width'
     Эти команды 'set' определяют высоту экрана в LPP строк и ширину в
     CPL знаков.  Соответствующие команды 'show' отображают текущие
     установки.

     Если вы определите высоту в ноль строк, GDB не будет
     останавливаться при выводе, независимо от того, насколько он
     длинный.  Это полезно, если вывод осуществляется в файл или буфер
     редактора.

     Аналогично, вы можете определить 'set width 0', чтобы запретить GDB
     переносить строки вывода.


File: gdb.info,  Node: Числа,  Next: Сообщения/предупреждения,  Prev: Размер экрана,  Up: Управление GDB

15.5 Числа
==========

Вы всегда можете вводить в GDB числа в восьмеричной, десятичной или
шестнадцатеричной системе в соответствии c обычными соглашениями:
восьмеричные числа начинаются с '0', десятичные числа оканчиваются на
'.', а шестнадцатеричные числа начинаются с '0x'.  Числа, которые не
начинаются ни c одного из этих знаков, по умолчанию считаются
десятичными; аналогично, отображение чисел по умолчанию -- если не
определен никакой конкретный формат -- осуществляется по основанию 10.
Командой 'set radix' вы можете изменять основание, устанавливаемое по
умолчанию для ввода и вывода.

'set input-radix ОСНОВАНИЕ'
     Установить основание по умолчанию для числового ввода.
     Поддерживаемые варианты для ОСНОВАНИЯ -- 8, 10 или 16.  Само
     ОСНОВАНИЕ должно быть определено либо недвусмысленно, либо с
     использованием текущего основания системы счисления по умолчанию;
     например, любая из команд

          set radix 012
          set radix 10.
          set radix 0xa

     устанавливает десятичное основание.  С другой стороны, 'set radix
     10' оставляет основание системы счисления без изменений независимо
     от того, каким оно было.

'set output-radix ОСНОВАНИЕ'
     Установить основание по умолчанию для числового вывода.
     Поддерживаемые варианты для ОСНОВАНИЯ -- 8, 10 или 16.  Само
     ОСНОВАНИЕ должно быть определено либо недвусмысленно, либо с
     использованием текущего основания системы счисления по умолчанию.

'show input-radix'
     Отобразить текущее основание по умолчанию для числового ввода.

'show output-radix'
     Отобразить текущее основание по умолчанию для числового вывода.


File: gdb.info,  Node: Сообщения/предупреждения,  Next: Отладочный вывод,  Prev: Числа,  Up: Управление GDB

15.6 Необязательные предупреждения и сообщения
==============================================

По умолчанию, GDB ничего не сообщает о своей внутренней деятельности.
Если вы работаете на медленной машине, то вы можете захотеть
использовать команду 'set verbose'.  Она велит GDB сообщать вам, когда
он выполняет длинную внутреннюю операцию, чтобы вы не думали, что он
завис.

   В настоящее время 'set verbose' управляет только сообщениями о чтении
таблиц символов исходного файла; смотрите *note Команды для задания
файлов: Файлы, описание 'symbol-file'.

'set verbose on'
     Разрешает GDB выводить некоторые информационные сообщения.

'set verbose off'
     Отключает вывод некоторых информационных сообщений.

'show verbose'
     Сообщает, установлено 'set verbose' в 'on' или 'off'.

   По умолчанию, если GDB сталкивается с ошибками в таблице символов
объектного файла, он не сообщает об этом; но если вы отлаживаете
компилятор, эта информация может вам пригодиться (*note Ошибки чтения
файлов с символами: Ошибки с символами.).

'set complaints ПРЕДЕЛ'
     Позволяет GDB выводить ПРЕДЕЛ сообщений о каждом типе необычных
     символов прежде, чем перестать сообщать о проблеме.  Установите
     ПРЕДЕЛ в ноль для подавления всех сообщений, или очень большим,
     чтобы предотвратить подавление сообщений.

'show complaints'
     Выводит ограничение GDB на вывод сообщений о символах.

   По умолчанию GDB осмотрителен и задает, как иногда кажется, множество
глупых вопросов, чтобы подтвердить некоторые команды.  Например, если вы
пытаетесь выполнить программу, которая уже выполняется:

     (gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

   Если вы неуклонно желаете сами разбираться с последствиями ваших
собственных команд, вы можете отключить эту "возможность":

'set confirm off'
     Отключает запросы подтверждений.

'set confirm on'
     Включает запросы подтверждений (по умолчанию).

'show confirm'
     Показывает, выводятся ли запросы подтверждений.


File: gdb.info,  Node: Отладочный вывод,  Prev: Сообщения/предупреждения,  Up: Управление GDB

15.7 Необязательные сообщения о внутренних событиях
===================================================

'set debug arch'
     Включает и отключает вывод отладочной информации gdbarch.  По
     умолчанию отключено.
'show debug arch'
     Отображает текущее состояние вывода отладочной информации gdbarch.
'set debug event'
     Включает и отключает вывод отладочной информации о событиях GDB. По
     умолчанию отключено.
'show debug event'
     Отображает текущее состояние вывода отладочной информации о
     событиях GDB.
'set debug expression'
     Включает и отключает вывод отладочной информации о выражениях GDB.
     По умолчанию отключено.
'show debug expression'
     Отображает текущее состояние вывода отладочной информации о
     выражениях GDB.
'set debug overload'
     Включает и выключает вывод GDB отладочной информации о
     перегруженных символах Си++.  Это включает такую информацию, как
     упорядочивание функций и тому подобное.  По умолчанию отключено.
'show debug overload'
     Отображает текущее состояние вывода GDB отладочной информации о
     перегруженных символах Си++.
'set debug remote'
     Включает и выключает вывод отчета о всех пакетах, посланных вперед
     и назад по последовательной линии удаленной машине.  Информация
     печатается в стандартный выходной поток GDB. По умолчанию
     отключено.
'show debug remote'
     Выводит состояние вывода удаленных пакетов.
'set debug serial'
     Включает и выключает вывод GDB отладочной информации о
     последовательном соединении.  По умолчанию отключено.
'show debug serial'
     Отображает текущее состояние вывода GDB отладочной информации о
     последовательном соединении.
'set debug target'
     Включает и выключает вывод GDB отладочной информации о цели.  Сюда
     входит информация о том, что происходит на уровне цели GDB. По
     умолчанию отключено.
'show debug target'
     Отображает текущее состояние вывода GDB отладочной информации о
     цели.
'set debug varobj'
     Включает и отключает вывод GDB отладочной информации о переменных
     объектах.  По умолчанию отключено.
'show debug varobj'
     Отображает текущее состояние вывода GDB отладочной информации о
     переменных объектах.


File: gdb.info,  Node: Последовательности,  Next: Emacs,  Prev: Управление GDB,  Up: Top

16 Фиксированные последовательности команд
******************************************

Кроме команд точки останова (*note Команды точки останова: Команды
останова.), GDB предоставляет два способа сохранить последовательности
команд для выполнения целиком: определяемые пользователем команды и
командные файлы.

* Menu:

* Определяемые пользователем команды::
                                Определяемые пользователем команды
* Ловушки::                     Определяемые пользователем команды-ловушки
* Командные файлы::             Командные файлы
* Вывод::                       Команды для управления выводом


File: gdb.info,  Node: Определяемые пользователем команды,  Next: Ловушки,  Up: Последовательности

16.1 Команды, определяемые пользователем
========================================

"Команда, определяемая пользователем" -- это последовательность команд
GDB, которой вы назначаете имя как новой команде.  Это осуществляется
командой 'define'.  Пользовательские команды могут иметь до 10
параметров, разделенных пробелами.  Внутри команды пользователя, доступ
к параметрам производится посредством $ARG0...$ARG9.  Вот простой
пример:

     define adder
       print $arg0 + $arg1 + $arg2

Для выполнения команды используйте:

     adder 1 2 3

Этот пример определяет команду 'adder', которая печатает сумму трех
своих параметров.  Обратите внимание, параметры являются текстовыми
подстановками, так что они могут ссылаться на переменные, использовать
сложные выражения или даже выполнять вызовы подчиненных функций.

'define ИМЯ-КОМАНДЫ'
     Определить команду с именем ИМЯ-КОМАНДЫ.  Если команда с таким
     именем уже имеется, у вас запрашивается подтверждение на ее
     переопределение.

     Определение команды состоит из других командных строк GDB, которые
     задаются после команды 'define'.  Конец этих команд отмечается
     строкой, содержащей 'end'.

'if'
     Имеет один аргумент -- вычисляемое выражение.  Команда
     сопровождается последовательностью команд, которые выполняются,
     если выражение истинно (отлично от нуля).  Затем может следовать
     необязательная строка 'else', сопровождаемая последовательностью
     команд, которые выполняются только при ложном значении данного
     выражения.  Конец списка отмечается строкой, содержащей 'end'.

'while'
     Синтаксис подобен 'if': команда имеет один параметр, который
     является вычисляемым выражением и должен сопровождаться командами,
     по одной в строке, которые завершаются 'end'.  Выполнение команд
     повторяется, пока выражение истинно.

'document ИМЯ-КОМАНДЫ'
     Документирует определенную пользователем команду ИМЯ-КОМАНДЫ, чтобы
     к ней можно было обращаться посредством 'help'.  Команда
     ИМЯ-КОМАНДЫ должна быть определена ранее.  Эта команда считывает
     строки документации точно так же, как 'define' считывает строки
     определения команды, до строки 'end'.  После завершения команды
     'document', написанная вами документация будет отображаться
     командой 'help' для команды ИМЯ-КОМАНДЫ.

     Вы можете использовать команду 'document' неоднократно, чтобы
     изменить документацию команды.  Переопределение команды посредством
     'define' не изменяет документации.

'help user-defined'
     Перечислить все определенные пользователем команды, вместе с первой
     строкой документации (если она есть).

'show user'
'show user ИМЯ-КОМАНДЫ'
     Вывести команды GDB, использовавшиеся для определения ИМЯ-КОМАНДЫ
     (но не ее документацию).  Если ИМЯ-КОМАНДЫ не задано, вывести
     содержимое всех определенных пользователем команд.

   При выполнении команд, определенных пользователем, команды
определения не печатаются.  Ошибка в любой из них останавливает
выполнение всей определенной пользователем команды.

   При использовании в интерактивном режиме, команды, обычно
запрашивающие подтверждение, выполняются без запроса, если они
используется внутри определенной пользователем команды.  Многие команды
GDB, которые обычно печатают сообщения о своих действиях, опускают их
при использовании в команде, определенной пользователем.


File: gdb.info,  Node: Ловушки,  Next: Командные файлы,  Prev: Определяемые пользователем команды,  Up: Последовательности

16.2 Определяемые пользователем команды-ловушки
===============================================

Вы можете определять "ловушки", которые являются специальным видом
определяемых пользователем команд.  Всякий раз, когда вы выполняете
команду 'foo', перед ней выполняется определенная пользователем команда
'hook-foo' (без параметров), если она существует.

   Также может быть определена ловушка, которая вызывается после
выполненной вами команды.  Когда вы выполняете команду 'foo', после нее
вызывается (без аргументов) определенная пользователем команда
'hookpost-foo', если она существует.  Ловушки, срабатывающие после
выполнения команды, могут существовать одновременно с ловушками,
вызываемыми до выполнения той же команды.

   Ловушка может вызывать ту же команду, которую она ловит.  Если это
происходит, ловушка заново не вызывается.  Тем самым избегаются
бесконечные циклы.

   Кроме того, существует псевдокоманда 'stop'.  Определение
('hook-stop') велит выполняться связанным с ней командам при каждом
останове вашей программы: перед выполнением команд точек останова, перед
выводом на экран сообщений или кадров стека.

   Например, чтобы игнорировать сигналы 'SIGALRM' во время выполнения в
пошаговом режиме, но обрабатывать их при нормальном выполнении, вы
можете определить:

     define hook-stop
     handle SIGALRM nopass
     end

     define hook-run
     handle SIGALRM pass
     end

     define hook-continue
     handle SIGLARM pass
     end

   В качестве другого примера, чтобы поймать начало и конец команды
'echo' и добавить дополнительный текст до и после сообщения, вы можете
определить:

     define hook-echo
     echo <<<---
     end

     define hookpost-echo
     echo --->>>\n
     end

     (gdb) echo Hello World
     <<<---Hello World--->>>
     (gdb)


   Вы можете определить ловушку для любой однословной команды GDB, но не
для синонимов команды; вам следует определить ловушку для базового имени
команды, например, 'backtrace', но не 'bt'.  Если во время выполнения
вашей ловушки возникает ошибка, выполнение команд GDB останавливается, и
он выдает приглашение (до того, как введенная вами команда начнет
выполняться).

   Если вы попытаетесь определить ловушку, не соответствующую никакой
известной команде, вы получите предупреждение от команды 'define'.


File: gdb.info,  Node: Командные файлы,  Next: Вывод,  Prev: Ловушки,  Up: Последовательности

16.3 Командные файлы
====================

Командный файл для GDB -- это файл, состоящий из строк с командами GDB.
Такие файлы могут также включать комментарии (строки, начинающиеся с
'#').  Пустая строка в командном файле ничего не делает; она не означает
повторение последней команды, как это было бы при вводе с терминала.

   Когда вы вызываете GDB, он автоматически выполняет команды из своих
"файлов инициализации".  Это файлы, называющиеся '.gdbinit' в Unix и
'gdb.ini' в DOS/Windows.  Во время старта, GDB делает следующее:

  1. считывает файл инициализации (если он существует) в вашем домашнем
     каталоге(1).

  2. Обрабатывает ключи и операнды командной строки.

  3. Считывает файл инициализации (если он существует) в текущем рабочем
     каталоге.

  4. Считывает командные файлы, заданные с помощью ключа '-x'.

   Файл инициализации в вашем домашнем каталоге может устанавливать
параметры (такие как 'set complaints'), которые влияют на последующую
обработку ключей и операндов командной строки.  Файлы инициализации не
выполняются, если вы используете ключ '-nx' *note Выбор режимов:
Параметры режима.

   В некоторых конфигурациях GDB, файлу инициализации присваивается
другое имя (обычно это среды, где специализированная форма GDB должна
сосуществовать с другими формами, следовательно должно быть отличное имя
для файла инициализации специализированной версии).  Следующие среды
используют специальные имена файлов инициализации:

   * VxWorks (ОС реального времени Wind River Systems): '.vxgdbinit'

   * OS68K (ОС реального времени Enea Data Systems): '.os68gdbinit'

   * ES-1800 (эмулятор Ericsson Telecom AB M68000): '.esgdbinit'

   Вы также можете запросить выполнение командного файла с помощью
команды 'source':

'source ИМЯ-ФАЙЛА'
     Выполнить командный файл ИМЯ-ФАЙЛА.

   Строки командного файла выполняются последовательно, при этом они не
выводятся.  Ошибка в любой команде завершает выполнение всего командного
файла.

   Команды, запрашивающие подтверждение в интерактивном режиме, при
выполнении в командном файле выполняются без запросов.  Многие команды
GDB, обычно выводящие сообщения о своих действиях, опускают эти
сообщения при вызове из командных файлов.

   ---------- Footnotes ----------

   (1) В системах DOS/Windows, домашним каталогом считается тот, на
который указывает переменная среды 'HOME'.


File: gdb.info,  Node: Вывод,  Prev: Командные файлы,  Up: Последовательности

16.4 Команды для управляемого вывода
====================================

Во время выполнения командного файла или определенной пользователем
команды нормальный вывод GDB подавляется; единственный появляющийся
вывод -- тот, который производится явно командами из определения.  В
этом разделе описываются три команды, полезные для получения именно
такого вывода, который вы хотите.

'echo ТЕКСТ'
     Напечатать ТЕКСТ.  Непечатные знаки могут быть включены в ТЕКСТ при
     помощи экранирующих последовательностей Си, таких как '\n' для
     перехода на новую строку.  *Переход на новую строку не печатается,
     если вы его не укажете.*  В дополнение к стандартным экранирующим
     последовательностям Си, обратная косая черта, за которой следует
     пробел, обозначает пробел.  Это полезно для отображения строки с
     пробелами в начале или конце, поскольку в противном случае
     начальные и конечные пробелы удаляются из всех аргументов.  Чтобы
     напечатать ' and foo = ', используйте команду 'echo \ and foo =
     \ '.

     Обратная косая черта в конце ТЕКСТА может использоваться, как и в
     Си, для продолжения команды на последующие строки.  Например,

          echo Вот пример текста,\n\
          который занимает\n\
          несколько строк.\n

     производит такой же вывод как

          echo Вот пример текста,\n
          echo который занимает\n
          echo несколько строк.\n

'output ВЫРАЖЕНИЕ'
     Напечатать значение ВЫРАЖЕНИЯ и ничего кроме него: никаких новых
     строк, никаких '$NN = '.  Значение также не заносится в историю
     значений.  *Note Выражения: Выражения, для дополнительной
     информации о выражениях.

'output/ФОРМАТ ВЫРАЖЕНИЕ'
     Вывести значение ВЫРАЖЕНИЯ в формате ФОРМАТ.  Вы можете
     использовать те же форматы, что и для 'print'.  *Note Форматы
     вывода: Форматы вывода, для получения большей информации.

'printf СТРОКА, ВЫРАЖЕНИЯ...'
     Напечатать значения ВЫРАЖЕНИЙ, причем формат вывода задает СТРОКА.
     ВЫРАЖЕНИЯ разделяются запятыми и могут быть либо числами, либо
     указателями.  Их значения печатаются так, как определяет СТРОКА, в
     точности, как если бы ваша программа выполняла подпрограмму Си

          printf (СТРОКА, ВЫРАЖЕНИЯ...);

     Например, вы можете напечатать два шестнадцатеричных значения:

          printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo

     Единственые экранирующие последовательности с обратной косой
     чертой, которые вы можете использовать в строке формата -- простые
     последовательности, состоящие из обратной косой черты, за которой
     следует буква.


File: gdb.info,  Node: Emacs,  Next: Примечания,  Prev: Последовательности,  Up: Top

17 Использование GDB под управлением GNU Emacs
**********************************************

Специальный интерфейс позволяет вам использовать GNU Emacs для просмотра
(и редактирования) исходных файлов программы, которую вы отлаживаете с
помощью GDB.

   Чтобы использовать этот интерфейс, используйте команду 'M-x gdb' в
Emacs.  В качестве аргумента задайте выполняемый файл, который вы хотите
отладить.  Эта команда вызывает GDB как подпроцесс Emacs с вводом и
выводом через заново созданный буфер.

   Под управлением Emacs, GDB используется точно так же, как обычно, за
исключением двух моментов:

   * Весь "терминальный" ввод и вывод происходит через буфер Emacs.

   Это относится как к командам GDB и их выводу, так и к вводу и выводу,
производимыми отлаживаемой программой.

   Это полезно, потому что вы можете копировать текст предыдущих команд
и вводить их снова; вы даже можете использовать таким образом части
вывода.

   Все средства режима оболочки Emacs доступны для взаимодействия с
вашей программой.  В частности, вы можете посылать сигналы обычным путем
-- например, 'C-c C-c' для прерывания, 'C-c C-z' для остановки.

   * GDB отображает исходный код через Emacs.

   Каждый раз, когда GDB отображает кадр стека, Emacs автоматически
находит исходный файл для него и помещает стрелку ('=>') с левого края
текущей строки.  Emacs использует отдельный буфер для отображения
исходного текста и разделяет экран, чтобы отобразить как сеанс GDB, так
и исходный текст.

   Тем не менее, явные команды GDB 'list' и 'search' производят вывод
как обычно, но у вас, скорее всего, не будет причин использовать их из
Emacs.

     _Предупреждение:_ Если каталог, в котором находится ваша программа,
     не является текущим, Emacs легко может ошибиться при определении
     местонахождения исходных файлов; в этом случае вспомогательный
     буфер с исходным текстом не появляется.  GDB может искать
     программы, используя переменную среды 'PATH', так что сеансы ввода
     и вывода происходят нормально; но Emacs не получает достаточно
     информации от GDB, чтобы найти исходные файлы в такой ситуации.
     Чтобы избежать этой проблемы, либо запускайте режим GDB из
     каталога, где находится ваша программа, либо укажите абсолютное имя
     файла, когда будет запрошен параметр для 'M-x gdb'.

     Подобная путаница может возникнуть, если вы используете команду GDB
     'file', чтобы переключиться к отладке программы, находящейся в
     каком-нибудь другом месте, из существующего буфера GDB в Emacs.

   По умолчанию, 'M-x gdb' вызывает программу с именем 'gdb'.  Если вам
нужно вызвать GDB под другим именем (например, если вы храните несколько
конфигураций под различными именами), вы можете установить переменную
Emacs 'gdb-command-name'; например, установка

     (setq gdb-command-name "mygdb")

(которой предшествует 'M-:' или 'ESC :', или если она введена в буфер
'*scratch*' или в вашем файле '.emacs'), заставит Emacs вызвать
программу "'mygdb'".

   В буфере ввода-вывода GDB, вы можете использовать следующие
специальные команды Emacs в дополнение к стандартным командам режима
оболочки:

'C-h m'
     Описывает возможности режима GDB Emacs.

'M-s'
     Выполнить до другой строки исходного текста, подобно команде GDB
     'step'; также обновляет окно отображения для показа текущего файла
     и положения в нем.

'M-n'
     Выполнить до следующей строки исходного текста в этой функции,
     пропуская все вызовы функций, подобно команде GDB 'next'.  Затем
     обновить окно отображения, чтобы показать текущий файл и положение
     в нем.

'M-i'
     Выполнить одну инструкцию, подобно команде GDB 'stepi'; обновляет
     окно отображения.

'M-x gdb-nexti'
     Выполнить до следующей инструкции, используя команду GDB 'nexti';
     обновляет окно отображения.

'C-c C-f'
     Выполнить до выхода из выбранного кадра стека, подобно команде GDB
     'finish'.

'M-c'
     Продолжить выполнение вашей программы, подобно команде GDB
     'continue'.

     _Предупреждение:_ В Emacs версии 19, эта команда вызывается
     посредством 'C-c C-p'.

'M-u'
     Подняться вверх по стеку на число кадров, заданное числовым
     параметром, подобно команде GDB 'up' (*note Числовые аргументы:
     (Emacs)Аргументы.).

     _Предупреждение:_ В Emacs версии 19, эта команда вызывается
     посредством 'C-c C-u'.

'M-d'
     Спуститься вниз по стеку на число кадров, заданное числовым
     параметром, аналогично команде GDB 'down'.

     _Предупреждение:_ В Emacs версии 19, эта команда вызывается
     посредством 'C-c C-d'.

'C-x &'
     Прочитать число в позиции курсора и вставить его в конец буфера
     ввода-вывода GDB. Например, если вы хотите дисассемблировать код по
     адресу, отображенному ранее, наберите 'disassemble'; затем
     переместите курсор на изображение адреса и задайте аргумент для
     'disassemble', набрав 'C-x &'.

     Вы можете и дальше настраивать это, определяя элементы списка
     'gdb-print-command'; если он определен, вы можете форматировать или
     как-либо иначе обрабатывать числа, задаваемые 'C-x &', перед их
     вставкой в буфер.  Числовой аргумент к 'C-x &' показывает, что вам
     нужно специальное форматирование, а также действует как индекс для
     выбора элемента из списка.  Если элемент списка является строкой,
     то вставляемое число форматируется с использованием функции Emacs
     'format'; в противном случае, число передается как параметр
     соответствующему элементу списка.

   В любом исходном файле, команда Emacs 'C-x SPC' ('gdb-break') велит
GDB установить точку останова на строке исходного текста, в которой
находится точка.

   Если вы случайно удалите буфер отображения исходного текста, его
можно легко вернуть обратно, введя команду 'f' в буфере GDB, чтобы
запросить отображение кадра; когда выполнение происходит под управлением
Emacs, это при необходимости создает исходный буфер заново, чтобы
показать вам текущий кадр.

   Исходные файлы, отображаемые в Emacs, находятся в обычных буферах
Emacs, которые получают доступ к исходным файлам обычным способом.  При
желании вы можете редактировать файлы в этих буферах; но помните, что
GDB взаимодействует с Emacs в терминах номеров строк.  Если вы добавите
или удалите строки из текста, известные GDB номера строк больше не будут
соответствовать коду.


File: gdb.info,  Node: Примечания,  Next: GDB/MI,  Prev: Emacs,  Up: Top

18 Примечания GDB
*****************

Эта глава описывает примечания в GDB. Примечания разработаны для
согласования GDB с графическими интерфейсами пользователя или другими
аналогичными программами, которые хотят взаимодействовать с GDB на
относительно высоком уровне.

* Menu:

* Обзор примечаний::    Что такое примечания; общий синтаксис.
* Префикс server::      Подача команды без воздействия на состояние пользователя.
* Примечания к значениям::   Значения явно помечаются.
* Примечания к кадрам:: Примечания к кадрам стека.
* Отображения::         GDB может отображать что-то периодически.
* Приглашения::         Примечания, отмечающие потребность GDB во вводе.
* Ошибки::              Примечания к сообщениям об ошибках.
* Информация о точке останова::     Информация о точках останова.
* Недостоверность::     Некоторые примечания, описывающие недостоверные вещи.
* Примечания к выполнению::
                        Выполняется ли программа, как она остановилась, и т.д.
* Примечания к исходному тексту::  Примечания, описывающие исходный код.
* Дальнейшие планы::    Примечания, которые могут понадобиться в будущем.


File: gdb.info,  Node: Обзор примечаний,  Next: Префикс server,  Up: Примечания

18.1 Что такое примечание?
==========================

Чтобы создавать примечания, запустите GDB с ключом '--annotate=2'.

   Примечания начинаются со знака новой строки, двух знаков 'control-z'
и имени примечания.  Если нет дополнительной информации, связанной с
примечанием, непосредственно за его именем следует знак новой строки.
Если дополнительная информация есть, за именем примечания следует
пропуск, дополнительная информация и знак новой строки.  Дополнительная
информация не может содержать знаков новой строки.

   Любой вывод, не начинающийся с новой строки и двух 'control-z',
означает буквальный вывод GDB. В настоящее время GDB не нужно выводить
два 'control-z' вслед за знаком новой строки, но если это понадобится,
примечания могут быть расширены 'экранирующим' примечанием, которое
означает вывод этих трех знаков.

   Вот простой пример запуска GDB с примечаниями:

     $ gdb --annotate=2
     GNU GDB 5.0
     Copyright 2000 Free Software Foundation, Inc.
     GDB is free software, covered by the GNU General Public License,
     and you are welcome to change it and/or distribute copies of it
     under certain conditions.
     Type "show copying" to see the conditions.
     There is absolutely no warranty for GDB.  Type "show warranty"
     for details.
     This GDB was configured as "sparc-sun-sunos4.1.3"

     ^Z^Zpre-prompt
     (gdb)
     ^Z^Zprompt
     quit

     ^Z^Zpost-prompt
     $

   Здесь 'quit' является для GDB вводом; остальное -- вывод GDB. Три
строки, начинающиеся с '^Z^Z' (где '^Z' означает знак 'control-z'), суть
примечания; остальное является выводом GDB.


File: gdb.info,  Node: Префикс server,  Next: Примечания к значениям,  Prev: Обзор примечаний,  Up: Примечания

18.2 Префикс server
===================

Чтобы подать команду GDB, не оказывая влияния на определенные аспекты
состояния, видимые для пользователей, начните ее с 'server '.  Это
означает, что данная команда не воздействует на историю команд, а также
не влияет на представление GDB о том, какую команду повторять, если в
пустой строке нажата клавиша <RET>.

   Префикс server не влияет на запись значений в историю значений; чтобы
напечатать значение, не занося его в историю, используйте команду
'output' вместо 'print'.


File: gdb.info,  Node: Примечания к значениям,  Next: Примечания к кадрам,  Prev: Префикс server,  Up: Примечания

18.3 Значения
=============

Когда значение выводится в различных контекстах, GDB использует
примечания, чтобы отделить его от окружающего текста.

   Если значение выводится с помощью 'print' и добавляется в историю
значений, примечание выглядит так:

     ^Z^Zvalue-history-begin НОМЕР-В-ИСТОРИИ ФЛАГИ-ЗНАЧЕНИЯ
     СТРОКА-ИСТОРИИ
     ^Z^Zvalue-history-value
     ЗНАЧЕНИЕ
     ^Z^Zvalue-history-end

где НОМЕР-В-ИСТОРИИ -- номер, который значение получает в истории,
СТРОКА-ИСТОРИИ -- строка, такая как '$5 = ', которая представляет
значение пользователю, ЗНАЧЕНИЕ является выводом, соответствующим самому
значению, а ФЛАГИ-ЗНАЧЕНИЯ -- '*' для значения, которое может быть
разыменовано, и '-', если нет.

   Если значение не добавляется в историю значений (это может быть или
неверное число с плавающей точкой, или оно выводится командой 'output'),
примечание выглядит похожим образом:

     ^Z^Zvalue-begin ФЛАГИ-ЗНАЧЕНИЯ
     ЗНАЧЕНИЕ
     ^Z^Zvalue-end

   Когда GDB выводит аргумент функции (например, в выводе команды
'backtrace'), он делает такие примечания:

     ^Z^Zarg-begin
     ИМЯ-АРГУМЕНТА
     ^Z^Zarg-name-end
     СТРОКА-РАЗДЕЛИТЕЛЬ
     ^Z^Zarg-value ФЛАГИ-ЗНАЧЕНИЯ
     ЗНАЧЕНИЕ
     ^Z^Zarg-end

где ИМЯ-АРГУМЕНТА есть имя аргумента, СТРОКА-РАЗДЕЛИТЕЛЬ -- текст (такой
как '='), который отделяет имя от значения для удобства пользователя, а
ФЛАГИ-ЗНАЧЕНИЯ и ЗНАЧЕНИЕ имеют такой же смысл, что и в примечании
'value-history-begin'.

   При выводе структуры, GDB делает следующие примечания:

     ^Z^Zfield-begin ФЛАГИ-ЗНАЧЕНИЯ
     ИМЯ-ПОЛЯ
     ^Z^Zfield-name-end
     СТРОКА-РАЗДЕЛИТЕЛЬ
     ^Z^Zfield-value
     ЗНАЧЕНИЕ
     ^Z^Zfield-end

где ИМЯ-ПОЛЯ есть имя поля, СТРОКА-РАЗДЕЛИТЕЛЬ -- текст (такой как '='),
который отделяет имя от значения для удобства пользователя, а
ФЛАГИ-ЗНАЧЕНИЯ и ЗНАЧЕНИЕ имеют тот же смысл, что и в примечании
'value-history-begin'.

   При выводе массива, GDB делает следующие примечания:

     ^Z^Zarray-section-begin ИНДЕКС-В-МАССИВЕ ФЛАГИ-ЗНАЧЕНИЯ

где ИНДЕКС-В-МАССИВЕ -- индекс первого аннотируемого элемента, а
ФЛАГИ-ЗНАЧЕНИЯ имеют такой же смысл, что и в примечании
'value-history-begin'.  За этим следует произвольное число элементов.
Элемент может быть либо одиночным

     ',' ПРОПУСК           ; опускается для первого элемента
     ЗНАЧЕНИЕ
     ^Z^Zelt

   либо повторяющимся

     ',' ПРОПУСК           ; опускается для первого элемента
     ЗНАЧЕНИЕ
     ^Z^Zelt-rep ЧИСЛО-ПОВТОРЕНИЙ
     СТРОКА-ПОВТОРЕНИЙ
     ^Z^Zelt-rep-end

   В обоих случаях ЗНАЧЕНИЕ является выводом значения элемента, а
ПРОПУСК может содержать пробелы, знаки табуляции и новой строки.  В
случае повторяющихся элементов, ЧИСЛО-ПОВТОРЕНИЙ представляет число
последовательных элементов массива, которые содержат данное значение, а
СТРОКА-ПОВТОРЕНИЙ является строкой, которая предназначена для
уведомления пользователя о том, что выводятся повторяющиеся элементы.

   После того как выведены все элементы массива, примечание к массиву
заканчивается так:

     ^Z^Zarray-section-end


File: gdb.info,  Node: Примечания к кадрам,  Next: Отображения,  Prev: Примечания к значениям,  Up: Примечания

18.4 Кадры
==========

Когда GDB печатает кадр, он делает к нему примечания.  Например, это
применяется к кадрам, выводимым при остановке GDB, к результатам вывода
таких команд, как 'backtrace' или 'up', и так далее.

   Примечания к кадру начинаются с

     ^Z^Zframe-begin УРОВЕНЬ АДРЕС
     СТРОКА-УРОВНЯ

где УРОВЕНЬ -- это номер кадра (0 для самого внутреннего кадра, другие
кадры имеют положительные номера), АДРЕС -- это адрес кода,
выполняющегося в данном кадре, а СТРОКА-УРОВНЯ -- строка,
предназначенная для передачи уровня пользователю.  АДРЕС имеет форму
'0x', за которым следует одна или более шестнадцатеричных цифр в нижнем
регистре (заметьте, что это не зависит от языка).  Кадр заканчивается
так:

     ^Z^Zframe-end

   Между этими комментариями находится основное тело кадра, которое
может состоять из

   *      ^Z^Zfunction-call
          СТРОКА-ВЫЗОВА-ФУНКЦИИ

     где СТРОКА-ВЫЗОВА-ФУНКЦИИ является текстом, предназначенным для
     уведомления пользователя, что этот кадр связан с вызовом функции,
     который GDB сделал в отлаживаемой программе.

   *      ^Z^Zsignal-handler-caller
          СТРОКА-ВЫЗОВА-ОБРАБОТЧИКА-СИГНАЛА

     где СТРОКА-ВЫЗОВА-ОБРАБОТЧИКА-СИГНАЛА -- текст, предназначенный для
     уведомления пользователя, что этот кадр связан с тем механизмом,
     который использовался операционной системой при вызове обработчика
     сигнала (это тот кадр, из которого произошел вызов обработчика, а
     не кадр для самого обработчика).

   * Обычный кадр.

     Это может (в зависимости от того, считается ли это информацией,
     интересной для пользователя) начинаться с

          ^Z^Zframe-address
          АДРЕС
          ^Z^Zframe-address-end
          СТРОКА-РАЗДЕЛИТЕЛЬ

     здесь АДРЕС -- это адрес, где происходит выполнение в кадре (тот же
     адрес, что и в примечании 'frame-begin', но выведенный в форме,
     предназначенной для пользователя -- в частности, синтаксис
     различается в зависимости от языка), а СТРОКА-РАЗДЕЛИТЕЛЬ является
     строкой, предназначенной для отделения этого адреса от того, что за
     ним следует для удобства пользователя.

     Затем идет

          ^Z^Zframe-function-name
          ИМЯ-ФУНКЦИИ
          ^Z^Zframe-args
          АРГУМЕНТЫ

     где ИМЯ-ФУНКЦИИ есть имя функции, выполняющейся в кадре, или '??',
     если оно не известно, а АРГУМЕНТЫ -- это аргументы к кадру, со
     скобками вокруг них (каждый аргумент аннотируется также
     индивидуально, *note Примечания к значениям::).

     Если доступна информация об исходных текстах, печатается ссылка на
     них:

          ^Z^Zframe-source-begin
          ВВОДНАЯ-ИСХОДНАЯ-СТРОКА
          ^Z^Zframe-source-file
          ИМЯ-ФАЙЛА
          ^Z^Zframe-source-file-end
          :
          ^Z^Zframe-source-line
          НОМЕР-СТРОКИ
          ^Z^Zframe-source-end

     где ВВОДНАЯ-ИСХОДНАЯ-СТРОКА отделяет ссылку от предшествующего ей
     текста, для удобства пользователя, ИМЯ-ФАЙЛА -- это имя исходного
     файла, НОМЕР-СТРОКИ -- номер строки в этом файле (первая строка
     имеет номер 1).

     Если GDB печатает некоторую информацию о том, откуда появился этот
     кадр (какая библиотека, какой сегмент загрузки и так далее; в
     настоящее время реализовано только на RS/6000), он делает такие
     примечания:

          ^Z^Zframe-where
          ИНФОРМАЦИЯ

     Затем, если исходный текст действительно должен быть отображен для
     этого кадра (это неверно, например, для вывода от команды
     'backtrace'), тогда выводится примечание 'source' (*note Примечания
     к исходному тексту::).  В отличие от большинства примечаний, этот
     вывод производится вместо обычного текста, который был бы
     напечатан, а не в дополнение к нему.


File: gdb.info,  Node: Отображения,  Next: Приглашения,  Prev: Примечания к кадрам,  Up: Примечания

18.5 Отображения
================

Когда GDB велят отобразить что-то с помощью команды 'display', к
результату отображения делаются примечания:

     ^Z^Zdisplay-begin
     НОМЕР
     ^Z^Zdisplay-number-end
     РАЗДЕЛИТЕЛЬ-НОМЕРОВ
     ^Z^Zdisplay-format
     ФОРМАТ
     ^Z^Zdisplay-expression
     ВЫРАЖЕНИЕ
     ^Z^Zdisplay-expression-end
     РАЗДЕЛИТЕЛЬ-ВЫРАЖЕНИЙ
     ^Z^Zdisplay-value
     ЗНАЧЕНИЕ
     ^Z^Zdisplay-end

здесь НОМЕР -- это номер отображения, РАЗДЕЛИТЕЛЬ-НОМЕРОВ предназначен
для отделения номеров от того, что следует затем для пользователя,
ФОРМАТ включает информацию о том, как отображается значение, такую как
размер, формат и так далее, ВЫРАЖЕНИЕ -- это отображаемое выражение,
РАЗДЕЛИТЕЛЬ-ВЫРАЖЕНИЙ предназначен для отделения выражения от следующего
за ним текста для пользователя, и ЗНАЧЕНИЕ -- это действительное
значение, которое отображается.


File: gdb.info,  Node: Приглашения,  Next: Ошибки,  Prev: Отображения,  Up: Примечания

18.6 Примечания ко вводу GDB
============================

Когда GDB выводит приглашение для ввода, он делает к этому примечания,
так что становится возможным узнать, когда посылать данные, когда
закончен вывод от данной команды, и так далее.

   Каждый из различных видов ввода имеет различный "тип ввода".  Каждый
тип ввода имеет три примечания: примечание 'pre-', обозначающее начало
каждого выводимого приглашения, простое примечание, обозначающее конец
приглашения, и затем примечание 'post-', обозначающее конец любого эхо,
которое может быть ассоциировано (а может и не быть) со вводом.
Например, характерной чертой типа ввода 'prompt' являются следующие
примечания:

     ^Z^Zpre-prompt
     ^Z^Zprompt
     ^Z^Zpost-prompt

   Существуют следующие типы ввода:

'prompt'
     Когда GDB запрашивает команду (главное приглашение GDB).

'commands'
     Когда GDB запрашивает набор команд, как в команде 'commands'.
     Примечания повторяются для каждой введенной команды.

'overload-choice'
     Когда GDB хочет, чтобы пользователь выбрал одну из нескольких
     перегруженных функций.

'query'
     Когда GDB хочет, чтобы пользователь подтвердил потенциально опасное
     действие.

'prompt-for-continue'
     Когда GDB запрашивает у пользователя нажатие ввода для продолжения.
     Замечание: не ожидайте, что это будет работать хорошо; используйте
     вместо этого 'set height 0' для отключения приглашений.  Это
     происходит потому, что при наличии примечаний подсчет строк
     происходит неверно.


File: gdb.info,  Node: Ошибки,  Next: Информация о точке останова,  Prev: Приглашения,  Up: Примечания

18.7 Ошибки
===========

     ^Z^Zquit

   Это примечание появляется непосредственно перед тем, как GDB отвечает
на прерывание.

     ^Z^Zerror

   Это примечание появляется сразу перед тем, как GDB отвечает на
ошибку.

   Примечания выхода и ошибки обозначают, что любое примечание, в
середине которого находился GDB, могут внезапно оборваться.  Например,
если за примечанием 'value-history-begin' следует 'error', то не нужно
ожидать соответствующий 'value-history-end'.  Однако, не следует также
ожидать, что его точно не будет; примечание об ошибке не обязательно
означает, что GDB немедленно возвращается в начало на самый верхний
уровень.

   Примечанию к ошибке или выходу может предшествовать

     ^Z^Zerror-begin

   Весь вывод между этим и примечанием к ошибке или выходу является
сообщением об ошибке.

   Пока примечаний к предупреждающим сообщениям не делается.


File: gdb.info,  Node: Информация о точке останова,  Next: Недостоверность,  Prev: Ошибки,  Up: Примечания

18.8 Информация о точке останова
================================

К выводу, производимому командой 'info breakpoints', делаются следующие
примечания:

     ^Z^Zbreakpoints-headers
     ЭЛЕМЕНТ-ЗАГОЛОВКА
     ^Z^Zbreakpoints-table

где ЭЛЕМЕНТ-ЗАГОЛОВКА имеет тот же синтаксис, что и элемент (смотрите
ниже), но вместо данных он содержит строки, которые предназначены для
разъяснения пользователю значений каждого поля.  Затем следует
произвольное число элементов.  Если поле не подходит к этому элементу,
оно опускается.  Поля могут содержать завершающие пропуски.  Каждое поле
состоит из:

     ^Z^Zrecord
     ^Z^Zfield 0
     НОМЕР
     ^Z^Zfield 1
     ТИП
     ^Z^Zfield 2
     ПОЛОЖЕНИЕ
     ^Z^Zfield 3
     ВКЛЮЧЕНА
     ^Z^Zfield 4
     АДРЕС
     ^Z^Zfield 5
     ЧТО
     ^Z^Zfield 6
     КАДР
     ^Z^Zfield 7
     УСЛОВИЕ
     ^Z^Zfield 8
     СЧЕТЧИК-ИГНОРИРОВАНИЙ
     ^Z^Zfield 9
     КОМАНДЫ

   Заметьте, что АДРЕС предназначен для использования пользователем --
синтаксис различается в зависимости от языка.

   Вывод заканчивается так:

     ^Z^Zbreakpoints-table-end


File: gdb.info,  Node: Недостоверность,  Next: Примечания к выполнению,  Prev: Информация о точке останова,  Up: Примечания

18.9 Сообщения о недостоверности
================================

Следующие примечания говорят о том, что определенные куски информации,
описывающие состояние, могли измениться.

'^Z^Zframes-invalid'

     Кадры (например, вывод команды 'backtrace') могли измениться.

'^Z^Zbreakpoints-invalid'

     Точки останова могли измениться.  Например, пользователь только что
     добавил или удалил точку останова.


File: gdb.info,  Node: Примечания к выполнению,  Next: Примечания к исходному тексту,  Prev: Недостоверность,  Up: Примечания

18.10 Выполнение программы
==========================

Когда программа начинает выполняться вследствие команды GDB, такой как
'step' или 'continue', выводится

     ^Z^Zstarting

   Когда программа останавливается, выводится

     ^Z^Zstopped

   Перед примечанием 'stopped', множество примечаний описывают, как
программа остановилась.

'^Z^Zexited КОД-ВЫХОДА'
     Программа завершилась, и КОД-ВЫХОДА является кодом выхода (ноль при
     успешном завершении, в противном случае не ноль).

'^Z^Zsignalled'
     Программа завершилась по сигналу.  После '^Z^Zsignalled',
     примечания продолжаются:

          ВСТУПИТЕЛЬНЫЙ-ТЕКСТ
          ^Z^Zsignal-name
          ИМЯ
          ^Z^Zsignal-name-end
          ТЕКСТ-В-СЕРЕДИНЕ
          ^Z^Zsignal-string
          СТРОКА
          ^Z^Zsignal-string-end
          ЗАКЛЮЧИТЕЛЬНЫЙ-ТЕКСТ

     где ИМЯ является именем сигнала, таким как 'SIGILL' или 'SIGSEGV',
     а СТРОКА представляет объяснение сигнала, например 'Illegal
     Instruction' или 'Segmentation fault'.  ВСТУПИТЕЛЬНЫЙ-ТЕКСТ,
     ТЕКСТ-В-СЕРЕДИНЕ и ЗАКЛЮЧИТЕЛЬНЫЙ-ТЕКСТ используются для удобства
     пользователя и не имеют определенного формата.

'^Z^Zsignal'
     Синтаксис этого примечания такой же, как для 'signalled', но GDB
     сообщает, что программа лишь получила сигнал, а не то, что она
     остановилась из-за него.

'^Z^Zbreakpoint НОМЕР'
     Программа достигла точки останова с номером НОМЕР.

'^Z^Zwatchpoint НОМЕР'
     Программа достигла точки наблюдения с номером НОМЕР.


File: gdb.info,  Node: Примечания к исходному тексту,  Next: Дальнейшие планы,  Prev: Примечания к выполнению,  Up: Примечания

18.11 Вывод исходного текста
============================

Следующие примечания используются вместо вывода исходного текста:

     ^Z^Zsource ИМЯ-ФАЙЛА:СТРОКА:ЗНАК:СЕРЕДИНА:АДРЕС

где ИМЯ-ФАЙЛА указывает абсолютное имя файла, СТРОКА -- это номер строки
в этом файле (первая строка имеет номер 1), ЗНАК -- позиция знака в
файле (первый знак в исходном файле имеет номер 0) (для большинства
отладочных форматов это будет обязательно указывать на начало строки),
СЕРЕДИНА есть 'middle', если АДРЕС находится в середине строки, или
'beg', если АДРЕС находится в начале строки, а АДРЕС является адресом в
целевой программе, ассоциированным с выводимым исходным текстом.  АДРЕС
записывается в форме '0x', за которым следует одна или несколько
шестнадцатеричных цифр в нижнем регистре (заметьте, что это не зависит
от языка).


File: gdb.info,  Node: Дальнейшие планы,  Prev: Примечания к исходному тексту,  Up: Примечания

18.12 Примечания, которые могут понадобиться в будущем
======================================================

    - target-invalid
      цель могла измениться (регистры, содержимое памяти или статус
      выполнения).  Для эффективности выполнения, мы можем захотеть
      определять 'register-invalid' и 'all-register-invalid' с большей
      точностью

    - систематические примечания к параметрам set/show (включая
      сообщения о недостоверности).

    - аналогично, 'info' возвращает список кандидатов на сообщение о
      недостоверности.


File: gdb.info,  Node: GDB/MI,  Next: Ошибки в GDB,  Prev: Примечания,  Up: Top

19 Интерфейс GDB/MI
*******************

* Menu:

* Синтаксис команд GDB/MI::
* Совместимость GDB/MI с CLI::
* Выходные записи GDB/MI::
* Формат описания команд GDB/MI::
* Команды GDB/MI для таблицы точек останова::
* Управление данными GDB/MI::
* Управление программой GDB/MI::
* Разные команды GDB/MI::
* Управление стеком GDB/MI::
* Запросы GDB/MI о символах::
* Управление целью GDB/MI::
* Команды GDB/MI для нитей::
* Команды GDB/MI для точек трассировки::
* Изменяемые объекты GDB/MI::

Назначение и цель
=================

GDB/MI -- это построчный машинно-ориентированный текстовый интерфейс к
GDB. Он предназначен специально для поддержки разработки систем, которые
используют отладчик лишь как одну маленькую компоненту большой системы.

   Эта глава является спецификацией интерфейса GDB/MI.  Она написана в
форме справочного руководства.

   Заметьте, что GDB/MI все еще находится в стадии разработки, так что
некоторые описанные ниже возможности являются неполными и могут быть
изменены.

Система обозначений и терминология
==================================

Эта глава использует следующую систему обозначений:

   * '|' разделяет две альтернативы.

   * '[ НЕЧТО ]' указывает, что НЕЧТО является необязательным: оно может
     быть задано, а может и нет.

   * '( ГРУППА )*' означает, что ГРУППА в скобках может повторяться ноль
     и более раз.

   * '( ГРУППА )+' означает, что ГРУППА в скобках может повторяться один
     и более раз.

   * '"СТРОКА"' обозначает текст СТРОКА.

Выражения признательности
=========================

В алфавитном порядке: Елена Заннони, Эндрю Кагни, Фернандо Нассер и Стан
Шебс.

* Menu:

* Синтаксис команд GDB/MI::
* Совместимость GDB/MI с CLI::
* Выходные записи GDB/MI::
* Формат описания команд GDB/MI::
* Команды GDB/MI для таблицы точек останова::
* Управление данными GDB/MI::
* Управление программой GDB/MI::
* Разные команды GDB/MI::
* Управление стеком GDB/MI::
* Запросы GDB/MI о символах::
* Управление целью GDB/MI::
* Команды GDB/MI для нитей::
* Команды GDB/MI для точек трассировки::
* Изменяемые объекты GDB/MI::


File: gdb.info,  Node: Синтаксис команд GDB/MI,  Next: Совместимость GDB/MI с CLI,  Up: GDB/MI

19.1 Синтаксис команд GDB/MI
============================

* Menu:

* Входной синтаксис GDB/MI::
* Выходной синтаксис GDB/MI::
* Простые примеры GDB/MI::


File: gdb.info,  Node: Входной синтаксис GDB/MI,  Next: Выходной синтаксис GDB/MI,  Up: Синтаксис команд GDB/MI

19.1.1 Входной синтаксис GDB/MI
-------------------------------

'КОМАНДА ==>'
     'КОМАНДА-CLI | КОМАНДА-MI'

'КОМАНДА-CLI ==>'
     '[ ЛЕКСЕМА ] КОМАНДА-CLI NL', где КОМАНДА-CLI есть любая
     существующая команда GDB CLI.

'КОМАНДА-MI ==>'
     '[ ЛЕКСЕМА ] "-" ДЕЙСТВИЕ ( " " КЛЮЧ )* [ " --" ] ( " " ПАРАМЕТР )*
     NL'

'ЛЕКСЕМА ==>'
     "любая последовательность цифр"

'КЛЮЧ ==>'
     '"-" ПАРАМЕТР [ " " ПАРАМЕТР ]'

'ПАРАМЕТР ==>'
     'НЕПУСТАЯ-ПОСЛЕДОВАТЕЛЬНОСТЬ | СТРОКА-СИ'

'ДЕЙСТВИЕ ==>'
     _любое из действий, описанных в этой главе_

'НЕПУСТАЯ-ПОСЛЕДОВАТЕЛЬНОСТЬ ==>'
     _все что угодно, не содержащее специальных знаков, таких как "-",
     NL, """ и, конечно, " "_

'СТРОКА-СИ ==>'
     '""" СОДЕРЖИМОЕ-СЕМИБИТНОЙ-СТРОКИ-ISO-СИ """'

'NL ==>'
     'CR | CR-LF'

Замечания:

   * Команды CLI все еще обрабатываются интерпретатором MI; их вывод
     описан ниже.

   * 'ЛЕКСЕМА', если присутствует, передается назад, когда выполнение
     команды завершается.

   * Некоторые команды MI допускают необязательные аргументы как часть
     списка параметров.  Каждый ключ идентифицируется предшествующей ему
     чертой '-', и за ним может следовать в качестве параметра
     необязательный аргумент.  Ключи появляются в начале списка
     параметров и могут быть отделены от обычных параметров при помощи
     '--' (это полезно, когда некоторые параметры начинаются с черты).

   Прагматические соображения:

   * Мы хотим получить простой доступ к существующему синтаксису CLI
     (для отладки).

   * Мы хотим, чтобы работа MI была легко заметна.


File: gdb.info,  Node: Выходной синтаксис GDB/MI,  Next: Простые примеры GDB/MI,  Prev: Входной синтаксис GDB/MI,  Up: Синтаксис команд GDB/MI

19.1.2 Выходной синтаксис GDB/MI
--------------------------------

Вывод GDB/MI состоит из нуля или более внеочередных записей, за которыми
может следовать одна результирующая запись.  Эта запись относится к
самой последней команде.  Последовательность выводимых записей
завершается '(gdb)'.

   Если входная команда начиналась с префикса 'ЛЕКСЕМА', то
соответствующий вывод для этой команды также будет начинаться с того же
префикса ЛЕКСЕМА.

'ВЫВОД ==>'
     '( ВНЕОЧЕРЕДНАЯ-ЗАПИСЬ )* [ РЕЗУЛЬТИРУЮЩАЯ-ЗАПИСЬ ] "(gdb)" NL'

'РЕЗУЛЬТИРУЮЩАЯ-ЗАПИСЬ ==>'
     ' [ ЛЕКСЕМА ] "^" РЕЗУЛЬТИРУЮЩИЙ-КЛАСС ( "," РЕЗУЛЬТАТ )* NL'

'ВНЕОЧЕРЕДНАЯ-ЗАПИСЬ ==>'
     'АСИНХР-ЗАПИСЬ | ПОТОЧН-ЗАПИСЬ'

'АСИНХР-ЗАПИСЬ ==>'
     'АСИНХР-ВЫВОД-ВЫПОЛН | АСИНХР-ВЫВОД-СТАТУСА | АСИНХР-ВЫВОД-УВЕДОМЛ'

'АСИНХР-ВЫВОД-ВЫПОЛН ==>'
     '[ ЛЕКСЕМА ] "*" АСИНХР-ВЫВОД'

'АСИНХР-ВЫВОД-СТАТУСА ==>'
     '[ ЛЕКСЕМА ] "+" АСИНХР-ВЫВОД'

'АСИНХР-ВЫВОД-УВЕДОМЛ ==>'
     '[ ЛЕКСЕМА ] "=" АСИНХР-ВЫВОД'

'АСИНХР-ВЫВОД ==>'
     'АСИНХР-КЛАСС ( "," РЕЗУЛЬТАТ )* NL'

'РЕЗУЛЬТ-КЛАСС ==>'
     '"done" | "running" | "connected" | "error" | "exit"'

'АСИНХР-КЛАСС ==>'
     '"stopped" | ДРУГОЕ' (где ДРУГОЕ будет добавлено по необходимости
     -- это все еще находится в стадии разработки).

'РЕЗУЛЬТАТ ==>'
     ' ПЕРЕМЕННАЯ "=" ЗНАЧЕНИЕ'

'ПЕРЕМЕННАЯ ==>'
     ' СТРОКА '

'ЗНАЧЕНИЕ ==>'
     ' КОНСТАНТА | НАБОР | СПИСОК '

'КОНСТАНТА ==>'
     'СТРОКА-СИ'

'НАБОР ==>'
     ' "{}" | "{" РЕЗУЛЬТАТ ( "," РЕЗУЛЬТАТ )* "}" '

'СПИСОК ==>'
     ' "[]" | "[" ЗНАЧЕНИЕ ( "," ЗНАЧЕНИЕ )* "]" | "[" РЕЗУЛЬТАТ ( ","
     РЕЗУЛЬТАТ )* "]" '

'ПОТОЧН-ЗАПИСЬ ==>'
     'КОНСОЛЬН-ПОТОЧН-ВЫВОД | ЦЕЛЕВ-ПОТОЧН-ВЫВОД | ЖУРН-ПОТОЧН-ВЫВОД'

'КОНСОЛЬН-ПОТОЧН-ВЫВОД ==>'
     '"~" СТРОКА-СИ'

'ЦЕЛЕВ-ПОТОЧН-ВЫВОД ==>'
     '"@" СТРОКА-СИ'

'ЖУРН-ПОТОЧН-ВЫВОД ==>'
     '"&" СТРОКА-СИ'

'NL ==>'
     'CR | CR-LF'

'ЛЕКСЕМА ==>'
     _любая последовательность цифр_.

Замечания:

   * Все выходные последовательности заканчиваются одной строкой,
     содержащей точку.

   * 'ЛЕКСЕМА' берется из соответствующего запроса.  Если выполнение
     команды прерывается командой '-exec-interrupt', ЛЕКСЕМА,
     ассоциированная с сообщением '*stopped', является лексемой исходной
     выполняемой команды, а не лексемой команды прерывания.

   * АСИНХР-ВЫВОД-СТАТУСА содержит последующую информацию состояния о
     выполнении медленной операции.  Она может быть отброшена.  Весь
     вывод состояния начинается с префикса '+'.

   * АСИНХР-ВЫВОД-ВЫПОЛН содержит асинхронное изменения состояния на
     цели (остановлена, запущена, исчезла).  Весь асинхронный вывод
     начинается с префикса '*'.

   * АСИНХР-ВЫВОД-УВЕДОМЛ содержит сопровождающую информацию, которую
     должен обработать клиент (например, информацию о новой точке
     останова).  Весь уведомительный вывод начинается с префикса '='.

   * КОНСОЛЬН-ПОТОЧН-ВЫВОД является выводом, который должен быть
     отображен на консоли без изменений.  Он является текстовым ответом
     на команду CLI. Весь консольный вывод начинается с префикса '~'.

   * ЦЕЛЕВ-ПОТОЧН-ВЫВОД является выводом, произведенным целевой
     программой.  Весь целевой вывод начинается с префикса '@'.

   * ЖУРН-ПОТОЧН-ВЫВОД является выходным текстом, происходящим от
     внутренней реализации GDB, например, сообщения, которые должны быть
     отображены как часть журнала ошибок.  Весь журнальный вывод
     начинается с префикса '&'.

   * Новые команды GDB/MI должны выводить только СПИСКИ, содержащие
     ЗНАЧЕНИЯ.

   *Note Поточные записи GDB/MI: Поточные записи GDB/MI, для более
подробной информации о различных выводимых записях.


File: gdb.info,  Node: Простые примеры GDB/MI,  Prev: Выходной синтаксис GDB/MI,  Up: Синтаксис команд GDB/MI

19.1.3 Простые примеры взаимодействия с GDB/MI
----------------------------------------------

Этот подраздел представляет несколько простых примеров взаимодействия с
использованием интерфейса GDB/MI.  В этих примерах, '->' означает, что
следующая строка передается GDB/MI в качестве ввода, а '<-' означает
вывод, полученный от GDB/MI.

Останов цели
............

Вот пример останова подчиненного процесса:

     -> -stop
     <- (gdb)

и затем:

     <- *stop,reason="stop",address="0x123",source="a.c:123"
     <- (gdb)

Простая команда CLI
...................

Вот пример простой команды CLI, передаваемой ему через GDB/MI.

     -> print 1+2
     <- ~3\n
     <- (gdb)

Команда с побочными эффектами
.............................

     -> -symbol-file xyz.exe
     <- *breakpoint,nr="3",address="0x123",source="a.c:123"
     <- (gdb)

Плохая команда
..............

Вот что происходит, если вы передаете несуществующую команду:

     -> -rubbish
     <- error,"Rubbish not found"
     <- (gdb)


File: gdb.info,  Node: Совместимость GDB/MI с CLI,  Next: Выходные записи GDB/MI,  Prev: Синтаксис команд GDB/MI,  Up: GDB/MI

19.2 Совместимость GDB/MI с CLI
===============================

Чтобы помочь пользователям, знакомым с существующим в GDB интерфейсом
CLI, GDB/MI принимает существующие команды CLI. Как определено
синтаксисом, такие команды могут быть непосредственно введены в
интерфейс GDB/MI, и GDB будет отвечать.

   Этот механизм предоставляется для помощи разработчикам клиентов
GDB/MI, а не как надежный интерфейс к CLI. Так как команда
интерпретируется в среде, которая подразумевает поведение GDB/MI, точные
результаты таких команд в конечном итоге скорее всего станут
неудобоваримой смесью вывода GDB/MI и CLI.


File: gdb.info,  Node: Выходные записи GDB/MI,  Next: Формат описания команд GDB/MI,  Prev: Совместимость GDB/MI с CLI,  Up: GDB/MI

19.3 Выходные записи GDB/MI
===========================

* Menu:

* Результирующие записи GDB/MI::
* Поточные записи GDB/MI::
* Внеочередные записи GDB/MI::


File: gdb.info,  Node: Результирующие записи GDB/MI,  Next: Поточные записи GDB/MI,  Up: Выходные записи GDB/MI

19.3.1 Результирующие записи GDB/MI
-----------------------------------

В дополнение к множеству внеочередных уведомлений, ответ на команду
GDB/MI включает один из следующих указателей результата:

'"^done" [ "," РЕЗУЛЬТАТЫ ]'
     Синхронная операция прошла успешно, возвращаемыми значениями
     являются 'РЕЗУЛЬТАТЫ'.

'"^running"'
     Асинхронная операция была успешно начата.  Цель выполняется.

'"^error" "," СТРОКА-СИ'
     Операция завершилась с ошибкой.  'СТРОКА-СИ' содержит
     соответствующее сообщение об ошибке.


File: gdb.info,  Node: Поточные записи GDB/MI,  Next: Внеочередные записи GDB/MI,  Prev: Результирующие записи GDB/MI,  Up: Выходные записи GDB/MI

19.3.2 Поточные записи GDB/MI
-----------------------------

GDB хранит несколько выходных потоков: консоль, цель и журнал.  Вывод,
предназначенный для этих потоков, пропускается через интерфейс GDB/MI
при помощи "поточных записей".

   Каждая поточная запись начинается с уникального "префиксного знака",
который идентифицирует свой поток (*note Выходной синтаксис GDB/MI:
Выходной синтаксис GDB/MI.). Помимо префикса, каждая поточная запись
содержит 'СТРОКУ-ВЫВОД'.  Это либо простой текст (с подразумеваемым
знаком новой строки), или Си-строка в кавычках (которая не содержит
подразумеваемого знака новой строки).

'"~" СТРОКА-ВЫВОД'
     Консольный поток вывода содержит текст, который должен быть
     отображен в консольном окне CLI. Он содержит текстовые ответы на
     команды CLI.

'"@" СТРОКА-ВЫВОД'
     Целевой поток вывода содержит произвольный текстовый вывод от
     выполняемой цели.

'"&" СТРОКА-ВЫВОД'
     Журнальный поток содержит отладочные сообщения, которые создает сам
     GDB.


File: gdb.info,  Node: Внеочередные записи GDB/MI,  Prev: Поточные записи GDB/MI,  Up: Выходные записи GDB/MI

19.3.3 Внеочередные записи GDB/MI
---------------------------------

"Внеочередные" записи используются для уведомления клиента GDB/MI о
произошедших дополнительных изменениях.  Эти изменения могут либо
исходить от GDB/MI (например, измененная точка останова), либо быть
результатом действий цели (например, цель остановилась).

   Ниже приведен предварительный список возможных внеочередных записей.

'"*" "stop"'


File: gdb.info,  Node: Формат описания команд GDB/MI,  Next: Команды GDB/MI для таблицы точек останова,  Prev: Выходные записи GDB/MI,  Up: GDB/MI

19.4 Формат описания команд GDB/MI
==================================

Оставшиеся разделы описывают блоки команд.  Каждый блок команд
схематично аналогичен этому разделу.

   Заметьте, что разбиения строк в примерах присутствуют только для
удобства чтения.  Они не появляются в реальном выводе.  Учтите также,
что команды с недоступными примерами (Н.П.) еще не реализованы.

Мотивация
---------

Мотивация для этого набора команд.

Введение
--------

Краткое введение в этот набор команд в целом.

Команды
-------

Для каждой команды в блоке, описано следующее:

Краткое описание
................

      -command АРГ...

Команда GDB
...........

Соответствующая команда CLI GDB.

Результат
.........

Внеочередные сообщения
......................

Примечания
..........

Пример
......


File: gdb.info,  Node: Команды GDB/MI для таблицы точек останова,  Next: Управление данными GDB/MI,  Prev: Формат описания команд GDB/MI,  Up: GDB/MI

19.5 Команды GDB/MI для таблицы точек останова
==============================================

Этот раздел описывает команды GDB/MI для управления точками останова.

Команда '-break-after'
----------------------

Краткое описание
................

      -break-after НОМЕР ЧИСЛО

   Точка останова с номером НОМЕР не срабатывает, пока она не будет
достигнута ЧИСЛО раз.  Чтобы увидеть, как это отражается на выводе
команды '-break-list', смотрите ниже описание команды '-break-list'.

Команда GDB
...........

Соответствующей командой GDB является 'ignore'.

Пример
......

     (gdb)
     -break-insert main
     ^done,bkpt={number="1",addr="0x000100d0",file="hello.c",line="5"}
     (gdb)
     -break-after 1 3
     ~
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0",
     ignore="3"}]}
     (gdb)

Команда '-break-condition'
--------------------------

Краткое описание
................

      -break-condition НОМЕР ВЫРАЖ

   Точка останова НОМЕР остановит программу, только если условие ВЫРАЖ
истинно.  Условие становится частью вывода '-break-list' (смотрите ниже
описание команды '-break-list').

Команда GDB
...........

Соответствующей командой GDB является 'condition'.

Пример
......

     (gdb)
     -break-condition 1 1
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",cond="1",
     times="0",ignore="3"}]}
     (gdb)

Команда '-break-delete'
-----------------------

Краткое описание
................

      -break-delete ( ТОЧКА-ОСТАНОВА )+

   Удалить точки останова, чьи номера указаны в списке аргументов.  Это
очевидным образом отражается на списке точек останова.

Команда GDB
...........

Соответствующей командой GDB является 'delete'.

Пример
......

     (gdb)
     -break-delete 1
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="0",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[]}
     (gdb)

Команда '-break-disable'
------------------------

Краткое описание
................

      -break-disable ( ТОЧКА-ОСТАНОВА )+

   Отключить перечисленные ТОЧКИ-ОСТАНОВА.  Для указанных ТОЧЕК-ОСТАНОВА
поле 'enabled' в списке точек останова теперь установлено в 'n'.

Команда GDB
...........

Соответствующей командой GDB является 'disable'.

Пример
......

     (gdb)
     -break-disable 2
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="2",type="breakpoint",disp="keep",enabled="n",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0"}]}
     (gdb)

Команда '-break-enable'
-----------------------

Краткое описание
................

      -break-enable ( ТОЧКА-ОСТАНОВА )+

   Включить (ранее отключенные) ТОЧКИ-ОСТАНОВА.

Команда GDB
...........

Соответствующей командой GDB является 'enable'.

Пример
......

     (gdb)
     -break-enable 2
     ^done
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="2",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0"}]}
     (gdb)

Команда '-break-info'
---------------------

Краткое описание
................

      -break-info ТОЧКА-ОСТАНОВА

   Получить информацию об одной точке останова.

Команда GDB
...........

Соответствующей командой GDB является 'info break ТОЧКА-ОСТАНОВА'.

Пример
......

Н.П.

Команда '-break-insert'
-----------------------

Краткое описание
................

      -break-insert [ -t ] [ -h ] [ -r ]
         [ -c УСЛОВИЕ ] [ -i СЧЕТЧИК-ИГНОРИРОВАНИЙ ]
         [ -p НИТЬ ] [ СТРОКА | АДРЕС ]

СТРОКА, если указана, может быть одной из:

   * функция
   * имя-файла:номер-строки
   * имя-файла:функция
   * *адрес

   Вот возможные необязательные параметры этой команды:

'-t'
     Вставить временную точку останова.
'-h'
     Вставить аппаратную точку останова.
'-c УСЛОВИЕ'
     Сделать точку останова условной с заданным УСЛОВИЕМ.
'-i СЧЕТЧИК-ИГНОРИРОВАНИЙ'
     Инициализировать СЧЕТЧИК-ИГНОРИРОВАНИЙ.
'-r'
     Вставить обычную точку останова во всех функциях, чьи имена
     удовлетворяют данному регулярному выражению.  Другие флаги к
     регулярному выражению неприменимы.

Результат
.........

Результат имеет форму:

      ^done,bkptno="НОМЕР",func="ИМЯ-ФУНКЦИИ",
       file="ИМЯ-ФАЙЛА",line="НОМ-СТРОКИ"

где НОМЕР является номером этой точки останова в GDB, ИМЯ-ФУНКЦИИ -- имя
функции, в которой была вставлена точка останова, ИМЯ-ФАЙЛА -- имя
исходного файла, в котором находится эта функция, а НОМ-СТРОКИ является
номером строки исходного текста в этом файле.

   Замечание: этот формат может изменяться.

Команда GDB
...........

Соответствующими командами GDB являются 'break', 'tbreak', 'hbreak',
'thbreak' и 'rbreak'.

Пример
......

     (gdb)
     -break-insert main
     ^done,bkpt={number="1",addr="0x0001072c",file="recursive2.c",line="4"}
     (gdb)
     -break-insert -t foo
     ^done,bkpt={number="2",addr="0x00010774",file="recursive2.c",line="11"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x0001072c", func="main",file="recursive2.c",line="4",times="0"},
     bkpt={number="2",type="breakpoint",disp="del",enabled="y",
     addr="0x00010774",func="foo",file="recursive2.c",line="11",times="0"}]}
     (gdb)
     -break-insert -r foo.*
     ~int foo(int, int);
     ^done,bkpt={number="3",addr="0x00010774",file="recursive2.c",line="11"}
     (gdb)

Команда '-break-list'
---------------------

Краткое описание
................

      -break-list

   Отображает список установленных точек останова, показывая следующие
поля:

'Number'
     номер точки останова
'Type'
     тип точки останова: 'breakpoint' или 'watchpoint'
'Disposition'
     эта точка останова должна быть удалена или отключена при
     срабатывании: 'keep' или 'nokeep'
'Enabled'
     включена точка останова или нет: 'y' или 'n'
'Address'
     местоположение в памяти, где установлена точка останова
'What'
     логическое положение точки останова, выраженное именем функции,
     именем файла, номером строки
'Times'
     Число раз, которое точка останова срабатывала

   Если точек останова или наблюдения нет, поле 'body' 'BreakpointTable'
является пустым списком.

Команда GDB
...........

Соответствующей командой GDB является 'info break'.

Пример
......

     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x000100d0",func="main",file="hello.c",line="5",times="0"},
     bkpt={number="2",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010114",func="foo",file="hello.c",line="13",times="0"}]}
     (gdb)

   Вот пример результата, когда точек останова нет:

     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="0",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[]}
     (gdb)

Команда '-break-watch'
----------------------

Краткое описание
................

      -break-watch [ -a | -r ]

   Создать точку наблюдения.  С ключом '-a' будет создана точка
наблюдения за "доступом", то есть такая точка наблюдения, которая
срабатывает либо при чтении, либо при записи в определенное
местоположение в памяти.  С ключом '-r' созданная точка наблюдения будет
точкой наблюдения за "чтением", то есть она будет срабатывать, только
когда к определенному местоположению в памяти осуществляется доступ на
чтение.  Без этих ключей будет создана обычная точка наблюдения, то есть
она будет срабатывать, когда к местоположению в памяти осуществляется
доступ для записи.  *Note Установка точек наблюдения: Установка точек
наблюдения.

   Заметьте, что '-break-list' выдаст единый список установленных точек
наблюдения и останова.

Комада GDB
..........

Соответствующими командами GDB являются 'watch', 'awatch' и 'rwatch'.

Пример
......

Установка точки наблюдения за переменной в функции 'main':

     (gdb)
     -break-watch x
     ^done,wpt={number="2",exp="x"}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-trigger",wpt={number="2",exp="x"},
     value={old="-268439212",new="55"},
     frame={func="main",args=[],file="recursive2.c",line="5"}
     (gdb)

   Установка точки наблюдения за локальной переменной функции.  GDB
дважды остановит выполнение программы: сначала при изменении значения
переменной, затем при выходе точки наблюдения из области видимости.

     (gdb)
     -break-watch C
     ^done,wpt={number="5",exp="C"}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-trigger",
     wpt={number="5",exp="C"},value={old="-276895068",new="3"},
     frame={func="callee4",args=[],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="13"}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-scope",wpnum="5",
     frame={func="callee3",args=[{name="strarg",
     value="0x11940 \"A string argument.\""}],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
     (gdb)

   Получение списка точек останова и наблюдения в разных местах
выполнения программы.  Заметьте, что как только точка наблюдения выходит
из области видимости, она удаляется.

     (gdb)
     -break-watch C
     ^done,wpt={number="2",exp="C"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"},
     bkpt={number="2",type="watchpoint",disp="keep",
     enabled="y",addr="",what="C",times="0"}]}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-trigger",wpt={number="2",exp="C"},
     value={old="-276895068",new="3"},
     frame={func="callee4",args=[],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="13"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="2",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"},
     bkpt={number="2",type="watchpoint",disp="keep",
     enabled="y",addr="",what="C",times="-5"}]}
     (gdb)
     -exec-continue
     ^running
     ^done,reason="watchpoint-scope",wpnum="2",
     frame={func="callee3",args=[{name="strarg",
     value="0x11940 \"A string argument.\""}],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
     (gdb)
     -break-list
     ^done,BreakpointTable={nr_rows="1",nr_cols="6",
     hdr=[{width="3",alignment="-1",col_name="number",colhdr="Num"},
     {width="14",alignment="-1",col_name="type",colhdr="Type"},
     {width="4",alignment="-1",col_name="disp",colhdr="Disp"},
     {width="3",alignment="-1",col_name="enabled",colhdr="Enb"},
     {width="10",alignment="-1",col_name="addr",colhdr="Address"},
     {width="40",alignment="2",col_name="what",colhdr="What"}],
     body=[bkpt={number="1",type="breakpoint",disp="keep",enabled="y",
     addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8",times="1"}]}
     (gdb)


File: gdb.info,  Node: Управление данными GDB/MI,  Next: Управление программой GDB/MI,  Prev: Команды GDB/MI для таблицы точек останова,  Up: GDB/MI

19.6 Управление данными GDB/MI
==============================

Этот раздел описывает команды GDB/MI для управления данными:
исследование памяти и регистров, вычисление выражений и так далее.

Команда '-data-disassemble'
---------------------------

Краткое описание
................

      -data-disassemble
         [ -s НАЧ-АДР -e КОН-АДР ]
       | [ -f ИМЯ-ФАЙЛА -l НОМ-СТРОКИ [ -n СТ ] ]
       -- РЕЖИМ

Где:

'НАЧ-АДР'
     начальный адрес (или '$pc')
'КОН-АДР'
     конечный адрес
'ИМЯ-ФАЙЛА'
     имя файла для дисассемблирования
'НОМ-СТРОКИ'
     номер строки, в районе которой проводить дисассемблирование
'СТ'
     число строк дисассемблирования, которое необходимо произвести.
     Если равно -1 и КОН-АДР не указан, то будет дисассемблирована целая
     функция.  Если КОН-АДР указан и не равен нулю, и СТ меньше, чем
     количество строк дисассемблирования между НАЧ-АДР и КОН-АДР,
     отображаются только СТ строк.  Если СТ больше, чем число строк
     между НАЧ-АДР и КОН-АДР, отображаются только строки до КОН-АДР.
'РЕЖИМ'
     либо 0 (означает только результат дисассемблирования), либо 1
     (означает смесь исходного текста и результата дисассемблирования).

Результат
.........

Вывод для каждой инструкции состоит из четырех полей:

   * Адрес
   * Имя-Функции
   * Смещение
   * Инструкция

   Заметьте, что то, что включено в поле инструкции, не обрабатывается
непосредственно GDB/MI, то есть изменить его формат невозможно.

Команда GDB
...........

Непосредственного отображения этой команды в CLI нет.

Пример
......

Дисассемблирование от текущего значения '$pc' до '$pc + 20':

     (gdb)
     -data-disassemble -s $pc -e "$pc + 20" -- 0
     ^done,
     asm_insns=[
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov  2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi  %hi(0x11800), %o2"},
     {address="0x000107c8",func-name="main",offset="12",
     inst="or  %o2, 0x140, %o1\t! 0x11940 <_lib_version+8>"},
     {address="0x000107cc",func-name="main",offset="16",
     inst="sethi  %hi(0x11800), %o2"},
     {address="0x000107d0",func-name="main",offset="20",
     inst="or  %o2, 0x168, %o4\t! 0x11968 <_lib_version+48>"}]
     (gdb)

   Дисассемблирование всей функции 'main'.  Строка 32 является частью
'main'.

     -data-disassemble -f basics.c -l 32 -- 0
     ^done,asm_insns=[
     {address="0x000107bc",func-name="main",offset="0",
     inst="save  %sp, -112, %sp"},
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov   2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi %hi(0x11800), %o2"},
     [...]
     {address="0x0001081c",func-name="main",offset="96",inst="ret "},
     {address="0x00010820",func-name="main",offset="100",inst="restore "}]
     (gdb)

   Дисассемблирование 3 инструкций от начала 'main':

     (gdb)
     -data-disassemble -f basics.c -l 32 -n 3 -- 0
     ^done,asm_insns=[
     {address="0x000107bc",func-name="main",offset="0",
     inst="save  %sp, -112, %sp"},
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov  2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi  %hi(0x11800), %o2"}]
     (gdb)

   Дисассемблирование 3 инструкций от начала 'main' в смешаном режиме:

     (gdb)
     -data-disassemble -f basics.c -l 32 -n 3 -- 1
     ^done,asm_insns=[
     src_and_asm_line={line="31",
     file="/kwikemart/marge/ezannoni/flathead-dev/devo/gdb/ \
       testsuite/gdb.mi/basics.c",line_asm_insn=[
     {address="0x000107bc",func-name="main",offset="0",
     inst="save  %sp, -112, %sp"}]},
     src_and_asm_line={line="32",
     file="/kwikemart/marge/ezannoni/flathead-dev/devo/gdb/ \
       testsuite/gdb.mi/basics.c",line_asm_insn=[
     {address="0x000107c0",func-name="main",offset="4",
     inst="mov  2, %o0"},
     {address="0x000107c4",func-name="main",offset="8",
     inst="sethi  %hi(0x11800), %o2"}]}]
     (gdb)

Команда '-data-evaluate-expression'
-----------------------------------

Краткое описание
................

      -data-evaluate-expression ВЫРАЖ

   Вычислить выражение ВЫРАЖ.  Выражение может содержать подчиненный
вызов функции.  Вызов функции будет выполнен синхронно.  Если выражение
содержит пробелы, оно должно быть заключено в двойные кавычки.

Команда GDB
...........

Соответствующими командами GDB являются 'print', 'output' и 'call'.  В
'gdbtk' есть соответствующая команда 'gdb_eval'.

Пример
......

В следующем примере числа, предшествующие командам, суть "лексемы".  Для
их описания, см.  *note Синтаксис команд GDB/MI: Синтаксис команд
GDB/MI. Обратите внимание на то, как GDB/MI возвращает те же лексемы в
своем выводе.

     211-data-evaluate-expression A
     211^done,value="1"
     (gdb)
     311-data-evaluate-expression &A
     311^done,value="0xefffeb7c"
     (gdb)
     411-data-evaluate-expression A+3
     411^done,value="4"
     (gdb)
     511-data-evaluate-expression "A + 3"
     511^done,value="4"
     (gdb)

Команда '-data-list-changed-registers'
--------------------------------------

Краткое описание
................

      -data-list-changed-registers

   Выводит список регистров, которые изменились.

Команда GDB
...........

GDB не имеет прямого аналога этой команды; соответствующей командой
'gdbtk' является 'gdb_changed_register_list'.

Пример
......

На плате PPC MBX:

     (gdb)
     -exec-continue
     ^running

     (gdb)
     *stopped,reason="breakpoint-hit",bkptno="1",frame={func="main",
     args=[],file="try.c",line="5"}
     (gdb)
     -data-list-changed-registers
     ^done,changed-registers=["0","1","2","4","5","6","7","8","9",
     "10","11","13","14","15","16","17","18","19","20","21","22","23",
     "24","25","26","27","28","30","31","64","65","66","67","69"]
     (gdb)

Команда '-data-list-register-names'
-----------------------------------

Краткое описание
................

      -data-list-register-names [ ( НОМ-РЕГ )+ ]

   Показать список имен регистров текущей цели.  Если аргументы не
заданы, показывается список имен всех регистров.  Если в качестве
аргументов заданы целые числа, команда напечатает список имен регистров,
соответствующих аргументам.  Чтобы гарантировать согласованность имен
регистров и их номеров, выводимый список может содержать имена пустых
регистров.

Команда GDB
...........

В GDB нет команды, которая соответствует '-data-list-register-names'.  В
'gdbtk' соответствующей командой является 'gdb_regnames'.

Пример
......

Для платы PPC MBX:
     (gdb)
     -data-list-register-names
     ^done,register-names=["r0","r1","r2","r3","r4","r5","r6","r7",
     "r8","r9","r10","r11","r12","r13","r14","r15","r16","r17","r18",
     "r19","r20","r21","r22","r23","r24","r25","r26","r27","r28","r29",
     "r30","r31","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9",
     "f10","f11","f12","f13","f14","f15","f16","f17","f18","f19","f20",
     "f21","f22","f23","f24","f25","f26","f27","f28","f29","f30","f31",
     "", "pc","ps","cr","lr","ctr","xer"]
     (gdb)
     -data-list-register-names 1 2 3
     ^done,register-names=["r1","r2","r3"]
     (gdb)

Команда '-data-list-register-values'
------------------------------------

Краткое описание
................

      -data-list-register-values ФМТ [ ( НОМ-РЕГ )*]

   Отобразить содержимое регистров.  ФМТ является форматом, в
соответствии с которым должно быть возвращено содержимое регистров, за
которым следует необязательный список чисел, указывающих регистры,
подлежащие отображению.  Отсутствие списка чисел означает, что должно
быть возвращено содержимое всех регистров.

   Вот допустимые форматы для ФМТ:

'x'
     Шестнадцатеричный
'o'
     Восьмеричный
't'
     Двоичный
'd'
     Десятичный
'r'
     Без преобразования
'N'
     Натуральный

Команда GDB
...........

Соответствующими командами GDB являются 'info reg', 'info all-reg' и (в
'gdbtk') 'gdb_fetch_registers'.

Пример
......

Для платы PPC MBX (имейте ввиду: переносы строк даны только для удобства
чтения, они не появляются в реальном выводе):

     (gdb)
     -data-list-register-values r 64 65
     ^done,register-values=[{number="64",value="0xfe00a300"},
     {number="65",value="0x00029002"}]
     (gdb)
     -data-list-register-values x
     ^done,register-values=[{number="0",value="0xfe0043c8"},
     {number="1",value="0x3fff88"},{number="2",value="0xfffffffe"},
     {number="3",value="0x0"},{number="4",value="0xa"},
     {number="5",value="0x3fff68"},{number="6",value="0x3fff58"},
     {number="7",value="0xfe011e98"},{number="8",value="0x2"},
     {number="9",value="0xfa202820"},{number="10",value="0xfa202808"},
     {number="11",value="0x1"},{number="12",value="0x0"},
     {number="13",value="0x4544"},{number="14",value="0xffdfffff"},
     {number="15",value="0xffffffff"},{number="16",value="0xfffffeff"},
     {number="17",value="0xefffffed"},{number="18",value="0xfffffffe"},
     {number="19",value="0xffffffff"},{number="20",value="0xffffffff"},
     {number="21",value="0xffffffff"},{number="22",value="0xfffffff7"},
     {number="23",value="0xffffffff"},{number="24",value="0xffffffff"},
     {number="25",value="0xffffffff"},{number="26",value="0xfffffffb"},
     {number="27",value="0xffffffff"},{number="28",value="0xf7bfffff"},
     {number="29",value="0x0"},{number="30",value="0xfe010000"},
     {number="31",value="0x0"},{number="32",value="0x0"},
     {number="33",value="0x0"},{number="34",value="0x0"},
     {number="35",value="0x0"},{number="36",value="0x0"},
     {number="37",value="0x0"},{number="38",value="0x0"},
     {number="39",value="0x0"},{number="40",value="0x0"},
     {number="41",value="0x0"},{number="42",value="0x0"},
     {number="43",value="0x0"},{number="44",value="0x0"},
     {number="45",value="0x0"},{number="46",value="0x0"},
     {number="47",value="0x0"},{number="48",value="0x0"},
     {number="49",value="0x0"},{number="50",value="0x0"},
     {number="51",value="0x0"},{number="52",value="0x0"},
     {number="53",value="0x0"},{number="54",value="0x0"},
     {number="55",value="0x0"},{number="56",value="0x0"},
     {number="57",value="0x0"},{number="58",value="0x0"},
     {number="59",value="0x0"},{number="60",value="0x0"},
     {number="61",value="0x0"},{number="62",value="0x0"},
     {number="63",value="0x0"},{number="64",value="0xfe00a300"},
     {number="65",value="0x29002"},{number="66",value="0x202f04b5"},
     {number="67",value="0xfe0043b0"},{number="68",value="0xfe00b3e4"},
     {number="69",value="0x20002b03"}]
     (gdb)

Команда '-data-read-memory'
---------------------------

Краткое описание
................

      -data-read-memory [ -o СМЕЩЕНИЕ ]
        АДРЕС ФОРМАТ-СЛОВА РАЗМЕР-СЛОВА
        ЧИСЛО-СТРОК ЧИСЛО-КОЛОНОК [ ASЗНАК ]

где:

'АДРЕС'
     Выражение, определяющее адрес в памяти первого слова, которое надо
     прочитать.  Сложные выражения, содержащие пробельные знаки, должны
     заключаться в кавычки с использованием соглашений Си.

'ФОРМАТ-СЛОВА'
     Формат, который должен быть использован для печати слов памяти.
     Обозначения те же, что и для команды GDB 'print' (*note Форматы
     вывода: Форматы вывода.).

'РАЗМЕР-СЛОВА'
     Размер в байтах каждого слова в памяти.

'ЧИСЛО-СТРОК'
     Число строк в выходной таблице.

'ЧИСЛО-КОЛОНОК'
     Число колонок в выходной таблице.

'ASЗНАК'
     В настоящее время означает, что каждая строка должна включать
     ASCII-дамп.  Значение ASЗНАК используется в качестве заполняющего
     знака, когда байт не является элементом набора печатных знаков
     ASCII (печатные знаки ASCII это те знаки, чьи коды находятся между
     32 и 126 включительно).

'СМЕЩЕНИЕ'
     Смещение, которое надо добавить к АДРЕСУ перед тем, как начать
     извлечение из памяти.

   Эта команда отображает содержимое памяти в виде таблицы из
ЧИСЛО-СТРОК на ЧИСЛО-КОЛОНОК слов, причем каждое слово занимает
РАЗМЕР-СЛОВА байт.  В общей сложности считывается 'ЧИСЛО-СТРОК *
ЧИСЛО-КОЛОНОК * РАЗМЕР-СЛОВА' байт (возвращается как 'total-bytes').
Если цель должна возвратить меньше запрошенного числа байт,
отсутствующие слова идентифицируются при помощи 'N/A'.  Число байт,
прочитанное с цели, возвращается в 'nr-bytes', а начальный адрес,
использованный для чтении памяти, в 'addr'.

   Адрес следующей/предыдущей строки или страницы доступен в 'next-row'
и 'prev-row', 'next-page' и 'prev-page'.

Команда GDB
...........

Соответствующей командой GDB является 'x'.  'gdbtk' имеет команду чтения
памяти 'gdb_get_mem'.

Пример
......

Прочитать шесть байт памяти, начиная с 'bytes+6', но сместиться на '-6'
байт.  Форматировать в три ряда по две колонки.  Один байт на слово.
Отображать каждое слово в шестнадцатеричном виде.

     (gdb)
     9-data-read-memory -o -6 -- bytes+6 x 1 3 2
     9^done,addr="0x00001390",nr-bytes="6",total-bytes="6",
     next-row="0x00001396",prev-row="0x0000138e",next-page="0x00001396",
     prev-page="0x0000138a",memory=[
     {addr="0x00001390",data=["0x00","0x01"]},
     {addr="0x00001392",data=["0x02","0x03"]},
     {addr="0x00001394",data=["0x04","0x05"]}]
     (gdb)

   Прочитать два байта памяти, начиная с адреса 'shorts + 64' и
отобразить в виде одного слова в десятичном виде.

     (gdb)
     5-data-read-memory shorts+64 d 2 1 1
     5^done,addr="0x00001510",nr-bytes="2",total-bytes="2",
     next-row="0x00001512",prev-row="0x0000150e",
     next-page="0x00001512",prev-page="0x0000150e",memory=[
     {addr="0x00001510",data=["128"]}]
     (gdb)

   Прочитать тридцать два байта памяти, начиная с 'bytes+16', и
форматировать на восемь рядов по четыре колонки.  Включить строку,
закодированную с использованием 'x' в качестве непечатного знака.

     (gdb)
     4-data-read-memory bytes+16 x 1 8 4 x
     4^done,addr="0x000013a0",nr-bytes="32",total-bytes="32",
     next-row="0x000013c0",prev-row="0x0000139c",
     next-page="0x000013c0",prev-page="0x00001380",memory=[
     {addr="0x000013a0",data=["0x10","0x11","0x12","0x13"],ascii="xxxx"},
     {addr="0x000013a4",data=["0x14","0x15","0x16","0x17"],ascii="xxxx"},
     {addr="0x000013a8",data=["0x18","0x19","0x1a","0x1b"],ascii="xxxx"},
     {addr="0x000013ac",data=["0x1c","0x1d","0x1e","0x1f"],ascii="xxxx"},
     {addr="0x000013b0",data=["0x20","0x21","0x22","0x23"],ascii=" !\"#"},
     {addr="0x000013b4",data=["0x24","0x25","0x26","0x27"],ascii="$%&'"},
     {addr="0x000013b8",data=["0x28","0x29","0x2a","0x2b"],ascii="()*+"},
     {addr="0x000013bc",data=["0x2c","0x2d","0x2e","0x2f"],ascii=",-./"}]
     (gdb)

Команда '-display-delete'
-------------------------

Краткое описание
................

      -display-delete НОМЕР

   Удалить элемент с указанным НОМЕРОМ из списка выражений, подлежащих
отображению.

Команда GDB
...........

Соответствующей командой GDB является 'delete display'.

Пример
......

Н.П.

Команда '-display-disable'
--------------------------

Краткое описание
................

      -display-disable НОМЕР

   Отключить элемент списка выражений с указанным НОМЕРОМ.

Команда GDB
...........

Соответствующей командой GDB является 'disable display'.

Пример
......

Н.П.

Команда '-display-enable'
-------------------------

Краткое описание
................

      -display-enable НОМЕР

   Включить элемент списка выражений с указанным НОМЕРОМ.

Команда GDB
...........

Соответствующей командой GDB является 'enable display'.

Пример
......

Н.П.

Команда '-display-insert'
-------------------------

Краткое описание
................

      -display-insert ВЫРАЖЕНИЕ

   Отображать ВЫРАЖЕНИЕ всякий раз, когда программа останавливается.

Команда GDB
...........

Соответствующей командой GDB является 'display'.

Пример
......

Н.П.

Команда '-display-list'
-----------------------

Краткое описание
................

      -display-list

   Перечислить элементы списка выражений, подлежащих автоматическому
отображению.  Текущие значения не показывать.

Команда GDB
...........

Соответствующей командой GDB является 'info display'.

Пример
......

Н.П.

Команда '-environment-cd'
-------------------------

Краткое описание
................

      -environment-cd КАТ

   Установить рабочий каталог GDB.

Команда GDB
...........

Соответствующей командой GDB является 'cd'.

Пример
......

     (gdb)
     -environment-cd /kwikemart/marge/ezannoni/flathead-dev/devo/gdb
     ^done
     (gdb)

Команда '-environment-directory'
--------------------------------

Краткое описание
................

      -environment-directory КАТ

   Добавить каталог КАТ в начало пути поиска исходных файлов.

Команда GDB
...........

Соответствующей командой GDB является 'dir'.

Пример
......

     (gdb)
     -environment-directory /kwikemart/marge/ezannoni/flathead-dev/devo/gdb
     ^done
     (gdb)

Команда '-environment-path'
---------------------------

Краткое описание
................

      -environment-path ( КАТ )+

   Добавить каталоги КАТ в начало пути поиска объектных файлов.

Команда GDB
...........

Соответствующей командой GDB является 'path'.

Пример
......

     (gdb)
     -environment-path /kwikemart/marge/ezannoni/flathead-dev/ppc-eabi/gdb
     ^done
     (gdb)

Команда '-environment-pwd'
--------------------------

Краткое описание
................

      -environment-pwd

   Показать текущий рабочий каталог.

Команда GDB
...........

Соответствующей командой GDB является 'pwd'.

Пример
......

     (gdb)
     -environment-pwd
     ~Working directory /kwikemart/marge/ezannoni/flathead-dev/devo/gdb.
     ^done
     (gdb)


File: gdb.info,  Node: Управление программой GDB/MI,  Next: Разные команды GDB/MI,  Prev: Управление данными GDB/MI,  Up: GDB/MI

19.7 Управление программой GDB/MI
=================================

Завершение программы
....................

В процессе выполнения, подчиненная программа может достигнуть конца,
если она не встретит ни одной точки останова.  В этом случае вывод будет
включать код завершения, если программа завершилась ненормально.

Примеры
.......

Программа завершилась нормально:

     (gdb)
     -exec-run
     ^running
     (gdb)
     x = 55
     *stopped,reason="exited-normally"
     (gdb)

Программа завершилась ненормально:

     (gdb)
     -exec-run
     ^running
     (gdb)
     x = 55
     *stopped,reason="exited",exit-code="01"
     (gdb)

   Кроме того, программа может завершиться так, как если бы она получила
сигнал, например 'SIGINT'.  В этом случае GDB/MI отображает следующее:

     (gdb)
     *stopped,reason="exited-signalled",signal-name="SIGINT",
     signal-meaning="Interrupt"

Команда '-exec-abort'
---------------------

Краткое описание
................

      -exec-abort

   Убить выполняющуюся подчиненную программу.

Команда GDB
...........

Соответствующей командой GDB является 'kill'.

Пример
......

Н.П.

Команда '-exec-arguments'
-------------------------

Краткое описание
................

      -exec-arguments АРГ

   Установить аргументы подчиненной программы, которые должны быть
использованы при следующем '-exec-run'.

Команда GDB
...........

Соответствующей командой GDB является 'set args'.

Пример
......

Пока нет.

Команда '-exec-continue'
------------------------

Краткое описание
................

      -exec-continue

   Асинхронная команда.  Возобновляет выполнение подчиненной программы
до тех пор, пока не будет встречена точка останова, или пока подчиненная
программа не завершится.

Команда GDB
...........

Соответствующей командой GDB является 'continue'.

Пример
......

     -exec-continue
     ^running
     (gdb)
     @Hello world
     *stopped,reason="breakpoint-hit",bkptno="2",frame={func="foo",args=[],
     file="hello.c",line="13"}
     (gdb)

Команда '-exec-finish'
----------------------

Краткое описание
................

      -exec-finish

   Асинхронная команда.  Возобновляет выполнение подчиненной программы
до тех пор, пока не завершится текущая функция.  Отображает результаты,
возвращенные функцией.

Команда GDB
...........

Соответствующей командой GDB является 'finish'.

Пример
......

Функция, возвращающая 'void'.

     -exec-finish
     ^running
     (gdb)
     @hello from foo
     *stopped,reason="function-finished",frame={func="main",args=[],
     file="hello.c",line="7"}
     (gdb)

   Функция, возвращающая что-либо отличное от 'void'.  Печатается имя
внутренней переменной GDB, хранящей результат, а также и сам результат.

     -exec-finish
     ^running
     (gdb)
     *stopped,reason="function-finished",frame={addr="0x000107b0",func="foo",
     args=[{name="a",value="1"],{name="b",value="9"}},
     file="recursive2.c",line="14"},
     gdb-result-var="$1",return-value="0"
     (gdb)

Команда '-exec-interrupt'
-------------------------

Краткое описание
................

      -exec-interrupt

   Асинхронная команда.  Прерывает фоновое исполнение цели.  Заметьте,
что лексема, ассоциированная с сообщением об останове, совпадает с
лексемой для выполнения команды, которая была прервана.  Лексема для
самого прерывания появляется только в выводе '^done'.  Если пользователь
пытается прервать невыполняющуюся программу, будет выведено сообщение об
ошибке.

Команда GDB
...........

Соответствующей командой GDB является 'interrupt'.

Пример
......

     (gdb)
     111-exec-continue
     111^running

     (gdb)
     222-exec-interrupt
     222^done
     (gdb)
     111*stopped,signal-name="SIGINT",signal-meaning="Interrupt",
     frame={addr="0x00010140",func="foo",args=[],file="try.c",line="13"}
     (gdb)

     (gdb)
     -exec-interrupt
     ^error,msg="mi_cmd_exec_interrupt: Inferior not executing."
     (gdb)

Команда '-exec-next'
--------------------

Краткое описание
................

      -exec-next

   Асинхронная команда.  Возобновляет выполнение подчиненной программы,
останавливая ее, когда достигается начало следующей строки исходного
текста.

Команда GDB
...........

Соответствующей командой GDB является 'next'.

Пример
......

     -exec-next
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",line="8",file="hello.c"
     (gdb)

Команда '-exec-next-instruction'
--------------------------------

Краткое описание
................

      -exec-next-instruction

   Асинхронная команда.  Выполняет одну машинную инструкцию.  Если
инструкция является вызовом функции, выполнение продолжается до возврата
из функции.  Если программа останавливается на инструкции в середине
строки исходного текста, печатается также адрес.

Команда GDB
...........

Соответствующей командой GDB является 'nexti'.

Пример
......

     (gdb)
     -exec-next-instruction
     ^running

     (gdb)
     *stopped,reason="end-stepping-range",
     addr="0x000100d4",line="5",file="hello.c"
     (gdb)

Команда '-exec-return'
----------------------

Краткое описание
................

      -exec-return

   Велит текущей функции немедленно вернуться.  Не выполняет подчиненную
программу.  Отображает новый текущий кадр.

Команда GDB
...........

Соответствующей командой GDB является 'return'.

Пример
......

     (gdb)
     200-break-insert callee4
     200^done,bkpt={number="1",addr="0x00010734",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"}
     (gdb)
     000-exec-run
     000^running
     (gdb)
     000*stopped,reason="breakpoint-hit",bkptno="1",
     frame={func="callee4",args=[],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"}
     (gdb)
     205-break-delete
     205^done
     (gdb)
     111-exec-return
     111^done,frame={level="0 ",func="callee3",
     args=[{name="strarg",
     value="0x11940 \"A string argument.\""}],
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="18"}
     (gdb)

Команда '-exec-run'
-------------------

Краткое описание
................

      -exec-run

   Асинхронная команда.  Начинает выполнение подчиненной программы с
начала.  Она выполняется до тех пор, пока либо не встретится точка
останова, либо программа не завершится.

Команда GDB
...........

Соответствующей командой GDB является 'run'.

Пример
......

     (gdb)
     -break-insert main
     ^done,bkpt={number="1",addr="0x0001072c",file="recursive2.c",line="4"}
     (gdb)
     -exec-run
     ^running
     (gdb)
     *stopped,reason="breakpoint-hit",bkptno="1",
     frame={func="main",args=[],file="recursive2.c",line="4"}
     (gdb)

Команда '-exec-show-arguments'
------------------------------

Краткое описание
................

      -exec-show-arguments

   Печатает аргументы программы.

Команда GDB
...........

Соответствующей командой GDB является 'show args'.

Пример
......

Н.П.

Команда '-exec-step'
--------------------

Краткое описание
................

      -exec-step

   Асинхронная команда.  Возобновляет выполнение подчиненной программы,
останавливая ее, когда будет достигнуто начало следующей строки
исходного файла, при условии, что она не является вызовом функции.  Если
же следующая строка является вызовом функции, программа останавливается
на первой инструкции этой функции.

Команда GDB
...........

Соответствующей командой GDB является 'step'.

Пример
......

Пошаговый вход в функцию:

     -exec-step
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",
     frame={func="foo",args=[{name="a",value="10"},
     {name="b",value="0"}],file="recursive2.c",line="11"}
     (gdb)

   Обычное пошаговое выполнение:

     -exec-step
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",line="14",file="recursive2.c"
     (gdb)

Команда '-exec-step-instruction'
--------------------------------

Краткое описание
................

      -exec-step-instruction

   Асинхронная команда.  Возобновляет выполнение подчиненной программы,
выполняя одну машинную инструкцию.  Вывод, когда GDB остановится, будет
различаться в зависимости от того, остановились мы в середине исходной
строки или нет.  В первом случае, адрес, по которому программа
остановлена, также будет напечатан.

Команда GDB
...........

Соответствующей командой GDB является 'stepi'.

Пример
......

     (gdb)
     -exec-step-instruction
     ^running

     (gdb)
     *stopped,reason="end-stepping-range",
     frame={func="foo",args=[],file="try.c",line="10"}
     (gdb)
     -exec-step-instruction
     ^running

     (gdb)
     *stopped,reason="end-stepping-range",
     frame={addr="0x000100f4",func="foo",args=[],file="try.c",line="10"}
     (gdb)

Команда '-exec-until'
---------------------

Краткое описание
................

      -exec-until [ МЕСТОПОЛОЖЕНИЕ ]

   Асинхронная команда.  Выполняет подчиненную программу до тех пор,
пока не будет достигнуто указанное в аргументе МЕСТОПОЛОЖЕНИЕ.  Если
аргумента нет, подчиненная программа выполняется, пока не будет
достигнута строка исходного текста, превышающая текущую.  В этом случае,
причиной остановки будет 'location-reached'.

Команда GDB
...........

Соответствующей командой GDB является 'until'.

Пример
......

     (gdb)
     -exec-until recursive2.c:6
     ^running
     (gdb)
     x = 55
     *stopped,reason="location-reached",frame={func="main",args=[],
     file="recursive2.c",line="6"}
     (gdb)

Команда '-file-exec-and-symbols'
--------------------------------

Краткое описание
................

      -file-exec-and-symbols ФАЙЛ

   Указать выполняемый файл для отладки.  Это тот файл, из которого
также читается таблица символов.  Если файл не указан, команда очищает
информацию о выполняемом файле и символах.  Если при использовании этой
команды без аргументов установлены точки останова, GDB выдаст сообщение
об ошибке.  В противном случае, никакого вывода не будет, за исключением
уведомления о завершении.

Команда GDB
...........

Соответствующей командой GDB является 'file'.

Пример
......

     (gdb)
     -file-exec-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
     ^done
     (gdb)

Команда '-file-exec-file'
-------------------------

Краткое описание
................

      -file-exec-file ФАЙЛ

   Указать выполняемый файл для отладки.  В отличие от
'-file-exec-and-symbols', таблица символов _не_ считывается из этого
файла.  При использовании без аргумента, GDB очищает информацию о
выполняемом файле.  Никакого вывода не производится, за исключением
уведомления о завершении.

Команда GDB
...........

Соответствующей командой GDB является 'exec-file'.

Пример
......

     (gdb)
     -file-exec-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
     ^done
     (gdb)

Команда '-file-list-exec-sections'
----------------------------------

Краткое описание
................

      -file-list-exec-sections

   Перечисляет разделы текущего выполняемого файла.

Команда GDB
...........

Команда GDB 'info file' показывает, помимо всего прочего, ту же
информацию, что и эта команда.  'gdbtk' имеет соответствующую команду
'gdb_load_info'.

Пример
......

Н.П.

Команда '-file-list-exec-source-files'
--------------------------------------

Краткое описание
................

      -file-list-exec-source-files

   Перечисляет исходные файлы для текущего выполняемого файла.

Команда GDB
...........

В GDB нет команды, непосредственно соответствующей этой.  'gdbtk' имеет
аналогичную команду 'gdb_listfiles'.

Пример
......

Н.П.

Команда '-file-list-shared-libraries'
-------------------------------------

Краткое описание
................

      -file-list-shared-libraries

   Перечисляет используемые программой разделяемые библиотеки.

Команда GDB
...........

Соответствующей командой GDB является 'info shared'.

Пример
......

Н.П.

Команда '-file-list-symbol-files'
---------------------------------

Краткое описание
................

      -file-list-symbol-files

   Перечисляет файлы символов.

Команда GDB
...........

Соответствующей командой GDB является 'info file' (ее часть).

Пример
......

Н.П.

Команда '-file-symbol-file'
---------------------------

Краткое описание
................

      -file-symbol-file ФАЙЛ

   Прочитать информацию символьной таблицы из указанного в аргументе
ФАЙЛА.  Будучи использованной без аргументов, очищает таблицу символьной
информации GDB. Никакого вывода не производится, кроме уведомления о
завершении.

Команда GDB
...........

Соответствующей командой GDB является 'symbol-file'.

Пример
......

     (gdb)
     -file-symbol-file /kwikemart/marge/ezannoni/TRUNK/mbx/hello.mbx
     ^done
     (gdb)


File: gdb.info,  Node: Разные команды GDB/MI,  Next: Управление стеком GDB/MI,  Prev: Управление программой GDB/MI,  Up: GDB/MI

19.8 Разные команды GDB в GDB/MI
================================

Команда '-gdb-exit'
-------------------

Краткое описание
................

      -gdb-exit

   Немедленно выйти из GDB.

Команда GDB
...........

Примерно соответствует команде 'quit'.

Пример
......

     (gdb)
     -gdb-exit

Команда '-gdb-set'
------------------

Краткое описание
................

      -gdb-set

   Установить внутреннюю переменную GDB.

Команда GDB
...........

Соответствующей командой GDB является 'set'.

Пример
......

     (gdb)
     -gdb-set $foo=3
     ^done
     (gdb)

Команда '-gdb-show'
-------------------

Краткое описание
................

      -gdb-show

   Показать текущее значение переменной GDB.

Команда GDB
...........

Соответствующей командой GDB является 'show'.

Пример
......

     (gdb)
     -gdb-show annotate
     ^done,value="0"
     (gdb)

Команда '-gdb-version'
----------------------

Краткое описание
................

      -gdb-version

   Вывести информацию о версии GDB. Используется преимущественно при
тестировании.

Команда GDB
...........

Эквивалентной команды GDB нет.  По умолчанию, GDB показывает эту
информацию, когда вы вызываете интерактивный сеанс.

Пример
......

     (gdb)
     -gdb-version
     ~GNU gdb 5.2.1
     ~Copyright 2000 Free Software Foundation, Inc.
     ~GDB is free software, covered by the GNU General Public License, and
     ~you are welcome to change it and/or distribute copies of it under
     ~ certain conditions.
     ~Type "show copying" to see the conditions.
     ~There is absolutely no warranty for GDB.  Type "show warranty" for
     ~ details.
     ~This GDB was configured as
      "--host=sparc-sun-solaris2.5.1 --target=ppc-eabi".
     ^done
     (gdb)


File: gdb.info,  Node: Управление стеком GDB/MI,  Next: Запросы GDB/MI о символах,  Prev: Разные команды GDB/MI,  Up: GDB/MI

19.9 Команды GDB/MI управления стеком
=====================================

Команда '-stack-info-frame'
---------------------------

Краткое описание
................

      -stack-info-frame

   Получить информацию о текущем кадре.

Команда GDB
...........

Соответствующей командой GDB является 'info frame' или 'frame' (без
аргументов).

Пример
......

Н.П.

Команда '-stack-info-depth'
---------------------------

Краткое описание
................

      -stack-info-depth [ МАКС-ГЛУБ ]

   Возвращает глубину стека.  Если указан целочисленный аргумент
МАКС-ГЛУБ, не считать более МАКС-ГЛУБ кадров.

Команда GDB
...........

Эквивалентной команды GDB нет.

Пример
......

Для стека с уровнями кадров от 0 до 11:

     (gdb)
     -stack-info-depth
     ^done,depth="12"
     (gdb)
     -stack-info-depth 4
     ^done,depth="4"
     (gdb)
     -stack-info-depth 12
     ^done,depth="12"
     (gdb)
     -stack-info-depth 11
     ^done,depth="11"
     (gdb)
     -stack-info-depth 13
     ^done,depth="12"
     (gdb)

Команда '-stack-list-arguments'
-------------------------------

Краткое описание
................

      -stack-list-arguments ПОКАЗ-ЗНАЧ
         [ НИЖН-КАДР ВЕРХН-КАДР ]

   Отобразить список аргументов для кадров от НИЖН-КАДР до ВЕРХН-КАДР
(включительно).  Если НИЖН-КАДР и ВЕРХН-КАДР не указаны, перечислить
аргументы для всего стека вызовов.

   Аргумент ПОКАЗ-ЗНАЧ должен иметь значение 0 или 1.  Значение 0
означает, что выводятся только имена аргументов, а 1 -- что печатаются
как имена, так и значения аргументов.

Команда GDB
...........

GDB не имеет эквивалентной команды.  В 'gdbtk' есть команда
'gdb_get_args', которая частично перекрывается с действием
'-stack-list-arguments'.

Пример
......

     (gdb)
     -stack-list-frames
     ^done,
     stack=[
     frame={level="0 ",addr="0x00010734",func="callee4",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="8"},
     frame={level="1 ",addr="0x0001076c",func="callee3",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="17"},
     frame={level="2 ",addr="0x0001078c",func="callee2",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="22"},
     frame={level="3 ",addr="0x000107b4",func="callee1",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="27"},
     frame={level="4 ",addr="0x000107e0",func="main",
     file="../../../devo/gdb/testsuite/gdb.mi/basics.c",line="32"}]
     (gdb)
     -stack-list-arguments 0
     ^done,
     stack-args=[
     frame={level="0",args=[]},
     frame={level="1",args=[name="strarg"]},
     frame={level="2",args=[name="intarg",name="strarg"]},
     frame={level="3",args=[name="intarg",name="strarg",name="fltarg"]},
     frame={level="4",args=[]}]
     (gdb)
     -stack-list-arguments 1
     ^done,
     stack-args=[
     frame={level="0",args=[]},
     frame={level="1",
      args=[{name="strarg",value="0x11940 \"Строковый аргумент.\""}]},
     frame={level="2",args=[
     {name="intarg",value="2"},
     {name="strarg",value="0x11940 \"Строковый аргумент.\""}]},
     {frame={level="3",args=[
     {name="intarg",value="2"},
     {name="strarg",value="0x11940 \"Строковый аргумент.\""},
     {name="fltarg",value="3.5"}]},
     frame={level="4",args=[]}]
     (gdb)
     -stack-list-arguments 0 2 2
     ^done,stack-args=[frame={level="2",args=[name="intarg",name="strarg"]}]
     (gdb)
     -stack-list-arguments 1 2 2
     ^done,stack-args=[frame={level="2",
     args=[{name="intarg",value="2"},
     {name="strarg",value="0x11940 \"Строковый аргумент.\""}]}]
     (gdb)

Команда '-stack-list-frames'
----------------------------

Краткое описание
................

      -stack-list-frames [ НИЖН-КАДР ВЕРХН-КАДР ]

   Перечисляет кадры, находящиеся в данный момент в стеке.  Для каждого
кадра, команда отображает следующую информацию:

'LEVEL'
     Номер кадра, 0 для самого верхнего, то есть для самой внутренней
     функции.
'ADDR'
     Значение '$pc' для этого кадра.
'FUNC'
     Имя функции.
'FILE'
     Имя исходного файла, где находится функция.
'LINE'
     Номер строки, соответствующий '$pc'.

   Будучи вызванной без аргументов, эта команда печатает цепочку вызовов
для всего стека.  Если задано два целочисленных аргумента, она
показывает кадры с уровнями между этими аргументами (включительно).
Если аргументы равны, она показывает один единственный кадр
соответствующего уровня.

Команда GDB
...........

Соответствующими командами GDB являются 'backtrace' и 'where'.

Пример
......

Цепочка вызовов стека целиком:

     (gdb)
     -stack-list-frames
     ^done,stack=
     [frame={level="0 ",addr="0x0001076c",func="foo",
       file="recursive2.c",line="11"},
     frame={level="1 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="2 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="3 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="4 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="5 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="6 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="7 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="8 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="9 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="10",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="11",addr="0x00010738",func="main",
       file="recursive2.c",line="4"}]
     (gdb)

   Показать кадры между НИЖН-КАДР и ВЕРХН-КАДР:

     (gdb)
     -stack-list-frames 3 5
     ^done,stack=
     [frame={level="3 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="4 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"},
     frame={level="5 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"}]
     (gdb)

   Показать один кадр:

     (gdb)
     -stack-list-frames 3 3
     ^done,stack=
     [frame={level="3 ",addr="0x000107a4",func="foo",
       file="recursive2.c",line="14"}]
     (gdb)

Команда '-stack-list-locals'
----------------------------

Краткое описание
................

      -stack-list-locals ПЕЧАТАТЬ-ЗНАЧЕНИЯ

   Вывести имена локальных переменных для текущего кадра.  С параметром
0 выводит только имена переменных, с параметром 1 выводит также их
значения.

Команда GDB
...........

'info locals' в GDB, 'gdb_get_locals' в 'gdbtk'.

Пример
......

     (gdb)
     -stack-list-locals 0
     ^done,locals=[name="A",name="B",name="C"]
     (gdb)
     -stack-list-locals 1
     ^done,locals=[{name="A",value="1"},{name="B",value="2"},
       {name="C",value="3"}]
     (gdb)

Команда '-stack-select-frame'
-----------------------------

Краткое описание
................

      -stack-select-frame НОМ-КАДРА

   Изменить текущий кадр.  Выбрать другой кадр НОМ-КАДРА в стеке.

Команда GDB
...........

Соответствующими командами GDB являются 'frame', 'up', 'down',
'select-frame', 'up-silent' и 'down-silent'.

Пример
......

     (gdb)
     -stack-select-frame 2
     ^done
     (gdb)


File: gdb.info,  Node: Запросы GDB/MI о символах,  Next: Управление целью GDB/MI,  Prev: Управление стеком GDB/MI,  Up: GDB/MI

19.10 Команды GDB/MI запросов о символах
========================================

Команда '-symbol-info-address'
------------------------------

Краткое описание
................

      -symbol-info-address СИМВОЛ

   Описать, где хранится СИМВОЛ.

Команда GDB
...........

Соответствующей командой GDB является 'info address'.

Пример
......

Н.П.

Команда '-symbol-info-file'
---------------------------

Краткое описание
................

      -symbol-info-file

   Показать файл для символа.

Команда GDB
...........

Эквивалентной команды GDB нет.  В 'gdbtk' есть команда 'gdb_find_file'.

Пример
......

Н.П.

Команда '-symbol-info-function'
-------------------------------

Краткое описание
................

      -symbol-info-function

   Показать, в какой функции находится символ.

Команда GDB
...........

'gdb_get_function' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-info-line'
---------------------------

Краткое описание
................

      -symbol-info-line

   Показать адреса памяти кода для текущей строки.

Команда GDB
...........

Соответствующей командой GDB является 'info line'.  В 'gdbtk' есть
команды 'gdb_get_line' и 'gdb_get_file'.

Пример
......

Н.П.

Команда '-symbol-info-symbol'
-----------------------------

Краткое описание
................

      -symbol-info-symbol АДРЕС

   Описать, какой символ находится в местоположении АДРЕС.

Команда GDB
...........

Соответствующей командой GDB является 'info symbol'.

Пример
......

Н.П.

Команда '-symbol-list-functions'
--------------------------------

Краткое описание
................

      -symbol-list-functions

   Перечислить функции, находящиеся в выполняемом файле.

Команда GDB
...........

'info functions' в GDB, 'gdb_listfunc' и 'gdb_search' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-list-types'
----------------------------

Краткое описание
................

      -symbol-list-types

   Перечислить все имена типов.

Команда GDB
...........

Соответствующими командами являются 'info types' в GDB и 'gdb_search' в
'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-list-variables'
--------------------------------

Краткое описание
................

      -symbol-list-variables

   Перечислить имена всех глобальных и статических переменных.

Команда GDB
...........

'info variables' в GDB, 'gdb_search' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-locate'
------------------------

Краткое описание
................

      -symbol-locate

Команда GDB
...........

'gdb_loc' в 'gdbtk'.

Пример
......

Н.П.

Команда '-symbol-type'
----------------------

Краткое описание
................

      -symbol-type ПЕРЕМЕННАЯ

   Показать тип ПЕРЕМЕННОЙ.

Команда GDB
...........

Соответствующей командой GDB является 'ptype', в 'gdbtk' есть команда
'gdb_obj_variable'.

Пример
......

Н.П.


File: gdb.info,  Node: Управление целью GDB/MI,  Next: Команды GDB/MI для нитей,  Prev: Запросы GDB/MI о символах,  Up: GDB/MI

19.11 Команды GDB/MI управления целью
=====================================

Команда '-target-attach'
------------------------

Краткое описание
................

      -target-attach ИД-ПРОЦ | ФАЙЛ

   Присоединиться к процессу ИД-ПРОЦ или файлу ФАЙЛ вне GDB.

Команда GDB
...........

Соответствующей командой GDB является 'attach'.

Пример
......

Н.П.

Команда '-target-compare-sections'
----------------------------------

Краткое описание
................

      -target-compare-sections [ РАЗДЕЛ ]

   Сравнить данные раздела РАЗДЕЛ на цели с выполняемым файлом.  Без
аргумента сравниваются все разделы.

Команда GDB
...........

Эквивалентной командой в GDB является 'compare-sections'.

Пример
......

Н.П.

Команда '-target-detach'
------------------------

Краткое описание
................

      -target-detach

   Отсоединиться от удаленной цели.  Никакого вывода не производится.

Команда GDB
...........

Соответствующей командой GDB является 'detach'.

Пример
......

     (gdb)
     -target-detach
     ^done
     (gdb)

Команда '-target-download'
--------------------------

Краткое описание
................

      -target-download

   Загружает выполняемый файл на удаленную цель.  Команда два раза в
секунду обновляет сообщение, которое включает поля:

'section'
     Имя раздела.
'section-sent'
     Размер переданного на данный момент участка для этого раздела.
'section-size'
     Размер раздела.
'total-sent'
     Общий размер переданной на данный момент информации (текущий и
     предыдущие разделы).
'total-size'
     Размер всего выполняемого файла, подлежащего загрузке.

Каждое сообщение посылается в виде сообщения статуса (*note Выходной
синтаксис GDB/MI: Выходной синтаксис GDB/MI.).

   Кроме того, команда печатает имена и размеры разделов, по мере их
загрузки.  Эти сообщения включают следующие поля:

'section'
     Имя раздела.
'section-size'
     Размер раздела.
'total-size'
     Размер всего выполняемого файла, подлежащего загрузке.

В конце печатается суммарная информация.

Команда GDB
...........

Соответствующей командой GDB является 'load'.

Пример
......

Замечание: каждое сообщение статуса появляется на одной строке.  Здесь
сообщения были разбиты на несколько строк, чтобы они могли влезть на
страницу.

     (gdb)
     -target-download
     +download,{section=".text",section-size="6668",total-size="9880"}
     +download,{section=".text",section-sent="512",section-size="6668",
     total-sent="512",total-size="9880"}
     +download,{section=".text",section-sent="1024",section-size="6668",
     total-sent="1024",total-size="9880"}
     +download,{section=".text",section-sent="1536",section-size="6668",
     total-sent="1536",total-size="9880"}
     +download,{section=".text",section-sent="2048",section-size="6668",
     total-sent="2048",total-size="9880"}
     +download,{section=".text",section-sent="2560",section-size="6668",
     total-sent="2560",total-size="9880"}
     +download,{section=".text",section-sent="3072",section-size="6668",
     total-sent="3072",total-size="9880"}
     +download,{section=".text",section-sent="3584",section-size="6668",
     total-sent="3584",total-size="9880"}
     +download,{section=".text",section-sent="4096",section-size="6668",
     total-sent="4096",total-size="9880"}
     +download,{section=".text",section-sent="4608",section-size="6668",
     total-sent="4608",total-size="9880"}
     +download,{section=".text",section-sent="5120",section-size="6668",
     total-sent="5120",total-size="9880"}
     +download,{section=".text",section-sent="5632",section-size="6668",
     total-sent="5632",total-size="9880"}
     +download,{section=".text",section-sent="6144",section-size="6668",
     total-sent="6144",total-size="9880"}
     +download,{section=".text",section-sent="6656",section-size="6668",
     total-sent="6656",total-size="9880"}
     +download,{section=".init",section-size="28",total-size="9880"}
     +download,{section=".fini",section-size="28",total-size="9880"}
     +download,{section=".data",section-size="3156",total-size="9880"}
     +download,{section=".data",section-sent="512",section-size="3156",
     total-sent="7236",total-size="9880"}
     +download,{section=".data",section-sent="1024",section-size="3156",
     total-sent="7748",total-size="9880"}
     +download,{section=".data",section-sent="1536",section-size="3156",
     total-sent="8260",total-size="9880"}
     +download,{section=".data",section-sent="2048",section-size="3156",
     total-sent="8772",total-size="9880"}
     +download,{section=".data",section-sent="2560",section-size="3156",
     total-sent="9284",total-size="9880"}
     +download,{section=".data",section-sent="3072",section-size="3156",
     total-sent="9796",total-size="9880"}
     ^done,address="0x10004",load-size="9880",transfer-rate="6586",
     write-rate="429"
     (gdb)

Команда '-target-exec-status'
-----------------------------

Краткое описание
................

      -target-exec-status

   Предоставить информацию о состоянии цели (например, выполняется она
или нет).

Команда GDB
...........

Эквивалентной команды GDB нет.

Пример
......

Н.П.

Команда '-target-list-available-targets'
----------------------------------------

Краткое описание
................

      -target-list-available-targets

   Перечислить цели, к которым можно установить соединение.

Команда GDB
...........

Соответствующей командой GDB является 'help target'.

Пример
......

Н.П.

Команда '-target-list-current-targets'
--------------------------------------

Краткое описание
................

      -target-list-current-targets

   Описать текущую цель.

Команда GDB
...........

Соответствующая информация (вместе с другой) печатается командой 'info
file'.

Пример
......

Н.П.

Команда '-target-list-parameters'
---------------------------------

Краткое описание
................

      -target-list-parameters

Команда GDB
...........

Эквивалента нет.

Пример
......

Н.П.

Команда '-target-select'
------------------------

Краткое описание
................

      -target-select ТИП ПАРАМЕТРЫ ...

   Соединить GDB с удаленной целью.  Эта команда допускает два
аргумента:

'ТИП'
     Тип цели, например, 'async', 'remote', и т.д.
'ПАРАМЕТРЫ'
     Имена устройств, названия машин и тому подобное.  *Note Команды для
     управления целями: Команды для целей, для более полной информации.

   Результатом является уведомление о соединении, за которым следует
адрес, по которому находится целевая программа, в следующей форме:

     ^connected,addr="АДРЕС",func="ИМЯ ФУНКЦИИ",
       args=[СПИСОК АРГУМЕНТОВ]

Команда GDB
...........

Соответствующей командой GDB является 'target'.

Пример
......

     (gdb)
     -target-select async /dev/ttya
     ^connected,addr="0xfe00a300",func="??",args=[]
     (gdb)


File: gdb.info,  Node: Команды GDB/MI для нитей,  Next: Команды GDB/MI для точек трассировки,  Prev: Управление целью GDB/MI,  Up: GDB/MI

19.12 Команды GDB/MI для нитей
==============================

Команда '-thread-info'
----------------------

Краткое описание
................

      -thread-info

Команда GDB
...........

Эквивалента нет.

Пример
......

Н.П.

Команда '-thread-list-all-threads'
----------------------------------

Краткое описание
................

      -thread-list-all-threads

Команда GDB
...........

Эквивалентной командой GDB является 'info threads'.

Пример
......

Н.П.

Команда '-thread-list-ids'
--------------------------

Краткое описание
................

      -thread-list-ids

   Выводит список известных GDB в данный момент идентификаторов нитей.
В конце списка также выводится общее число таких нитей.

Команда GDB
...........

Часть 'info threads' предоставляет ту же информацию.

Пример
......

Кроме основного процесса нет ни одной нити:

     (gdb)
     -thread-list-ids
     ^done,thread-ids={},number-of-threads="0"
     (gdb)

   Несколько нитей:

     (gdb)
     -thread-list-ids
     ^done,thread-ids={thread-id="3",thread-id="2",thread-id="1"},
     number-of-threads="3"
     (gdb)

Команда '-thread-select'
------------------------

Краткое описание
................

      -thread-select НОМЕР-НИТИ

   Сделать нить НОМЕР-НИТИ текущей.  Команда выводит номер новой текущей
нити и самый верхний кадр для нее.

Команда GDB
...........

Соответствующей командой GDB является 'thread'.

Пример
......

     (gdb)
     -exec-next
     ^running
     (gdb)
     *stopped,reason="end-stepping-range",thread-id="2",line="187",
     file="../../../devo/gdb/testsuite/gdb.threads/linux-dp.c"
     (gdb)
     -thread-list-ids
     ^done,
     thread-ids={thread-id="3",thread-id="2",thread-id="1"},
     number-of-threads="3"
     (gdb)
     -thread-select 3
     ^done,new-thread-id="3",
     frame={level="0 ",func="vprintf",
     args=[{name="format",value="0x8048e9c \"%*s%c %d %c\\n\""},
     {name="arg",value="0x2"}],file="vprintf.c",line="31"}
     (gdb)


File: gdb.info,  Node: Команды GDB/MI для точек трассировки,  Next: Изменяемые объекты GDB/MI,  Prev: Команды GDB/MI для нитей,  Up: GDB/MI

19.13 Команды GDB/MI для точек трассировки
==========================================

Команды для точек трассировки еще не реализованы.


File: gdb.info,  Node: Изменяемые объекты GDB/MI,  Prev: Команды GDB/MI для точек трассировки,  Up: GDB/MI

19.14 Изменяемые объекты GDB/MI
===============================

Обоснование для изменяемых объектов в GDB/MI
--------------------------------------------

Для реализации изменяемого отладочного окна (локальные переменные,
наблюдаемые выражения, и т.д.), мы предлагаем модификацию существующего
кода, используемого в 'Insight'.

   Вот две основные причины для этого:

  1. Он был проверен на практике (это уже его второе поколение).

  2. Это сократит время разработки (не стоит говорить, как это сейчас
     важно).

   Первоначальный интерфейс был разработан для использования из кода на
Tcl, так что он был немного изменен, чтобы его можно было использовать
через GDB/MI.  Этот раздел описывает операции GDB/MI, которые будут
доступны, и дает некоторые советы по их использованию.

   _Замечание_: В дополнение к описанному здесь набору операций, мы
ожидаем, что GUI-реализация изменяемого окна будет требовать, как
минимум, следующие операции:

   * '-gdb-show' 'output-radix'
   * '-stack-list-arguments'
   * '-stack-list-locals'
   * '-stack-select-frame'

Введение в изменяемые объекты в GDB/MI
--------------------------------------

Основной идеей изменяемых объектов является создание именованного
объекта для представления переменной, выражения, местоположения в памяти
или даже регистра ЦП. Для каждого созданного объекта существует набор
операций для изучения или изменения его свойств.

   Более того, сложные типы данных, такие как структуры Си, представлены
в древовидном формате.  Например, переменная типа 'struct' является
корнем, а потомки будут представлять элементы этой структуры.  Если
потомок сам является сложным типом, он также будет иметь своих потомков.
Соответствующие различия языков учитываются для Си, Си++ и Java.

   При возврате реальных значений объектов, эта возможность позволяет
отдельно выбирать формат отображения, используемый при создании
результата.  Формат может быть таким: двоичный, десятичный,
шестнадцатеричный, восьмеричный и обычный.  Обычный -- это формат по
умолчанию, выбираемый автоматически в зависимости от типа переменной
(например, десятичный для 'int', шестнадцатеричный для указателей, и
т.д.).

   Далее следует полный набор операций GDB/MI, определенный для доступа
к этим возможностям:

*Операция*                    *Описание*
                              
'-var-create'                 создать изменяемый объект
'-var-delete'                 удалить изменяемый объект и его потомков
'-var-set-format'             установить формат отображения для этой
                              переменной
'-var-show-format'            показать формат отображения для этой
                              переменной
'-var-info-num-children'      сообщает, сколько потомков имеет данный
                              объект
'-var-list-children'          возвращает список потомков объекта
'-var-info-type'              показать тип этого изменяемого объекта
'-var-info-expression'        напечатать, что представляет этот
                              изменяемый объект
'-var-show-attributes'        является ли эта переменная редактируемой?
                              она здесь существует?
'-var-evaluate-expression'    получить значение этой переменной
'-var-assign'                 установить значение этой переменной
'-var-update'                 скорректировать переменную и ее потомков

   В следующем подразделе мы подробно описываем каждую операцию и
предлагаем возможный способ ее использования.

Описание и использование операций для изменяемых объектов
---------------------------------------------------------

Команда '-var-create'
---------------------

Краткое описание
................

      -var-create {ИМЯ | "-"}
         {АДРЕС-КАДРА | "*"} ВЫРАЖЕНИЕ

   Данная операция создает изменяемый объект.  Это позволяет наблюдать
за переменной, результатом выражения, ячейкой памяти или регистром ЦП.

   Параметр ИМЯ является строкой, по которой можно ссылаться на объект.
Она должна быть уникальной.  Если указан '-', система изменяемых
объектов автоматически сгенерирует строку "varNNNNNN". Она будет
уникальной, при условии, что ИМЯ не будет указано в этом формате.
Команда завершается ошибкой, если найдено повторяющееся имя.

   В АДРЕСЕ-КАДРА может быть задан кадр, в котором должно быть вычислено
выражение.  '*' указывает, что должен использоваться текущий кадр.

   ВЫРАЖЕНИЕ -- это произвольное выражение, правильное в текущем наборе
языков (не должно начинаться со '*'), или одно из следующего:

   * '*АДРЕС', где АДРЕС есть адрес ячейки памяти

   * '*АДРЕС-АДРЕС' -- диапазон адресов памяти (TBD)

   * '$ИМЯ-РЕГ' -- имя регистра ЦП

Результат
.........

Эта операция возвращает имя, число потомков и тип созданного объекта.
Тип возвращается как строка, как будто она создана GDB CLI:

      name="ИМЯ",numchild="N",type="ТИП"

Команда '-var-delete'
---------------------

Краткое описание
................

      -var-delete ИМЯ

   Удаляет созданный ранее изменяемый объект и всех его потомков.

   Возвращает ошибку, если объект с именем ИМЯ не найден.

Команда '-var-set-format'
-------------------------

Краткое описание
................

      -var-set-format ИМЯ СПЕЦИФ-ФОРМАТА

   Устанавливает формат вывода в СПЕЦИФ-ФОРМАТА для значения объекта
ИМЯ.

   Синтаксис СПЕЦИФ-ФОРМАТА следующий:

      СПЕЦИФ-ФОРМАТА ==>
      {binary | decimal | hexadecimal | octal | natural}

Команда '-var-show-format'
--------------------------

Краткое описание
................

      -var-show-format ИМЯ

   Возвращает формат, используемый для отображения значений объекта ИМЯ.

      ФОРМАТ ==>
      СПЕЦИФ-ФОРМАТА

Команда '-var-info-num-children'
--------------------------------

Краткое описание
................

      -var-info-num-children ИМЯ

   Возвращает число потомков изменяемого объекта с именем ИМЯ:

      numchild=N

Команда '-var-list-children'
----------------------------

Краткое описание
................

      -var-list-children ИМЯ

   Возвращает список потомков указанного изменяемого объекта:

      numchild=N,children={{name=ИМЯ,
      numchild=N,type=ТИП},(повторяется N раз)}

Команда '-var-info-type'
------------------------

Краткое описание
................

      -var-info-type ИМЯ

   Возвращает тип указанного изменяемого объекта ИМЯ.  Тип возвращается
как строка в том же формате, в котором она выдается GDB CLI:

      type=ИМЯ-ТИПА

Команда '-var-info-expression'
------------------------------

Краткое описание
................

      -var-info-expression ИМЯ

   Возвращает то, что представляет изменяемый объект с именем ИМЯ:

      lang=СПЕЦИФ-ЯЗЫКА,exp=ВЫРАЖЕНИЕ

где СПЕЦИФ-ЯЗЫКА есть '{"C" | "C++" | "Java"}'.

Команда '-var-show-attributes'
------------------------------

Краткое описание
................

      -var-show-attributes ИМЯ

   Перечисляет атрибуты заданного изменяемого объекта ИМЯ:

      status=АТР [ ( ,АТР )* ]

где АТР есть '{ { editable | noneditable } | TBD }'.

Команда '-var-evaluate-expression'
----------------------------------

Краткое описание
................

      -var-evaluate-expression ИМЯ

   Вычисляет выражение, которое представлено указанным изменяемым
объектом и возвращает его значение в виде строки в текущем формате,
определенном для объекта:

      value=ЗНАЧЕНИЕ

Команда '-var-assign'
---------------------

Краткое описание
................

      -var-assign ИМЯ ВЫРАЖЕНИЕ

   Присваивает значение ВЫРАЖЕНИЯ изменяемому объекту, заданному ИМЕНЕМ.
Объект должен быть в состоянии 'editable'.

Команда '-var-update'
---------------------

Краткое описание
................

      -var-update {ИМЯ | "*"}

   Обновить значение изменяемого объекта с именем ИМЯ путем вычисления
его выражения, после получения всех новых значений из памяти или
регистров.  '*' приводит к обновлению всех существующих изменяемых
объектов.


File: gdb.info,  Node: Ошибки в GDB,  Next: Редактирование командной строки,  Prev: GDB/MI,  Up: Top

20 Отчеты об ошибках в GDB
**************************

Ваши отчеты об ошибках играют существенную роль в обеспечении надежности
GDB.

   Сообщение об ошибке может помочь вам найти решение вашей проблемы, а
может и не помочь.  Но в любом случае, основная функция отчета об ошибке
-- помочь всему обществу сделать следующую версию GDB лучше.  Отчеты об
ошибках -- это ваш вклад в поддержку GDB.

   Чтобы отчет об ошибке сделал свое дело, вы должны включить в него
информацию, которая даст нам возможность ее устранить.

* Menu:

* Критерий ошибки::             Вы нашли ошибку?
* Отчеты об ошибках::           Как составлять отчеты об ошибках


File: gdb.info,  Node: Критерий ошибки,  Next: Отчеты об ошибках,  Up: Ошибки в GDB

20.1 Вы нашли ошибку?
=====================

Если вы не уверены, нашли ли вы ошибку, вот несколько руководящих
принципов:

   * Если отладчик получает фатальный сигнал, то это ошибка в GDB,
     независимо от ввода.  В надежных отладчиках сбоев не бывает.

   * Если GDB выводит сообщение об ошибке для допустимого ввода -- это
     ошибка.  (Заметьте, что если вы выполняете кросс-отладку, проблема
     может возникать где-то в соединении к цели.)

   * Если GDB не выводит сообщение об ошибке для недопустимого ввода,
     это ошибка.  Однако вы должны обратить внимание, что если по вашему
     мнению что-то является "недопустимым вводом", по нашему мнению это
     может быть "расширением" или "поддержкой традиционной практики".

   * Если вы опытный пользователь средств отладки, ваши предложения по
     улучшению GDB приветствуются в любом случае.


File: gdb.info,  Node: Отчеты об ошибках,  Prev: Критерий ошибки,  Up: Ошибки в GDB

20.2 Как составлять отчеты об ошибках
=====================================

Некоторые компании и частные лица предлагают поддержку для программных
продуктов GNU.  Если вы получили GDB из организации поддержки, мы
рекомендуем вам сперва связаться с ней.

   Вы можете найти контактную информацию для многих организаций
поддержки и частных лиц в файле 'etc/SERVICE' в дистрибутиве GNU Emacs.

   В любом случае, мы также рекомендуем вам послать отчет об ошибке в
GDB по этому адресу:

     <bug-gdb@gnu.org>

   *Не посылайте отчеты об ошибках в 'info-gdb', или в 'help-gdb', или в
какую-либо группу новостей.*  Большинство пользователей GDB не хотят
получать отчеты об ошибках.  Те, кто этого действительно хочет, должны
получать 'bug-gdb'.

   Список рассылки 'bug-gdb' имеет группу новостей 'gnu.gdb.bug',
которая работает как повторитель.  Список рассылки и группа новостей
содержат в точности одинаковые сообщения.  Часто люди посылают сообщения
об ошибках в группу новостей вместо отправки по электронной почте.  Это
работает, но есть одна проблема, которая может стать решающей: сообщения
в группу новостей часто не несут информации об обратном адресе
отправителя.  Таким образом, если нам потребуется запросить
дополнительную информацию, у нас может не быть возможности связаться с
вами.  По этой причине лучше посылать отчеты об ошибках в список
рассылки.

   В крайнем случае посылайте отчеты об ошибках на бумаге по адресу:

     GNU Debugger Bugs
     Free Software Foundation Inc.
     59 Temple Place - Suite 330
     Boston, MA 02111-1307
     USA

   Основной принцип действенного составления отчетов об ошибках:
*сообщайте все факты*.  Если вы не уверены, оставить факт или исключить,
оставьте его!

   Часто люди опускают факты, потому что думают, что знают причины
проблемы, и полагают, что некоторые детали не имеют значения.  Например,
вы можете решить, что имя переменной, которую вы используете в примере,
не играет роли.  Возможно это так, но нельзя быть уверенным в этом.
Может быть, ошибкой является неверное обращение к памяти, которое
выбрало данные из ячеек, где хранилось это имя; возможно, если бы имя
было другим, содержимое этих ячеек ввело бы отладчик в заблуждение, и
ошибка не была бы замечена.  Относитесь к этому осторожно и приводите
конкретные, полные примеры.  Это самое простое, что вы можете сделать, и
наиболее полезное.

   Помните, что цель отчета об ошибке состоит в том, чтобы дать нам
возможность установить дефект.  Может случиться, что об этой ошибке нам
уже сообщали, но не вы, но мы не можем этого знать, если отчет об ошибке
не будет полным и самодостаточным.

   Иногда люди дают несколько поверхностных фактов и спрашивают, "не
говорит ли это об ошибке?".  Такие сообщения о дефектах бесполезны, и мы
убеждаем всех _отказываться отвечать на них_, за исключением того, чтобы
побудить автора отчета послать его правильно.

   Чтобы дать нам возможность устранить ошибку, вы должны включить в
сообщение следующее:

   * Версию GDB. GDB сообщает ее при вызове без параметров; вы можете
     также вывести ее в любой момент, используя 'show version'.

     Без этого мы не будем знать, имеет ли смысл поиск ошибки в текущей
     версии отладчика.

   * Тип машины, которой вы пользуетесь, название и номер версии
     операционной системы.

   * Какой компилятор (и его версия) использовался при компиляции GDB.
     Например, "gcc-2.8.1".

   * Какой компилятор (и его версия) использовался для компиляции
     отлаживаемой программы -- например "gcc-2.8.1" или "HP92453-01
     A.10.32.03 HP C Compiler".  Для gcc, вы можете использовать 'gcc
     --version', чтобы получить эту информацию; для других компиляторов,
     смотрите их документацию.

   * Параметры команды, которые вы дали компилятору для компиляции
     вашего примера, с которым вы наблюдали ошибку.  Например,
     использовали ли вы '-O'?  Для гарантии, что вы не пропустите
     что-нибудь важное, перечисляйте все.  Копии 'Makefile' (или
     результата вызова 'make') достаточно.

     Если мы должны будем угадывать аргументы, мы, возможно, сделаем это
     неправильно и можем не столкнуться с ошибкой.

   * Полный сценарий ввода и все необходимые исходные файлы, которые
     воспроизведут ошибку.

   * Описание наблюдаемого вами поведения, которое вы считаете
     ошибочным.  Например, "Это приводит к фатальному сигналу".

     Конечно, если ошибка состоит в получении GDB фатального сигнала, то
     мы, конечно, заметим это.  Но если ошибкой является некорректный
     вывод, мы можем не заметить этого, если это не бросается в глаза.
     Вы также можете не дать нам возможности ошибиться.

     Даже если ваша проблема заключается в фатальном сигнале, вы все же
     должны сообщить об этом явно.  Предположим, происходит что-то
     странное, например, ваша копия GDB рассинхронизировалась, или вы
     столкнулись с ошибкой в библиотеке Си вашей системы.  (Такое
     бывало!)  Ваша копия может завершиться аварийно, а наша нет.  Если
     вы предупредите нас об ожидаемой аварии, а в нашей системе этого не
     произойдет, мы будем знать, что ошибка произошла не из-за нас.
     Если вы нас не предупредите, мы не сможем сделать никаких выводов
     из наших наблюдений.

   * Если вы хотите предложить внести изменения в исходные тексты GDB,
     присылайте нам контекстные изменения.  Даже если вы желаете
     обсудить что-нибудь из исходных текстов, ссылайтесь по контексту, а
     не по номеру строки.

     Номера строк в наших исходных текстах разработки не будут
     соответствовать вашим.  Ваши номера строк не дадут нам никакой
     полезной информации.

   Вот некоторые вещи, не являющиеся обязательными:

   * Описание контекста ошибки.

     Часто люди, сталкивающиеся с ошибкой, тратят много времени на
     исследования, какие изменения входного файла приведут к ее
     исчезновению, а какие на нее не влияют.

     Это часто занимает много времени и приносит мало пользы, потому что
     мы найдем ошибку посредством выполнения одного примера под
     управлением отладчика с точками останова, а не чистыми выводами из
     серии примеров.  Мы рекомендуем вам сохранить это время для
     чего-нибудь другого.

     Конечно, если вы сможете найти более простой пример для отчета
     _вместо_ первоначального, это будет удобнее для нас.  Выделение
     ошибок в выводе будет проще, выполнение под управлением отладчика
     будет занимать меньше времени, и так далее.

     Однако, это упрощение не является жизненно важным; если вы не
     хотите делать этого, сообщайте об ошибке в любом случае и посылайте
     нам весь тестовый материал, который вы использовали.

   * Заплата для ошибки.

     Заплата для исправления ошибки действительно поможет нам, если это
     хорошая заплата.  Но не опускайте необходимую информацию, такую как
     тестовый пример, предполагая, что заплата это все, в чем мы
     нуждаемся.  Мы можем обнаружить проблемы с вашей заплатой и решить
     устранить ошибку другим путем, или мы можем вообще не понять смысл
     вашей заплаты.

     Иногда для такой сложной программы, как GDB, очень трудно создать
     пример, который заставит программу следовать по определенному пути
     в процессе выполнения.  Если вы не пришлете нам пример, мы не
     сможем сконструировать его сами, и таким образом не сможем
     проверить, что ошибка устранена.

     И если мы не сможем понять, какую ошибку вы пытаетесь исправить,
     или почему ваша заплата являются улучшением, мы не используем ее.
     Тестовый пример поможет нам во всем разобраться.

   * Предположения, в чем состоит ошибка, или от чего она зависит.

     Такие предположения обычно неверны.  Даже мы не можем сделать
     правильных предположений о такого рода вещах до запуска отладчика и
     выявления фактов.


File: gdb.info,  Node: Редактирование командной строки,  Next: Интерактивное использование истории,  Prev: Ошибки в GDB,  Up: Top

21 Редактирование командной строки
**********************************

Эта глава описывает основные возможности интерфейса редактирования
командной строки GNU.

* Menu:

* Введение и обозначения::         Обозначения, используемые в этом тексте.
* Взаимодействие с Readline::      Минимальный набор команд для редактирования
                                   командной строки.
* Файл инициализации Readline::    Настройка Readline с точки
                                   зрения пользователя
* Привязываемые команды Readline:: Описание большинства команд Readline,
                                   доступных для привязки.
* Режим vi Readline::              Короткое описание, как сделать поведение
                                   Readline похожим на редактор vi.


File: gdb.info,  Node: Введение и обозначения,  Next: Взаимодействие с Readline,  Up: Редактирование командной строки

21.1 Введение в редактирование строк
====================================

Следующие абзацы описывают нотацию, используемую для обозначения нажатия
клавиш.

   Текст 'C-k' читается как 'Control-K' и описывает знак, получаемый
нажатием клавиши <k> при нажатой клавише Control.

   Текст 'M-k' читается как 'Meta-K' и описывает знак, вводимый нажатием
клавиши <k> при нажатой клавише Meta (если у вас она имеется).  На
многих клавиатурах клавиша Meta надписана как <ALT>.  На клавиатурах с
двумя клавишами <ALT> (обычно по разные стороны от пробела), <ALT> на
левой стороне обычно устанавливается для работы клавишей Meta.  Правый
<ALT> также может быть сконфигурирован для работы Meta, или он может
быть сконфигурирован как другой модификатор, например как клавиша
Compose для ввода букв с акцентами.

   Если у вас нет клавиши Meta или <ALT> или другой клавиши, работающей
как Meta, идентичное нажатие клавиш можно получить нажав сначала <ESC>,
а затем <k>.  Эти процессы называются "метафикацией" клавиши <k>.

   Текст 'M-C-k' читается как 'Meta-Control-k' и описывает знак,
получаемый посредством "метафикации" 'C-k'.

   Кроме того, некоторые клавиши имеют собственные имена.  Именно,
<DEL>, <ESC>, <LFD>, <SPC>, <RET> и <TAB> в этом тексте или в файле
инициализации обозначают сами себя (*note Файл инициализации
Readline::).  Если на вашей клавиатуре нет клавиши <LFD>, нажатие 'C-j'
приведет к вводу желаемого знака.  Клавиша <RET> на некоторых
клавиатурах может быть отмечена как <Return> или <Enter>.


File: gdb.info,  Node: Взаимодействие с Readline,  Next: Файл инициализации Readline,  Prev: Введение и обозначения,  Up: Редактирование командной строки

21.2 Взаимодействие с Readline
==============================

Часто во время интерактивного сеанса вы вводите длинную строку текста и
только потом замечаете, что первое слово набрано неправильно.
Библиотека Readline дает вам набор команд для управления текстом во
время ввода, позволяя вам лишь исправить опечатку, а не набирать заново
большую часть строки.  С помощью этих команд редактирования, вы
перемещаете курсор в место, требующее исправления, и удаляете или
вставляете текст для коррекции.  Затем, когда строка полностью
исправлена, вы просто нажимаете <RET>.  Чтобы нажать <RET>, вам не
обязательно находиться в конце строки; вся строка вводится независимо от
расположения в ней курсора.

* Menu:

* Сведения первой необходимости:: Минимум, который вам необходимо
                                  знать о Readline.
* Команды перемещения Readline::  Перемещение по строке ввода.
* Команды уничтожения Readline::  Как уничтожить текст, и как его восстановить.
* Параметры команд Readline::     Задание числовых аргументов командам.
* Поиск в истории::               Поиск в предыдущих строках.


File: gdb.info,  Node: Сведения первой необходимости,  Next: Команды перемещения Readline,  Up: Взаимодействие с Readline

21.2.1 Сведения первой необходимости
------------------------------------

Для того, чтобы ввести знак в строку, просто нажмите его.  Введенный
знак появляется там, где был курсор, и затем курсор перемещается на одну
позицию вправо.  Если вы неверно набрали знак, вы можете использовать
ваш знак уничтожения, чтобы вернуться и удалить неверный знак.

   Иногда вы можете набрать знак ошибочно и не заметить ошибки, пока не
напечатаете несколько других знаков.  В этом случае, вы можете набрать
'C-b', чтобы переместить курсор влево, и затем исправить вашу ошибку.
После этого, вы можете переместить курсор вправо нажатием 'C-f'.

   Когда вы добавляете текст в середину строки, знаки справа от курсора
'сдвигаются вперед', чтобы освободить место для вставляемого текста.
Аналогично, когда вы удаляете текст за курсором, знаки справа от него
'сдвигаются назад', занимая пустое пространство, созданное в результате
удаления текста.  Ниже следует список команд первой необходимости для
редактирования вводимого текста.

'C-b'
     Переместиться назад на одну позицию.
'C-f'
     Переместиться вперед на одну позицию.
<DEL> или <Backspace>
     Удалить знак слева от курсора.
'C-d'
     Удалить знак под курсором.
Ввод знаков
     Вставить знак в строку в позицию курсора.
'C-_' или 'C-x C-u'
     Отменить последнюю команду редактирования.  Вы можете отменить все,
     вернувшись назад к пустой строке.

(В зависимости от вашей конфигурации, клавиша <Backspace> может быть
настроена удалять знак слева от курсора, а <DEL> удалять знак под
курсором, как 'C-d', вместо знака, расположенного от курсора слева.)


File: gdb.info,  Node: Команды перемещения Readline,  Next: Команды уничтожения Readline,  Prev: Сведения первой необходимости,  Up: Взаимодействие с Readline

21.2.2 Команды перемещения Readline
-----------------------------------

Приведенная выше таблица описывает только самые базовые
последовательности клавиш, которые могут вам понадобиться для
редактирования строки ввода.  Для удобства, в дополнение к 'C-b', 'C-f',
'C-d' и <DEL> были добавлены многие другие команды.  Вот некоторые из
них, предназначенные для более быстрого перемещения по строке.

'C-a'
     Переместиться в начало строки.
'C-e'
     Переместиться в конец строки.
'M-f'
     Переместиться вперед на слово.  Слово состоит из букв и цифр.
'M-b'
     Переместиться назад на слово.
'C-l'
     Очистить экран, напечатав текущую строку заново вверху экрана.

   Заметьте, что 'C-f' перемещает курсор вперед на один знак, в то время
как 'M-f' перемещает вперед на слово.  Это своего рода соглашение, что
при нажатии клавиши Сontrol производятся действия над знаками, а при
нажатии клавиши Meta -- над словами.


File: gdb.info,  Node: Команды уничтожения Readline,  Next: Параметры команд Readline,  Prev: Команды перемещения Readline,  Up: Взаимодействие с Readline

21.2.3 Команды уничтожения Readline
-----------------------------------

"Уничтожение" текста означает уничтожение текста из строки, но
сохранение его для дальнейшего использования, обычно для
"восстановления" (повторной вставки) обратно в строку.  ('Вырезать' и
'вставить' являются более современными жаргонными синонимами для
'уничтожить' и 'восстановить'.)

   Если в описании команды сказано, что она 'уничтожает' текст, то вы
можете быть уверены, что позже его можно будет получить обратно в другом
(или том же самом) месте.

   Когда вы используете команду уничтожения, текст сохраняется в
"кольцевом списке уничтожений".  Любое число последовательных
уничтожений сохраняет весь уничтоженный текст вместе, так что когда вы
восстанавливаете его назад, вы получите все.  Список уничтожений не
имеет привязки к строкам; текст, уничтоженный вами в предыдущей строке
ввода, доступен для восстановления позже, когда вы вводите другую
строку.

   Вот список команд для уничтожения текста.

'C-k'
     Уничтожить текст от текущей позиции курсора до конца строки.

'M-d'
     Уничтожить от курсора до конца текущего слова или, если курсор
     находится между словами, до конца следующего слова.  Границы слов
     такие же, как и используемые 'M-f'.

'M-<DEL>'
     Уничтожить от курсора до начала текущего слова или, если курсор
     находится между словами, до начала предыдущего слова.  Границы слов
     такие же, как и используемые 'M-b'.

'C-w'
     Уничтожить от курсора до предыдущего пробельного символа.  Это
     отличается от M-<DEL>, так как границы слова различаются.

   Вот как можно "восстановить" текст обратно в строку.  Восстановление
означает копирование последнего уничтоженного текста из буфера
уничтожений.

'C-y'
     Восстановить последний уничтоженный текст в буфер перед курсором.

'M-y'
     Циклический сдвиг по кольцевому списку уничтожений и восстановление
     новой вершины.  Вы можете использовать это, только если предыдущая
     команда была 'C-y' или 'M-y'.


File: gdb.info,  Node: Параметры команд Readline,  Next: Поиск в истории,  Prev: Команды уничтожения Readline,  Up: Взаимодействие с Readline

21.2.4 Параметры команд Readline
--------------------------------

Вы можете передавать числовые параметры командам Readline.  Иногда
параметр действует как счетчик повторений, иногда он является _знаком
минус_, если аргумент отрицателен.  Если вы передаете отрицательный
параметр команде, которая обычно действует в прямом направлении, то она
будет действовать в обратном направлении.  Например, чтобы уничтожить
текст до начала строки, вы можете набрать ''M--' 'C-k''.

   Общий способ передачи числовых параметров команде состоит в наборе
Meta-цифр перед командой.  Если первая набранная 'цифра' есть знак минус
('-'), тогда знак аргумента будет отрицательным.  Если вы набрали одну
мета-цифру для начала параметра, вы можете набрать оставшиеся цифры и
потом команду.  Например, чтобы передать команде 'C-d' параметр 10, вы
можете набрать ''M-1 0 C-d''.


File: gdb.info,  Node: Поиск в истории,  Prev: Параметры команд Readline,  Up: Взаимодействие с Readline

21.2.5 Поиск команд в истории
-----------------------------

Readline предоставляет команды для поиска в истории команд строк,
содержащих указанную подстроку.  Существует два режима поиска:
"наращиваемый" и "ненаращиваемый".

   Наращиваемый поиск начинается до того, как пользователь закончит ввод
строки поиска.  По мере ввода очередных знаков строки поиска, Readline
отображает следующий элемент из истории, соответствующий строке,
введенной на данный момент.  Наращиваемый поиск требует ровно столько
знаков, сколько требуется для нахождения желаемого элемента истории.
Для поиска определенной строки в истории в обратном направлении, введите
'C-r'.  Ввод 'C-s' производит поиск в прямом направлении.  Знаки,
присутствующие в значении переменной 'isearch-terminators', используются
для завершения наращиваемого поиска.  Если этой переменной не было
присвоено значение, знаки <ESC> и 'C-J' будут завершать наращиваемый
поиск.  'C-g' прерывает наращиваемый поиск и восстанавливает исходную
строку.  Когда поиск завершается, элемент истории, содержащий искомую
строку, становится текущей строкой.

   Для нахождения других подходящих элементов списка истории, введите
соответственно 'C-r' или 'C-s'.  Это произведет поиск вперед или назад в
истории до следующего элемента, соответствующего введенной строке
поиска.  Любая другая последовательность клавиш, привязанная к команде
Readline, завершит поиск и выполнит эту команду.  Например, <RET>
завершит поиск и примет эту строку, таким образом выполняя команду из
списка истории.

   Ненаращиваемый поиск считывает строку поиска целиком, до начала
поиска соответствующих строк истории.  Строка поиска может быть введена
пользователем или являться частью содержимого текущей строки.


File: gdb.info,  Node: Файл инициализации Readline,  Next: Привязываемые команды Readline,  Prev: Взаимодействие с Readline,  Up: Редактирование командной строки

21.3 Файл инициализации Readline
================================

Хотя библиотека Readline поставляется с установленным по умолчанию
набором привязок клавиш, аналогичному Emacs, возможно использование
другого набора привязок.  Любой пользователь может настраивать
программы, которые используют Readline, помещая команды в файл
"inputrc", обычно в своем домашнем каталоге.  Имя этого файла берется из
переменной среды 'INPUTRC'.  Если эта переменная не установлена, по
умолчанию берется файл '~/.inputrc'.

   Когда запускается программа, использующая библиотеку Readline, файл
инициализации считывается, и устанавливаются привязки клавиш.

   Кроме того, команда 'C-x C-r' считывает файл инициализации заново,
так что изменения, которые вы могли cделать к этому времени, вступают в
силу.

* Menu:

* Синтаксис файла инициализации Readline:: Синтаксис команд файла инициализации.
* Условные конструкции инициализации::     Условные привязки клавиш в
                                           файле инициализации.
* Пример файла инициализации::             Пример файла инициализации.


File: gdb.info,  Node: Синтаксис файла инициализации Readline,  Next: Условные конструкции инициализации,  Up: Файл инициализации Readline

21.3.1 Синтаксис файла инициализации Readline
---------------------------------------------

Существуют всего несколько конструкций, которые допускаются в файле
инициализации Readline.  Пустые строки игнорируются.  Строки,
начинающиеся с '#', являются комментариями.  Строки, начинающиеся с '$',
обозначают условные конструкции (*note Условные конструкции
инициализации::).  Другие строки обозначают установку переменных и
привязки клавиш.

Установка переменных
     Вы можете изменять поведение Readline во время выполнения
     посредством изменения значений переменных, используя команду 'set'
     в файле инициализации.  Вот как можно изменить привязку клавиш
     Emacs, используемую по умолчанию, для использования команд
     редактирования строки 'vi':

          set editing-mode vi

     Основная часть поведения при выполнении изменяется с помощью
     следующих переменных.

     'bell-style'
          Контролирует, что происходит, когда Readline хочет издать звук
          на терминале.  Если установлено в 'none', Readline никогда не
          издает звук.  Если установлено в 'visible', Readline
          использует визуальный звонок, если есть возможность.  Если
          установлено в 'audible' (по умолчанию), Readline пытается
          издать звук на терминале.

     'comment-begin'
          Строка для вставки в начало строки, когда выполняется команда
          'insert-comment'.  По умолчанию '"#"'.

     'completion-ignore-case'
          Если установлено в 'on', Readline производит проверку
          совпадений и завершение имени файла без учета регистра.  По
          умолчанию 'off'.

     'completion-query-items'
          Количество возможных завершений, определяющее, когда у
          пользователя запрашивается, хочет ли он увидеть список
          возможных вариантов.  Если число возможных завершений больше
          этого значения, Readline спросит у пользователя, хочет он их
          просмотреть или нет; в противном случае, они просто
          отображаются.  По умолчанию устанавливается предел '100'.

     'convert-meta'
          Если установлено в 'on', Readline будет преобразовывать знаки
          с установленным восьмым битом в последовательность клавиш
          ASCII, удаляя восьмой бит и подставляя в качестве префикса
          знак <ESC>, тем самым преобразовывая их в последовательность
          клавиш с Meta-префиксом.  По умолчанию 'on'.

     'disable-completion'
          Если установлено в 'on', Readline будет препятствовать
          завершению слов.  Знаки завершения будут вставляться в строку
          так, как если бы они отображались в 'self-insert'.  По
          умолчанию 'off'.

     'editing-mode'
          Переменная 'editing-mode' контролирует, какой набор привязок
          клавиш используется.  По умолчанию, Readline запускается в
          режиме редактирования Emacs, где нажатия клавиш очень похожи
          на Emacs.  Эта переменная может быть установлена или в
          'emacs', или в 'vi'.

     'enable-keypad'
          Когда установлено в 'on', Readline будет пытаться
          активизировать малую клавиатуру приложения, когда она
          вызывается.  Это требуется некоторым системам для активации
          клавиш со стрелками.  По умолчанию 'off'.

     'expand-tilde'
          Если установлено в 'on', производится раскрывание тильды,
          когда Readline осуществляет завершение слова.  По умолчанию
          'off'.

     'horizontal-scroll-mode'
          Эта переменная может быть установлена в 'on' или 'off'.
          Установка в 'on' означает, что текст в редактируемых строках
          будет прокручиваться горизонтально в одной строке экрана,
          когда ширина строки становится больше ширины экрана, вместо
          переноса на новую строку.  По умолчанию, эта переменная
          установлена в 'off'.

     'input-meta'
          Если установлено в 'on', Readline включит восьмибитный ввод
          (восьмой бит не будет удаляться из считываемых знаков)
          независимо от того, поддерживает ли это терминал.  Значение по
          умолчанию 'off'.  Имя 'meta-flag' является синонимом для этой
          переменной.

     'isearch-terminators'
          Строка из знаков, которые должны прекращать наращиваемый поиск
          без последующего выполнения знака как команды (*note Поиск в
          истории::).  Если этой переменной не присвоено значение,
          наращиваемый поиск прекращают знаки <ESC> и 'C-J'.

     'keymap'
          Устанавливает текущую раскладку клавиатуры Readline для
          привязок команд к клавишам.  Возможные имена для 'keymap':
          'emacs', 'emacs-standard', 'emacs-meta', 'emacs-ctlx', 'vi',
          'vi-command' и 'vi-insert'.  'vi' эквивалентно 'vi-command';
          'emacs' эквивалентно 'emacs-standard'.  Значение по умолчанию
          'emacs'.  Значение переменной 'editing-mode' также влияет на
          раскладку по умолчанию.

     'mark-directories'
          Если установлено в 'on', к именам каталогов после завершения
          добавляется косая черта.  По умолчанию 'on'.

     'mark-modified-lines'
          Эта переменная, будучи установлена в 'on', велит Readline
          отображать звездочку ('*') в начале тех строк истории, которые
          были модифицированы.  По умолчанию, эта переменная установлена
          в 'off'.

     'output-meta'
          Если установлено в 'on', Readline будет отображать знаки с
          установленным восьмым битом непосредственно, а не в виде
          экранирующих последовательностей с Meta-префиксом.  По
          умолчанию 'off'.

     'print-completions-horizontally'
          Если установлено в 'on', Readline будет отображать завершения,
          отсортированные горизонтально в алфавитном порядке, а не вниз
          по экрану.  По умолчанию 'off'.

     'show-all-if-ambiguous'
          Это изменяет поведение по умолчанию функций завершения.  При
          установке в 'on', если слово имеет более одного возможного
          завершения, они будут выводиться немедленно, вместо подачи
          сигнала.  По умолчанию 'off'.

     'visible-stats'
          Если установлено в 'on', при выводе возможных завершений, к
          имени файла добавляется знак, обозначающий тип файла.  По
          умолчанию 'off'.

Привязки клавиш
     Синтаксис для управления привязками клавиш в файле инициализации
     прост.  Во-первых, вы должны найти имя команды, которую вы хотите
     изменить.  Следующий раздел содержит таблицы с именем команды,
     привязкой клавиш по умолчанию, если таковые есть, и коротким
     описанием, что делает команда.

     Если вы знаете имя команды, просто поместите в строке файла
     инициализации название клавиши, к которой вы хотите привязать
     команду, двоеточие и затем имя команды.  Название клавиши может
     быть выражено различными способами, в зависимости от того, как вам
     удобнее.

     НАЗВ-КЛАВИШИ: ИМЯ-ФУНКЦИИ или МАКРОС
          НАЗВ-КЛАВИШИ -- это название клавиши, записанное по-английски.
          Например:
               Control-u: universal-argument
               Meta-Rubout: backward-kill-word
               Control-o: "> output"

          В этом примере, 'C-u' привязана к функции
          'universal-argument', а 'C-o' привязана к выполнению
          макрокоманды, записанной с правой стороны (то есть, вставить
          текст '> output' в строку).

     "ПОСЛЕД-КЛАВИШ": ИМЯ-ФУНКЦИИ или МАКРО
          ПОСЛЕД-КЛАВИШ отличается от вышеупомянутого НАЗВ-КЛАВИШИ тем,
          что позволяет определять строки, обозначающие целую
          последовательность клавиш, посредством ее заключения в двойные
          кавычки.  Могут быть использованы некоторые экранирующие
          последовательности в стиле GNU Emacs, как в следующем примере,
          но имена специальных знаков не распознаются.

               "\C-u": universal-argument
               "\C-x\C-r": re-read-init-file
               "\e[11~": "Function Key 1"

          В этом примере, 'C-u' привязывается к функции
          'universal-argument' (как это было в первом примере), ''C-x'
          'C-r'' привязывается к функции 're-read-init-file' и '<ESC> '[
          1 1 ~'' привязывается к вставке текста 'Function Key 1'.

     Следующие экранирующие последовательности в стиле GNU Emacs
     доступны при определении последовательности клавиш:

     '\C-'
          префикс Control
     '\M-'
          префикс Meta
     '\e'
          префикс экранирующего знака
     '\\'
          обратная косая черта
     '\"'
          <">, знак двойных кавычек
     '\''
          <'>, одинарная кавычка или апостроф

     В дополнение к экранирующим последовательностям стиля GNU Emacs,
     доступен второй набор последовательностей с обратной косой чертой:

     '\a'
          тревога (звуковой сигнал)
     '\b'
          переместиться назад на одну позицию
     '\d'
          удаление
     '\f'
          перевод страницы
     '\n'
          новая строка
     '\r'
          возврат каретки
     '\t'
          горизонтальная табуляция
     '\v'
          вертикальная табуляция
     '\NNN'
          знак, восьмеричное значение кода 'ASCII' которого есть NNN (от
          одной до трех цифр)
     '\xNNN'
          знак, шестнадцатеричное значение кода 'ASCII' которого есть
          NNN (от одной до трех цифр)

     При вводе текста макрокоманды, для обозначения ее определения
     должны использоваться одиночные или двойные кавычки.
     Предполагается, что текст без кавычек является именем функции.  В
     теле макрокоманды, экранирующие последовательности с обратной косой
     чертой раскрываются.  Обратная косая черта будет экранировать любой
     другой знак в тексте макрокоманды, включая '"' и '''.  Например,
     следующая привязка велит ''C-x' \' вставлять одиночную '\' в
     строку:
          "\C-x\\": "\\"


File: gdb.info,  Node: Условные конструкции инициализации,  Next: Пример файла инициализации,  Prev: Синтаксис файла инициализации Readline,  Up: Файл инициализации Readline

21.3.2 Условные конструкции инициализации
-----------------------------------------

Readline реализует возможности, аналогичные по смыслу возможностям
условной компиляции препроцессора Си, позволяющие производить привязки
клавиш и установку переменных в результате тестов.  Вот четыре
директивы, используемые анализатором.

'$if'
     Конструкция '$if' позволяет производить привязки в зависимости от
     режима редактирования, используемого терминала, или приложения,
     использующего Readline.  Содержимое теста продолжается до конца
     строки; для его ограничения не требуются никакие знаки.

     'mode'
          Форма 'mode=' директивы '$if' используется для проверки в
          каком из режимов находится Readline: 'emacs' или 'vi'.  Это
          может быть использовано, например, вместе с командой 'set
          keymap' для установки привязок в наборы 'emacs-standard' и
          'emacs-ctlx', только если Readline запускается в режиме
          'emacs'.

     'term'
          Форма 'term=' может использоваться для включения привязок
          клавиш, уникальных для какого-либо терминала, возможно для
          привязки вывода последовательности клавиш к функциональным
          клавишам терминала.  Слово, стоящее справа от '=',
          сравнивается как с полным названием терминала, так и с частью
          названия, идущей до первого '-'.  Это позволяет, например,
          опознавать как 'sun', так и 'sun-cmd'.

     'application'
          Конструкция APPLICATION используется для включения установок,
          уникальных для какого-либо приложения.  Каждая программа,
          использующая библиотеку Readline, устанавливает APPLICATION
          NAME, и вы можете проверить его.  Это может быть использовано
          для привязки последовательностей клавиш к функциям, полезным в
          конкретной программе.  Например, следующая команда добавляет
          последовательность, которая заключает в кавычки текущее или
          предыдущее слово в Bash:
               $if Bash
               # Quote the current or previous word
               "\C-xq": "\eb\"\ef\""
               $endif

'$endif'
     Эта команда, как показано в предыдущем примере, заканчивает команду
     '$if'.

'$else'
     Команды этой ветви директивы '$if' выполняются, если проверка
     заканчивается неудачей.

'$include'
     Эта директива принимает в качестве аргумента одно имя файла и
     считывает из него команды и привязки клавиш.
          $include /etc/inputrc


File: gdb.info,  Node: Пример файла инициализации,  Prev: Условные конструкции инициализации,  Up: Файл инициализации Readline

21.3.3 Пример файла инициализации
---------------------------------

Вот пример файла INPUTRC.  Он иллюстрирует привязки клавиш, присвоение
значений переменным и синтаксис условий.

     # Этот файл управляет поведением редактирования строки ввода в
     # программах, использующих библиотеку Gnu Readline.  Среди таких программ
     # FTP, Bash и Gdb.
     #
     # Вы можете заново считать файл inputrc с помощью C-x C-r.
     # Строки, начинающиеся с '#', являются комментариями.
     #
     # Сначала, включим все общесистемные привязки и переменные из
     # /etc/Inputrc
     $include /etc/Inputrc

     #
     # Установка различных привязок для режима emacs.

     set editing-mode emacs

     $if mode=emacs

     Meta-Control-h:	backward-kill-word	Текст после имени функции игнорируется

     #
     # Стрелки в режиме малой клавиатуры
     #
     #"\M-OD":        backward-char
     #"\M-OC":        forward-char
     #"\M-OA":        previous-history
     #"\M-OB":        next-history
     #
     # Стрелки в режиме ANSI
     #
     "\M-[D":        backward-char
     "\M-[C":        forward-char
     "\M-[A":        previous-history
     "\M-[B":        next-history
     #
     # Стрелки в восьмибитном режиме малой клавиатуры
     #
     #"\M-\C-OD":       backward-char
     #"\M-\C-OC":       forward-char
     #"\M-\C-OA":       previous-history
     #"\M-\C-OB":       next-history
     #
     # Стрелки в восьмибитном режиме ANSI
     #
     #"\M-\C-[D":       backward-char
     #"\M-\C-[C":       forward-char
     #"\M-\C-[A":       previous-history
     #"\M-\C-[B":       next-history

     C-q: quoted-insert

     $endif

     # Привязки старого стиля.  Устанавливается по умолчанию.
     TAB: complete

     # Макрокоманды, удобные при взаимодействии с оболочкой
     $if Bash
     # редактирование пути
     "\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
     # Подготовка к вводу слова в кавычках -- вставляет открывающуюся и
     # закрывающуюся двойные кавычки и помещает курсор сразу за открывающей
     "\C-x\"": "\"\"\C-b"
     # вставляет обратную косую черту (testing backslash escapes in sequences
     # and macros)  "\C-x\\": "\\"
     # Заключает в кавычки текущее или предыдущее слово
     "\C-xq": "\eb\"\ef\""
     # Добавляет привязку для обновления строки
     "\C-xr": redraw-current-line
     # Редактирование переменной в текущей строке
     "\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
     $endif

     # использовать визуальный звонок, если он доступен
     set bell-style visible

     # не урезать знаки при чтении до 7 бит
     set input-meta on

     # позволяет ввод знаков iso-latin1 вместо их преобразования к
     # последовательностям с Meta-префиксом
     # prefix-meta sequences
     set convert-meta off

     # отображает знаки непосредственно с установленным восьмым битом, а не
     # в виде знаков с Meta-префиксом
     set output-meta on

     # если существует более 150 возможных завершений слова, запросить
     # пользователя, хочет ли он видеть их все
     set completion-query-items 150

     # Для FTP
     $if Ftp
     "\C-xg": "get \M-?"
     "\C-xt": "put \M-?"
     "\M-.": yank-last-arg
     $endif


File: gdb.info,  Node: Привязываемые команды Readline,  Next: Режим vi Readline,  Prev: Файл инициализации Readline,  Up: Редактирование командной строки

21.4 Привязываемые команды Readline
===================================

* Menu:

* Команды для перемещения::     Перемещение по строке.
* Команды для истории::         Вызов предыдущих строк.
* Команды для текста::          Команды для изменения текста.
* Команды для уничтожения::     Команды для уничтожения и восстановления.
* Числовые параметры::          Задание числовых параметров,
                                счетчиков повторений.
* Команды для завершения::      Readline вводит за вас.
* Клавиатурные макросы::        Сохранений и повторное выполнений
                                введенных символов.
* Разные команды::              Прочие разные команды.

Этот раздел описывает команды Readline, которые могут быть привязаны к
последовательностям клавиш.

