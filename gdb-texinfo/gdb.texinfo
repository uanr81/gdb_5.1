\input texinfo      @c -*-texinfo-*-
@c $Id: gdb.texinfo,v 1.22 2001/06/16 11:05:42 dima Exp $
@c Copyright 1988-2000
@c Free Software Foundation, Inc.
@c
@c %**start of header
@c makeinfo ignores cmds prev to setfilename, so its arg cannot make use
@c of @set vars.  However, you can override filename with makeinfo -o.
@setfilename gdb-ru.info
@c

@documentlanguage ru
@documentencoding koi8-r


@include gdb-cfg.texi
@c
@settitle Отладка с помощью @value{GDBN}
@setchapternewpage odd
@c %**end of header
@iftex
@c @smallbook
@afourpaper       @c !!! Added by dima
@c @cropmarks
@end iftex

@c сноска-примечание переводчика
@macro transnote{note}
@footnote{\note\ @i{(Прим.@: переводчика)}}
@end macro

@finalout
@syncodeindex ky cp

@c readline appendices use @vindex, @findex and @ftable
@c annotate.texi and gdbmi use @findex.
@syncodeindex vr cp
@syncodeindex fn cp

@c !!set GDB manual's edition --- not the same as GDB version!
@set EDITION Восьмая

@c !!set GDB manual's revision date
@set DATE Март 2000

@c THIS MANUAL REQUIRES TEXINFO 3.12 OR LATER.

@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.
@dircategory Programming & development tools.
@direntry
* Gdb-ru: (gdb-ru).                  Отладчик @sc{gnu}.
@end direntry

@ifinfo
Этот файл описывает отладчик @sc{gnu} @value{GDBN}.


@cite{Отладка с помощью @value{GDBN}: отладчик @sc{gnu} уровня исходного
кода},  @value{EDITION} Редакция, @value{DATE}, для @value{GDBN} версии
@value{GDBVN}.

Copyright (C) 1988-2000 Free Software Foundation, Inc.@*
Перевод Copyright (C) 1999-2001 Дмитрий Сиваченко.
Под редакцией Олега Тихонова.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ifinfo

@titlepage
@title Отладка с помощью @value{GDBN}
@subtitle Отладчик @sc{gnu} уровня исходного кода
@sp 1
@subtitle @value{EDITION} редакция, для @value{GDBN} версии @value{GDBVN}
@subtitle @value{DATE}
@author Ричард Столмен, Роланд Пеш, Стан Шебс и другие.
@page
@tex
{\parskip=0pt
\hfill (Присылайте сообщения об ошибках и комментарии к @value{GDBN} по
адресу bug-gdb\@gnu.org.)\par
\hfill {\it Отладка с помощью @value{GDBN}}\par
\hfill \TeX{}info \texinfoversion\par
}
@end tex

@vskip 0pt plus 1filll
Copyright @copyright{} 1988-2000 Free Software Foundation, Inc.@*
Перевод @copyright{} 1999-2001 Дмитрий Сиваченко.@*
Под редакцией Олега Тихонова.
@sp 2
@ignore
@c !!!!!!!!! Commented by me!
Published by the Free Software Foundation @*
59 Temple Place - Suite 330, @*
Boston, MA 02111-1307 USA @*
ISBN 1-882114-77-9 @*
@end ignore

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end titlepage
@page

@ifnottex

@node Top, Обзор, (dir), (dir)

@top Отладка с помощью @value{GDBN}

Этот файл описывает @value{GDBN}, символьный отладчик @sc{gnu}.

@value{EDITION} редакция, @value{DATE}, для @value{GDBN} версии
@value{GDBVN}.

Copyright (C) 1988-2000 Free Software Foundation, Inc.

@menu
* Обзор::                       Обзор @value{GDBN}
* Пример сеанса::               Пример сеанса @value{GDBN}

* Вызов::                       Вход и выход из @value{GDBN}
* Команды::                     Команды @value{GDBN}
* Выполнение::                  Выполнение программ под управлением @value{GDBN}
* Остановка::                   Остановка и продолжение
* Стек::                        Исследование стека
* Исходные файлы::              Исследование исходных файлов
* Данные::                      Исследование данных

* Языки::                       Использование @value{GDBN} с различными языками

* Символы::                     Исследование таблицы символов
* Изменения::                   Изменение выполнения
* Файлы GDB::                   Файлы @value{GDBN}
* Отладочные цели::             Определение отладочной цели
* Конфигурации::                Информация о конфигурации
* Управление GDB::              Управление @value{GDBN}
* Последовательности::          Фиксированные последовательности команд
* Emacs::                       Использование @value{GDBN} под управлением @sc{gnu} Emacs
* Примечания::                  Интерфейс примечаний @value{GDBN}
* GDB/MI::                      Машинный интерфейс @value{GDBN}

* Ошибки в GDB::                Отчеты об ошибках в @value{GDBN}
* Редактирование командной строки::
                                Редактирование командной строки
* Интерактивное использование истории::
                                Интерактивное использование истории
* Форматирование документации:: Как отформатировать и распечатать
                                документацию по @value{GDBN}
* Установка GDB::               Установка @value{GDBN}
* Алфавитный указатель::        Алфавитный указатель

@detailmenu

Обзор @value{GDBN}

* Свободные программы::         Свободно распространяемые программы
* Выражение признательности::   Кто внес вклад в развитие GDB

Вход и выход из GDB

* Вызов GDB::                  
* Выход из GDB::                
* Команды оболочки::            

Вызов @value{GDBN}

* Параметры файлов::             
* Параметры режима::            

Команды @value{GDBN}

* Синтаксис команд::            
* Завершение::                  
* Справка::                     

Выполнение программ под управлением @value{GDBN}

* Компиляция::                  
* Начало выполнения::           
* Аргументы::                   
* Среда::                       
* Рабочий каталог::             
* Ввод-вывод::                  
* Присоединение::               
* Уничтожение процесса::        
* Нити::                        
* Процессы::                    

Остановка и продолжение исполнения

* Точки останова::              
* Продолжение и пошаговое выполнение::  
* Сигналы::                     
* Остановка нитей::              

Точки останова, точки наблюдения и точки перехвата

* Установка точек останова::    
* Установка точек наблюдения::  
* Установка точек перехвата::   
* Удаление точек останова::     
* Отключение::                  
* Условия::                     
* Команды останова::            
* Меню точки останова::         
* Ошибки в точках останова::    

Исследование стека

* Кадры::                       
* Цепочки вызовов::             
* Выбор::                       
* Информация о кадре::          

Исследование исходных файлов

* Вывод строк::                 
* Поиск::                       
* Пути для исходных файлов::  
* Машинный код::                

Исследование данных

* Выражения::                   
* Переменные::                  
* Массивы::                     
* Форматы вывода::              
* Память::                      
* Автоматическое отображение::  
* Параметры вывода::            
* История значений::            
* Вспомогательные переменные::  
* Регистры::                    
* Вычисления с плавающей точкой::  

Использование @value{GDBN} с различными языками программирования

* Переход от одного языка к другому::  
* Отображение языка::           
* Проверка::                    
* Поддержка::                   

Переход от одного языка к другому

* Имена файлов::                
* Установка рабочего языка::    
* Автоматическое::              

Проверка диапазона принадлежности типу

* Проверка типов::              
* Проверка диапазона::          

Поддерживаемые языки

* Си::                          
* Модула-2::                    
* Chill::                       

Си и Си++

* Операторы Си::                
* Константы Си::                
* Выражения Си++::              
* Значения Си по умолчанию::  
* Проверки в Си::               
* Отладка Си::                  
* Отладка Си++::                

Модула-2

* Операторы Модулы-2::          
* Встроенные функции/процедуры::  
* Константы Модулы-2::          
* Установки по умолчанию М-2::  
* Отклонения::                  
* Проверки Модулы-2::           
* Область видимости в Модуле-2::  
* GDB и Модула-2::              

Chill

* Как отображаются режимы::     
* Местоположения::              
* Значения и операции с ними::  
* Проверка диапазона и типов в Chill::  
* Установки по умолчанию Chill::

Изменение выполнения

* Присваивание::                
* Переходы::                    
* Подача сигналов::             
* Возврат::                     
* Вызовы::                      
* Внесение изменений::          

Файлы @value{GDBN}

* Файлы::                       
* Ошибки с символами::          

Определение отладочной цели

* Активные цели::               
* Команды для целей::           
* Порядок байтов::              
* Удаленная отладка::           
* Отображение объектов ядра::    

Удаленная отладка

* Удаленный::                   

Удаленный последовательный протокол @value{GDBN}

* Содержимое заглушки::         
* Начальная загрузка::                
* Сеанс отладки::               
* Протокол::                    
* Сервер::                      
* NetWare::                     

Информация о конфигурации

* Чистая::                      
* Встроенная ОС::               
* Встроенные процессоры::       
* Архитектуры::                 

Чистая

* HP-UX::                       
* Информация о процессах SVR4::  

Встроенные операционные системы

* VxWorks::                     

Использование @value{GDBN} с VxWorks

* Соединение к VxWorks::        
* Загрузка на VxWorks::         
* Присоединение к VxWorks::     

Встроенные процессоры

* Встроенный A29K::             
* ARM::                         
* H8/300::                      
* H8/500::                      
* i960::                        
* M32R/D::                      
* M68K::                        
* M88K::                        
* Встроенный MIPS::             
* PowerPC::                     
* PA::                          
* SH::                          
* Sparclet::                    
* Sparclite::                   
* ST2000::                      
* Z8000::                       

Встроенный AMD A29K

* A29K UDI::                    
* A29K EB29K::                  
* Коммуникации (EB29K)::        
* gdb-EB29K::                   
* Удаленный журнал::            

Hitachi H8/300

* Платы Hitachi::               
* Hitachi ICE::                 
* Специально для Hitachi::  

Intel i960

* Вызов Nindy::                
* Параметры Nindy::             
* Сброс Nindy::                 

Tsqware Sparclet

* Файл Sparclet::               
* Соединение к Sparclet::       
* Загрузка на Sparclet::           
* Выполнение Sparclet::         

Архитектуры

* A29K::                        
* Alpha::                       
* MIPS::                        

Управление @value{GDBN}

* Приглашение::
* Редактирование::
* История::
* Размер экрана::
* Числа::
* Сообщения/предупреждения::
* Отладочный вывод::

Фиксированные последовательности команд

* Определяемые пользователем команды::  
* Ловушки::                     
* Командные файлы::             
* Вывод::                       

Сообщение об ошибках в @value{GDBN}

* Критерий ошибки::             
* Отчеты об ошибках::           

Установка @value{GDBN}

* Отдельный объектный каталог::  
* Имена конфигураций::          
* Ключи configure::             

@end detailmenu
@end menu

@end ifnottex

@c TeX can handle the contents at the start but makeinfo 3.12 can not
@iftex
@contents
@end iftex

@node Обзор
@unnumbered Обзор @value{GDBN}

Назначение отладчика, такого как @value{GDBN} --- позволить вам увидеть,
что происходит ``внутри'' другой программы во время ее выполнения,
или что делала другая программа в момент краха.

@value{GDBN} может выполнять действия четырех основных типов (а также
другие, дополняющие эти основные), чтобы помочь вам выявить ошибку:

@itemize @bullet
@item
Начать выполнение вашей программы, задав все, что
может повлиять на ее поведение.

@item
Остановить вашу программу при указанных условиях.

@item
Исследовать, что случилось, когда ваша программа остановилась.

@item
Изменить вашу программу, чтобы вы могли поэкспериментировать с
устранением эффектов одной ошибки и продолжить выявление других.
@end itemize

Вы можете использовать @value{GDBN} для отладки программ, написанных на Си
и Си++.
Для получения более подробной информации, смотрите @ref{Поддержка,,Поддерживаемые языки}.
Для дополнительной информации, смотрите @ref{Си,,Си и Си++}.

@cindex Chill
@cindex Модула-2
@value{GDBN} частично поддерживает языки Модула-2 и Chill.  Для получения
информации о Модуле-2, смотрите @ref{Модула-2,,Модула-2}.  Для получения
информации о Chill, см. @ref{Chill}

@cindex Паскаль
Отладка программ на Паскале, которые используют множества,
поддиапазоны, файловые переменные или вложенные функции, в настоящее
время не работает.  @value{GDBN} не поддерживает ввод выражений, вывод
значений, и аналогичные возможности, использующие синтаксис Паскаля.

@cindex Фортран
@value{GDBN} можно использовать для отладки программ, написанных на
Фортране, хотя может возникнуть необходимость ссылаться на некоторые
переменные, добавляя в конец имени знак подчеркивания.

@menu
* Свободные программы::         Свободно распространяемые программы
* Выражение признательности::   Кто внес вклад в развитие GDB
@end menu

@node Свободные программы
@unnumberedsec Свободно распространяемые программы

@value{GDBN} --- @dfn{свободная программа}, защищенная Универсальной
Общественной Лицензией @sc{gnu} (GPL).  GPL предоставляет вам свободу
копировать или изменять программу, но каждый человек, получая копию,
также получает свободу изменять эту копию (это означает, что у него
должен быть доступ к исходному коду), и свободу распространять
последующие копии.  Обычные компании, разрабатывающие программы,
используют авторские права для ограничения ваших свобод; Фонд Свободного
Программного Обеспечения использует GPL для сохранения этих свобод.

Главное, Универсальная Общественная Лицензия --- это лицензия, говорящая,
что вы имеете эти свободы и что вы не можете их у кого-либо отнять.

@node Выражение признательности
@unnumberedsec Кто внес вклад в развитие @value{GDBN}

Первоначальным автором @value{GDBN}, как и многих других программ
@sc{gnu}, был Ричард Столмен.  Многие другие люди внесли вклад в его
разработку.  Этот раздел пытается отдать должное основным участникам
разработки.  Одним из достоинств свободных программ является то, что
каждый может внести свой вклад в их развитие; к сожалению, мы не можем в
действительности поблагодарить здесь всех.  Файл @file{ChangeLog} в
поставке @value{GDBN} представляет детальнейший отчет.

Изменения, сделанные задолго до версии 2.0, потеряны в тумане времен.

@quotation
@emph{Оправдание:} Дополнения к этому разделу особенно приветствуются.
Если вы или ваши друзья (или враги, чтобы соблюдать справедливость) были
незаслуженно пропущены в этом списке, мы будем рады добавить ваши имена!
@end quotation

Особенно мы хотим сказать спасибо тем, кто присматривал за @value{GDBN}
между основными выпусками, чтобы они не сочли свои многочисленные
заслуги оставленными без благодарности:
Эндрю Кагни (выпуск 5.0);
Джим Бленди (выпуск 4.18);
Джесон Моленда (выпуск 4.17);
Стан Шебс (выпуск 4.14);
Фред Фиш (выпуски 4.16, 4.15, 4.13, 4.12, 4.11, 4.10, и 4.9);
Сту Гроссман и Джон Гилмор (выпуски 4.8, 4.7, 4.6, 4.5, и 4.4);
Джон Гилмор (выпуски 4.3, 4.2, 4.1, 4.0, и 3.9);
Джим Кингдон (выпуски 3.5, 3.4, и 3.3)
и Ренди Смит (выпуски 3.2, 3.1, и 3.0).

Ричард Столмен, которому в различные времена помогали Петер ТерМаат, Крис
Хенсон и Ричард Млинарик, занимался выпусками до 2.8.

Михаэль Тиманн является автором большей части поддержки @sc{gnu} Си++ в
@value{GDBN}, со значительным дополнительным вкладом от Пера Бозера.
Джеймс Кларк написал дешифровщик@footnote{В Си++ и других
объектно-ориентированных языках программирования, у вас может быть
несколько функций с одним именем, но с аргументами разных типов.
Например:

@example
int add_two(int a, int b);
double add_two(double a, double b);
double add_two(double a, int b);
@end example

@noindent
Компилятор генерирует код для вызова верной функции по заданным
аргументам.  Это называется @dfn{перегрузкой функций}.

Однако, компоновщик требует, чтобы все символы имели недвусмысленные
имена.  Поэтому компилятор @emph{шифрует} (от английского ``mangle'')
имена перегруженных функций так, чтобы они включали типы аргументов и
возвращаемые значения.  К примеру, приведенные выше функции
могут быть зашифрованы примерно так:

@example
add_two_Ret_int_int_int
add_two_Ret_double_double_double
add_two_Ret_double_double_int
@end example

@noindent
(в действительности шифрованные имена выглядят безобразнее).  В
результате компоновщик может правильно обработать перегруженные функции.
@emph{Дешифровщик} (от английского ``demangler'') --- это программа (или
функция), которая выполняет обратную операцию: анализируя зашифрованные
имена, она выдает исходную сигнатуру функции.  Это необходимо, чтобы
отобразить то, что программист сможет понять и связать с исходным
текстом своей программы.  Для этого любому средству отладки,
поддерживающему Си++, обычно требуется дешифровщик. @i{(Прим.@: переводчика)}
@example
@end example
} имен @sc{gnu} Си++.
@c ?????????? пустой пример --- видимо баг в техинфо!!!!
Ранняя работа по Си++ была сделана Петером ТерМаатом (который также сделал
много общей работы по обновлению, приведшей к выпуску 3.0).

Для исследования многих форматов объектных файлов @value{GDBN} 4
использует библиотеку подпрограмм BFD.  BFD был совместным проектом
Дэвида В.@w{ }Хенкел-Волласа, Рича Пиксли, Стива Чемберлена и Джона Гилмора.

Дэвид Джонсон первоначально написал поддержку COFF; Пейс Виллисон
первоначально сделал поддержку инкапсулированного COFF.

Брент Бенсон из Harris Computer Systems сделал поддержку DWARF2.

Адам ДеБур и Брэндли Дэвис сделали поддержку ISI Optimum V.
Пер Бозер, Нобоюки Хикичи, и Алессандро Форин сделали поддержку MIPS.
Жан-Даниэль Фекет сделал поддержку Sun 386i.
Крис Хенсон улучшил поддержку HP9000.
Нобоюки Хикичи и Томоюки Хаси сделали поддержку Sony/News OS 3.
Дэвид Джонсон сделал поддержку Encore Umax.
Юрки Куоппала сделал поддержку Altos 3068.
Джефф Ло сделал поддержку HP PA и SOM.
Кейс Паккард сделал поддержку NS32K.
Доуг Ребсон сделал поддержку Acorn Risc Machine.
Боб Раск сделал поддержку Harris Nighthawk CX-UX.
Крис Смит сделал поддержку Convex (и отладку программ на Фортране).
Джонатан Стоун сделал поддержку Pyramid.
Михаэль Тиманн сделал поддержку SPARC.
Тим Такер сделал поддержку для Gould NP1 и Gould Powernode.
Пейс Виллисон сделал поддержку Intel 386.
Джей Восбург сделал поддержку Symmetry.

Андреас Шваб сделал поддержку M68K Linux.

Рич Шаефер и Петер Шауер помогли реализовать поддержку разделяемых
библиотек SunOS.

Джей Фенласон и Роланд МакГрес проверили совместимость @value{GDBN} и GAS
по нескольким наборам машинных инструкций.

Патрик Дювал, Тед Голдстейн, Викрам Кока и Гленн Инжел помогли разработать
удаленную отладку.  Корпорации Intel, Wind River Systems, AMD и ARM
сделали модули удаленной отладки для целей i960, VxWorks, A29K UDI,
и RDI соответственно.

Брайан Фокс является автором библиотек Readline, предоставляющих
историю команд и возможность редактирования командной строки.

Эндрю Бирс из SUNY Buffalo написал код для переключения языков,
поддержку Модулы-2, главу `Языки' этого руководства.

Фред Фиш написал большую часть поддержки Unix System Vr4.
Он также улучшил поддержку завершения команд для поддержки перегруженных
символов Си++.

Hitachi America, Ltd. спонсировала поддержку для процессоров H8/300,
H8/500 и Super-H.

NEC спонсировала поддержку процессоров v850, Vr4xxx и Vr5xxx.

Mitsubishi спонсировала поддержку процессоров D10V, D30V и M32R/D.

Toshiba спонсировала поддержку процессора TX39 Mips.

Matsushita спонсировала поддержку процессоров MN10200 и MN10300.

Fujitsu спонсировала поддержку процессоров  SPARClite и FR30.

Кунг Шу, Джефф Ло и Рик Слэдки добавили поддержку аппаратных точек
наблюдения.

Михаэль Снайдер добавил поддержку точек трассировки.

Сту Гроссман написал gdbserver.

Джим Кингдон, Петер Шауер, Ян Тейлор и Сту Гроссман сделали почти
бесчисленное количество исправлений и улучшений во всем @value{GDBN}.

Следующие люди из Hewlett-Packard Company сделали
поддержку архитектуры PA-RISC 2.0, HP-UX 10.20, 10.30 и 11.0
(усеченный режим), реализации нитей HP в ядре, компилятора HP aC++,
и конечного интерфейса пользователя: Бен Крепп, Ричард Тайтл,
Джон Бишоп, Сюзан Макчиа, Кэси Манн, Сэтиш Пай, Индиа Поул, Стив
Рейраур и Елена Заннони.  Ким Хаас предоставил специфичную для HP
информацию для этого руководства.

Cygnus Solutions спонсировала поддержку @value{GDBN} и большую часть его
развития с 1991 года.  Среди инженеров Cygnus, работавших над @value{GDBN}
на постоянной основе, Марк Александер, Джим Бленди, Пер Бозер, Кевин
Беттнер, Эдит Эпштейн, Крис Фейлор, Фред Фиш, Мартин Хант, Джим
Ингам, Джон Гилмор, Сту Гроссман, Кунг Шу, Джим Кингдон, Джон Мецлер,
Фернандо Нассер, Джеффри Ноер, Дон Перчик, Рич Пиксли, Зденек
Радуч, Кейс Сейц, Стан Шебс, Дэвид Тейлор и Елена Заннони.  Кроме того,
Дейв Бролли, Ян Кармихаэль, Стив Чемберлен, Ник Клифтон,
Джэй Ти Конклин, Стен Кокс, Ди Джей Делори, Ульрих Дреппер, Фрэнк Эйглер, Дуг
Эванс, Син Фаган, Дэвид Хенкель-Воллас, Ричард Хендерсон, Джефф
Холком, Джефф Ло, Джим Лемке, Том Лорд, Боб Мансон, Михаэль Мейсснер,
Джейсон Меррилл, Кэтрин Мур, Дрю Мосли, Кен Робурн, Гавин
Ромиг-Кох, Роб Савой, Джейми Смит, Майк Стамп, Ян Тейлор, Анжела
Томас, Михаэль Тиманн, Том Тромей, Рон Унро, Джим Вилсон и Дэвид
Зун также внесли свой вклад в большей или меньшей степени.


@node Пример сеанса
@chapter Пример сеанса @value{GDBN}

Вы можете пользоваться этим руководством в свое удовольствие, чтобы
прочитать о @value{GDBN} все.  Однако, достаточно небольшого количества
команд, чтобы начать пользоваться отладчиком.  Эта глава иллюстрирует
эти команды.

@iftex
В этом примере сеанса мы выделяем ввод пользователя так: @b{ввод},
чтобы его было проще отличить от находящегося рядом вывода программы.
@end iftex

В одной из предварительных версий программы @sc{gnu} @code{m4} (настраиваемый
макропроцессор), была допущена следующая ошибка: иногда, при замене
строк, определяющих кавычки, со значений по умолчанию, команды,
использовавшиеся для поиска одного макроопределения внутри другого,
прекращали работать.  В следующем коротком сеансе @code{m4} мы
определим макрос @code{foo}, который раскрывается в @code{0000}; затем мы
используем встроенную процедуру @code{m4} @code{defn}, чтобы определить
точно такой же макрос @code{bar}.  Однако, если мы изменим открывающую кавычку
на @code{<QUOTE>}, а закрывающую на @code{<UNQUOTE>}, та же самая процедура не
сможет определить новый синоним @code{baz}:

@smallexample
$ @b{cd gnu/m4}
$ @b{./m4}
@b{define(foo,0000)}

@b{foo}
0000
@b{define(bar,defn(`foo'))}

@b{bar}
0000
@b{changequote(<QUOTE>,<UNQUOTE>)}

@b{define(baz,defn(<QUOTE>foo<UNQUOTE>))}
@b{baz}
@b{C-d}
m4: End of input: 0: fatal error: EOF in string@footnote{m4: Конец ввода: 0: фатальная ошибка: EOF в строке  @i{(Прим.@: переводчика)}}
@end smallexample

@noindent
Попытаемся с помощью @value{GDBN} понять, что же происходит.

@smallexample
$ @b{@value{GDBP} m4}
@value{GDBN} is free software and you are welcome to distribute copies
 of it under certain conditions; type "show copying" to see
 the conditions.
There is absolutely no warranty for @value{GDBN}; type "show warranty"
 for details.

@value{GDBN} @value{GDBVN}, Copyright 1999 Free Software Foundation, Inc...
(@value{GDBP})
@end smallexample

@noindent
@value{GDBN} читает только минимум символьных данных, достаточный для того,
чтобы знать, где в случае
необходимости искать остальные; в результате первое приглашение
появляется очень быстро.  Теперь мы велим @value{GDBN} использовать меньшую
чем обычно ширину экрана, чтобы примеры умещались на
страницах этого руководства.

@smallexample
(@value{GDBP}) @b{set width 70}
@end smallexample

@noindent
Нам необходимо увидеть, как работает встроенная процедура @code{m4}
@code{changequote}.  Посмотрев исходный текст, мы знаем, что
соответствующей подпрограммой является @code{m4_changequote}, так что мы
устанавливаем на ней точку останова с помощью команды @value{GDBN} @code{break}.

@smallexample
(@value{GDBP}) @b{break m4_changequote}
Breakpoint 1 at 0x62f4: file builtin.c, line 879.
@end smallexample

@noindent
Используя команду @code{run}, мы запускаем @code{m4} под управлением
@value{GDBN}; до тех пор, пока управление не достигло подпрограммы
@code{m4_changequote}, программа выполняется как обычно:

@smallexample
(@value{GDBP}) @b{run}
Starting program: /work/Editorial/gdb/gnu/m4/m4
@b{define(foo,0000)}

@b{foo}
0000
@end smallexample

@noindent
Чтобы активировать точку останова, мы вызываем @code{changequote}.
@value{GDBN} приостанавливает выполнение @code{m4}, выводя на экран
информацию о том месте, где он остановился.

@smallexample
@b{changequote(<QUOTE>,<UNQUOTE>)}

Breakpoint 1, m4_changequote (argc=3, argv=0x33c70)
    at builtin.c:879
879         if (bad_argc(TOKEN_DATA_TEXT(argv[0]),argc,1,3))
@end smallexample

@noindent
Теперь мы используем команду @code{n} (@code{next}), чтобы продолжить
выполнение до следующей строки текущей функции.

@smallexample
(@value{GDBP}) @b{n}
882         set_quotes((argc >= 2) ? TOKEN_DATA_TEXT(argv[1])\
 : nil,
@end smallexample

@noindent
@code{set_quotes} выглядит как нужная нам подпрограмма.  Мы можем войти в
нее, используя команду @code{s} (@code{step}) вместо @code{next}.
@code{step} переходит на следующую исполняемую строку @emph{любой}
подпрограммы, так что она входит в @code{set_quotes}.

@smallexample
(@value{GDBP}) @b{s}
set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
    at input.c:530
530         if (lquote != def_lquote)
@end smallexample

@noindent
Отображение, показывающее подпрограмму (и ее параметры), где @code{m4}
сейчас приостановлен, называется отображением кадра стека.  Оно
показывает обзор стека.  Мы можем использовать команду
@code{backtrace} (которую можно сокращать как @code{bt}), чтобы посмотреть, в
каком месте стека мы находимся: команда @code{backtrace} выводит
кадр стека для каждой активной подпрограммы.

@smallexample
(@value{GDBP}) @b{bt}
#0  set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
    at input.c:530
#1  0x6344 in m4_changequote (argc=3, argv=0x33c70)
    at builtin.c:882
#2  0x8174 in expand_macro (sym=0x33320) at macro.c:242
#3  0x7a88 in expand_token (obs=0x0, t=209696, td=0xf7fffa30)
    at macro.c:71
#4  0x79dc in expand_input () at macro.c:40
#5  0x2930 in main (argc=0, argv=0xf7fffb20) at m4.c:195
@end smallexample

@noindent
Пройдем по шагам еще несколько строк, чтобы понять, что же происходит.
Первые два раза мы можем использовать @samp{s}; следующие два раза
мы пользуемся командой @code{n}, чтобы избежать
вхождения в подпрограмму @code{xstrdup}.

@smallexample
(@value{GDBP}) @b{s}
0x3b5c  532         if (rquote != def_rquote)
(@value{GDBP}) @b{s}
0x3b80  535         lquote = (lq == nil || *lq == '\0') ?  \
def_lquote : xstrdup(lq);
(@value{GDBP}) @b{n}
536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
 : xstrdup(rq);
(@value{GDBP}) @b{n}
538         len_lquote = strlen(rquote);
@end smallexample

@noindent
Последняя выведенная строка выглядит несколько странно; мы можем
исследовать переменные @code{lquote} и @code{rquote}, чтобы понять,
действительно ли это определенные нами новые левая и правая кавычки.
Мы используем команду @code{p} (@code{print}), чтобы посмотреть их значения.

@smallexample
(@value{GDBP}) @b{p lquote}
$1 = 0x35d40 "<QUOTE>"
(@value{GDBP}) @b{p rquote}
$2 = 0x35d50 "<UNQUOTE>"
@end smallexample

@noindent
Действительно, @code{lquote} и @code{rquote} являются новыми кавычками.  Для
просмотра контекста, мы можем вывести десять строк исходного текста,
окружающих текущую строку, используя команду @code{l} (@code{list}).

@smallexample
(@value{GDBP}) @b{l}
533             xfree(rquote);
534
535         lquote = (lq == nil || *lq == '\0') ? def_lquote\
 : xstrdup (lq);
536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
 : xstrdup (rq);
537
538         len_lquote = strlen(rquote);
539         len_rquote = strlen(lquote);
540     @}
541
542     void
@end smallexample

Давайте пройдем еще две строки, которые устанавливают @code{len_lquote} и
@code{len_rquote}, и затем исследуем значения этих переменных.

@smallexample
(@value{GDBP}) @b{n}
539         len_rquote = strlen(lquote);
(@value{GDBP}) @b{n}
540     @}
(@value{GDBP}) @b{p len_lquote}
$3 = 9
(@value{GDBP}) @b{p len_rquote}
$4 = 7
@end smallexample

@noindent
Это, очевидно, неправильно, так как @code{len_lquote} и @code{len_rquote}
обозначают длины переменных @code{lquote} и @code{rquote} соответственно.
Мы можем присвоить им лучшие значения, используя
команду @code{p}, так как она может выводить значение любого выражения, а
выражение может содержать вызовы подпрограмм и присваивания.

@smallexample
(@value{GDBP}) @b{p len_lquote=strlen(lquote)}
$5 = 7
(@value{GDBP}) @b{p len_rquote=strlen(rquote)}
$6 = 9
@end smallexample

@noindent
Достаточно ли этого, чтобы решить проблему использования новых кавычек
во встроенной процедуре @code{m4} @code{defn}?  Мы можем
продолжить выполнение @code{m4} командой @code{c} (@code{continue}),
и затем попробовать пример, первоначально вызывавший ошибку:

@smallexample
(@value{GDBP}) @b{c}
Continuing.

@b{define(baz,defn(<QUOTE>foo<UNQUOTE>))}

baz
0000
@end smallexample

@noindent
Получилось!  Теперь новые кавычки работают так же хорошо, как и стандартные.
Кажется, проблема заключалась лишь в двух опечатках, приводивших к
неправильному определению длин.  Мы позволим @code{m4} выйти, подавая ему
на вход EOF:

@smallexample
@b{C-d}
Program exited normally.@footnote{Программа завершилась нормально.  @i{(Прим.@: переводчика)}}
@end smallexample

@noindent
Сообщение @samp{Program exited normally.}
исходит от @value{GDBN}; оно
показывает, что @code{m4} закончила выполнение.  Мы можем завершить наш
сеанс работы с @value{GDBN} командой @code{quit}.

@smallexample
(@value{GDBP}) @b{quit}
@end smallexample

@node Вызов
@chapter Вход и выход из @value{GDBN}

Эта глава посвящена тому, как запустить @value{GDBN} и как из него выйти.
Основные принципы:
@itemize @bullet
@item
введите @samp{@value{GDBP}} для вызова @value{GDBN}.
@item
введите @code{quit} или @kbd{C-d} для выхода из него.
@end itemize

@menu
* Вызов GDB::                   Как начать работу с @value{GDBN}
* Выход из GDB::                Как выйти из @value{GDBN}
* Команды оболочки::            Как использовать команды оболочки из @value{GDBN}
@end menu

@node Вызов GDB
@section Вызов @value{GDBN}

Вызывайте @value{GDBN} путем запуска программы @code{@value{GDBP}}.
Начав работу, @value{GDBN} считывает команды с терминала до тех пор,
пока вы не скажете ему выйти.

Вы также можете запустить @code{@value{GDBP}} с различными аргументами и
ключами, чтобы с самого начала более детально задать среду отладки.

Ключи командной строки, описанные здесь, предназначены для охвата
различных ситуаций; в действительности, в некоторых средах часть этих
ключей может быть недоступна.

Чаще всего @value{GDBN} вызывается с одним аргументом, который определяет
исполняемую программу:

@example
@value{GDBP} @var{программа}
@end example

@noindent
Вы также можете указать при старте как исполняемую программу, так и файл
дампа памяти:

@example
@value{GDBP} @var{программа} @var{дамп}
@end example

Если вы хотите отладить выполняющийся в данный момент процесс, то
вместо этого, вы можете указать вторым аргументом идентификатор этого
процесса:

@example
@value{GDBP} @var{программа} 1234
@end example

@noindent
присоединит @value{GDBN} к процессу @code{1234} (если, конечно, у вас
нет файла с именем @file{1234}, @value{GDBN} сначала проверяет
наличие файла дампа памяти).

Преимущества, которые можно получить при использовании второго аргумента
командной строки, требуют наличия достаточно полной операционной системы;
если вы используете @value{GDBN} как удаленный отладчик, присоединенный к
компьютеру без операционной системы, там вообще может не быть понятия
``процесса'', и часто нет никакого способа получить дамп.  @value{GDBN}
предупредит вас, если ему не удается присоединиться к процессу или
считать файл дампа памяти.

Вы можете запустить @code{@value{GDBP}} без вывода начального сообщения,
описывающего отсутствие гарантии, задав ключ @code{-silent}:

@smallexample
@value{GDBP} -silent
@end smallexample

@noindent
Кроме того, вы можете контролировать процесс запуска @value{GDBN} с
помощью ключей командной строки.  @value{GDBN} может сам напомнить вам о
доступных ключах.

@noindent
Введите

@example
@value{GDBP} -help
@end example

@noindent
чтобы вывести на экран все доступные ключи с кратким описанием их использования
(сокращенный эквивалент --- @samp{@value{GDBP} -h}).

Все заданные вами ключи и параметры командной строки обрабатываются
последовательно.  Порядок становится важным при использовании ключа @samp{-x}.


@menu
* Параметры файлов::            Выбор файлов
* Параметры режима::            Выбор режимов
@end menu

@node Параметры файлов
@subsection Выбор файлов

При запуске, @value{GDBN} считывает параметры, отличные от ключей, как
указатели на исполняемую программу и файл дампа (или
идентификатор процесса), точно так же, как если бы эти параметры
задавались ключами @samp{-se} и @samp{-c} соответственно.  (@value{GDBN}
считает первый параметр, не имеющий соответствующего флага ключа,
эквивалентом ключа @samp{-se}, за которым следует этот параметр; а
второй такой параметр, если он есть, ---
эквивалентом ключа @samp{-c}, за которым следует этот параметр.)

Если @value{GDBN} был сконфигурирован без включения поддержки файлов дампа,
что имеет место для большинства встроенных целей, то он выразит недовольство
вторым аргументом и проигнорирует его.

Многие ключи имеют как длинную, так и краткую формы;
в следующем списке приводятся обе.  @value{GDBN} также распознает 
недвусмысленные сокращения длинных форм.  (Вы можете,
по желанию, обозначать ключи с помощью @samp{--}, а не @samp{-}, хотя
мы показываем наиболее употребляемый формат.)

@table @code
@item -symbols @var{файл}
@itemx -s @var{файл}
@cindex @code{--symbols}
@cindex @code{-s}
Читать таблицу символов из файла @var{файл}.

@item -exec @var{файл}
@itemx -e @var{файл}
@cindex @code{--exec}
@cindex @code{-e}
Использовать @var{файл} как исполняемый для выполнения и исследования
данных вместе с дампом памяти, когда это необходимо.

@item -se @var{файл}
@cindex @code{--se}
Читать таблицу символов из файла @var{файл} и использовать его как
исполняемый файл.

@item -core @var{файл}
@itemx -c @var{файл}
@cindex @code{--core}
@cindex @code{-c}
Использовать @var{файл} как дамп памяти для исследования.

@item -c @var{номер}
Присоединиться к процессу с идентификатором @var{номер}, также, как
по команде @code{attach} (при условии, что нет файла в формате дампа
памяти с именем @var{номер}; в этом
случае @samp{-c} определяет этот файл как дамп для считывания).

@item -command @var{файл}
@itemx -x @var{файл}
@cindex @code{--command}
@cindex @code{-x}
Выполнить команды @value{GDBN} из файла @var{файл}.  @xref{Командные
файлы,, Командные файлы}.

@item -directory @var{каталог}
@itemx -d @var{каталог}
@cindex @code{--directory}
@cindex @code{-d}
Добавить @var{каталог} к путям поиска файлов с исходными текстами.

@item -m
@itemx -mapped
@cindex @code{--mapped}
@cindex @code{-m}
@emph{Предупреждение: этот ключ зависит от возможностей операционной системы,
которые реализованы не везде.}@*
Если отображаемые в память файлы поддерживаются в вашей системе через
системный вызов @code{mmap}, вы можете использовать этот ключ,
чтобы @value{GDBN} записывал символы из вашей программы в файл в текущем
каталоге, допускающий повторное использование.  Если программа,
которую вы отлаживаете, называется @file{/tmp/fred}, то отображаемым
символьным файлом будет @file{/tmp/fred.syms}.  Последующие отладочные
сеансы @value{GDBN} замечают наличие этого файла и могут быстро
отобразить в память символьную информацию из него, а не читать
таблицу символов из выполняемого файла.

Файл @file{.syms} специфичен для рабочей машины, на которой запускается
@value{GDBN}.  Он содержит точный образ внутренней символьной
таблицы @value{GDBN}.  Он не может быть разделен между несколькими
рабочими платформами.

@item -r
@itemx -readnow
@cindex @code{--readnow}
@cindex @code{-r}
Читать символьную таблицу каждого файла, содержащего таблицу символов,
сразу целиком, а не стандартным образом, при котором она считывается
постепенно по мере необходимости.  Эта команда замедляет запуск, но дальнейшие
операции производятся быстрее.

@end table

Ключи @code{-mapped} и @code{-readnow} обычно используются вместе, чтобы
построить файл @file{.syms}, который содержит полную информацию о
символах.  (@xref{Файлы,,Команды для задания файлов}, для информации о
файлах @file{.syms}.)  Вот простой вызов @value{GDBN}, не делающий
ничего, кроме построения файла @file{.syms} для использования в будущем:

@example
@value{GDBP} -batch -nx -mapped -readnow имя-программы
@end example

@node Параметры режима
@subsection Выбор режимов

Вы можете вызывать @value{GDBN} в различных альтернативных
режимах --- например, в пакетном или в ``тихом'' режиме.

@table @code
@item -nx
@itemx -n
@cindex @code{--nx}
@cindex @code{-n}
Не выполнять команды ни из каких файлов инициализации (обычно
называемых @file{.gdbinit}, или @file{gdb.ini} на PC).  В нормальном
режиме, @value{GDBN} выполняет команды из этих файлов после обработки всех
командных ключей и параметров.  @xref{Командные файлы,,Командные файлы}.

@item -quiet
@itemx -silent
@itemx -q
@cindex @code{--quiet}
@cindex @code{--silent}
@cindex @code{-q}
``Тихий''.  Не печатать вводное сообщение и информацию об авторских
правах.  Эти сообщения также подавляются в пакетном режиме.

@item -batch
@cindex @code{--batch}
Выполняться в пакетном режиме.  Выйти со значением @code{0} после обработки
всех командных файлов, заданных ключом @samp{-x} (и всех команд
из инициализационных файлов, если это не запрещено ключом @samp{-n}).
Выйти с ненулевым значением, если во время выполнения
команд @value{GDBN} из командных файлов произойдет ошибка.

Пакетный режим может быть полезен при вызове @value{GDBN} как
фильтра; например, чтобы загрузить программу и запустить ее на
другом компьютере; чтобы это было более удобно, сообщение

@example
Program exited normally.
@end example

@noindent
(которое обычно выдается при завершении программы, выполняемой
под управлением @value{GDBN}) при выполнении в пакетном режиме не выдается.

@item -nowindows
@itemx -nw
@cindex @code{--nowindows}
@cindex @code{-nw}
``Без окон''.  Если @value{GDBN} имеет встроенный графический интерфейс
пользователя (GUI), то этот ключ велит @value{GDBN} использовать только
интерфейс командной строки.  Если GUI недоступен, этот ключ не
оказывает никакого действия.

@item -windows
@itemx -w
@cindex @code{--windows}
@cindex @code{-w}
Если @value{GDBN} включает GUI, этот ключ требует использовать его, если
только возможно.

@item -cd @var{каталог}
@cindex @code{--cd}
Запустить @value{GDBN}, используя в качестве рабочего каталога
@var{каталог}, вместо текущего.

@item -fullname
@itemx -f
@cindex @code{--fullname}
@cindex @code{-f}
@sc{gnu} Emacs устанавливает этот ключ, когда вызывает @value{GDBN} как
подпроцесс.  Это велит @value{GDBN} выводить полное имя файла и
номер строки в стандартном, распознаваемом стиле всякий раз, когда
отображается кадр стека (что включает каждую остановку вашей программы).
Этот распознаваемый формат выглядит как два знака @samp{\032},
за которыми следует имя файла, номер строки и символьная позиция,
разделенные двоеточиями, и знак новой строки.
Программа интерфейса Emacs-@value{GDBN} использует два
знака @samp{\032} как сигнал для отображения исходного текста
для кадра.

@item -epoch
@cindex @code{--epoch}
Интерфейс Epoch Emacs-@value{GDBN} устанавливает этот ключ, когда
вызывает @value{GDBN} как подпроцесс.  Это велит @value{GDBN} изменить
свои подпрограммы печати так, чтобы позволить Epoch отображать значения
выражений в отдельном окне.

@item -annotate @var{уровень}
@cindex @code{--annotate}
Этот ключ устанавливает @dfn{уровень примечаний} внутри
@value{GDBN}.  Его эффект аналогичен использованию @samp{set annotate
@var{уровень}} (@pxref{Примечания}).  Уровень примечаний контролирует,
какое количество информации @value{GDBN} выводит вместе с приглашением,
значениями выражений, строками исходного текста и другими типами
вывода.  Уровень 0 является обычным, уровень 1
используется, когда @value{GDBN} выполняется как подпроцесс @sc{gnu}
Emacs, уровень 2 выводит максимальное количество примечаний и подходит
для программ, которые управляют @value{GDBN}.

@item -async
@cindex @code{--async}
Использовать асинхронный цикл событий для интерфейса командной строки.
@value{GDBN} обрабатывает все события, такие как ввод пользователя с
клавиатуры, через специальный цикл событий.  Это позволяет @value{GDBN}
принимать и обрабатывать команды пользователя параллельно с выполнением
отлаживаемого процесса@footnote{@value{GDBN}, собранный средствами
@sc{djgpp} для MS-DOS/MS-Windows, поддерживает этот режим
функционирования, но цикл событий приостанавливается, когда выполняется
отлаживаемая программа.}, так что вы не должны ждать возвращения
управления @value{GDBN}, прежде чем ввести следующую команду.
(@emph{Замечание:} в версии 5.0, асинхронное выполнение на целевой
системе еще не поддерживается, так что режим @samp{-async} еще
не полностью реализован.)

Когда стандартный ввод соединен с терминальным устройством, @value{GDBN}
по умолчанию использует асинхронный цикл событий, если это не отключено
ключом @samp{-noasync}.

@item -noasync
@cindex @code{--noasync}
Отключить асинхронный цикл событий для интерфейса командной строки.

@item -baud @var{бод-в-сек}
@itemx -b @var{бод-в-сек}
@cindex @code{--baud}
@cindex @code{-b}
Устанавливает скорость линии (скорость в бодах, или в битах в
секунду) любого последовательного интерфейса, используемого @value{GDBN}
для удаленной отладки.

@item -tty @var{устройство}
@itemx -t @var{устройство}
@cindex @code{--tty}
@cindex @code{-t}
Запуститься, используя @var{устройство} для стандартного ввода и вывода вашей
программы.

@c @item -tui
@c @cindex @code{--tui}
@c Использовать Оконечный Интерфейс Пользователя.  Для информации,
@c прочитайте файл @file{TUI.html}, который в системах HP-UX обычно
@c устанавливается в каталог @code{/opt/langtools/wdb/doc}, используя
@c Web-навигатор.  Не используйте этот ключ, если вы запускаете
@c @value{GDBN} из Emacs (см. @pxref{Emacs, ,Использование @value{GDBN} из
@c sc{gnu} Emacs}).

@c @item -xdb
@c @cindex @code{--xdb}
@c Выполняться в режиме XDB-совместимости, позволяя использовать
@c определенные команды XDB.  Для информации, см. файл
@c @file{xdb_trans.html}, который в системах HP-UX обычно устанавливается
@c в каталог @code{/opt/langtools/wdb/doc}.

@item -interpreter @var{интерп}
@cindex @code{--interpreter}
Использовать интерпретатор @var{интерп} к качестве интерфейса с
управляющей программой или устройством.  Подразумевается, что этот ключ
должен устанавливаться программами, которые взаимодействуют с
@value{GDBN}, используя его как выходной буфер.
Например, @samp{--interpreter=mi} велит @value{GDBN} использовать
@dfn{интерфейс gdbmi} (@pxref{GDB/MI, , Интерфейс @sc{gdb/mi}}).

@item -write
@cindex @code{--write}
Открыть выполняемый файл и файл дампа памяти как для чтения, так и для
записи.  Это эквивалентно команде @value{GDBN} @samp{set write on}
(@pxref{Внесение изменений}).

@item -statistics
@cindex @code{--statistics}
Этот ключ велит @value{GDBN} печатать статистику о времени и
использовании памяти после завершения каждой команды и
возврата к приглашению.

@item -version
@cindex @code{--version}
Этот ключ велит @value{GDBN} напечатать номер своей версии и объявление
об отсутствии гарантий и затем завершиться.

@end table

@node Выход из GDB
@section Выход из @value{GDBN}
@cindex выход из @value{GDBN}

@table @code
@kindex quit @r{[}@var{выражение}@r{]}
@kindex q @r{(@code{quit})}
@item quit @r{[}@var{выражение}@r{]}
@itemx q
Чтобы выйти из @value{GDBN}, используйте команду @code{quit}
(сокращенно @code{q})
или введите знак конца файла (обычно @kbd{C-d}).
Если вы не укажете @var{выражение}, @value{GDBN}
закончит работу нормально; в противном случае, он
использует результат @var{выражения} как код ошибки.
@end table

@cindex прерывание
Прерывание (часто @kbd{C-c}) не приводит к выходу из @value{GDBN},
а завершает любую выполняющуюся команду и возвращает вас
на командный уровень.  Вы можете безопасно пользоваться
прерыванием в любое время, потому что @value{GDBN} не позволяет ему вступить в
силу до того, как это станет безопасным.

Если вы использовали @value{GDBN} для управления присоединенным процессом
или устройством, вы можете освободить его командой @code{detach}
(@pxref{Присоединение, ,Отладка запущенного ранее процесса}).

@node Команды оболочки
@section Команды оболочки

Если вам потребовалось выполнить команды оболочки во время сеанса
отладки, нет смысла приостанавливать или покидать
@value{GDBN}; вам достаточно воспользоваться командой @code{shell}.

@table @code
@kindex shell
@cindex выход в оболочку
@item shell @var{командная строка}
Вызвать стандартную оболочку для выполнения @var{командной строки}.
Переменная среды @env{SHELL}, если она существует, определяет,
какую оболочку запустить.  В противном случае, @value{GDBN}
использует оболочку по умолчанию (@file{/bin/sh} в системах Unix,
@file{COMMAND.COM} в MS-DOS, и так далее).
@end table

В средах разработки часто бывает необходимо воспользоваться
утилитой @code{make}.  Для этой цели вам не обязательно пользоваться
командой @code{shell} в @value{GDBN}:

@table @code
@kindex make
@cindex вызов make
@item make @var{make-арг}
Выполнить программу @code{make} с указанными аргументами.  Это
эквивалентно @samp{shell make @var{make-арг}}.
@end table

@node Команды
@chapter Команды @value{GDBN}

Вы можете сокращать команды @value{GDBN} по нескольким первым знакам
имени команды, если это сокращение однозначно; и вы можете повторять
определенные команды @value{GDBN} простым нажатием @key{RET}.  Вы также
можете использовать клавишу @key{TAB} для того, чтобы @value{GDBN} сам
дополнил остаток слова в команде (или показал вам возможные
альтернативы, если существует несколько вариантов).

@menu
* Синтаксис команд::            Как давать команды @value{GDBN}
* Завершение::                  Завершение команд
* Справка::                     Как запросить помощь у @value{GDBN}
@end menu

@node Синтаксис команд
@section Синтаксис команд

Команда @value{GDBN} представляет собой одну строку ввода.  Никаких
ограничений на ее длину нет.  Она начинается именем команды, за которым
следуют параметры, значение которых определяется ее названием.
Например, команда @code{step} допускает в качестве параметра число
шагов, как в @samp{step 5}.  Вы также можете использовать команду
@code{step} и без параметров.  Некоторые команды не допускают
никаких параметров.

@cindex сокращения
Названия команд @value{GDBN} всегда могут быть сокращены, если это
сокращение однозначно.  Другие возможные сокращения команд перечислены в
документации по отдельным командам.  В некоторых случаях допускаются
даже неоднозначные сокращения; например, @code{s} специально определено
как эквивалент @code{step}, хотя существуют другие команды, чьи
названия начинаются на @code{s}.  Вы можете проверить сокращения,
задавая их как параметр для команды @code{help}.

@cindex повтор команд
@kindex RET
@kindex RET @r{(повторить последнюю команду)}
Введенная пустая строка (просто нажатие @key{RET}), означает повтор
предыдущей команды.  Определенные команды (например, @code{run})
не повторяются таким способом; это те команды, непреднамеренное
повторение которых может вызвать проблемы, и которые вы вряд ли захотите
повторять.

Команды @code{list} и @code{x}, при их повторе нажатием @key{RET},
вместо точного повтора создают новые параметры.  Это позволяет легко
просматривать исходный текст или память.

@value{GDBN} может также использовать @key{RET} по-другому: для
разделения длинного вывода, аналогично обычной утилите @code{more}
(@pxref{Размер экрана,,Размер экрана}).  Так как в такой ситуации легко
нажать @key{RET} слишком много раз, @value{GDBN} блокирует повтор после
любой команды, генерирующей такой тип вывода.

@kindex #
@kindex # @r{(комментарий)}
@cindex комментарий
Любой текст, расположенный от знака @kbd{#} до конца строки является
комментарием; он ничего не делает.  В основном, это полезно в
командных файлах (@pxref{Командные файлы,,Командные файлы}).

@node Завершение
@section Завершение команд

@cindex завершение
@cindex завершение слов
@value{GDBN} может дополнить за вас окончание слова в команде, если
существует только один вариант; он также может в любой момент
показать, какие завершения возможны для следующего слова в
команде.  Это работает для команд и подкоманд @value{GDBN}, а
также для имен символов в вашей программе.

Нажмите @key{TAB} в любой момент, когда захотите, чтобы
@value{GDBN} дополнил оставшуюся часть слова.  Если существует только
одна возможность, @value{GDBN} дополняет слово и ждет, пока вы закончите
команду (или нажмете @key{RET}, чтобы ввести ее).  Например, если вы
введете

@example
(@value{GDBP}) info bre @key{TAB}
@end example

@noindent
@value{GDBN} дополнит остаток слова @samp{breakpoints}, так как у
команды @code{info} есть единственная подкоманда, начинающаяся с @samp{bre}:

@example
(@value{GDBP}) info breakpoints
@end example

@noindent
Теперь вы можете нажать либо @key{RET}, чтобы выполнить команду
@code{info breakpoints}, либо удалить часть знаков и ввести что-то другое,
если @samp{breakpoints} не является той командой, которую вы ожидали.
(Если вы с самого начала были уверены, что хотите @code{info breakpoints},
вы также могли просто нажать @key{RET} сразу после @samp{info bre},
использовав сокращение команды вместо завершения).

Если при нажатии @key{TAB} существует несколько вариантов для следующего
слова, @value{GDBN} издает звук.  Вы можете либо ввести больше знаков
и попробовать снова, либо нажать @key{TAB} второй раз; @value{GDBN}
выведет все возможные завершения для этого слова.  Например, вы можете
захотеть установить точку останова на подпрограмме, чье имя начинается с
@samp{make_}, но когда вы вводите @kbd{b make_@key{TAB}}, @value{GDBN}
лишь издает звук.  Повторное нажатие @key{TAB} отображает все имена
функций в вашей программе, начинающиеся с этих знаков.  Например:

@example
(@value{GDBP}) b make_ @key{TAB}
@exdent @value{GDBN} издает звук; нажав @key{TAB} еще раз, видим:
make_a_section_from_file     make_environ
make_abs_section             make_function_type
make_blockvector             make_pointer_type
make_cleanup                 make_reference_type
make_command                 make_symbol_completion_list
(@value{GDBP}) b make_
@end example

@noindent
После отображения возможных вариантов, @value{GDBN} копирует ваш
частичный ввод (@samp{b make_} в этом примере), так что вы можете закончить
команду.

Если вы сначала хотите только увидеть список альтернатив, вы можете
нажать @kbd{M-?}, а не нажимать @key{TAB} дважды.  @kbd{M-?} означает
@kbd{@key{META} ?}.  Вы можете ввести это, либо нажав @kbd{?}, удерживая клавишу,
обозначенную на вашей клавиатуре как @key{META} (если такая есть),
либо как @key{ESC}, за которой следует @kbd{?}.

@cindex кавычки в командах
@cindex завершение строк, заключенных в кавычки
Иногда нужная вам строка, являясь логически ``словом'', может содержать
скобки или другие знаки, которые @value{GDBN} обычно исключает из
своего понятия о слове.  Чтобы позволить завершению слов работать в
такой ситуации, вы можете заключить слова в командах @value{GDBN} в
@code{'} (знаки одинарных кавычек).

Наиболее вероятная ситуация, где вам это может потребоваться, --- это при
вводе имени функции в Си++.  Это происходит потому, что Си++ допускает
перегрузку функций (множественные определения одной и той же функции,
различающиеся типом параметров).  Например, когда вы хотите установить
точку останова, вам может потребоваться различать, имеете вы в виду
версию @code{name} с параметром целого типа, @code{name(int)}, или же
версию с параметром вещественного типа, @code{name(float)}.  Для
использования возможностей завершения слов в такой ситуации, введите
одинарную кавычку @code{'} в начале имени функции.  Это предупреждает
@value{GDBN}, что ему может потребоваться принять во внимание больше
информации, чем обычно, когда вы нажимаете @key{TAB} или @kbd{M-?} для
запроса завершения слова:

@example
(@value{GDBP}) b 'bubble( @kbd{M-?}
bubble(double,double)    bubble(int,int)
(@value{GDBP}) b 'bubble(
@end example

В некоторых случаях @value{GDBN} может сам определить, что завершение
имени требует использования кавычек.  Когда это происходит, @value{GDBN}
вставляет кавычку за вас (выполняя завершение настолько, на сколько это
возможно), если вы не ввели ее в первой позиции:

@example
(@value{GDBP}) b bub @key{TAB}
@exdent @value{GDBN} изменяет вашу строку ввода на следующую, и издает звук:
(@value{GDBP}) b 'bubble(
@end example

@noindent
Вообще, @value{GDBN} может определить, что кавычка нужна (и вставляет
ее), если вы запрашиваете завершение перегруженного символа до того, как
начали вводить список параметров.

Для получения большей информации о перегруженных функциях, смотрите @ref{Выражения Си++,
, Выражения Си++}.  Вы можете использовать команду @code{set
overload-resolution off} для отключения распознавания перегруженных
символов; смотрите @ref{Отладка Си++, ,Возможности @value{GDBN} для Си++}.


@node Справка
@section Получение справки
@cindex документация
@kindex help

Используя команду @code{help}, вы всегда можете запросить информацию о
командах у самого @value{GDBN}.


@table @code
@kindex h @r{(@code{help})}
@item help
@itemx h
Вы можете использовать @code{help} (сокращенно @code{h}) без параметров
для отображения короткого списка именованных классов команд:

@smallexample
(@value{GDBP}) help
List of classes of commands:

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
stack -- Examining the stack
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without
               stopping the program
user-defined -- User-defined commands

Type "help" followed by a class name for a list of
commands in that class.
Type "help" followed by command name for full
documentation.
Command name abbreviations are allowed if unambiguous.
(@value{GDBP})
@end smallexample

@item help @var{класс}
Используя один из общих классов справки как параметр, вы можете получить
список отдельных команд этого класса.  Вот, например, отображение справки
для класса @code{status}:

@smallexample
(@value{GDBP}) help status
Status inquiries.

List of commands:

@c Line break in "show" line falsifies real output, but needed
@c to fit in smallbook page size.
info -- Generic command for showing things
 about the program being debugged
show -- Generic command for showing things
 about the debugger

Type "help" followed by command name for full
documentation.
Command name abbreviations are allowed if unambiguous.
(@value{GDBP})
@end smallexample

@item help @var{команда}
Если указать имя команды в качестве параметра @code{help}, @value{GDBN}
выведет короткую справку о том, как ей пользоваться.

@kindex apropos
@item apropos @var{арг}
Команда @code{apropos @var{арг}} производит поиск по регулярному
выражению, заданному в @var{арг}, во всех командах @value{GDBN} и их
документации.  Она выводит все найденные совпадения.  Например:

@smallexample
apropos reload
@end smallexample

@noindent выводит:

@smallexample
@c @group
set symbol-reloading -- Set dynamic symbol table reloading
                                 multiple times in one run
show symbol-reloading -- Show dynamic symbol table reloading
                                 multiple times in one run
@c @end group
@end smallexample

@kindex complete
@item complete @var{арг}
Команда @code{complete @var{арг}} перечисляет все возможные завершения для
начала команды.  Используйте @var{арг} для задания начала команды,
которую вы хотите завершить.  Например,

@smallexample
complete i
@end smallexample

@noindent приводит к:

@smallexample
@group
if
ignore
info
inspect
@end group
@end smallexample

@noindent Это предназначено для использования @sc{gnu} Emacs.
@end table

В дополнение к @code{help}, вы можете использовать команды @value{GDBN}
@code{info} и @code{show} для получения информации о состоянии вашей программы,
или о состоянии самого @value{GDBN}.  Каждая команда поддерживает много
тем запросов; это руководство описывает каждую тему в соответствующем месте.
Списки в разделах @code{info} и @code{show} в Алфавитном указателе
указывают на все подкоманды.  @xref{Алфавитный указатель}.

@c @group
@table @code
@kindex info
@kindex i @r{(@code{info})}
@item info
Эта команда (сокращенно @code{i}) предназначена для описания состояния
вашей программы.  Например, вы можете с помощью @code{info args}
просмотреть аргументы, переданные вашей программе, с помощью @code{info
registers} перечислить используемые в настоящий момент регистры или
используя @code{info breakpoints} вывести установленные вами точки
останова.  Вы можете получить полный список подкоманд команды
@code{info} с помощью @w{@code{help info}}.

@kindex set
@item set
Вы можете присвоить переменной среды результат выражения с помощью
@code{set}.  Например, вы можете сделать приглашением @value{GDBN}
знак $ используя @code{set prompt $}.

@kindex show
@item show
В отличие от @code{info}, команда @code{show} предназначена для описания
состояния самого @value{GDBN}.  Вы можете изменить почти все, что
показывает @code{show}, используя соответствующую команду @code{set}.
Например, командой @code{set radix} вы можете указать, какую систему
счисления использовать для вывода, или просто узнать, какая система
используется в данный момент с помощью команды @code{show radix}.

@kindex info set
Для отображения всех устанавливаемых параметров и их текущих значений
вы можете использовать @code{show} без аргументов; также можно
использовать @code{info set}.  Обе команды приводят к одинаковому
результату.
@end table
@c @end group

Вот три еще подкоманды @code{show}; они отличаются от остальных тем, не имеют
соответствующих @code{set}-команд:

@table @code
@kindex show version
@cindex номер версии
@item show version
Показывает, какая версия @value{GDBN} запущена.  Вам следует включать
эту информацию в отчеты об ошибках в @value{GDBN}.  Если вы
используете несколько версий @value{GDBN}, вам может потребоваться
определить, какая из них запущена; по мере развития отладчика
появляются новые команды, а старые могут исчезнуть.  Кроме того, многие
распространители операционных систем поставляют модифицированные версии
@value{GDBN}, также существуют модифицированные версии @value{GDBN} в
@sc{gnu}/Linux.  Номер версии --- это номер, появляющийся при старте.

@kindex show copying
@item show copying
Выводит информацию о правах на распространение @value{GDBN}.

@kindex show warranty
@item show warranty
Отображает заявление @sc{gnu} об отсутствии гарантий, или заявление 
о гарантиях, если ваша версия @value{GDBN} поставляется с гарантиями.

@end table

@node Выполнение
@chapter Выполнение программ под управлением @value{GDBN}

Прежде чем выполнять программу под управлением @value{GDBN}, при
компиляции вы должны сгенерировать отладочную информацию.

Вы можете запустить @value{GDBN} с параметрами или без, в любой среде
по вашему выбору.  Если вы отлаживаете программу на той же машине, на
которой выполняется @value{GDBN}, вы можете перенаправлять ввод и вывод
вашей программы, отлаживать уже выполняющийся процесс или убить
дочерний процесс.

@menu
* Компиляция::                  Компиляция для отладки
* Начало выполнения::           Запуск вашей программы
* Аргументы::                   Аргументы вашей программы
* Среда::                       Среда вашей программы

* Рабочий каталог::             Рабочий каталог вашей программы
* Ввод-вывод::                  Ввод и вывод вашей программы
* Присоединение::               Отладка запущенного ранее процесса
* Уничтожение процесса::        Уничтожение дочернего процесса

* Нити::                        Отладка программ с несколькими нитями
* Процессы::                    Отладка программ с несколькими процессами
@end menu

@node Компиляция
@section Компиляция для отладки

Для эффективной отладки программы, при компиляции вы должны
сгенерировать отладочную информацию.  Эта отладочная информация
сохраняется в объектном файле; она описывает тип данных
каждой переменной или функции и соответствие между номерами строк
исходного текста и адресами в выполняемом коде.

Чтобы запросить генерацию отладочной информации, укажите ключ @samp{-g}
при вызове компилятора.

Многие компиляторы Си не могут обрабатывать ключи @samp{-g} и @samp{-O}
вместе.  Используя такие компиляторы, вы не можете создавать
оптимизированные выполняемые файлы, содержащие отладочную информацию.

@value{NGCC}, @sc{gnu} компилятор Си, поддерживает @samp{-g} вместе с ключом
@samp{-O} или без него, что делает возможной отладку оптимизированного кода.  Мы
рекомендуем вам @emph{всегда} использовать @samp{-g} при
компиляции программ.  Вы можете думать, что ваша программа правильная,
но нет никакого смысла испытывать удачу.

@cindex оптимизированный код, отладка
@cindex отладка оптимизированного кода
Когда вы отлаживаете программу, откомпилированную с @samp{-g -O},
помните, что оптимизатор перестраивает ваш код; отладчик же показывает то, что
там находится в действительности.  Не удивляйтесь, если
порядок выполнения не будет в точности соответствовать вашему исходному
файлу!  Крайний пример: если вы определяете переменную, но нигде ее не
используете, @value{GDBN} никогда не увидит этой переменной, потому
что при оптимизации компилятор ее исключит.

Некоторые вещи не работают с @samp{-g -O} так же хорошо, как с одним @samp{-g},
в частности, на машинах с планированием инструкций.
Если сомневаетесь, перекомпилируйте с одним ключом @samp{-g}, и если это
устранит проблему, пожалуйста, сообщите нам об этом как об ошибке
(включите тестовый пример!).

Ранние версии компилятора @sc{gnu} Си допускали вариант ключа для отладочной
информации @w{@samp{-gg}}.  @value{GDBN} больше не поддерживает этот
формат; если этот ключ есть у вашего компилятора @sc{gnu} Си, не
используйте его.

@need 2000
@node Начало выполнения
@section Начало выполнения вашей программы
@cindex запуск
@cindex выполнение

@table @code
@kindex run
@kindex r @r{(@code{run})}
@item run
@itemx r
Используйте команду @code{run} для запуска вашей программы под
управлением @value{GDBN}.  Сначала вы должны задать имя программы (кроме
как на VxWorks) с параметрами @value{GDBN} (@pxref{Вызов, ,Вход и выход
из @value{GDBN}}), или используя команды @code{file} или @code{exec-file}
(@pxref{Файлы, ,Команды для задания файлов}).

@end table

Если вы запускаете вашу программу в среде выполнения, поддерживающей
процессы, @code{run} создает подчиненный процесс, и этот процесс
выполняет вашу программу.  (В средах, не поддерживающих процессы,
@code{run} выполняет переход на начало вашей программы.)

Выполнение программы зависит от определенной информации, которую она
получает от породившего ее процесса.  @value{GDBN} предоставляет способы
задать эту информацию, что вы должны сделать @emph{до} запуска
программы.  (Вы можете изменить ее после старта, но такие
изменения воздействуют на вашу программу только при следующем запуске.)
Эта информация может быть разделена на четыре категории:

@table @asis
@item @emph{Параметры.}
Задайте параметры, которые нужно передать вашей программе, в качестве параметров
команды @code{run}.  Если на вашей системе доступна оболочка, она
используется для передачи параметров, так что при их описании вы можете
использовать обычные соглашения (такие как раскрывание шаблонов или
подстановка переменных).
В системах Unix, вы можете контролировать, какая оболочка используется, с
помощью переменной среды @code{SHELL}.
@xref{Аргументы, ,Аргументы вашей программы}.

@item @emph{Среда.}
Обычно ваша программа наследует свою среду от @value{GDBN}, но вы
можете использовать команды @value{GDBN} @code{set environment} и
@code{unset environment}, чтобы изменить часть настроек среды, влияющих
на нее.  @xref{Среда, ,Рабочая среда вашей программы}.

@item @emph{Рабочий каталог.}
Ваша программа наследует свой рабочий каталог от @value{GDBN}.  Вы
можете установить рабочий каталог @value{GDBN} командой @code{cd}.
@xref{Рабочий каталог, ,Рабочий каталог вашей программы}.

@item @emph{Стандартный ввод и вывод.}
Обычно ваша программа использует те же устройства для стандартного
ввода и вывода, что и @value{GDBN}.  Вы можете перенаправить ввод и
вывод в строке команды @code{run} или использовать команду @code{tty},
чтобы установить другое устройство для вашей программы.
@xref{Ввод-вывод, ,Ввод и вывод вашей программы}.

@cindex каналы
@emph{Предупреждение:} Хотя перенаправление ввода и вывода работает, вы
не можете использовать каналы для передачи выходных данных отлаживаемой
программы другой программе; если вы попытаетесь это сделать, скорее
всего @value{GDBN} перейдет к отладке не той программы.
@end table

Когда вы подаете команду @code{run}, ваша программа начинает выполняться
немедленно.  @xref{Остановка, ,Остановка и продолжение}, для обсуждения
того, как остановить вашу программу.  Как только программа
остановилась, вы можете вызывать функции вашей программы, используя
команды @code{print} или @code{call}.  @xref{Данные, ,Исследование данных}.

Если время модификации символьного файла изменилось с того
момента, когда @value{GDBN} последний раз считывал символы, он
уничтожает свою символьную таблицу и считывает ее заново.  При этом
@value{GDBN} старается сохранить ваши текущие точки останова.

@node Аргументы
@section Аргументы вашей программы

@cindex аргументы (вашей программы)
Аргументы к вашей программе могут быть заданы как аргументы к команде
@code{run}.
Они передаются оболочке, которая раскрывает символы шаблонов и выполняет
перенаправление ввода-вывода, и с того момента попадают в вашу
программу.  Переменная среды @code{SHELL} (если она существует)
определяет, какую оболочку использует @value{GDBN}.  Если вы не
определите @code{SHELL}, он использует оболочку по умолчанию
(@file{/bin/sh} в Unix).

В не-Unix-системах, программу обычно запускает непосредственно
@value{GDBN}, который эмулирует перенаправление ввода-вывода через
соответствующие системные вызовы, и символы шаблонов раскрываются кодом
запуска, а не оболочкой.

@code{run} без аргументов использует те же аргументы, которые
использовались предыдущей командой @code{run}, или которые установлены
командой @code{set args}.

@table @code
@kindex set args
@item set args
Задает аргументы, которые будут использоваться при следующем запуске
вашей программы.  Если у @code{set args} нет аргументов, @code{run}
выполняет вашу программу без аргументов.  Если вы запустили
программу с аргументами, то единственный способ запустить ее
снова без аргументов --- это использовать @code{set args} до следующего
запуска командой @code{run}.

@kindex show args
@item show args
Показать аргументы, которые будут переданы вашей программе при ее вызове.
@end table

@node Среда
@section Рабочая среда вашей программы

@cindex среда (вашей программы)
@dfn{Среда} состоит из набора переменных среды и их значений.
Переменные среды обычно хранят такие данные, как ваше имя пользователя,
домашний каталог, тип терминала и путь поиска для
запуска программ.  Как правило, вы устанавливаете переменные среды с
помощью оболочки, и они наследуются всеми другими программами, которые вы
вызываете.  При отладке может оказаться полезным попробовать
запустить программу в измененной среде, не перезапуская
@value{GDBN}.

@table @code
@kindex path
@item path @var{каталог}
Добавить @var{каталог} в начало переменной среды @code{PATH} (пути
поиска выполняемых файлов), как для @value{GDBN}, так и для вашей
программы.  Вы можете указать названия нескольких каталогов, разделив их
пробелом или системно-зависимым разделителем (@samp{:} в Unix, @samp{;}
в MS-DOS и MS-Windows).  Если @var{каталог} уже находится в списке путей,
он переносится в начало, так что поиск в нем будет производиться
раньше.

Вы можете использовать строку @samp{cwd}, чтобы сослаться на
рабочий каталог, который является текущим в тот момент, когда
@value{GDBN} производит поиск.  Если вместо этого вы используете
@samp{.}, то она будет указывать на тот каталог, в котором вы
выполнили команду @code{path}.  @value{GDBN} заменяет @samp{.} в
аргументе @var{каталог} (на текущий путь) до добавления @var{каталога} к
списку путей поиска.

@kindex show paths
@item show paths
Отобразить список путей для поиска выполняемых файлов (переменную среды
@code{PATH}).

@kindex show environment
@item show environment @r{[}@var{имя-перем}@r{]}
Вывести значение переменной среды @var{имя-перем}, которое будет
передано вашей программе при ее старте.  Если вы не указываете
@var{имя-перем}, вывести названия и значения всех переменных среды,
передаваемых вашей программе.  Вы можете сократить
@code{environment} как @code{env}.

@kindex set environment
@item set environment @var{имя-перем} @r{[}=@var{значение}@r{]}
Присваивает @var{значение} переменной среды @var{имя-перем}.  Значение
меняется только для вашей программы, но не для самого @value{GDBN}.
@var{значение} может быть любой строкой; значениями переменных среды
являются просто строки, а их интерпретацию обеспечивает ваша
программа.  Параметр @var{значение} является необязательным; если он
опущен, переменная устанавливается в пустое значение.

Например, эта команда:

@example
set env USER = foo
@end example

@noindent
говорит отлаживаемой программе, что при последующих запусках именем
пользователя является @samp{foo}.  (Пробелы, окружающие @samp{=},
использованы здесь для ясности; в действительности, они не обязательны.)

@kindex unset environment
@item unset environment @var{имя-перем}
Удалить переменную @var{имя-перем} из среды, передаваемой вашей
программе.  Это отличается от @samp{set env @var{имя-перем} =};
@code{unset environment} удаляет переменную из среды, а не присваивает
ей пустое значение.
@end table

@emph{Предупреждение:} В системах Unix, @value{GDBN} вызывает вашу
программу, используя оболочку, указанную вашей переменной среды
@code{SHELL}, если она определена (или @code{/bin/sh}, если не
определена).  Если переменная @code{SHELL} указывает на оболочку,
которая выполняет файл инициализации --- такой как @file{.cshrc} для
оболочки C-shell, или @file{.bashrc} для BASH --- любая переменная, которую вы
установите в этом файле, воздействует на вашу программу.  В этой
связи, вы можете захотеть перенести установку переменных среды в
файлы, которые выполняются только при входе в систему, такие как
@file{.login} или @file{.profile}.

@node Рабочий каталог
@section Рабочий каталог вашей программы

@cindex рабочий каталог (вашей программы)
Каждый раз, когда вы запускаете свою программу командой @code{run}, она
наследует рабочий каталог от текущего рабочего каталога
@value{GDBN}.  В начальный момент, рабочий каталог @value{GDBN}
наследуется от его родительского процесса (обычно оболочки), но вы
можете задать новый рабочий каталог командой @code{cd} из @value{GDBN}.

Рабочий каталог @value{GDBN} также служит каталогом по умолчанию для
команд отладчика, определяющих действия с файлами.  @xref{Файлы,
,Команды для задания файлов}.

@table @code
@kindex cd
@item cd @var{каталог}
Установить рабочий каталог @value{GDBN} в @var{каталог}.

@kindex pwd
@item pwd
Вывести рабочий каталог @value{GDBN}.
@end table

@node Ввод-вывод
@section Ввод и вывод вашей программы

@cindex перенаправление
@cindex ввод-вывод
@cindex терминал
По умолчанию, программа, которую вы запускаете под управлением
@value{GDBN}, осуществляет ввод и вывод на тот же терминал, что и
@value{GDBN}.  Для взаимодействия с вами, @value{GDBN} переключает
терминал в свой собственный терминальный режим, но он записывает
терминальные режимы, которые использовала ваша программа, и
переключается назад к ним, когда вы продолжаете выполнение программы.

@table @code
@kindex info terminal
@item info terminal
Отображает информацию, записанную @value{GDBN} о терминальных режимах,
которые использует ваша программа.
@end table

Вы можете перенаправить ввод и/или вывод вашей программы, используя
перенаправление оболочки с помощью команды @code{run}.  Например,

@example
run > выходной-файл
@end example

@noindent
запускает вашу программу, перенаправляя ее вывод в @file{выходной-файл}.

@kindex tty
@cindex управляющий терминал
Другой способ задать, как ваша программа должна осуществлять ввод и
вывод, --- использовать команду @code{tty}.  Эта команда принимает в
качестве аргумента имя файла, который будет использоваться по умолчанию
для будущих команд @code{run}.  Она также сбрасывает управляющий
терминал для дочернего процесса для будущих команд @code{run}.
Например,

@example
tty /dev/ttyb
@end example

@noindent
указывает, что процессы, запущенные последующими командами @code{run},
для ввода и вывода используют по умолчанию терминал @file{/dev/ttyb}, и
что он будет их управляющим терминалом.

Явное перенаправление в @code{run} замещает эффект команды @code{tty}
для устройств ввода-вывода, но не ее воздействие на управляющий терминал.

Когда вы используете команду @code{tty} или перенаправляете ввод в
команде @code{run}, изменяется только ввод @emph{для вашей программы}.
Ввод для @value{GDBN} по прежнему происходит через ваш терминал.

@node Присоединение
@section Отладка запущенного ранее процесса
@kindex attach
@cindex присоединение

@table @code
@item attach @var{идент-процесса}
Эта команда присоединяется к выполняющемуся процессу --- процессу, который
был запущен вне @value{GDBN}.  (Команда @code{info files} показывает ваши
активные цели.)  В качестве аргумента эта команда получает идентификатор
процесса.  Обычный способ узнать идентификатор
Unix-процесса --- воспользоваться утилитой @code{ps} или командой оболочки
@samp{jobs -l}.

@code{attach} не повторяется, если вы нажмете @key{RET} второй раз
после выполнения команды.
@end table

Чтобы использовать @code{attach}, ваша программа должна выполняться в
среде, поддерживающей процессы; например, @code{attach} не работает на
специальных машинах, не имеющих операционной системы.  Вы также должны
обладать полномочиями для посылки сигнала процессу.

Когда вы используете @code{attach}, отладчик находит программу
выполняющегося процесса, производя поиск сперва в текущем рабочем
каталоге, а затем (если программа не найдена), используя пути поиска
исходных файлов (@pxref{Пути для исходных файлов, ,Определение каталогов с
исходными файлами}).  Также, для загрузки программы вы можете
использовать команду @code{file}.  @xref{Файлы, ,Команды для задания
файлов}.

Первое, что @value{GDBN} делает после подготовки указанного процесса к
отладке --- останавливает его.  Вы можете исследовать и изменять
присоединенный процесс всеми командами @value{GDBN}, которые обычно
доступны, когда вы запускаете процессы с помощью @code{run}.  Вы можете
устанавливать точки останова; вы можете пошагово выполнять программу и
продолжить ее обычное выполнение, вы можете изменять области данных.
Если вы решите продолжить выполнение процесса после присоединения к нему
@value{GDBN}, вы можете использовать команду @code{continue}.

@table @code
@kindex detach
@item detach
Когда вы закончили отлаживать присоединенный процесс, для его
освобождения из-под управления @value{GDBN} вы можете использовать
команду @code{detach}.  Отсоединение процесса продолжает его
выполнение.  После команды @code{detach}, этот процесс и
@value{GDBN} снова становятся совершенно независимыми, и вы готовы
присоединить или запустить с помощью @code{run} другой процесс.
@code{detach} не повторяется, если вы нажмете @key{RET} еще раз.
@end table

Если вы выйдете из @value{GDBN} или используете команду @code{run}, пока
у вас есть присоединенный процесс, вы убьете этот процесс.  По
умолчанию, @value{GDBN} запрашивает подтверждение, если вы пытаетесь
сделать одну из этих вещей; вы можете контролировать, нужно вам это
подтверждение или нет, используя команду @code{set confirm}
(@pxref{Сообщения/предупреждения, ,Необязательные предупреждения и
сообщения}).

@node Уничтожение процесса
@section Уничтожение дочернего процесса

@table @code
@kindex kill
@item kill
Уничтожить дочерний процесс, в котором ваша программа выполняется под
управлением @value{GDBN}.
@end table

Эта команда полезна, если вы хотите отладить дамп памяти, а не
выполняющийся процесс.  @value{GDBN} игнорирует любые дампы памяти, пока
ваша программа выполняется.

В некоторых операционных системах программа не может быть выполнена вне
@value{GDBN}, пока в ней есть точки останова, установленные
отладчиком.  В этой ситуации вы можете использовать команду
@code{kill}, чтобы разрешить выполнение вашей программы вне отладчика.

Команда @code{kill} также полезна, если вы хотите перекомпилировать и
перекомпоновать вашу программу, так как во многих системах невозможно
модифицировать исполняемый файл во время выполнения процесса.  В этом
случае, когда вы в следующий раз введете @code{run}, @value{GDBN}
заметит, что файл изменился, и заново прочитает символьную таблицу
(стараясь при этом сохранить ваши точки останова).

@node Нити
@section Отладка программ с несколькими нитями

@cindex нити выполнения
@cindex переключение между нитями
В некоторых операционных системах, таких как HP-UX и Solaris, одна
программа может иметь несколько @dfn{нитей} выполнения.  Точная семантика
нитей меняется от одной операционной системы к другой, но в общем, нити
одной программы сродни нескольким процессам --- за исключением того, что
они разделяют одно адресное пространство (то есть, все они могут исследовать и
модифицировать одни и те же переменные).  С другой стороны, каждая нить
имеет свои собственные регистры и стек выполнения, и, возможно, свои
собственные участки памяти.

@value{GDBN} предоставляет следующие возможности для отладки
многонитевых программ:

@itemize @bullet
@item автоматическое уведомление о новых нитях
@item @samp{thread @var{номер-нити}}, команда для переключения между
нитями
@item @samp{info threads}, команда для запроса информации о
существующих нитях
@item @samp{thread apply [@var{номер-нити}] [@var{all}] @var{арг}},
команда для применения некоторой команды к списку нитей
@item точки останова, определяемые отдельно для каждой нити
@end itemize

@quotation
@emph{Предупреждение:} Пока эти возможности доступны не в любой
конфигурации @value{GDBN}, где операционная система поддерживает нити.
Если ваш @value{GDBN} не поддерживает нити, эти команды не имеют
эффекта.  Например, в системах без поддержки нитей @value{GDBN} ничего
не выводит на команду @samp{info threads} и всегда отвергает команду
@code{thread}, как в этом примере:

@smallexample
(@value{GDBP}) info threads
(@value{GDBP}) thread 1
Thread ID 1 not known.  Use the "info threads" command to
see the IDs of currently known threads.@footnote{Нить с идентификатором 1 неизвестна.  Используйте команду "info threads", чтобы получить идентификаторы известных нитей.  @i{(Прим.@: переводчика)}}
@end smallexample
@end quotation

@cindex нить, выделенная для отладки
@cindex текущая нить
Возможности @value{GDBN} для отладки нитей позволяют вам наблюдать все нити
во время выполнения вашей программы, но когда управление переходит к
@value{GDBN}, одна конкретная нить выделяется для отладки.  Она
называется @dfn{текущей нитью}.  Отладочные команды показывают
информацию о программе с точки зрения текущей нити.

@cindex сообщение о новом @var{сист-теге}
@cindex идентификатор нити (системный)
Когда @value{GDBN} обнаруживает новую нить в вашей программе, он выводит
для нее идентификатор на целевой системе с сообщением в форме @samp{[New
@var{сист-тег}]}.  @var{Сист-тег} является идентификатором нити, чья форма
различается в зависимости от конкретной системы.  Например, в LynxOS вы
можете увидеть

@example
[New process 35 thread 27]
@end example

@noindent
когда @value{GDBN} замечает новую нить.  Напротив, в системе SGI,
@var{сист-тег} выглядит просто как @samp{process 368}, без дополнительных
спецификаций.

@cindex номер нити
@cindex идентификатор нити (@value{GDBN})
Для отладочных целей, @value{GDBN} присваивает свои собственные номера
нитей --- всегда в виде одного целого числа --- каждой нити в вашей
программе.

@table @code
@kindex info threads
@item info threads
Вывести краткую информацию обо всех имеющихся в данный момент в вашей
программе нитях.  Для каждой нити, @value{GDBN} отображает (в этом
порядке):

@enumerate
@item номер нити, назначенный @value{GDBN}

@item идентификатор нити на целевой системе (@var{сист-тег})

@item краткие сведения о текущем кадре стека для этой нити
@end enumerate

@noindent
Звездочка @samp{*} слева от номера нити @value{GDBN} обозначает текущую
нить.

Например,
@end table

@smallexample
(@value{GDBP}) info threads
  3 process 35 thread 27  0x34e5 in sigpause ()
  2 process 35 thread 23  0x34e5 in sigpause ()
* 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
    at threadtest.c:68
@end smallexample

В системах HP-UX:

@cindex номер нити
@cindex идентификатор нити (@value{GDBN})
Для отладочных целей, @value{GDBN} присваивает свои собственные номера
нитей --- небольшие целые, присваиваемые в порядке создания нитей ---
каждой нити в вашей программе.

@cindex сообщение о новом @var{сист-теге}, в HP-UX
@cindex идентификатор нити (системный), в HP-UX
Когда @value{GDBN} обнаруживает новую нить в вашей программе, он выводит
как номер нити, присвоенный @value{GDBN}, так и идентификатор на целевой
системе для нити с сообщением в форме @samp{[New @var{сист-тег}]}.
@var{сист-тег} является идентификатором нити, чья форма
различается в зависимости от конкретной системы.  Например, в HP-UX,
когда @value{GDBN} замечает новую нить, вы увидите

@example
[New thread 2 (system thread 26594)]
@end example


@table @code
@kindex info threads
@item info threads
Вывести краткую информацию обо всех имеющихся в данный момент в вашей
программе нитях.  Для каждой нити, @value{GDBN} отображает (в этом
порядке):

@enumerate
@item номер нити, назначенный @value{GDBN}

@item идентификатор нити на целевой системе (@var{сист-тег})

@item краткие сведения о текущем кадре стека для этой нити
@end enumerate

@noindent
Звездочка @samp{*} слева от номера нити @value{GDBN} означает текущую
нить.

Например,
@end table

@example
(@value{GDBP}) info threads
    * 3 system thread 26607  worker (wptr=0x7b09c318 "@@") \@*
                               at quicksort.c:137
      2 system thread 26606  0x7b0030d8 in __ksleep () \@*
                               from /usr/lib/libc.2
      1 system thread 27905  0x7b003498 in _brk () \@*
                               from /usr/lib/libc.2
@end example

@table @code
@kindex thread @var{номер-нити}
@item thread @var{номер-нити}
Сделать нить с номером @var{номер-нити} текущей.  Аргумент команды,
@var{номер-нити}, является внутренним номером нити @value{GDBN}, который
показан в первом поле @samp{info threads}.  @value{GDBN} отвечает,
выводя системный идентификатор выбранной вами нити и обзор ее кадра
стека:

@smallexample
(@value{GDBP}) thread 2
[Switching to process 35 thread 23]
0x34e5 in sigpause ()
@end smallexample

@noindent
Также как и с сообщением @samp{[New @dots{}]}, форма текста после
@samp{Switching to} зависит от соглашений для идентификации нитей в
вашей системе.

@kindex threads apply
@item threads apply [@var{номер-нити}] [@var{all}] @var{арг}
Команда @code{thread apply} позволяет вам применить команду к одной или
нескольким нитям.  Задайте номера нитей, на которые вы хотите
воздействовать, в аргументе @var{номер-нити}.  @var{Номер-нити} --- это
внутренний номер нити @value{GDBN}, который показан в первом поле
@samp{info threads}.  Чтобы применить команду ко всем нитям, используйте
@code{thread apply all} @var{арг}.
@end table

@cindex автоматический выбор нити
@cindex автоматическое переключение между нитями
@cindex нити, автоматическое переключение
Когда @value{GDBN} останавливает вашу программу, вследствие точки
останова или по сигналу, он автоматически выбирает нить, в которой
появилась эта точка останова или сигнал.  @value{GDBN} предупреждает вас о
переключении контекста сообщением в форме @samp{[Switching to
@var{сист-тег}]} для идентификации нити.

@xref{Остановка нитей,,Остановка и запуск многонитевых программ}, для
дополнительной информации о поведении @value{GDBN}, когда вы
останавливаете и запускаете многонитевую программу.

@xref{Установка точек наблюдения,,Установка точек наблюдения}, для
информации о точках наблюдения в многонитевых программах.

@node Процессы
@section Отладка многонитевых программ

@cindex fork, отладка программ, использующих этот вызов
@cindex многие процессы
В большинстве систем @value{GDBN} не имеет специальной поддержки для
отладки программ, создающих дополнительные процессы с помощью функции
@code{fork}.  Когда программа вызывает @code{fork}, @value{GDBN} будет
продолжать отладку родительского процесса, а дочерний процесс будет
выполняться беспрепятственно.  Если выполнение дочернего процесса дойдет
до места, где вы установили точку останова, дочерний процесс получит
сигнал @code{SIGTRAP}, который приведет к остановке процесса (если он не
перехватывает этот сигнал).

Однако, если вы хотите отладить дочерний процесс, существует достаточно
простое решение.  Поместите вызов @code{sleep} в код программы, который
дочерний процесс выполнит после @code{fork}.  Может быть удобным
вызывать @code{sleep}, только если установлена определенная переменная
среды, или если существует определенный файл, так что задержка не будет
происходить, если вы не захотите отлаживать дочерний процесс.
Пока дочерний процесс спит, используйте программу @code{ps} для
получения его идентификатора.  Затем укажите @value{GDBN}
(новому экземпляру @value{GDBN}, если вы отлаживаете также и родительский
процесс) присоединиться к дочернему процессу (@pxref{Присоединение}).
Начиная с этого момента, вы можете отлаживать дочерний процесс точно
так же, как любой другой процесс, к которому вы присоединились.

В системе HP-UX (только в версиях 11.x и более поздних?) @value{GDBN}
предоставляет средства для отладки программ, которые создают
дополнительные процессы, используя функции @code{fork} или @code{vfork}.

По умолчанию, когда программа ветвится, @value{GDBN} будет продолжать
отладку родительского процесса, а дочерний процесс будет выполняться
беспрепятственно.

Если вы хотите отлаживать дочерний процесс вместо родительского,
используйте команду @w{@code{set follow-fork-mode}}.

@table @code
@kindex set follow-fork-mode
@item set follow-fork-mode @var{режим}
Устанавливает реакцию отладчика на вызов @code{fork} или @code{vfork} в
программе.  Вызов @code{fork} или @code{vfork} создает новый процесс.
@var{режим} может быть:

@table @code
@item parent
После ветвления отлаживается исходный процесс.  Дочерний процесс
выполняется беспрепятственно.  Это поведение по умолчанию.

@item child
После ветвления отлаживается новый процесс.  Родительский процесс
выполняется беспрепятственно.

@item ask
Отладчик будет запрашивать один из этих вариантов.
@end table

@item show follow-fork-mode
Отображает текущую реакцию отладчика на вызов @code{fork} или
@code{vfork}.
@end table

Если вы запрашиваете отладку дочернего процесса, и за
@code{vfork} следует @code{exec}, @value{GDBN} выполняет новую программу
до первой установленной в ней точки останова.  Если в вашей исходной
программе была установлена точка останова на функции @code{main},
она будет также установлена на @code{main} в
дочернем процессе.

Когда дочерний процесс порождается вызовом @code{vfork}, вы не можете
отлаживать дочерний или родительский процесс до тех пор, пока не
завершится вызов @code{exec}.

Если вы даете @value{GDBN} команду @code{run} после выполнения
@code{exec}, новая программа стартует заново.  Чтобы перезапустить
родительский процесс, используйте команду @code{file} с именем
выполняемого файла родительской программы в качестве аргумента.

Вы можете использовать команду @code{catch}, чтобы остановить
@value{GDBN}, когда сделан вызов @code{fork}, @code{vfork} или
@code{exec}.  @xref{Установка точек перехвата, ,Установка точек перехвата}.

@node Остановка
@chapter Остановка и продолжение исполнения

Основные цели применения отладчика --- позволить вам остановить программу до ее
завершения или, в случае нарушений в работе программы, исследовать программу и
выяснить причину неполадок.

Внутри @value{GDBN} ваша программа может остановиться по нескольким
причинам, таким как сигнал, точка останова или достижение новой строки
после команды @value{GDBN}, такой как @code{step}.  Затем вы можете
исследовать и изменять значения переменных, устанавливать новые точки
останова и удалять старые и затем продолжить выполнение.  Обычно
выводимые @value{GDBN} сообщения предоставляют достаточную информацию о
состоянии вашей программы, но вы также можете запросить эту информацию
явно в любое время.

@table @code
@kindex info program
@item info program
Отобразить информацию о состоянии вашей программы: выполняется она или
нет, каким процессом она является, и почему остановлена.
@end table

@menu
* Точки останова::              Точки останова, наблюдения и перехвата
* Продолжение и пошаговое выполнение::
                                Возобновление выполнения
* Сигналы::                     Сигналы
* Остановка нитей::             Остановка и запуск многонитевых программ
@end menu

@node Точки останова
@section Точки останова, точки наблюдения и точки перехвата

@cindex точки останова
@dfn{Точка останова} останавливает вашу программу всякий раз, когда ее
выполнение достигает определенного места.  Для каждой точки останова вы
можете добавлять условия для лучшего управления условиями остановки.
Вы можете устанавливать точки останова командой
@code{break} и ее вариантами (@pxref{Установка точек останова,
,Установка точек останова}), чтобы задать место, где должна остановиться
ваша программа, по номеру строки, имени функции или точному адресу.

В конфигурациях HP-UX, SunOS 4.x, SVR4 и Alpha OSF/1, вы можете устанавливать
точки останова в разделяемых библиотеках до запуска выполняемого файла.
В системах HP-UX существует небольшое ограничение: вы должны подождать,
пока программа не перестанет выполняться, для установки точек
останова в подпрограммах из разделяемой библиотеки, которые не
вызываются напрямую из программы (например, подпрограммах, являющихся
аргументами вызова @code{pthread_create}).

@cindex точки наблюдения
@cindex трассировка памяти
@cindex точка останова по адресу памяти
@cindex точка останова по изменению переменной
@dfn{Точка наблюдения} --- это специальная точка останова, которая
останавливает вашу программу при изменении значения выражения.  Вы
должны использовать другую команду для установки точки наблюдения
(@pxref{Установка точек наблюдения, ,Установка точек наблюдения}), но
помимо этого, вы можете обращаться с ней так же, как с любой
другой точкой останова: вы включаете, отключаете и удаляете точки
останова и точки наблюдения при помощи одних и тех же команд.

Вы можете сделать так, чтобы при каждой остановке в точке останова
автоматически отображались некоторые значения из вашей программы.
@xref{Автоматическое отображение, ,Автоматическое отображение}.

@cindex точки перехвата
@cindex точка останова по событию
@dfn{Точка перехвата} --- это другая специализированная точка останова,
которая останавливает вашу программу при возникновении события
определенного типа, такого как выбрасывание исключения в Си++ или
загрузка библиотеки.  Так же, как с точками наблюдения, вы используете
другую команду для установки точки перехвата, (@pxref{Установка точек
перехвата, ,Установка точек перехвата}), но помимо этого, вы можете
обращаться с ней так же, как с любой другой точкой останова.  (Для
остановки, когда ваша программа получает сигнал, используйте команду
@code{handle}; смотрите @ref{Сигналы, ,Сигналы}.)

@cindex номера точек останова
@cindex номера для точек останова
Когда вы создаете точку останова, наблюдения или перехвата, @value{GDBN}
присваивает ей номер; эти номера являются последовательными
целыми числами, начинающимися с единицы.  Во многих командах для
управления различными возможностями точек останова вы используете эти
номера для указания точки останова, которую вы хотите изменить.  Каждая
точка останова может быть @dfn{включена} или @dfn{отключена}; если точка
останова отключена, она не оказывает никакого влияния на вашу программу,
пока вы снова не включите ее.

@cindex диапазоны точек останова
@cindex диапазоны для точек останова
Некоторые команды @value{GDBN} допускают в качестве указания точек
останова, на которые они действуют, их диапазоны.  Диапазон точек
останова --- это или номер одной точки, например @samp{5}, или два таких
номера, в порядке увеличения, разделенные дефисом, например @samp{5-7}.
Когда команде задается диапазон точек останова, она действует на все
точки останова в этом диапазоне.

@menu
* Установка точек останова::    Установка точек останова
* Установка точек наблюдения::  Установка точек наблюдения
* Установка точек перехвата::   Установка точек перехвата
* Удаление точек останова::     Удаление точек останова
* Отключение::                  Отключение точек останова
* Условия::                     Условия останова
* Команды останова::            Команды точки останова
* Меню точки останова::         Меню точки останова
* Ошибки в точках останова::    ``Не удается поместить точки останова''
@end menu

@node Установка точек останова
@subsection Установка точек останова

@kindex break
@kindex b @r{(@code{break})}
@vindex $bpnum@r{, вспомогательная переменная}
@cindex последняя точка останова
Точки останова устанавливаются командой @code{break} (сокращенно
@code{b}).  Вспомогательная переменная отладчика @samp{$bpnum} хранит
номер последней установленной вами точки останова; смотрите
@ref{Вспомогательные переменные,,Вспомогательные переменные}, для
обсуждения того, что вы можете делать со вспомогательными переменными.

Вы можете задавать место для установки новой точки останова несколькими
способами.

@table @code
@item break @var{функция}
Установить точку останова на входе в функцию @var{функция}.
При использовании языков, допускающих перегрузку символов, таких как
Си++, @var{функция} может ссылаться более чем на одно возможное место
останова.  @xref{Меню точки останова,,Меню точки останова}, для
обсуждения такой ситуации.

@item break +@var{смещение}
@itemx break -@var{смещение}
Установить точку останова через несколько строк впереди или сзади от
позиции, на которой выполнение остановилось в текущем выбранном
@dfn{кадре стека}.  (@xref{Кадры, ,Кадры стека}, для описания кадров стека.)

@item break @var{номер-строки}
Установить точку останова на строке @var{номер-строки} в текущем
исходном файле.  Текущий исходный файл --- это файл, исходный текст
которого отображался последним.  Точка останова остановит вашу программу
сразу перед выполнением какого-либо кода на этой строке.

@item break @var{имя-файла}:@var{номер-строки}
Установить точку останова на строке @var{номер-строки} в исходном
файле @var{имя-файла}.

@item break @var{имя-файла}:@var{функция}
Установить точку останова на входе в @var{функцию},
находящуюся в файле @var{имя-файла}.  Указание имени файла вместе с
именем функции является излишним, за исключением ситуаций, когда
несколько файлов содержат одинаково названные функции.

@item break *@var{адрес}
Установить точку останова по адресу @var{адрес}.  Вы можете
использовать это для установки точек останова в тех частях вашей
программы, которые не имеют отладочной информации или исходных файлов.

@item break
При вызове без аргументов, @code{break} устанавливает точку останова на
инструкции, которая должна быть выполнена следующей в выбранном кадре
стека (@pxref{Стек, ,Исследование стека}).  В любом выбранном кадре,
кроме самого внутреннего, это останавливает вашу программу, как только
управление возвращается в этот кадр.  Это похоже на результат команды
@code{finish} в кадре внутри выбранного кадра --- за исключением того, что
@code{finish} не оставляет активной точки останова.  Если вы используете
@code{break} без аргументов в самом внутреннем кадре, @value{GDBN}
останавливается, когда в следующий раз достигает текущего места; это
может быть полезно внутри циклов.

Обычно @value{GDBN} игнорирует точки останова, когда он возобновляет
выполнение, пока не будет выполнена хотя бы одна
инструкция.  Если бы он этого не делал, вы не могли бы продолжать
выполнение после точки останова, не отключив сперва ее.
Это правило применяется вне зависимости от того, существовала или нет
точка останова, когда ваша программа остановилась.

@item break @dots{} if @var{усл}
Установить точку останова с условием @var{усл}; каждый раз, когда
достигается эта точка останова, происходит вычисление выражения @var{усл}, и
остановка происходит, только если эта величина не равна нулю --- то есть, если
@var{усл} истинно.  @samp{@dots{}} означает один из возможных
аргументов, перечисленных выше (или отсутствие аргументов), описывающих
место остановки.  @xref{Условия, ,Условия остановки}, для большей
информации об условных точках останова.

@kindex tbreak
@item tbreak @var{арг}
Установить точку останова только до первой активизации.  Аргументы
@var{арг} такие же, как для команды @code{break}, и точка останова
устанавливается аналогичным образом, но она автоматически уничтожается
после того, как ваша программа первый раз на ней остановится.
@xref{Отключение, ,Отключение точек останова}.

@kindex hbreak
@item hbreak @var{арг}
Установить аппаратно-поддерживаемую точку останова.
Аргументы @var{арг} такие же, как и для команды @code{break}, и точка
останова устанавливается аналогичным образом, но она требует аппаратной
поддержки, и некоторые целевые платформы могут ее не иметь.  Основной
целью этого является отладка кода EPROM/ROM, так что вы можете установить точку
останова на инструкции без изменения инструкции.  Это может быть
использовано с новой генерацией ловушек, предоставляемой SPARClite DSU и
некоторыми машинами на базе x86.  Эти платформы будут генерировать
ловушки, когда программа обращается к некоторым данным или адресу
инструкции, которые назначены регистрам отладки.  Однако, регистры
аппаратных точек останова могут хранить ограниченное число точек
останова.  Например, на DSU, только две точки останова могут быть
установлены одновременно, и @value{GDBN} будет отвергать эту команду,
если используется больше.  Удалите или отключите неиспользуемые
аппаратные точки останова перед установкой новых (@pxref{Отключение,
,Отключение точек останова}).  @xref{Условия, Условия останова}.

@kindex thbreak
@item thbreak @var{арг}
Установить аппаратно-поддерживаемую точку останова,
включенную только до первой активизации.  Аргументы @var{арг} такие же,
как и для команды @code{hbreak}, и точка останова устанавливается
аналогичным образом.  Однако, как в случае команды @code{tbreak}, точка
останова автоматически уничтожается после того, как программа первый раз
на ней остановится.  Также, как и в случае команды @code{hbreak},
точка останова требует аппаратной поддержки и некоторые аппаратные
платформы могут ее не иметь.  @xref{Отключение, ,Отключение точек
останова}.  Смотрите также @ref{Условия, ,Условия остановки}.

@kindex rbreak
@cindex регулярное выражение
@item rbreak @var{рег-выр}
Установить точки останова на всех функциях, удовлетворяющих
регулярному выражению @var{рег-выр}.  Эта команда устанавливает
безусловные точки останова при всех совпадениях, выводя список всех
установленных точек останова.  После установки,
они рассматриваются точно так же, как точки останова,
установленные командой @code{break}.  Вы можете удалять их, отключать
или делать их условными таким же способом, как любые другие точки
останова.

Регулярные выражения имеют стандартный синтаксис, используемый такими
средствами, как @file{grep}.  Заметьте, что это отличается от
синтаксиса, используемого оболочками; так, например, @code{foo*}
подходит для всех функций, которые включают @code{fo}, за которым
следует любое число букв @code{o}.  Существует неявное @code{.*} в
начале и в конце введенного вами регулярного выражения, так что для
нахождения только тех функций, которые начинаются на @code{foo},
используйте @code{^foo}.

При отладке программ, написанных на Си++, @code{rbreak} полезна для
установки точек останова на перегруженных функциях, не являющихся
членами никакого специального класса.

@kindex info breakpoints
@cindex @code{$_} и @code{info breakpoints}
@item info breakpoints @r{[}@var{n}@r{]}
@itemx info break @r{[}@var{n}@r{]}
@itemx info watchpoints @r{[}@var{n}@r{]}
Вывести таблицу всех установленных и не удаленных точек останова,
наблюдения и перехвата, со следующими колонками для каждой точки:

@table @emph
@item Номер точки останова
@item Тип
Точка останова, наблюдения или перехвата.
@item План
Помечена ли точка останова для отключения или удаления после активации.
@item Включена или отключена
Включенные точки останова помечаются как @samp{y}.  @samp{n} отмечает
отключенные точки.
@item Адрес
Адрес памяти, где расположена точка останова в вашей программе.
@item Где
Файл и номер строки, где расположена точка останова в исходном файле.
@end table

@noindent
Если точка останова условная, @code{info break} показывает условие на
строке, следующей за этой точкой; команды точки останова, если они есть,
перечисляются после этого.

@noindent
@code{info break} с номером точки останова @var{n} в качестве аргумента
отображает только эту точку.  Вспомогательная переменная @code{$_} и
адрес по умолчанию для исследования для команды @code{x} устанавливаются
равными адресу последней из перечисленных точек останова (@pxref{Память,
,Исследование памяти}).

@noindent
@code{info break} отображает то число раз, которое точка останова была
активирована.  Это особенно полезно при использовании вместе с командой
@code{ignore}.  Вы можете игнорировать большое число активаций точки
останова, посмотреть информацию о точке останова, чтобы узнать, сколько
раз она активировалась, и затем запустить заново, игнорируя на единицу
меньше, чем это число.  Это быстро приведет вас к последней активации
этой точки останова.
@end table

@value{GDBN} позволяет вам установить любое число точек останова в
одном и том же месте вашей программы.  В этом нет ничего глупого или
бессмысленного.  Когда точки останова являются условными, это даже
полезно (@pxref{Условия, ,Условия останова}).

@cindex отрицательные номера точек останова
@cindex внутренние точки останова @value{GDBN}
@value{GDBN} иногда сам устанавливает точки останова в вашей программе
для специальных целей, таких как правильная обработка @code{longjmp} (в
программах на Си).  Этим внутренним точкам останова присваиваются
отрицательные номера, начиная с @code{-1}; @samp{info breakpoints} не
отображает их.

Вы можете увидеть эти точки останова с помощью служебной команды
@value{GDBN} @samp{maint info breakpoints}.

@table @code
@kindex maint info breakpoints
@item maint info breakpoints
Используя тот же формат, что и @samp{info breakpoints}, отобразить как
точки останова, установленные вами явно, так и те, которые
@value{GDBN} использует для внутренних целей.  Внутренние точки останова
показываются с отрицательными номерами.  Колонка типа определяет, какого
типа точка останова показана:

@table @code
@item breakpoint
Обычная, явно установленная точка останова.

@item watchpoint
Обычная, явно установленная точка наблюдения.

@item longjmp
Внутренняя точка останова, используемая для корректной обработки
пошагового выполнения вызовов @code{longjmp}.

@item longjmp resume
Внутренняя точка останова на цели @code{longjmp}.

@item until
Временная внутренняя точка останова, используемая командой @value{GDBN}
@code{until}.

@item finish
Временная внутренняя точка останова, используемая командой @value{GDBN}
@code{finish}.

@item shlib events
События в разделяемых библиотеках.

@end table

@end table


@node Установка точек наблюдения
@subsection Установка точек наблюдения

@cindex установка точек наблюдения
@cindex программные точки наблюдения
@cindex аппаратные точки наблюдения
Вы можете использовать точку наблюдения для остановки
выполнения, как только изменится значение какого-либо выражения, не
предсказывая конкретное место, где это может произойти.

В зависимости от вашей системы, точки наблюдения могут быть реализованы
программно или аппаратно.  @value{GDBN} осуществляет программную реализацию
точек наблюдения путем пошагового выполнения вашей программы и проверки
значения переменной на каждом шаге, что в сотни раз медленнее
нормального выполнения.  (Но, тем не менее, это того стоит, если нужно найти
ошибку в программе, когда вы не представляете, в какой части она
находится.)

В некоторых системах, таких как HP-UX, Linux и некоторых других
платформах, базирующихся на x86, @value{GDBN} включает поддержку для
аппаратных точек наблюдения, которые не замедляют выполнение вашей
программы.

@table @code
@kindex watch
@item watch @var{выраж}
Устанавливает точку наблюдения за выражением.  @value{GDBN} остановит
программу, когда @var{выраж} сохраняется программой, и его значение
изменяется.

@kindex rwatch
@item rwatch @var{выраж}
Устанавливает точку наблюдения, которая остановит программу, когда
наблюдаемое @var{выраж} считывается программой.

@kindex awatch
@item awatch @var{выраж}
Устанавливает точку наблюдения, которая остановит программу, когда
@var{выраж} либо считывается, либо сохраняется программой.

@kindex info watchpoints
@item info watchpoints
Эта команда печатает список точек наблюдения, останова и перехвата; это
то же самое, что и @code{info break}.
@end table

Когда это возможно, @value{GDBN} устанавливает @dfn{аппаратную точку
наблюдения}.  Аппаратные точки наблюдения выполняются очень быстро, и
отладчик сообщает об изменении значения точно в месте инструкции, где это
изменение произошло.  Если @value{GDBN} не может установить аппаратную
точку наблюдения, он устанавливает программную точку наблюдения, которая
выполняется намного медленнее и сообщает об изменении значения на следующем
операторе, а не инструкции, после появления изменения.

Когда вы даете команду @code{watch}, @value{GDBN} сообщает

@example
Hardware watchpoint @var{номер}: @var{выраж}
@end example

@noindent
если ему удалось установить аппаратную точку наблюдения.

В настоящее время, команды @code{awatch} и @code{rwatch} могут
устанавливать только аппаратные точки наблюдения, так как доступы к данным,
которые не изменяют величины наблюдаемого выражения, не могут быть
замечены без исследования каждой инструкции во время ее выполнения, а
@value{GDBN} пока этого не делает.  Если @value{GDBN} обнаруживает, что
не может установить аппаратную точку останова командами @code{awatch}
или @code{rwatch}, он напечатает сообщение, аналогичное этому:

@smallexample
Expression cannot be implemented with read/access watchpoint.@footnote{Выражение не может быть реализовано с помощью точки наблюдения чтения/доступа.  @i{(Прим.@: переводчика)}}
@end smallexample

Иногда @value{GDBN} не может установить аппаратную точку наблюдения из-за
того, что тип данных наблюдаемого выражения занимает больше места, чем
допускает аппаратная точка наблюдения на целевой платформе.  Например,
некоторые системы позволяют наблюдать за областями, занимающими до 4
байт; на таких системах вы не можете устанавливать аппаратные точки
наблюдения за выражениями, которые в результате дают число
с плавающей точкой двойной точности (которое обычно занимает 8 байт).  В
качестве одного из решений, можно разбить большую область на несколько
меньших областей, и затем наблюдать за каждой из них с помощью отдельной
точки наблюдения.

Если вы установите слишком много аппаратных точек наблюдения,
@value{GDBN} может быть не в состоянии задействовать их все, когда вы
возобновите выполнение вашей программы.  Так как точное количество
активных точек наблюдения неизвестно до того момента, как ваша
программа должна возобновить выполнение, @value{GDBN} может быть не в
состоянии предупредить вас об этом, когда вы устанавливаете точку
наблюдения, и предупреждение будет напечатано, только когда программа
возобновит выполнение:

@smallexample
Hardware watchpoint @var{номер}: Could not insert watchpoint@footnote{Аппаратная точка наблюдения @var{номер}: Не удается поместить точку наблюдения  @i{(Прим.@: переводчика)}}
@end smallexample

@noindent
Если это происходит, удалите или отключите некоторые точки наблюдения.

SPARClite DSU будет генерировать ловушки, когда программа обращается к
некоторым данным или адресу инструкции, которые отведены для отладочных
регистров.  Для адресов данных, DSU упрощает команду @code{watch}.
Однако, аппаратные регистры точек останова могут принять только две
точки наблюдения за данными, и обе точки наблюдения должны быть одного
типа.  Например, вы можете установить две точки наблюдения с помощью
команды @code{watch}, две с помощью команды @code{rwatch}, @strong{или}
две с помощью команды @code{awatch}, но вы не можете установить одну
точку наблюдения с помощью одной команды, а другую с помощью другой.
@value{GDBN} не примет команду, если вы попытаетесь совместить различные
точки наблюдения.  Удалите или отключите неиспользуемые точки наблюдения
перед установкой новых.

Если вы вызываете функцию интерактивно, используя @code{print} или
@code{call}, все установленные вами точки наблюдения будут неактивными
до тех, пор пока @value{GDBN} не достигнет точки останова другого типа,
или пока вызов не завершится.

@value{GDBN} автоматически удаляет точки наблюдения, которые наблюдают
за локальными переменными или за выражениями, которые используют такие
переменные, когда они выходят из области видимости, то есть когда
выполнение покидает блок, в котором эти переменные были определены.  В
частности, когда отлаживаемая программа завершается, @emph{все}
локальные переменные выходят из области видимости, и таким образом
остаются установленными только те точки наблюдения, которые наблюдают за
глобальными переменными.  Если вы снова запустите программу, вы должны
будете заново установить все такие точки наблюдения.  Одним из способов
сделать это будет установить точку останова на входе в функцию
@code{main}, и, когда программа остановится, установить все остальные точки
наблюдения.

@quotation
@cindex точки наблюдения и нити
@cindex нити и точки наблюдения
@emph{Предупреждение:} В многонитевых программах точки наблюдения
являются лишь частично полезными.  С текущей реализацией точек
наблюдения, @value{GDBN} может наблюдать за величиной выражения
только @emph{в одной нити}.  Если вы уверены, что выражение может измениться
только вследствие действий внутри текущей нити (и если вы также уверены,
что никакая другая нить не может стать текущей), то вы можете
использовать точки наблюдения как обычно.  Однако, @value{GDBN} может не
заметить, когда действия в другой нити изменяют выражение.

@emph{Предупреждение для HP-UX:} В многонитевых программах программные
точки наблюдения
являются лишь частично полезными.  Если @value{GDBN} создает программную
точку наблюдения, она может наблюдать за величиной выражения только
@emph{в одной нити}.  Если вы уверены, что выражение может измениться
только вследствие действий внутри текущей нити (и если вы также уверены,
что никакая другая нить не может стать текущей), то вы можете использовать
программные точки наблюдения как обычно.  Однако, @value{GDBN} может не
заметить, когда действия в другой нити изменяют выражение.
(Аппаратные же точки наблюдения напротив, наблюдают за выражением во
всех нитях.)
@end quotation

@node Установка точек перехвата
@subsection Установка точек перехвата
@cindex точки перехвата, установка
@cindex обработчики исключений
@cindex обработка событий

Вы можете использовать @dfn{точки перехвата}, чтобы вызвать остановку
отладчика в ответ на определенные типы событий в программе, такие как
исключения в Си++ или загрузка разделяемой библиотеки.  Для установки
точки перехвата используйте команду @code{catch}.

@table @code
@kindex catch
@item catch @var{событие}
Остановиться, когда происходит @var{событие}.  @var{Событие} может быть
одним из:
@table @code
@item throw
@kindex catch throw
Выбрасывание исключения Си++.

@item catch
@kindex catch catch
Перехват исключения Си++.

@item exec
@kindex catch exec
Вызов @code{exec}.  В настоящее время это доступно только на HP-UX.

@item fork
@kindex catch fork
Вызов @code{fork}.  В настоящее время это доступно только на HP-UX.

@item vfork
@kindex catch vfork
Вызов @code{vfork}.  В настоящее время это доступно только на HP-UX.

@item load
@itemx load @var{имя-библ}
@kindex catch load
Динамическая загрузка любой разделяемой библиотеки или загрузка
библиотеки @var{имя-библ}.  В настоящее время это доступно только на
HP-UX.

@item unload
@itemx unload @var{имя-библ}
@kindex catch unload
Выгрузка любой динамически загруженной разделяемой библиотеки или
выгрузка библиотеки @var{имя-библ}.  В настоящее время это доступно
только на HP-UX.
@end table

@item tcatch @var{событие}
Установить точку перехвата, которая включена только до первой
активации.  Точка перехвата автоматически уничтожается после того, как
событие перехвачено первый раз.

@end table

Используйте команду @code{info break} для получения списка текущих точек
перехвата.

В настоящее время, в @value{GDBN} существуют некоторые ограничения на
обработку исключений Си++ (@code{catch throw} и @code{catch catch}):

@itemize @bullet
@item
Если вы вызываете функцию интерактивно, @value{GDBN} обычно возвращает
вам управление после того, как функция закончила выполнение.  Однако,
если вызов возбуждает исключение, он может обойти механизм, возвращающий
вам управление, и заставить вашу программу либо остановиться, либо просто
продолжить выполнение до тех пор, пока она не активирует точку останова,
получит сигнал, который ждет @value{GDBN}, или выйдет.  Это имеет место,
даже если вы установите точку перехвата для исключения; точки перехвата
для исключений отключены при интерактивных вызовах.

@item
Вы не можете возбуждать исключения интерактивно.

@item
Вы не можете интерактивно установить обработчик исключения.
@end itemize

@cindex возбуждение исключений
Иногда @code{catch} не является лучшим способом отладки обработки
исключений: если вам необходимо точно знать, где исключение возбуждено,
то лучше остановиться @emph{до} того, как вызван обработчик исключения,
так как в этом случае вы можете увидеть стек до того, как произойдет
какое-либо развертывание.
Если вместо этого вы установите точку останова в обработчике исключений,
то может быть нелегко определить, где исключение было возбуждено.

Для остановки сразу перед вызовом обработчика исключений, вам необходимы
некоторые знания о реализации.  В случае @sc{gnu} Си++, исключения
возбуждаются путем вызова библиотечной функции @code{__raise_exception},
которая имеет следующий интерфейс ANSI Си:

@example
    /* @var{addr} -- где хранится идентификатор исключения.
       @var{id} -- идентификатор исключения.  */
    void __raise_exception (void **addr, void *id);
@end example

@noindent
Для того, чтобы отладчик перехватывал все исключения до того, как
произойдет развертывание стека, установите точку останова на
@code{__raise_exception}  (@pxref{Точки останова, ,Точки останова, точки
наблюдения и точки перехвата}).

С помощью условных точек останова (@pxref{Условия, ,Условия останова}),
зависящих от значения @var{id}, вы можете остановить вашу программу,
когда возбуждается определенное исключение.  Вы можете использовать
несколько условных точек останова, чтобы остановить программу, когда
возбуждается любое из нескольких исключений.


@node Удаление точек останова
@subsection Удаление точек останова

@cindex уничтожение точек останова, наблюдения, перехвата
@cindex очистка точек останова, наблюдения, перехвата
Часто бывает необходимо уничтожить точку останова, наблюдения или
перехвата, когда она сделала свое дело, и вы больше не хотите
останавливать там свою программу.  Это называется @dfn{уничтожением}
точки останова.  Точка останова, которая была уничтожена, более не
существует; она забыта.

С помощью команды @code{clear} вы можете удалять точки останова в
соответствии с тем, где они находятся в вашей программе.  С помощью
команды @code{delete} вы можете удалять отдельные точки останова,
наблюдения или перехвата, указывая их номера.

Не обязательно удалять точку останова, чтобы продолжить выполнение после
нее.  @value{GDBN} автоматически игнорирует точки останова на первой
инструкции, которая должна быть выполнена, когда вы продолжаете
исполнение без изменения адреса выполнения.

@table @code
@kindex clear
@item clear
Удаляет любые точки останова, установленные на следующей инструкции,
которая должна быть выполнена в выбранном кадре стека (@pxref{Выбор,
,Выбор кадра}).  Когда выбран самый внутренний кадр, это хороший способ
удалить ту точку останова, на которой ваша программа только что
остановилась.

@item clear @var{функция}
@itemx clear @var{имя-файла}:@var{функция}
Удалить любые точки останова, установленные на входе в @var{функцию}.

@item clear @var{номер-строки}
@itemx clear @var{имя-файла}:@var{номер-строки}
Удалить все точки останова, установленные на или внутри кода на
указанной строке.

@cindex уничтожение точек останова
@kindex delete
@kindex d @r{(@code{delete})}
@item delete @r{[}breakpoints@r{]} @r{[}@var{диапазон}@dots{}@r{]}
Удалить точки останова, наблюдения или перехвата из диапазона, указанного
в качестве аргумента.  Если аргумент не задан, удалить все точки
останова (@value{GDBN} запрашивает подтверждение, если у вас не
установлено @code{set confirm off}).  Вы можете сократить это команду
как @code{d}.
@end table

@node Отключение
@subsection Отключение точек останова

@kindex disable breakpoints
@kindex enable breakpoints
Вместо того, чтобы удалять точку останова, наблюдения или перехвата, вам
может быть удобнее @dfn{отключить} ее.  Это делает точку останова
бездействующей, как если бы она была удалена, но информация о ней
запоминается, так что вы можете позже @dfn{включить} ее
снова.

Вы отключаете и включаете точки останова, наблюдения и перехвата
командами @code{enable} и @code{disable}, возможно, указывая один или
более номеров точек останова в качестве аргументов.  Используйте
@code{info break} или @code{info watch} для распечатки списка точек
останова, наблюдения и перехвата, если вы не знаете, какие номера
использовать.

Точка останова, наблюдения или перехвата может находиться в одном из четырех
состояний:

@itemize @bullet
@item
Включена.  Точка останова останавливает вашу программу.  Точка останова,
установленная командой @code{break}, изначально находится в таком состоянии.
@item
Отключена.  Точка останова не оказывает воздействия на вашу программу.
@item
Включена до первого срабатывания.  Точка останова останавливает вашу
программу, но потом становится отключенной.
@item
Включена для удаления.  Точка останова останавливает вашу программу, но
сразу после этого она удаляется навсегда.  Точка останова, установленная
командой @code{tbreak}, изначально находится в этом состоянии.
@end itemize

Вы можете использовать следующие команды для включения или отключения
точек останова, наблюдения и перехвата:

@table @code
@kindex disable breakpoints
@kindex disable
@kindex dis @r{(@code{disable})}
@item disable @r{[}breakpoints@r{]} @r{[}@var{диапазон}@dots{}@r{]}
Отключить указанные точки останова или все точки останова, если ни
одна не перечислена.  Отключенная точка останова не оказывает никакого
действия, но она не забывается.  Все параметры, такие как счетчик
игнорирований, условия и команды запоминаются на случай, если точка
останова позже будет снова включена.  Вы можете сокращать @code{disable}
как @code{dis}.

@kindex enable breakpoints
@kindex enable
@item enable @r{[}breakpoints@r{]} @r{[}@var{диапазон}@dots{}@r{]}
Включает указанные (или все определенные) точки останова.  Они
снова становятся значимыми для остановки вашей программы.

@item enable @r{[}breakpoints@r{]} once @var{диапазон}@dots{}
Временно включить указанные точки останова.  @value{GDBN} отключает
любую из этих точек останова немедленно после срабатывания.

@item enable @r{[}breakpoints@r{]} delete @var{диапазон}@dots{}
Включить указанные точки останова до первого срабатывания, затем
уничтожить.  @value{GDBN} удаляет любую из этих точек останова, как
только ваша программа останавливается на ней.
@end table

Кроме точек останова, установленных командой @code{tbreak}
(@pxref{Установка точек останова, ,Установка точек останова}),
установленные вами точки останова изначально включены; следовательно,
они становятся отключенными или включенными, только когда вы используете
одну из вышеперечисленных команд.  (Команда @code{until} может
устанавливать и удалять свою собственную точку останова, но она не
изменяет состояние других точек останова; см. @ref{Продолжение и
пошаговое выполнение, ,Продолжение и выполнение по шагам}.)

@node Условия
@subsection Условия останова
@cindex условные точки останова
@cindex условия и точки останова

Простейшая точка останова останавливает вашу программу каждый раз, когда
управление достигает заданного места.  Вы можете также указать
@dfn{условие} для точки останова.  Условие является просто булевым
выражением в вашем языке программирования (@pxref{Выражения,
,Выражения}).  Точка останова с условием вычисляет выражение каждый раз,
когда ваша программа достигает ее, и ваша программа остановится только в
том случае, если условие @emph{истинно}.

Это противоположно использованию утверждений для проверки правильности
программы; в этом случае, вы хотите остановиться, когда утверждение
нарушается --- то есть, когда условие ложно.  В Си, если вы хотите
проверить утверждение, выраженное условием @var{assert}, вы должны
установить условие @samp{! @var{assert}} на соответствующей точке
останова.

Условия также допускаются для точек наблюдения; вам они могут не
понадобиться, так как точка наблюдения так или иначе контролирует значение
выражения --- но может оказаться проще, скажем, просто установить точку
наблюдения на имя переменной и указать условие, проверяющее, является ли
новое значение тем, которое нас интересует.

Условия останова могут иметь побочные эффекты и даже могут вызывать
функции в вашей программе.  Это может быть полезным, например, для
активации функций, которые запоминают продвижение выполнения вашей
программы, или для использования ваших собственных функций печати для
форматирования специальных структур данных.  Результаты полностью
предсказуемы, если нет другой включенной точки останова по тому же
адресу.  (В этом случае, @value{GDBN} может сначала увидеть другую точку
останова и остановить вашу программу программу без проверки условия
первой точки останова.)  Заметьте, что для выполнения побочных эффектов
при достижении точки останова обычно более удобны и гибки команды точек
останова, а не условия останова (@pxref{Команды останова, ,Команды точки
останова}).

Условия останова можно задать в момент установки точки останова,
используя @samp{if} в аргументах команды @code{break}.  @xref{Установка
точек останова, ,Установка точек останова}.  Они могут быть также
изменены в любой момент с помощью команды @code{condition}.

Вы также можете использовать ключевое слово @code{if} с командой
@code{watch}.  Команда @code{catch} не распознает ключевое слово
@code{if}; @code{condition} является единственным способом наложить
дальнейшие условия на точку перехвата.

@table @code
@kindex condition
@item condition @var{номер} @var{выражение}
Задайте @var{выражение} как условие остановки для точки останова,
наблюдения или перехвата с номером @var{номер}.  После того, как вы
установили условие, данная точка останова остановит вашу программу, только
если значение @var{выражения} будет истинным (ненулевым, в Си).  Когда
вы используете @code{condition}, @value{GDBN} немедленно проверяет
@var{выражение} на синтаксическую корректность и на тот факт, что
символы в нем ссылаются на реальные объекты в контексте данной точки останова.
Если @var{выражение} использует символы, не существующие в контексте
точки останова, @value{GDBN} выведет сообщение об ошибке:

@example
No symbol "foo" in current context.@footnote{В текущем контексте нет символа "foo".  @i{(Прим.@: переводчика)}}
@end example

@noindent
Однако, @value{GDBN} в действительности не вычисляет @var{выражение} в
момент подачи команды @code{condition} (или команды, устанавливающей
точку останова с условием, такой как @code{break if @dots{}}).
@xref{Выражения, ,Выражения}.

@item condition @var{номер}
Снимает условие с точки останова с номером @var{номер}.  Она становится
обычной безусловной точкой останова.
@end table

@cindex счетчик игнорирований (точек останова)
Специальным случаем условия для точки останова является остановка только
тогда, когда точка останова была достигнута определенное число раз.  Это
настолько полезно, что существует специальный способ сделать это,
используя @dfn{счетчик игнорирования}.  Каждая точка
останова имеет счетчик игнорирования, являющийся целым числом.
Как правило, счетчик игнорирования равен нулю и,
следовательно, не производит никакого действия.  Но если ваша программа
достигает точки останова, чей счетчик игнорирования положителен, тогда
вместо того чтобы остановиться, она лишь уменьшит его на единицу и
продолжит выполнение.  В результате, если величина счетчика
игнорирования равна @var{n}, точка останова не остановит программу
следующие @var{n} раз, когда программа его достигнет.

@table @code
@kindex ignore
@item ignore @var{номер} @var{значение}
Устанавливает счетчик игнорирований точки останова с номером @var{номер} в
@var{значение}.  Следующие @var{значение} раз, когда точка останова
будет достигнута, выполнение вашей программы не будет остановлено; 
@value{GDBN} не производит никаких действий, 
только уменьшает счетчик игнорирований.

Чтобы точка останова сработала при следующем достижении, установите
счетчик в ноль.

Когда вы используете @code{continue} для возобновления выполнения вашей
программы от точки останова, вы можете установить счетчик игнорирований
непосредственно как аргумент к @code{continue}, а не использовать
@code{ignore}.  @xref{Продолжение и пошаговое выполнение,,Продолжение и
выполнение по шагам}.

Если точка останова имеет положительный счетчик игнорирований и условие,
то условие не проверяется.  Как только счетчик игнорирований достигнет
нуля, @value{GDBN} возобновит проверку условия.

Вы можете достигнуть эффекта счетчика игнорирований с помощью такого
условия, как @w{@samp{$foo-- <= 0}}, используя вспомогательную
переменную отладчика, которая уменьшается каждый раз.
@xref{Вспомогательные переменные, ,Вспомогательные переменные}.
@end table

Счетчики игнорирований можно использовать с точками останова, точками
наблюдения и точками перехвата.


@node Команды останова
@subsection Команды точки останова

@cindex команды для точек останова
Вы можете подать любой точке останова (наблюдения или
перехвата) ряд команд, которые будут выполняться при остановке вашей
программы на этой точке останова.  Например, вы можете захотеть вывести
значения определенных выражений, или включить другие точки останова.

@table @code
@kindex commands
@kindex end
@item commands @r{[}@var{номер}@r{]}
@itemx @dots{} @var{список-команд} @dots{}
@itemx end
Определяет список команд для точки останова с номером @var{номер}.  Сами
команды указываются в следующих строках.  Для завершения списка команд,
введите строку, содержащую только @code{end}.

Чтобы удалить все команды точки останова, введите @code{commands} и
потом сразу @code{end}, то есть задайте пустой список команд.

Без аргумента @var{номер}, @code{commands} относится к последней
установленной точке останова, наблюдения или перехвата (но не к
последней встреченной).
@end table

Нажатие @key{RET}, как средство повторения последней команды
@value{GDBN}, отключено внутри @var{списка-команд}.

Вы можете использовать команды для точки останова, чтобы снова запустить
вашу программу на выполнение.  Просто используйте команду @code{continue}, или
@code{step}, или любую другую команду, возобновляющую выполнение.

После команды, возобновляющей выполнение, любые другие команды в списке
игнорируются.  Так сделано потому, что каждый раз, когда вы
возобновляете выполнение (даже просто с помощью @code{next} или
@code{step}), вы можете встретить другую точку останова --- которая может
иметь свой собственный список команд, что приведет к неоднозначности,
какой из списков выполнять.

@kindex silent
Если в качестве первой команды в списке вы укажете @code{silent},
обычное сообщение об остановке на точке останова не будет выводиться.
Это может быть желательно для точек останова, которые должны вывести
определенное сообщение и затем продолжить выполнение.  Если никакая из
оставшихся команд ничего не выводит, вы не увидите никакого знака о том,
что точка останова была достигнута.  @code{silent} имеет смысл только в
начале списка команд точки останова.

Команды @code{echo}, @code{output} и @code{printf} позволяют вам
более точно контролировать выводимый текст, и часто полезны в ``тихих''
точках останова.  @xref{Вывод, ,Команды управления выводом}.

Например, вот как вы можете использовать команды точки останова для
вывода величины @code{x} на входе в @code{foo}, когда @code{x}
положительна.

@example
break foo if x>0
commands
silent
printf "x is %d\n",x
cont
end
@end example

Одним из применений команд точки останова является компенсация одной
ошибки, так, чтобы вы могли искать другую.  Поместите точку останова
сразу после строки кода, содержащей ошибку, задайте ей условие для
определения случая, в котором было сделано что-то ошибочное, и
определите команды для присвоения правильных значений тем переменным,
для которых это требуется.  Закончите командой @code{continue}, чтобы
ваша программа не останавливалась, а начните с команды @code{silent},
чтобы не было никакого вывода.  Вот пример:

@example
break 403
commands
silent
set x = y + 4
cont
end
@end example

@node Меню точки останова
@subsection Меню точки останова
@cindex перегрузка
@cindex перегрузка символов

Некоторые языки программирования (особенно Си++) допускают, чтобы одно и
то же имя функции было определено несколько раз, для применения в
различных контекстах.  Это называется @dfn{перегрузкой}.  Когда имя
функции перегружается, простой записи @samp{break @var{функция}} недостаточно, чтобы
указать @value{GDBN}, где вы хотите установить точку останова.
Если вы столкнулись с этой проблемой, вы можете использовать что-то вроде
@samp{break @var{функция}(@var{типы})} для указания, какую конкретную
версию функции вы имеете в виду.  В противном случае, @value{GDBN}
предлагает вам выбор из пронумерованных вариантов для различных
возможных точек останова и ждет вашего выбора с приглашением
@samp{>}.  Первыми двумя вариантами всегда являются @samp{[0] cancel}
и @samp{[1] all}.  Ввод @kbd{1} устанавливает точку останова на каждом
определении @var{функции}, а ввод @kbd{0} прерывает команду @code{break}
без установки новых точек останова.

Например, следующая выдержка из сеанса иллюстрирует попытку установить
точку останова на перегруженном символе @code{String::after}.  Мы
выбрали три конкретных определения имени функции:

@smallexample
@group
(@value{GDBP}) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
> 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the "delete" command to delete unwanted
 breakpoints.
(@value{GDBP})
@end group
@end smallexample

@node Ошибки в точках останова
@subsection ``Не удается поместить точки останова''

В некоторых операционных системах точки останова не могут быть
использованы в программе, если какой-либо другой процесс выполняет эту
программу.  В этом случае, попытка выполнить или продолжить выполнение
программы с точкой останова приводит к тому, что @value{GDBN} печатает
сообщение об ошибке:

@example
Cannot insert breakpoints.
The same program may be running in another process.@footnote{Не удается поместить точки останова.  Возможно, эта программа выполняется в другом процессе.  @i{(Прим.@: переводчика)}}
@end example

Когда это происходит, у вас есть три варианта дальнейших действий:

@enumerate
@item
Удалить или отключить точки останова и затем продолжить.

@item
Приостановить @value{GDBN} и скопировать файл, содержащий вашу
программу, под другим именем.  Возобновить работу @value{GDBN} и
использовать команду @code{exec-file} для указания, что @value{GDBN}
должен выполнять вашу программу под этим именем.  Затем запустите
программу снова.

@item
Скомпоновать заново вашу программу так, чтобы сегмент текста был
неразделяемым, используя ключ компоновщика @samp{-N}.  Ограничения
операционной системы могут не распространяться на неразделяемые
выполняемые файлы.
@end enumerate

Аналогичное сообщение может выводиться, если вы запрашиваете слишком
много активных аппаратно-поддерживаемых точек останова и наблюдения:

@smallexample
Stopped; cannot insert breakpoints.
You may have requested too many hardware breakpoints and watchpoints.@footnote{Остановлено; не удается поместить точки останова.  Возможно, вы запросили слишком много аппаратно-поддерживаемых точек останова и наблюдения.  @i{(Прим.@: переводчика)}}
@end smallexample

@noindent
Это сообщение выводится, когда вы пытаетесь возобновить выполнение
программы, так как только тогда @value{GDBN} знает точно, сколько аппаратных
точек останова и наблюдения ему нужно установить.

Когда вы видите это сообщение, вам необходимо отключить или удалить
некоторые аппаратно-поддерживаемые точки останова и наблюдения и затем
продолжить.


@node Продолжение и пошаговое выполнение
@section Продолжение и выполнение по шагам

@cindex пошаговое выполнение
@cindex продолжение
@cindex возобновление выполнения
@dfn{Продолжение} означает возобновление выполнения программы до ее
нормального завершения.  Напротив, @dfn{пошаговое выполнение} означает
выполнение еще одного ``шага'' вашей программы, где ``шаг'' быть либо
одной строкой исходного кода, либо одной машинной инструкцией (в
зависимости от того, какую именно команду вы используете).  И в
случае продолжения, и в случае выполнения по шагам, ваша программа
может остановиться и раньше, вследствие точки останова или сигнала.
(Если она останавливается по сигналу, вы можете использовать
@code{handle}, или @samp{signal 0} для возобновления выполнения.
@xref{Сигналы, ,Сигналы}.)

@table @code
@kindex continue
@kindex c @r{(@code{продолжить})}
@kindex fg @r{(продолжить выполнение в фоновом режиме)}
@item continue @r{[}@var{счетчик-игнор}@r{]}
@itemx c @r{[}@var{счетчик-игнор}@r{]}
@itemx fg @r{[}@var{счетчик-игнор}@r{]}
Возобновить выполнение программы с того адреса, где она
остановилась последний раз; все точки останова, установленные по этому
адресу, пропускаются.  Необязательный аргумент @var{счетчик-игнор}
позволяет вам задать количество последующих игнорирований точки останова
в этом месте; его действие совпадает с действием @code{ignore}
(@pxref{Условия, ,Условия останова}).

Аргумент @var{счетчик-игнор} имеет смысл, только если ваша программа
остановилась в точке останова.  В остальных случаях аргумент к
@code{continue} игнорируется.

Синонимы @code{c} и @code{fg} (от @dfn{foreground}, так как отлаживаемая
программа считается фоновой), предоставляются исключительно для
удобства и имеют в точности тот же смысл, что и @code{continue}.
@end table

Чтобы возобновить выполнение с другого места, вы можете использовать
@code{return} (@pxref{Возврат, ,Возврат из функции}) чтобы вернуться
назад к вызывающей функции; или @code{jump} (@pxref{Переходы,
,Продолжение с другого адреса}) для перехода к произвольному месту в
вашей программе.

Типичная техника для использования пошагового выполнения заключается в
установке точки останова (@pxref{Точки останова, ,Точки останова, точки
наблюдения и точки перехвата}) на начале функции или раздела вашей программы,
где предположительно находится ошибка, выполнении вашей программы до
остановки на этой точке останова, и затем пошаговом выполнении
подозреваемого участка, с исследованием интересуемых переменных, пока вы
не увидите, что случилась ошибка.

@table @code
@kindex step
@kindex s @r{(@code{step})}
@item step
Продолжить выполнение вашей программы, пока управление не достигнет
другой строки исходного текста, затем остановить ее и вернуть
управление @value{GDBN}.  Эту команду можно сокращать как @code{s}.

@quotation
@emph{Предупреждение:} Если вы используете команду @code{step}, когда
управление находится внутри функции, которая была скомпилирована без
отладочной информации, выполнение продолжается, пока управление не
достигнет функции, которая @emph{имеет} ее.  Аналогично, пошаговое
выполнение не будет заходить в функцию, скомпилированную без отладочной
информации.  Для пошагового выполнения таких функций
используйте команду @code{stepi}, описанную ниже.
@end quotation

Команда @code{step} останавливается только на первой инструкции строки
исходного текста.  Это предотвращает множественные остановки, которые
в противном случае могут возникнуть в операторе @code{switch}, цикле
@code{for}, и так далее.  @code{step} продолжает останавливаться, если
функция, имеющая отладочную информацию, вызывается внутри строки.
Другими словами, @code{step} @emph{заходит внутрь} функций, вызываемых в
данной строке.

Также, команда @code{step} входит в функцию, только если для нее существует
информация о номерах строк.  Иначе она действует, как команда
@code{next}.  Это позволяет избежать проблем, появляющихся при
использовании @code{cc -gl} на машинах MIPS.  Раньше @code{step}
заходила в подпрограмму, если о ней существовала хоть какая-нибудь отладочная
информация.

@item step @code{число}
Продолжает выполнение, как по команде @code{step}, но делает это
указанное @var{число} раз.  Если до завершения указанного @var{числа}
шагов достигается точка останова, или приходит сигнал, не связанный с
пошаговым выполнением, пошаговое выполнение сразу останавливается.

@kindex next
@kindex n @r{(@code{next})}
@item next @r{[}@var{число}@r{]}
Продолжает выполнение до следующей строки исходного текста в текущем
(внутреннем) кадре стека.  Это аналогично @code{step}, но вызовы
функций, которые появляются внутри строки кода, выполняются без
остановки.  Выполнение останавливается, когда управление достигает другой
строки кода в исходном уровне стека, который выполнялся, когда вы дали
команду @code{next}.  Эта команда сокращается как @code{n}.

Аргумент @var{число} является счетчиком повторений, как для @code{step}.

Команда @code{next} останавливается только на первой инструкции исходной
строки.  Это предотвращает множественные остановки, которые
иначе могут возникнуть в операторах @code{switch}, циклах @code{for} и
так далее.

@kindex set step-mode
@item set step-mode
@cindex функции без информации о строках, и пошаговое выполнение
@cindex пошаговый вход в функции без информации о строках
@itemx set step-mode on
Команда @code{set step-mode on} велит команде @code{step}
останавливаться на первой инструкции в функции, не содержащей
отладочной информации о строках, а не выполнять ее без остановки.

Это полезно в случаях, когда вы можете быть заинтересованы в изучении
машинных инструкций функции, не имеющей символьной информации, и не
хотите, чтобы @value{GDBN} автоматически ее проскочил.

@item set step-mode off
Велит команде @code{step} выполнять все функции, не
содержащие отладочной информации, без остановки.  Это значение
используется по умолчанию.

@kindex finish
@item finish
Продолжить выполнение до возврата из функции в выбранном кадре стека.
Напечатать возвращенное значение (если таковое существует).

Сравните это с командой @code{return} (@pxref{Возврат, ,Возврат из
функции}).

@kindex until
@kindex u @r{(@code{until})}
@item until
@itemx u
Продолжить выполнение до достижения строки исходного текста, следующей за
текущей, в текущем кадре стека.  Эта команда используется для избежания
выполнения цикла по шагам больше одного раза.
Она похожа на команду @code{next}, за исключением
того, что когда @code{until} встречает переход, она автоматически
продолжает выполнение, пока счетчик выполнения программы не станет
больше, чем адрес перехода.

Это означает, что когда вы достигаете конца цикла после его выполнения по
шагам, @code{until} продолжает выполнение вашей программы, пока она не
выйдет из цикла.  Напротив, команда @code{next} в конце цикла просто
переходит назад в начало цикла, что заставляет вас выполнять по
шагам следующую итерацию.

@code{until} всегда останавливает вашу программу, если она пытается выйти
из текущего кадра стека.

@code{until} может привести к несколько неожиданным результатам, если
порядок машинных кодов не совпадает с порядком строк исходного текста.
Например, в следующем отрывке сеанса отладки, команда @code{f}
(@code{frame}) показывает, что выполнение остановилось на строке
@code{206}; хотя, когда мы используем @code{until}, мы переходим к строке
@code{195}:

@example
(@value{GDBP}) f
#0  main (argc=4, argv=0xf7fffae8) at m4.c:206
206                 expand_input();
(@value{GDBP}) until
195             for ( ; argc > 0; NEXTARG) @{
@end example

Это произошло потому, что для эффективности выполнения компилятор
сгенерировал код для проверки окончания цикла в конце, а не в начале
цикла --- даже если проверка в цикле @code{for} Си написана до тела
цикла.  Кажется, что команда @code{until} переместилась назад к началу
цикла, когда двигалась к этому выражению; однако, в действительности она
не переходила к более раннему оператору --- в терминах фактического
машинного кода.

@code{until} без аргументов работает посредством пошагового выполнения
отдельных инструкций, и, следовательно, является более медленной, чем
@code{until} с аргументом.

@item until @var{положение}
@itemx u @var{положение}
Продолжить выполнение вашей программы, пока либо указанное место не
будет достигнуто, либо не произойдет возврат из текущего кадра стека.
@var{положение} может быть любой из доступных форм аргумента для
@code{break} (@pxref{Установка точек останова, ,Установка точек
останова}).  Эта форма команды использует точки останова и,
следовательно, является более быстрой, чем @code{until} без аргумента.

@kindex stepi
@kindex si @r{(@code{stepi})}
@item stepi
@itemx stepi @var{арг}
@itemx si
Выполнить одну машинную инструкцию, затем остановиться и вернуться в
отладчик.

При пошаговом выполнении машинных инструкций, часто бывает полезным
сделать @samp{display/i $pc}.  Это велит @value{GDBN} автоматически
отображать инструкцию, которая будет выполняться следующей, каждый раз,
когда ваша программа останавливается.  @xref{Автоматическое отображение,
,Автоматическое отображение}.

Аргумент является счетчиком повторений, как для @code{step}.

@need 750
@kindex nexti
@kindex ni @r{(@code{nexti})}
@item nexti
@itemx nexti @var{арг}
@itemx ni
Выполнить одну машинную инструкцию, но если это вызов функции,
продолжать до возврата из нее.

Аргумент является счетчиком повторений, как для @code{next}.
@end table

@node Сигналы
@section Сигналы
@cindex сигналы

Сигнал --- это асинхронное событие, которое может произойти в программе.
Операционная система определяет возможные типы сигналов и дает каждому
типу имя и номер.  В Unix, например, @code{SIGINT} --- это сигнал, получаемый
программой, когда вы вводите знак прерывания (часто @kbd{C-c});
@code{SIGSEGV} --- сигнал, получаемый программой при ссылке на область
памяти, отличную от всех используемых областей; @code{SIGALRM} появляется
при срабатывании интервального таймера (возникает, только если ваша
программа запросила временной сигнал).

@cindex фатальные сигналы
Некоторые сигналы, такие как @code{SIGALRM}, являются обычной частью
функционирования вашей программы.  Другие, такие как @code{SIGSEGV},
обозначают ошибки; эти сигналы являются @dfn{фатальными} (они немедленно
убивают вашу программу), если программа не определила заранее другой
способ их обработки.  @code{SIGINT} не указывает на ошибку в вашей
программе, но обычно является фатальным, так что он может выполнять
функцию прерывания: убить программу.

@value{GDBN} способен обнаружить любое появление сигнала в вашей
программе.  Вы можете заранее сообщить @value{GDBN}, что делать для
каждого типа сигнала.

@cindex обработка сигналов
Обычно, @value{GDBN} установлен так, чтобы игнорировать неошибочные сигналы,
такие как @code{SIGALRM} (чтобы не мешать их действию при исполнении вашей
программы), но немедленно останавливать вашу программу всякий раз, когда
возникает сигнал об ошибке.  Вы можете изменить эти установки командой
@code{handle}.

@table @code
@kindex info signals
@item info signals
@itemx info handle
Напечатать таблицу всех типов сигналов и описания, как @value{GDBN}
будет обрабатывать каждый из них.  Вы можете использовать эту команду, чтобы
посмотреть номера всех определенных типов сигналов.

@code{info handle} является синонимом для @code{info signals}.

@kindex handle
@item handle @var{сигнал} @var{ключевые-слова}@dots{}
Изменить способ, которым @value{GDBN} обрабатывает @var{сигнал}.
@var{Сигнал} может быть номером сигнала или его именем (с @samp{SIG} или
без него в начале).  @var{Ключевые-слова} определяют, какие сделать изменения.
@end table

Ключевые слова, допускаемые командой @code{handle}, могут быть
сокращены.  Вот их полные имена:

@table @code
@item nostop
@value{GDBN} не должен останавливать вашу программу при получении
этого сигнала.  Все же он может вывести сообщение, уведомляющее о
получении сигнала.

@item stop
@value{GDBN} должен остановить вашу программу при получении этого
сигнала.  Это также подразумевает ключевое слово @code{print}.

@item print
@value{GDBN} должен вывести сообщение при возникновении данного сигнала.

@item noprint
@value{GDBN} вообще не должен замечать возникновение сигнала.  Это также
подразумевает ключевое слово @code{nostop}.

@item pass
@value{GDBN} должен позволить вашей программе увидеть этот сигнал;
программа может обработать сигнал, или же она может завершиться,
если сигнал фатальный и не обработан.

@item nopass
@value{GDBN} не должен позволять вашей программе видеть этот сигнал.
@end table

Когда сигнал останавливает вашу программу, он невидим для нее,
пока вы не продолжите выполнение.  Затем ваша программа видит
сигнал, если @emph{в данный момент} на рассматриваемый сигнал
распространяется действие команды @code{pass}.  Другими словами, после
того, как @value{GDBN} сообщит о сигнале, вы можете использовать команду
@code{handle} c @code{pass} или @code{nopass}, чтобы
указать, должна ли ваша программа увидеть этот сигнал при продолжении.

Вы также можете использовать команду @code{signal} для того, чтобы
помешать вашей программе увидеть сигнал или, наоборот, заставить ее
заметить обычно игнорируемый сигнал, или чтобы подать ей произвольный
сигнал в любое время.  Например, если ваша программа остановилась
вследствие какой-либо ошибки обращения к памяти, вы можете записать
правильные значения в ошибочные переменные и продолжить выполнение в
надежде посмотреть на дальнейшее выполнение, но ваша программа, вероятно,
немедленно остановилась бы из-за фатального сигнала, как только она 
его заметила бы.  Чтобы помешать этому, вы можете продолжить выполнение с
@samp{signal 0}.  @xref{Подача сигналов, ,Подача сигнала вашей программе}.

@node Остановка нитей
@section Остановка и запуск многонитевых программ

Когда ваша программа имеет несколько нитей выполнения
(@pxref{Нити,, Отладка многонитевых программ}), вы можете выбрать,
установить точки останова либо во всех, либо в каких-то отдельных нитях.

@table @code
@cindex точки останова и нити
@cindex точки останова в нитях
@kindex break @dots{} thread @var{номер-нити}
@item break @var{ном-строки} thread @var{номер-нити}
@itemx break @var{ном-строки} thread @var{номер-нити} if @dots{}
@var{ном-строки} определяет строки исходного текста; существует
несколько способов их задания, но результат всегда один и тот
же --- указание строки исходного текста.

Используйте классификатор @samp{thread @var{номер-нити}} с командой точки
останова, чтобы указать @value{GDBN}, что вы хотите остановить программу,
только когда определенная нить достигнет этой точки.
@var{номер-нити} --- это один из числовых идентификаторов нити,
присвоенный @value{GDBN}, показываемый в первой колонке при выводе
@samp{info threads}.

Если при установке точки останова вы не укажете @samp{thread
@var{номер-нити}}, точка останова будет действовать для @emph{всех}
нитей вашей программы.

Вы также можете использовать классификатор @code{thread} для условных
точек останова; в этом случае, поместите @samp{thread @var{номер-нити}}
перед условием точки останова, вот так:

@smallexample
(@value{GDBP}) break frik.c:13 thread 28 if bartab > lim
@end smallexample

@end table

@cindex остановленные нити
@cindex нити, остановленные
При любой остановке вашей программы под управлением @value{GDBN}
прекращается выполнение @emph{всех} нитей, а не только текущей.  Это
позволяет вам исследовать полное состояние программы, включая
переключение между нитями, не опасаясь, что это может изменить что-либо в
дальнейшем.

@cindex продолжение с нитями
@cindex нити, продолжение
Наоборот, когда вы снова запускаете программу, @emph{все} нити
начинают выполняться.  @emph{Это верно даже при пошаговом выполнении}
такими командами, как @code{step} или @code{next}.

В частности, @value{GDBN} не может пошагово выполнять все нити
параллельно.  Так как планированием выполнения нити занимается
операционная система отлаживаемой цели (не контролируемая @value{GDBN}),
то пока в текущей
нити выполняется один шаг, в других может выполниться несколько.  Более
того, когда выполнение программы останавливается, другие потоки вообще могут
остановиться в середине операторов, а не на границе между ними.

Вы даже можете обнаружить, что после продолжения исполнения или
после пошагового выполнения ваша программа остановилась в другой
нити.  Это случается всякий раз, когда другая нить достигает точки
останова, получает сигнал, или в ней возникает исключительная ситуация,
прежде чем первая нить завершает выполнение того, что вы запросили.

В некоторых операционных системах вы можете заблокировать планировщик
заданий и тем самым позволить выполняться только одной нити.

@table @code
@item set scheduler-locking @var{режим}
Устанавливает режим блокировки планировщика заданий.  Если он установлен
в @code{off}, то блокировки нет и любая нить может выполняться в любое
время.  Если этот режим установлен в @code{on}, то только текущая нить
может выполняться, когда выполнение продолжается.
Режим @code{step} производит оптимизацию для пошагового выполнения.  Он
не дает другим нитям ``захватывать приглашение'' путем приоритетного
прерывания обслуживания текущей нити во время пошагового выполнения.
Другие нити едва ли получат возможность начать выполнение, когда вы
выполняете очередной шаг.  С большей вероятностью они начнут выполняться,
когда вы выполняете команду @code{next} на вызове функции, и им ничто
не помешает выполняться, когда вы используете такие команды, как
@samp{continue}, @samp{until} или @samp{finish}.  Однако, если другие
нити не достигнут точки останова в течение отведенного им для
выполнения времени, они никогда не перехватят приглашение @value{GDBN} у
отлаживаемой вами нити.

@item show scheduler-locking
Отобразить текущий режим блокировки.
@end table


@node Стек
@chapter Исследование стека

Когда ваша программа остановилась, первое, что вам нужно
знать --- где она остановилась, и как она туда попала.

@cindex стек вызовов
Каждый раз, когда ваша программа производит вызов функции,
о нем создается определенная информация.  Она включает положение вызова
в вашей программе, параметры вызова и локальные переменные вызываемой
функции.  Информация сохраняется в блоке данных, называемом
@dfn{кадром стека}.  Кадры стека размещаются в области памяти, называемой
@dfn{стеком вызовов}.

Команды @value{GDBN} для исследования стека позволяют вам увидеть всю эту
информацию при остановке вашей программы.

@cindex выбранный кадр
Один из кадров стека является @dfn{выбранным}, и многие
команды @value{GDBN} неявно относятся к нему.  В частности, когда вы
запрашиваете у @value{GDBN} значение переменной вашей программы, это
значение находится в выбранном кадре.  Для выбора интересующего вас
кадра существуют специальные команды @value{GDBN}.  @xref{Выбор, ,Выбор кадра}.

Когда ваша программа останавливается, @value{GDBN} автоматически
выбирает текущий выполняющийся кадр и выдает его краткое описание,
аналогично команде @code{frame} (@pxref{Информация о кадре, ,Информация о
кадре стека}).

@menu
* Кадры::                       Кадры стека
* Цепочки вызовов::             Цепочки вызовов
* Выбор::                       Выбор кадра
* Информация о кадре::          Информация о кадре
@end menu

@node Кадры
@section Кадры стека

@cindex кадр, определение
@cindex кадр стека
Cтек вызовов разделен на непрерывные участки, называемые
@dfn{кадрами стека}, или @dfn{кадрами} для краткости;
каждый кадр является данными, связанными с одним вызовом одной
функции.  Кадр содержит аргументы, переданные функции, ее локальные
переменные и адрес, с которого она выполняется.

@cindex начальный кадр
@cindex внешний кадр
@cindex внутренний кадр
Когда ваша программа стартует, стек содержит только один кадр --- для
функции @code{main}.  Он называется @dfn{начальным} или @dfn{внешним}
кадром.  Каждый
раз при вызове функции создается новый кадр.  При каждом выходе
из функции кадр вызова этой функции уничтожается.  Если функция
является рекурсивной, для нее может существовать множество кадров.  Кадр
для функции, исполняемой в данный момент, называется @dfn{внутренним}
кадром.  Это кадр, созданный самым последним из всех существующих кадров стека.

@cindex указатель кадра
Внутри вашей программы кадры стека идентифицируются своим адресом.
Кадр стека состоит из множества байт, каждый из которых имеет
свой собственный адрес; каждый тип компьютеров имеет свой способ для
выбора одного байта, чей адрес служит адресом кадра.  Обычно, пока
выполнение происходит в данном кадре, этот адрес содержится в
регистре, называемом @dfn{регистром указателя кадра}.

@cindex номер кадра
@value{GDBN} присваивает номера всем существующим кадрам стека, начиная
с нуля для внутреннего кадра, единицу --- вызвавшему его кадру, и так далее.  В
действительности, эти номера не существуют в вашей программе; они
назначаются @value{GDBN}, чтобы предоставить вам способ различать кадры
стека в командах @value{GDBN}.

@cindex выполнение без кадров
Некоторые компиляторы позволяют компилировать функции так, чтобы
они выполнялись без создания кадров стека.  (Например, ключ @value{GCC}
@samp{-fomit-frame-pointer}
создает функции без кадра.)  Это иногда делается
с часто используемыми библиотечными функциями, чтобы сэкономить время,
требуемое для установки кадра.  @value{GDBN} имеет ограниченные
возможности для обработки таких вызовов.  Если
вызов внутренней функции происходит без создания кадра стека,
@value{GDBN}, тем не менее, описывает его так, как если бы он имел
отдельный кадр, который имеет, как обычно, номер 0, позволяя корректно
трассировать цепочку вызовов функций.  Однако, @value{GDBN} не
имеет средств для работы с функциями без кадра в другом месте стека.

@table @code
@kindex frame@r{, command}
@cindex текущий кадр стека
@item frame @var{арг}
Команда @code{frame} позволяет вам перемещаться от одного кадра стека
к другому и распечатывать выбранный вами кадр.  @var{Арг} может быть либо
адресом кадра, либо его номером.  Без аргумента, @code{frame}
выводит текущий кадр стека.

@kindex select-frame
@cindex тихий выбор стека
@item select-frame
Команда @code{select-frame} позволяет вам перемещаться от одного кадра
стека к другому без его распечатки.  Это ``тихая'' версия @code{frame}.
@end table

@node Цепочки вызовов
@section Цепочки вызовов

@cindex цепочки вызовов
@cindex стек вызовов
Цепочка вызовов предоставляет собой информацию о том, как ваша программа
оказалась там, где она есть.  Она отображает по одной строке для каждого кадра,
начиная с текущего выполняющегося кадра (кадра 0), за которым следует
кадр, из которого он был вызван (кадр 1), и далее вверх по стеку.

@table @code
@kindex backtrace
@kindex bt @r{(@code{backtrace})}
@item backtrace
@item bt
Вывести цепочку вызовов всего стека: по одной строке на кадр,
для всех кадров в стеке.

Вы можете прервать цепочку вызовов в любое время, введя знак
системного прерывания, обычно @kbd{C-c}.

@item backtrace @var{n}
@item bt @var{n}
То же самое, но выводятся только @var{n} внутренних кадров.

@item backtrace -@var{n}
@itemx bt -@var{n}
То же самое, но выводятся только @var{n} внешних кадров.
@end table

@kindex where
@kindex info stack
@kindex info s @r{(@code{info stack})}
@code{where} и @code{info stack} (сокращенно @code{info
s}) --- дополнительные синонимы для @code{backtrace}.

Каждая строка в цепочке вызовов показывает номер кадра и имя функции.
Счетчик команд также показывается, если только вы не используете
@code{set print address off}.  Цепочка вызовов также показывает имя
исходного файла, номер строки и аргументы функции.  Значение счетчика
команд опускается, если он указывает на начало кода для данной строки.

Ниже приведен пример цепочки вызовов.  Она была получена командой
@samp{bt 3}, так что она показывает три внутренних кадра.

@smallexample
@group
#0  m4_traceon (obs=0x24eb0, argc=1, argv=0x2b8c8)
    at builtin.c:993
#1  0x6e38 in expand_macro (sym=0x2b600) at macro.c:242
#2  0x6840 in expand_token (obs=0x0, t=177664, td=0xf7fffb08)
    at macro.c:71
(More stack frames follow...)
@end group
@end smallexample

@noindent
Информация о нулевом кадре не начинается со значения счетчика команд,
что указывает на то, что ваша программа остановилась в начале кода для
строки @code{993} файла @code{builtin.c}.

@node Выбор
@section Выбор кадра

Большинство команд для исследования стека и других данных в вашей
программе применяются выбранному в данный момент кадру.
Здесь приведены команды для выбора кадра стека; все они
завершаются выводом краткого описания выбранного кадра стека.

@table @code
@kindex frame@r{, selecting}
@kindex f @r{(@code{frame})}
@item frame @var{n}
@itemx f @var{n}
Выбрать кадр номер @var{n}.  Напоминаем, что нулевой кадр --- это
внутренний (исполняемый в данный момент) кадр,  первый кадр --- тот, из
которого вызван нулевой, и так далее.  Кадр с наибольшим номером --- это кадр
для функции @code{main}.

@item frame @var{адрес}
@itemx f @var{адрес}
Выбрать кадр, расположенный по адресу @var{адрес}.  В основном это
полезно, если формирование цепочки кадров стека было нарушено из-за
ошибки, сделавшей невозможным для @value{GDBN} правильное присвоение
номеров всем кадрам.  Кроме того, это может быть полезным,
когда у вашей программы есть несколько стеков и происходит
переключение от одного к другому.

В архитектуре SPARC, команде @code{frame} для выбора произвольного
кадра необходимо указать два адреса: указатель кадра и указатель вершины
стека.

В архитектурах MIPS и Alpha требуется два адреса: указатель
вершины стека и указатель команд.

В архитектуре 29k требуется три адреса: указатель вершины
стека регистров, указатель команд и указатель вершины стека памяти.

@kindex up
@item up @var{n}
Переместиться вверх по стеку на @var{n} кадров.  Для положительных
значений @var{n}, это перемещение происходит по направлению к внешнему
кадру, к кадрам с большими номерами, к кадрам, которые существуют
дольше.  По умолчанию @var{n} принимается равным единице.

@kindex down
@kindex do @r{(@code{down})}
@item down @var{n}
Передвинуться вниз по стеку на @var{n} кадров.  Для положительных
значений @var{n}, это продвижение происходит по направлению к
внутреннему кадру, к кадру с меньшим номером, к кадрам, которые были
созданы позже.  По умолчанию, значение @var{n} принимается равным
единице.  Вы можете сокращать @code{down} как @code{do}.
@end table

Все эти команды заканчиваются выводом двух строк, описывающих кадр.
Первая строка показывает номер кадра, имя функции, аргументы,
имя исходного файла и номер выполняемой строки в этом кадре.  Вторая
строка показывает содержимое этой строки исходного текста.

@need 1000
Например:

@smallexample
@group
(@value{GDBP}) up
#1  0x22f0 in main (argc=1, argv=0xf7fffbf4, env=0xf7fffbfc)
    at env.c:10
10              read_input_file (argv[i]);
@end group
@end smallexample

После такого вывода, команда @code{list} без аргументов выводит десять
строк, расположенных вокруг точки выполнения в кадре.
@xref{Вывод строк, ,Вывод строк исходного текста}.

@table @code
@kindex down-silently
@kindex up-silently
@item up-silently @var{n}
@itemx down-silently @var{n}
Эти две команды являются вариантами @code{up} и @code{down} соответственно,
отличаясь от них тем, что делают свою работу ``тихо'', не отображая новый
кадр.  Они предназначены для использования в основном в
командных сценариях @value{GDBN}, где вывод может быть ненужным и
отвлекающим.
@end table

@node Информация о кадре
@section Информация о кадре стека

Существуют несколько других команд для вывода информации о выбранном
кадре стека.

@table @code
@item frame
@itemx f
При использовании без аргументов, эта команда не выбирает новый
кадр, а выводит краткое описание текущего выбранного кадра стека.  Эту
команду можно сокращать как @code{f}.  С аргументом, эта команда
используется для выбора кадра стека.
@xref{Выбор, ,Выбор кадра стека}.

@kindex info frame
@kindex info f @r{(@code{info frame})}
@item info frame
@itemx info f
Эта команда выводит подробное описание выбранного кадра стека,
включающее:

@itemize @bullet
@item
адрес кадра
@item
адрес следующего вниз по стеку кадра (вызываемого из данного)
@item
адрес следующего вверх по стеку кадра (того, из которого был вызван данный)
@item
язык, на котором написан исходный код, соответствующий этому кадру
@item
адрес аргументов кадра
@item
адрес локальных переменных кадра
@item
сохраненный в кадре счетчик команд (адрес выполнения в кадре, вызвавшем данный)
@item
регистры, которые были сохранены в кадре
@end itemize

@noindent Подробное описание полезно, если из-за какой-либо ошибки формат
стека не соответствует обычным соглашениям.

@item info frame @var{адрес}
@itemx info f @var{адрес}
Вывести подробное описание кадра стека, расположенного по адресу
@var{адрес}, не выбирая этот кадр.  Выбранный кадр этой командой не
изменяется.  Она требует параметр
@var{адрес} того же типа, что и команда @code{frame} (для некоторых архитектур
не один, а несколько).
@xref{Выбор, ,Выбор кадра стека}.

@kindex info args
@item info args
Вывести аргументы выбранного кадра, каждый на отдельной строке.

@item info locals
@kindex info locals
Вывести локальные переменные выбранного кадра, каждую на отдельной
строке.  Выводятся все переменные (объявленные как статические или как
автоматические), доступные в точке выполнения выбранного кадра стека.

@kindex info catch
@cindex перехват исключений, список активных обработчиков
@cindex обработчики исключений, как их просмотреть
@item info catch
Выводит список всех обработчиков исключительных ситуаций, являющихся
активными в текущей точке выполнения текущего кадра стека.  Чтобы
увидеть другие обработчики исключительных ситуаций, перейдите в
соответствующую секцию (используя команды @code{up}, @code{down} или
@code{frame}); затем наберите @code{info catch}.
@xref{Установка точек перехвата, ,Установка точек перехвата}.

@end table


@node Исходные файлы
@chapter Исследование исходных файлов

@value{GDBN} может выводить части исходных текстов вашей программы, так как
отладочная информация, записанная в ней, сообщает @value{GDBN}, какие исходные
файлы использовались при создании программы.  Когда ваша программа
останавливается, @value{GDBN} сам выводит строку, на которой она
остановилась.  Аналогично, когда вы выбираете кадр стека (@pxref{Выбор,
,Выбор кадра стека}), @value{GDBN} выводит строку, на которой
остановилось выполнение в этом кадре.  Вы можете выводить другие части
исходных файлов с помощью явных команд.

Если вы используете @value{GDBN} через интерфейс к @sc{gnu} Emacs, вы можете
предпочесть воспользоваться средствами Emacs для просмотра исходных текстов;
смотрите @ref{Emacs, ,Использование @value{GDBN} под управлением
@sc{gnu} Emacs}.

@menu
* Вывод строк::                 Вывод строк исходного текста
* Поиск::                       Поиск в исходных файлах
* Пути для исходных файлов::    Определение каталогов для исходных файлов
* Машинный код::                Исходный текст и машинный код
@end menu

@node Вывод строк
@section Вывод строк исходного текста

@kindex list
@kindex l @r{(@code{info list})}
Чтобы вывести строки файла с исходным текстом, используйте команду
@code{list} (сокращенно @code{l}).  По умолчанию выводятся десять строк.
Существует несколько способов определения того, какую часть файла вы хотите
вывести.

Здесь представлены наиболее употребительные формы команды @code{list}:

@table @code
@item list @var{номер-строки}
Вывести строки, расположенные вокруг строки с номером @var{номер-строки}
в текущем исходном файле.

@item list @var{функция}
Вывести строки, расположенные вокруг начала функции @var{функция}.

@item list
Вывести еще определенное количество строк.  Если последние выведенные
строки выводились с помощью команды @code{list}, то выводятся
строки, следующие за последними выведенными; если, однако,
последней выведенной строкой была одиночная строка, выведенная
как часть отображения кадра стека (@pxref{Стек, ,Исследование стека}),
то выводятся строки, расположенные вокруг нее.

@item list -
Вывести строки, расположенные непосредственно перед последними
выведенными.
@end table

По умолчанию, для любой из этих форм команды @code{list} @value{GDBN}
выводит десять строк исходного текста.  Вы можете изменить это
командой @code{set listsize}:

@table @code
@kindex set listsize
@item set listsize @var{число}
Установить количество выводимых командой @code{list} строк в @var{число}
(если аргумент команды @code{list} не задает явно какое-нибудь другое число).

@kindex show listsize
@item show listsize
Отобразить количество строк, выводимых по команде @code{list}.
@end table

Повторение команды @code{list} нажатием @key{RET} отбрасывает аргумент,
так что это эквивалентно вводу просто @code{list}.  Это полезнее, чем
вывод тех же самых строк снова.  Исключение сделано для параметра
@samp{-}; этот параметр сохраняется при повторе команды, так что каждое
повторение приводит к перемещению вверх по исходному файлу.

@cindex указатели строк
Обычно команда @code{list} ожидает от вас ноль, один или два
@dfn{указателя строк}.  Указатели строк определяют строки
исходного текста; существует несколько способов их задания, но
результат всегда заключается в задании строки исходного текста.  Вот
полное описание возможных параметров команды @code{list}:

@table @code
@item list @var{указ-стр}
Вывести строки, расположенные вокруг строки, определяемой @var{указ-стр}.

@item list @var{перв},@var{посл}
Вывести строки с @var{перв} до @var{посл}.  Оба параметра являются
указателями строк.

@item list ,@var{посл}
Вывести строки, расположенные перед @var{посл}.

@item list @var{перв},
Вывести строки, начиная с @var{перв}.

@item list +
Вывести строки, расположенные сразу за последними выведенными.

@item list -
Вывести строки, расположенные непосредственно перед последними выведенными.

@item list
Описано в предыдущей таблице.
@end table

Ниже перечислены способы указания одиночной строки исходного
текста --- все виды указателей строк.

@table @code
@item @var{номер}
Определяет строку с номером @var{номер} из текущего исходного файла.
Если в качестве параметров к команде @code{list} задано два указателя
строк, это относится к тому же исходному файлу, что и первый указатель
строки.

@item +@var{смещение}
Указывает на строку, смещенную вперед на @var{смещение} строк
относительно последней выведенной строки.  Когда используется в качестве
второго указателя строки для команды @code{list}, имеющей два указателя,
задает строку, смещенную на @var{смещение} строк вниз относительно строки,
определенной первым указателем.

@item -@var{смещение}
Указывает на строку, расположенную на @var{смещение} строк раньше
последней выведенной строки.

@item @var{имя-файла}:@var{номер}
Задает строку @var{номер} из исходного файла @var{имя-файла}.

@item @var{функция}
Определяет строку, с которой начинается тело функции @var{функция}.
Например, в Си это строка с открывающейся фигурной скобкой.

@item @var{имя-файла}:@var{функция}
Определяет строку с открывающейся фигурной скобкой, с которой
начинается тело функции @var{функция} в файле @var{имя-файла}.  Имя
файла необходимо лишь для того, чтобы избежать неоднозначности, когда в
различных исходных файлах есть одинаково названные функции.

@item *@var{адрес}
Определяет строку, соответствующую адресу @var{адрес} программы.
@var{адрес} может быть любым выражением.
@end table

@node Поиск
@section Поиск в исходных файлах
@cindex поиск
@kindex reverse-search

Существуют две команды для поиска по регулярному выражению в текущем
исходном файле.

@table @code
@kindex search
@kindex forward-search
@item forward-search @var{рег-выраж}
@itemx search @var{рег-выраж}
Команда @samp{forward-search @var{рег-выраж}} проверяет на соответствие
регулярному выражению @var{рег-выраж} каждую строку, начиная со
строки, следующей за последней выведенной.  Найденная строка выводится.
Вы можете использовать синоним @samp{search @var{рег-выраж}} или
сокращать имя команды как @code{fo}.

@item reverse-search @var{рег-выраж}
Команда @samp{reverse-search @var{рег-выраж}}, двигаясь назад, проверяет на
соответствие регулярному выражению @var{рег-выраж} каждую строку,
начиная с предшествующей последней выведенной.  Найденная
строка выводится.  Вы можете сокращать эту команду как @code{rev}.
@end table

@node Пути для исходных файлов
@section Определение каталогов с исходными файлами

@cindex пути для исходных файлов
@cindex каталоги с исходными файлами
Исполняемые программы иногда не сохраняют имена каталогов, в которых
находились исходные файлы, из которых они скомпилированы, а хранят лишь имена
файлов.  Даже если они их сохранили, каталоги могли быть перемещены в
период между компиляцией и сеансом отладки.  У @value{GDBN} есть список
каталогов для поиска исходных файлов; он называется @dfn{путь для
исходных файлов}.  Каждый раз, когда @value{GDBN} требуется исходный
файл, он перебирает по порядку все каталоги из этого списка, пока не
находит файл с требуемым именем.  Заметьте, что пути поиска исполняемых
файлов для этой цели @emph{не} используются, как не используется и
текущий рабочий каталог, если только он не присутствует в пути для
исходных файлов.

Если @value{GDBN} не может найти исходный файл, используя путь для
исходных файлов, а в объектном файле программы указан какой-либо
каталог, @value{GDBN} просматривает также и его.  В последнюю очередь, если
путь для исходных файлов пуст и запись о каталоге компиляции отсутствует,
@value{GDBN} просматривает текущий каталог.

При переустановке или переупорядочивании пути для исходных файлов,
@value{GDBN} очищает любую запомненную им информацию о том,
где исходные файлы были найдены и о расположении строк в них.

@kindex directory
@kindex dir
Когда вы вызываете @value{GDBN}, путь для исходных файлов
содержит только @samp{cdir} и @samp{cwd}, в этом порядке.  Для
добавления других каталогов, используйте команду @code{directory}.

@table @code
@item directory @var{имя-каталога} @dots{}
@item dir @var{имя-каталога} @dots{}
Добавить каталог @var{имя-каталога} в начало пути для исходных
файлов.  Этой команде могут быть заданы несколько имен, разделенные
@samp{:} (@samp{;} в MS-DOS и MS-Windows, где @samp{:} обычно является
частью абсолютного имени файла) или пробелом.  Вы можете указать
каталог, который уже содержится в пути для исходных файлов; это
переместит его в начало, так что @value{GDBN} будет просматривать его
раньше.

@kindex cdir
@kindex cwd
@vindex $cdir@r{, вспомогательная переменная}
@vindex $cwd@r{, вспомогательная переменная}
@cindex каталог компиляции
@cindex текущий каталог
@cindex рабочий каталог
@cindex каталог, текущий
@cindex компиляции, каталог
Вы можете использовать строку @samp{$cdir} для ссылки на каталог
компиляции (если информация о нем сохранена), и @samp{$cwd} для ссылки
на текущий рабочий каталог.  @samp{$cwd} --- это не то же самое, что
@samp{.}.  Первая отслеживает текущий рабочий каталог, который может
меняться во время вашего сеанса работы с @value{GDBN}, тогда как
вторая сразу преобразовывается в текущий каталог в момент его
добавления в путь для исходных файлов.

@item directory
Очистить путь для файлов с исходными текстами.  Эта команда
требует подтверждения.

@item show directories
@kindex show directories
Вывести путь поиска исходных файлов: показать, какие каталоги он
содержит.
@end table

Если ваш путь для исходных файлов перемешан с уже неиспользуемыми
каталогами, @value{GDBN} может иногда вызвать недоумение, найдя
неправильный вариант исходного файла.  Вы можете исправить ситуацию
следующим образом:

@enumerate
@item
Использовать @code{directory} без параметров, чтобы очистить путь
поиска исходных файлов.

@item
Использовать @code{directory} с подходящими аргументами, чтобы
переустановить каталоги, которые вы хотите видеть в пути для исходных
файлов.  Вы можете добавить все каталоги одной командой.
@end enumerate

@node Машинный код
@section Исходный текст и машинный код

Вы можете использовать команду @code{info line}, чтобы отобразить строки
исходного текста в программные адреса (и наоборот), и
команду @code{disassemble}, чтобы вывести диапазон адресов в виде
машинных инструкций.  При запуске в режиме @sc{gnu} Emacs, команда
@code{info line} выводит стрелку, указывающую на заданную строку.
Также @code{info line} выводит адреса как в символьной форме, так и в
шестнадцатеричной.

@table @code
@kindex info line
@item info line @var{указ-стр}
Выводит начальный и конечный адреса скомпилированного кода,
соответствующего строке исходного текста @var{указ-стр}.  Вы можете
определить строки исходного текста любым способом, воспринимаемым
командой @code{list} (@pxref{Вывод строк, ,Вывод строк исходного текста}).
@end table

Например, мы можем использовать @code{info line} для определения
положения объектного кода первой строки функции
@code{m4_changequote}:

@smallexample
(@value{GDBP}) info line m4_changequote
Line 895 of "builtin.c" starts at pc 0x634c and ends at 0x6350.
@end smallexample

@noindent
Мы также можем запросить (используя @code{*@var{адрес}} как форму
задания @var{указ-стр}), какая строка исходного текста соответствует
определенному адресу:

@smallexample
(@value{GDBP}) info line *0x63ff
Line 926 of "builtin.c" starts at pc 0x63e4 and ends at 0x6404.
@end smallexample

@cindex @code{$_} и @code{info line}
@kindex x@r{(исследовать) и} info line
После @code{info line}, адрес, используемый по умолчанию для команды
@code{x}, меняется на начальный адрес строки, так что @samp{x/i}
достаточно для начала исследования машинного кода (@pxref{Память,
,Исследование памяти}).  Этот адрес также сохраняется как значение
вспомогательной переменной @code{$_} (@pxref{Вспомогательные переменные,
,Вспомогательные переменные}).

@table @code
@kindex disassemble
@cindex ассемблерные инструкции
@cindex инструкции ассемблера
@cindex машинные инструкции
@cindex вывод машинных инструкций
@item disassemble
Эта специализированная команда служит для дампа диапазона памяти в виде
машинных инструкций.  Диапазоном памяти по умолчанию является функция, в
которой находится счетчик программы в выбранном кадре.  Одиночным
параметром этой команды является значение счетчика программы;
@value{GDBN} выводит дамп функции, которой принадлежит указанный адрес.  Два
параметра определяют диапазон адресов для дампа (первый включается, второй
исключается).
@end table

Следующий пример показывает результат дисассемблирования диапазона
адресов кода HP PA-RISC 2.0:

@smallexample
(@value{GDBP}) disas 0x32c4 0x32e4
Dump of assembler code from 0x32c4 to 0x32e4:
0x32c4 <main+204>:      addil 0,dp
0x32c8 <main+208>:      ldw 0x22c(sr0,r1),r26
0x32cc <main+212>:      ldil 0x3000,r31
0x32d0 <main+216>:      ble 0x3f8(sr4,r31)
0x32d4 <main+220>:      ldo 0(r31),rp
0x32d8 <main+224>:      addil -0x800,dp
0x32dc <main+228>:      ldo 0x588(r1),r26
0x32e0 <main+232>:      ldil 0x3000,r31
End of assembler dump.
@end smallexample

Некоторые архитектуры имеют несколько широко используемых наборов мнемоник
инструкций или другой синтаксис.

@table @code
@kindex set disassembly-flavour
@cindex ассемблерные инструкции
@cindex инструкции ассемблера
@cindex машинные инструкции
@cindex вывод машинных инструкций
@cindex диалект дисассемблирования Intel
@cindex диалект дисассемблирования AT&T
@item set disassembly-flavor @var{набор-инструкций}
Выбрать набор инструкций для использования при дисассемблировании программы
командами @code{disassemble} и @code{x/i}.

В настоящее время эта команда определена только для Intel x86.  Вы
можете установить @var{набор-инструкций} в @code{intel} или @code{att}.
По умолчанию установлено @code{att}, диалект AT&T используется по
умолчанию ассемблерами Unix на архитектурах, базирующихся на x86.
@end table


@node Данные
@chapter Исследование данных

@cindex вывод данных
@cindex исследование данных
@kindex print
@kindex inspect
Для исследования данных в вашей программе обычно используется
команда @code{print} (сокращенно @code{p}) или ее синоним
@code{inspect}.  Она вычисляет и выводит значение выражения, записанного
на том же языке, что и ваша программа (@pxref{Языки,
,Использование @value{GDBN} с различными языками}).

@table @code
@item print @var{выраж}
@itemx print /@var{f} @var{выраж}
@var{выраж} является выражением (на исходном языке).  По умолчанию, значение
@var{выраж} выводится в формате, соответствующем его типу данных; вы можете
выбрать другой формат, указав @samp{/@var{f}}, где @var{f} --- буква,
определяющая формат; смотрите @ref{Форматы вывода,,Форматы вывода}.

@item print
@itemx print /@var{f}
Если вы опустите @var{выраж}, @value{GDBN} отображает последнее
значение снова (из @dfn{истории значений}; @pxref{История значений,
,История значений}).  Это предоставляет вам удобный способ изучить то же
самое значение в другом формате.
@end table

Команда @code{x} позволяет исследовать данные на более низком уровне.  Она
исследует данные в памяти по указанному адресу и выводит их в
указанном формате.  @xref{Память, ,Исследование памяти}.

Если вас интересует информация о типах или о том, как объявлены
поля структуры или класса, используйте команду @code{ptype @var{выраж}}
вместо @code{print}.  @xref{Символы, ,Исследование таблицы символов}.

@menu
* Выражения::                   Выражения
* Переменные::                  Переменные программы
* Массивы::                     Искусственные массивы
* Форматы вывода::              Форматы вывода
* Память::                      Исследование памяти
* Автоматическое отображение::  Автоматическое отображение
* Параметры вывода::            Параметры вывода
* История значений::            История значений
* Вспомогательные переменные::  Вспомогательные переменные
* Регистры::                    Регистры
* Вычисления с плавающей точкой::
                                Аппаратные средства поддержки вычислений
                                с плавающей точкой
@end menu

@node Выражения
@section Выражения

@cindex выражения
@code{print} и многие другие команды @value{GDBN} принимают в качестве
параметра выражение и вычисляют его значение.  В выражении @value{GDBN}
допустимо использование любого типа констант, переменных или операторов,
определенных в используемом вами языке программирования, включая
условные выражения, вызовы функций, приведение типов и строковые
постоянные.  К сожалению, исключением являются символы, определенные
командами препроцессора @code{#define}.

@value{GDBN} поддерживает константы-массивы в выражениях, введенных
пользователем.  Синтаксис следующий: @{@var{элемент},
@var{элемент}@dots{}@}.  Например, вы можете использовать команду
@code{print @{1, 2, 3@}}, чтобы создать в памяти массив,
который будет доступен в программе так же, как выделенный функцией
@code{malloc}.

По причине широкого распространения Си, большинство выражений в
примерах этого руководства написаны на Си.  @xref{Языки, ,Использование
@value{GDBN} с различными языками}, для информации об использовании
выражений в других языках.

В этом разделе мы обсуждаем операторы, которые вы можете использовать
в выражениях @value{GDBN} независимо от используемого вами языка
программирования.

Приведения типов поддерживается во всех языках, а не только в Си,
так как бывает очень полезно преобразовать число в указатель, чтобы
исследовать структуру, расположенную по этому адресу в памяти.

@value{GDBN} поддерживает эти операторы, в дополнении к следующим,
являющимися общими для языков программирования:

@table @code
@item @@
@samp{@@} является бинарным оператором, позволяющим рассматривать
области памяти как массивы.
@xref{Массивы, ,Исскуственные массивы}, для дополнительной информации.

@item ::
@samp{::} позволяет вам указывать переменную в терминах файла или функции,
где она определена.  @xref{Переменные, ,Переменные программы}.

@cindex @{@var{тип}@}
@cindex приведение области памяти к типу
@cindex память, просмотр в виде типизированного объекта
@cindex приведение, для просмотра памяти
@item @{@var{тип}@} @var{адрес}
Ссылается на объект типа @var{тип}, хранящийся в памяти по адресу
@var{адрес}.  @var{Адрес} может быть любым выражением, значением которого
является целое число или указатель (но вокруг бинарных операторов, также
как и вокруг оператора приведения типа, требуются скобки).  Эта
конструкция допустима вне зависимости от того, какого типа данные
предположительно расположены по @var{адресу}.
@end table

@node Переменные
@section Переменные программы

Чаще всего в качестве выражения используется имя переменной вашей
программы.

Переменные в выражениях трактуются в контексте выбранного кадра стека
(@pxref{Выбор, ,Выбор кадра стека}); они могут быть либо

@itemize @bullet
@item
глобальными (или статическими)
@end itemize

@noindent либо

@itemize @bullet
@item
видимыми из точки выполнения в данном кадре, в соответствии с правилами
определения области видимости языка программирования.
@end itemize

@noindent Это означает, что в функции

@example
foo (a)
     int a;
@{
  bar (a);
  @{
    int b = test ();
    bar (b);
  @}
@}
@end example

@noindent
вы можете исследовать и использовать переменную @code{a} всякий раз,
когда ваша программа выполняется в пределах функции @code{foo}, но
переменную @code{b} можно использовать или исследовать только тогда,
когда ваша программа выполняется внутри блока, в котором она объявлена.

@cindex конфликт имен переменных
Есть исключение: вы можете ссылаться на переменную или функцию, областью
видимости которой является единственный исходный файл, даже если точка
текущего выполнения в нем не находится.  Допускается существование
нескольких переменных или функций с одинаковым именем (в различных
исходных файлах).  Если это так, обращение к этому имени приводит к
непредсказуемым результатам.  Если хотите, вы можете указать
статическую переменную в конкретной функции или в файле, используя
двойное двоеточие:

@cindex двойное двоеточие, контекст для переменных/функций
@iftex
@cindex @code{::}, контекст для переменных/функций
@end iftex
@example
@var{файл}::@var{переменная}
@var{функция}::@var{переменная}
@end example

@noindent
Здесь @var{файл} или @var{функция} --- название контекста для статической
@var{переменной}.  В первом случае вы можете использовать кавычки, чтобы
@value{GDBN} рассматривал имя файла как одно слово; например, чтобы вывести
глобальное значение переменной @code{x}, определенной в @file{f2.c}:

@example
(@value{GDBP}) p 'f2.c'::x
@end example

@cindex определение области видимости в Си++
Такое использование @samp{::} крайне редко конфликтует с похожим
использованием той же записи в Си++.  @value{GDBN} также поддерживает
использование оператора определения области видимости Си++ в выражениях.

@cindex неверные значения
@cindex значения переменных, неверные
@quotation
@emph{Предупреждение:} В некоторых случаях, в определенной точке функции
(сразу после входа в новую область видимости и непосредственно перед
выходом из нее)
может показаться, что локальная переменная имеет неверное значение.
@end quotation

Вы можете столкнуться с этой проблемой при пошаговом выполнении по
одной машинной инструкции.  Она возникает из-за того, что на большинстве
машин процедура установки кадра стека (включая определения локальных
переменных) занимает более одной инструкции; если вы
производите пошаговое выполнение по одной машинной инструкции, может
показаться, что переменная имеет неверное значение, пока кадр стека не
будет полностью построен.  При выходе, для уничтожения кадра стека
обычно также требуется более одной инструкции; после начала
пошагового выполнения этой группы инструкций определения локальных переменных
могут пропасть.

Это также может случиться, когда компилятор делает значительную
оптимизацию.  Чтобы быть уверенным, что вы всегда видите точные
значения, отключите всю оптимизацию при компиляции.

@cindex ``No symbol "foo" in current context''
Другой возможный эффект оптимизации компилятора заключается в уничтожении
неиспользуемых переменных или в присвоении переменных регистрам (а не
адресам памяти).  В зависимости от поддержки таких ситуаций,
предоставляемой форматом отладочной информации, который использует
компилятор, @value{GDBN} может не вывести значения таких локальных
переменных.  Если это происходит, @value{GDBN} выведет сообщение,
подобное этому:

@example
No symbol "foo" in current context.
@end example

Для решения таких проблем или перекомпилируйте программу без
оптимизации, или используйте другой формат отладочной информации, если
компилятор поддерживает несколько таких форматов.  Например
@value{NGCC}, компилятор @sc{gnu} Си/Си++, обычно поддерживает ключ
@samp{-gstabs}.  @samp{-gstabs} создает отладочную информацию в формате,
являющимся развитием таких форматов, как COFF.  У вас может быть
возможность использовать DWARF2 (@samp{-gdwarf-2}), который тоже
является эффективной формой представления отладочной информации.
Смотрите @ref{Ключи для отладки,,Ключи для отладки вашей программы или
@sc{gnu} CC, gcc.info, Использование @sc{gnu} CC}, для дополнительной
информации.


@node Массивы
@section Искусственные массивы

@cindex искусственные массивы
@kindex @@@r{, ссылка на память как на массив}
Часто бывает полезным вывести несколько объектов одного типа,
расположенных в памяти последовательно; часть массива или динамический
массив, для которого в программе существует только указатель.

Вы можете это сделать, обращаясь к непрерывному участку памяти как к
@dfn{искусственному массиву}, используя бинарный оператор @samp{@@}.
Левым операндом для @samp{@@} должен быть первый элемент желаемого
массива, и он должен быть индивидуальным объектом.  Правым операндом
должна быть длина массива.  Результатом операции будет массив, все элементы
которого имеют тот же тип, что и левый аргумент.  Первым элементом
массива является левый аргумент; второй элемент формируется из байтов
памяти, непосредственно следующих за байтами, содержащими первый элемент, и
так далее.  Например, если в программе есть строка

@example
int *array = (int *) malloc (len * sizeof (int));
@end example

@noindent
то вы можете вывести содержимое @code{array} с помощью

@example
p *array@@len
@end example

Левый операнд операции @samp{@@} должен находиться в памяти.
Значения массивов, полученных операцией @samp{@@}, при индексации ведут
себя точно так же, как и другие массивы, и приводятся к указателям при
использовании в выражениях.  Искусственные массивы чаще всего появляются
в выражениях через историю значений (@pxref{История значений, ,История
значений}), после вывода одного из них.

Другой способ создания искусственного массива --- использование приведения
типов.  Оно заново интерпретирует значение так, как если бы оно было
массивом.  Значение не обязано находиться в памяти.

@example
(@value{GDBP}) p/x (short[2])0x12345678
$1 = @{0x1234, 0x5678@}
@end example

Если вы опускаете длину массива (как в
@samp{(@var{тип}[])@var{значение}}), @value{GDBN} для удобства вычисляет
его размер для заполнения значениями (как
@samp{sizeof(@var{значение})/sizeof(@var{тип})}:

@example
(@value{GDBP}) p/x (short[])0x12345678
$2 = @{0x1234, 0x5678@}
@end example

Иногда механизма искусственных массивов бывает недостаточно;
в сравнительно сложных структурах данных интересующие нас элементы могут
не быть смежными --- например, если вас интересуют значения указателей в
массиве.  Одно из удачных решений этой проблемы --- использование
вспомогательной переменной (@pxref{Вспомогательные переменные,
Вспомогательные переменные}) в качестве счетчика в выражении, выводящем
первое интересующее нас значение, а затем повторять это выражение
нажатием @key{RET}.  Предположим, например, у вас есть массив
@code{dtab} указателей на структуры, и вас интересуют значения полей
@code{fv} в каждой структуре.  Ниже приведен пример ваших возможных действий:

@example
set $i = 0
p dtab[$i++]->fv
@key{RET}
@key{RET}
@dots{}
@end example

@node Форматы вывода
@section Форматы вывода

@cindex форматированный вывод
@cindex форматы вывода
По умолчанию, @value{GDBN} печатает значение в соответствии с его типом.
Это не всегда отвечает вашему желанию.  Например, вы можете захотеть вывести
число в шестнадцатеричной записи или указатель в десятичной.  Или вы
можете захотеть просмотреть данные по некоторому адресу в памяти в
виде строки знаков или в виде инструкций.  Для этого при выводе значения
задайте @dfn{формат вывода}.

Простейшим применением форматов вывода является форматирование вывода
уже вычисленного выражения.  Чтобы сделать это, начните параметры
команды @code{print} с косой черты и символа формата.  Поддерживаются
следующие символы формата:

@table @code
@item x
Рассматривать биты значения как целое и вывести целое в
шестнадцатеричном виде.

@item d
Вывести как десятичное целое со знаком.

@item u
Вывести как десятичное целое без знака.

@item o
Вывести как восьмеричное целое.

@item t
Вывести как целое в двоичном виде.  Буква @samp{t} означает ``two''.
@footnote{@samp{b} не может быть использовано, потому что эти символы
формата также используются с командой @code{x}, где @samp{b} означает
``byte''; смотрите @ref{Память,,Исследование памяти}.}

@item a
@cindex неизвестный адрес, нахождение
Вывести в виде адреса, как абсолютного в шестнадцатеричной записи, так и
в виде смещения от ближайшего предшествующего символа.  Вы можете
использовать этот формат, чтобы определить, где (в какой
функции) расположен какой-либо неизвестный адрес:

@example
(@value{GDBP}) p/a 0x54320
$3 = 0x54320 <_initialize_vx+396>
@end example

@item c
Рассматривать как целое и вывести в виде строковой постоянной.

@item f
Рассматривать биты значения как число с плавающей точкой и вывести с
использованием обычного синтаксиса для этих чисел.
@end table

Например, чтобы вывести счетчик программы в шестнадцатеричном виде
(@pxref{Регистры}), введите

@example
p/x $pc
@end example

@noindent
Обратите внимание, что перед косой чертой не требуется пробела, потому
что имена команд в @value{GDBN} не могут содержать косую черту.

Чтобы вывести последнее значение из истории значений в другом
формате, вы можете воспользоваться командой @code{print} лишь с указанием
формата и без выражения.  Например, @samp{p/x} выведет последнее
значение в шестнадцатеричной форме.

@node Память
@section Исследование памяти

Вы можете использовать команду @code{x} (от слова ``examine'') для
исследования памяти в одном из нескольких форматов, независимо от типов
данных вашей программы.

@cindex исследование памяти
@table @code
@kindex x @r{(исследование памяти)}
@item x/@var{nfu} @var{адрес}
@itemx x @var{адрес}
@itemx x
Для исследования памяти используйте команду @code{x}.
@end table

@var{n}, @var{f} и @var{u} --- необязательные параметры, определяющие,
сколько памяти отобразить и в каком формате; @var{адрес} --- это выражение,
задающее адрес, с которого вы хотите начать отображение памяти.  Если вы
используете значения по умолчанию для @var{nfu}, то вам не нужно вводить
косую черту @samp{/}.  Некоторые команды устанавливают удобные значения
по умолчанию для @var{адреса}.

@table @r
@item @var{n}, счетчик повторений
Счетчик повторений является десятичным целым числом; по умолчанию 1.
Он определяет, сколько памяти отобразить (считая в единицах @var{u}).

@item @var{f}, формат отображения
Формат отображения --- это один из форматов, используемых командой
@code{print}, @samp{s} (строка, оканчивающаяся нулем), или @samp{i}
(машинная инструкция).  Первоначально, значением по умолчанию
установлено @samp{x} (шестнадцатеричная форма).  Значение по умолчанию
изменяется каждый раз, когда вы используете либо @code{x}, либо
@code{print}.

@item @var{u}, размер единицы измерений
Размер единицы измерений может быть одним из

@table @code
@item b
Байты.
@item h
Полуслова (два байта).
@item w
Слова (четыре байта).  Это первоначальное значение по умолчанию.
@item g
Длинные слова (восемь байт).
@end table

Каждый раз, когда вы определяете размер единицы измерений командой @code{x},
этот размер становится размером по умолчанию при последующем использовании
@code{x}.  (Для форматов @samp{s} и @samp{i} размер единицы измерений
игнорируется и обычно не пишется.)

@item @var{адрес}, начальный адрес отображения
@var{адрес} --- это адрес, с которого вы хотите, чтобы @value{GDBN}
начинал отображение памяти.  Значение выражения не обязано должно быть
указателем (хотя может им быть); оно всегда интерпретируется как целый
адрес байта в памяти.  @xref{Выражения, ,Выражения}, для дополнительной
информации о выражениях.  Значением по умолчанию для @var{адреса}
обычно является адрес, следующий за последним изученным адресом, но некоторые
другие команды также устанавливают это значение: @code{info breakpoints}
(в адрес последней выведенной точки останова), @code{info line} (в
начальный адрес строки) и @code{print} (если вы используете эту
команду для отображения значения из памяти).
@end table

Например, @samp{x/3uh 0x54320} --- запрос на вывод трех полуслов
(@code{h}) памяти в формате беззнаковых десятичных целых (@samp{u}),
начиная с адреса @code{0x54320}.  @samp{x/4xw $sp} выводит четыре слова
(@samp{w}) памяти, расположенные над указателем стека (здесь @samp{$sp};
@pxref{Регистры, ,Регистры}), в шестнадцатеричном виде (@samp{x}).

Так как все буквы, обозначающие размер единиц измерения, отличаются от букв,
определяющих форматы вывода, вы не должны запоминать, формат или размер
единиц измерений указывается раньше; это можно делать в любом
порядке.  Спецификации вывода @samp{4xw} и @samp{4wx} означают в
точности одно и то же.  (Однако, число @var{n} должно быть первым;
@samp{wx4} не сработает.)

Хотя размер единицы измерения @var{u} игнорируется для форматов @samp{s}
и @samp{i}, вы, тем не менее, можете воспользоваться счетчиком повторений
@var{n}; например, @samp{3i} указывает, что вы хотите вывести три
машинные инструкции, включая любые операнды.  Команда @code{disassemble}
предоставляет альтернативный способ исследования машинных инструкций;
смотрите @ref{Машинный код,,Исходный и машинный код}.

Все значения по умолчанию для аргументов команды @code{x} разработаны
таким образом, чтобы облегчить продолжение сканирования памяти с
минимальными конкретизациями при очередном использовании @code{x}.  Например,
после того, как вы просмотрели три машинные инструкции с помощью
@samp{x/3i @var{адрес}}, вы можете просмотреть следующие семь, используя
просто @samp{x/7}.  Если вы повторяете команду @code{x} нажатием
@key{RET}, число повторений @var{n} остается прежним; другие параметры
берутся по умолчанию, как для последовательных использований @code{x}.

@cindex @code{$_}, @code{$__} и история значений
Адреса и их содержимое, выводимые командой @code{x}, не сохраняются в
истории значений, так как они мешали бы.
Вместо этого,
@value{GDBN} делает их доступными для последующего использования в
выражениях как значения вспомогательных переменных @code{$_} и
@code{$__}.  После команды @code{x}, последний исследованный адрес
доступен для использования в выражениях во вспомогательной переменной
@code{$_}.  Содержимое этого адреса, исследованное только что, доступно во
вспомогательной переменной @code{$__}.

Если команде @code{x} задан счетчик повторений, адрес и его содержимое
сохраняются из последнего выведенного элемента памяти; это не то же
самое, что последний выведенный адрес, если в последней строке вывода
были отображены несколько элементов.

@node Автоматическое отображение
@section Автоматическое отображение
@cindex автоматическое отображение
@cindex отображение выражений

Если вам необходимо часто выводить значение какого-либо выражения
(чтобы увидеть, как оно меняется), вы можете добавить его в
@dfn{список автоматического отображения}, чтобы @value{GDBN} выводил его
значение каждый раз при остановке вашей программы.  Каждому выражению,
добавленному в список, присваивается идентификационный номер; чтобы
удалить выражение из списка, вы указываете этот номер.  Автоматическое
отображение выглядит следующим образом:

@example
2: foo = 38
3: bar[5] = (struct hack *) 0x3804
@end example

@noindent
Это отображение показывает номера элементов, выражения и их текущие
значения.  Как и при отображении, запрашиваемом вручную с помощью @code{x}
или @code{print}, вы можете указать предпочитаемый формат вывода;
фактически, @code{display} выбирает между @code{print}
и @code{x} в зависимости от того, насколько детально задана
спецификация формата: @code{x} используется, если вы указываете размер
элемента или один из двух форматов (@samp{i} и @code{s}), которые
поддерживаются только @code{x}; в остальных случаях применяется @code{print}.

@table @code
@kindex display
@item display @code{выраж}
Добавляет выражение @var{выраж} к списку выражений, отображаемых каждый
раз, когда ваша программа останавливается.  @xref{Выражения, ,Выражения}.

@code{display} не повторяется, если вы повторно нажимаете
@key{RET} после ее использования.

@item display/@var{формат} @var{выраж}
Если @var{формат} определяет только формат вывода, а не размер или
счетчик повторений, выражение @var{выраж} добавляется в список
автоматического отображения, но его отображение осуществляется в
указанном формате @var{формат}.  @xref{Форматы вывода,,Форматы вывода}.

@item display/@var{формат} @var{адрес}
Если @var{форматом} является @samp{i} или @samp{s}, или он включает в себя размер
элементов или их число, выражение @var{адрес} добавляется как адрес
памяти для исследования при каждой остановке вашей программы.  Под
исследованием в данном случае подразумевается выполнение
@samp{x/@var{формат} @var{адрес}}.  @xref{Память, ,Исследование памяти}.
@end table

Например, команда @samp{display/i $pc} может быть полезна, чтобы при каждой
остановке видеть машинную инструкцию, которая будет
выполняться следующей (@samp{$pc} --- это общее обозначение счетчика
программы; @pxref{Регистры, ,Регистры}).

@table @code
@kindex delete display
@kindex undisplay
@item undisplay @var{номера}@dots{}
@itemx delete display @var{номера}@dots{}
Удалить элементы с номерами @var{номера} из списка выражений, подлежащих
отображению.

@code{undisplay} не повторяется при последующем нажатии @key{RET}.
(Иначе вы сразу получили бы сообщение об ошибке @samp{No display number
@dots{}}.)

@kindex disable display
@item disable display @var{номера}@dots{}
Отключить отображение элементов с номерами @var{номера}.  Отключенные
элементы не выводятся автоматически, но и не забываются.
Впоследствии их можно снова включить.

@kindex enable display
@item enable display @var{номера}@dots{}
Включить отображение элементов с номерами @var{номера}.  Выражения,
соответствующие этим номерам, снова будут выводиться автоматически, пока
вы не укажете обратное.

@item display
Отобразить текущие значения выражений из списка, точно так же,
как это происходит при остановке вашей программы.

@kindex info display
@item info display
Вывести список выражений, ранее установленных для автоматического
отображения, каждое с его номером элемента, но не показывая значений.  Список
включает отключенные выражения, с соответствующей пометкой.  Он также
включает в себя выражения, которые не могут быть показаны прямо сейчас,
потому что обращаются к автоматическим переменным, недоступным
в данный момент.
@end table

Если отображаемое выражение обращается к локальным переменным, оно
не имеет смысла вне того лексического контекста, для которого оно
устанавливалось.  Такое выражения отключается, как только выполнение
входит в контекст, где одна из его переменных становится неопределенной.
Например, если вы дадите команду @code{display last_char}, находясь
внутри функции с аргументом @code{last_char}, @value{GDBN} будет
отображать этот аргумент, пока программа останавливается внутри этой
функции.  Как только она остановится где-то еще --- где нет переменной
@code{last_char} --- отображение будет отключено автоматически.  Вы
можете снова включить его при следующей остановке программы там, где
@code{last_char} будет вновь иметь смысл.

@node Параметры вывода
@section Параметры вывода

@cindex параметры формата
@cindex установки вывода
@value{GDBN} предоставляет следующие способы управления выводом массивов,
структур и символов.

@noindent
Данные параметры полезны при отладке программ на любом языке:

@table @code
@kindex set print address
@item set print address
@itemx set print address on
@value{GDBN} выводит адреса памяти, показывающие положение стека,
структур, указателей, точек останова и так далее, даже
когда он отображает также содержимое этих адресов.  Значение по умолчанию
установлено в @code{on}.  Например, вот как выглядит отображение кадра
стека с установленным @code{set print address on}:

@smallexample
@group
(@value{GDBP}) f
#0  set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
    at input.c:530
530         if (lquote != def_lquote)
@end group
@end smallexample

@item set print address off
Не выводить адреса при отображении их содержимого.  Вот, например,
тот же кадр стека, отображенный с установкой @code{set print address
off}:

@smallexample
@group
(@value{GDBP}) set print addr off
(@value{GDBP}) f
#0  set_quotes (lq="<<", rq=">>") at input.c:530
530         if (lquote != def_lquote)
@end group
@end smallexample

Вы можете использовать @samp{set print address off}, чтобы удалить
все машинно-зависимые отображения из интерфейса @value{GDBN}.  Например, с
@code{print address off}, вы должны получить одинаковый текст для
цепочек вызовов на всех машинах, независимо от того, включают они
указатели в качестве аргументов или нет.

@kindex show print address
@item show print address
Показать, должны выводиться адреса или нет.
@end table

При выводе адреса в символьной форме, @value{GDBN} обычно выводит ближайший
предшествующий символ плюс смещение.  Если этот символ не определяет
адрес однозначно (например, это имя, областью действия которого является
один исходный файл), вам может потребоваться дать пояснения.  Один из
способов это сделать --- с помощью @code{info line}; например,
@samp{info line *0x4537}.  Альтернативный способ заключается в том, чтобы
@value{GDBN} выводил имя исходного файла и номер строки при выводе
символьного адреса:

@table @code
@kindex set print symbol-filename
@item set print symbol-filename on
Велит @value{GDBN} выводить имя исходного файла и номер строки
символа в символьной форме адреса.

@item set print symbol-filename off
Не выводить имя исходного файла и номер строки символа.  Принимается по
умолчанию.

@kindex show print symbol-filename
@item show print symbol-filename
Показать, будет @value{GDBN} выводить имя исходного файла и номер строки
в символьной форме адреса или нет.
@end table

Другая ситуация, в которой полезно показывать имена файлов
и номера строк, возникает при дисассемблировании кода; @value{GDBN}
показывает вам номер строки и исходный файл, которые соответствуют
каждой инструкции.

Вы также можете захотеть видеть символьную форму только в том
случае, если выводимый адрес достаточно близок к ближайшему
предшествующему символу:

@table @code
@kindex set print max-symbolic-offset
@item set print max-symbolic-offset @var{макс-смещение}
Велит @value{GDBN} выводить символьные формы только тех
адресов, для которых смещение между ближайшим предшествующим символом и
адресом меньше, чем @var{макс-смещение}.  По умолчанию значение
@var{макс-смещение} равно 0; в этом случае @value{GDBN} всегда выводит
адрес в символьной форме, если ему предшествует хоть какой-нибудь символ.

@kindex show print max-symbolic-offset
@item show print max-symbolic-offset
Запрашивает информацию о максимальном смещении, для которого @value{GDBN}
выводит символьную форму адреса.
@end table

@cindex одиночный указатель, интерпретация
@cindex указатель, нахождение объекта ссылки
Если у вас есть указатель, и вы не знаете, на что он указывает,
попробуйте @samp{set print symbol-filename on}.  Затем вы можете определить
название и исходный файл переменной, на которую он указывает, используя
@samp{p/a @var{указатель}}.  Это интерпретирует адрес в символьной
форме.  Например, здесь @value{GDBN} показывает, что переменная
@code{ptt} указывает на другую переменную @code{t}, определенную в файле
@file{hi2.c}:

@example
(@value{GDBP}) set print symbol-filename on
(@value{GDBP}) p/a ptt
$4 = 0xe008 <t in hi2.c>
@end example

@quotation
@emph{Предупреждение:} Для указателей, ссылающихся на локальные
переменные, @samp{p/a} не показывает символьное имя и имя файла,
которому принадлежит объект ссылки, даже если установлен соответствующий
параметр @code{set print}.
@end quotation

Другие установки управляют выводом объектов различных типов:

@table @code
@kindex set print array
@item set print array
@itemx set print array on
Структурный вывод массивов.  Этот формат удобнее для чтения, но
занимает больше места.  По умолчанию отключено.

@item set print array off
Вернуться к сжатому формату вывода массивов.

@kindex show print array
@item show print array
Показать, какой формат (сжатый или структурный) выбран для отображения
массивов.

@kindex set print elements
@item set print elements @var{число-элементов}
Установить ограничение на количество выводимых @value{GDBN} элементов
массива.  Если @value{GDBN} выводит большой массив, вывод прерывается
после того, как будет выведено установленное командой @code{set print
elements} число элементов.  Это ограничение также действует при
отображении строк.  Когда @value{GDBN} стартует, этот предел принимается
равным 200.  Установка @var{число-элементов} в ноль означает, что вывод
не ограничен.

@kindex show print elements
@item show print elements
Показать количество элементов большого массива, которые будут выведены
@value{GDBN}.  Если это число равно 0, вывод не ограничивается.

@kindex set print null-stop
@item set print null-stop
Указывает @value{GDBN} прекращать вывод знаков массива, как только
встретится первый @sc{null}.  Это полезно, когда большие массивы
фактически содержат только короткие строки.
По умолчанию отключено.

@kindex set print pretty on
@item set print pretty on
Велит @value{GDBN} выводить структуры в формате с отступами, по одному
элементу в строке, например:

@smallexample
@group
$1 = @{
  next = 0x0,
  flags = @{
    sweet = 1,
    sour = 1
  @},
  meat = 0x54 "Pork"
@}
@end group
@end smallexample

@item set print pretty off
Указывает @value{GDBN} выводить структуры в компактном формате, как здесь:

@smallexample
@group
$1 = @{next = 0x0, flags = @{sweet = 1, sour = 1@}, \
meat = 0x54 "Pork"@}
@end group
@end smallexample

@noindent
Этот формат устанавливается по умолчанию.

@kindex show print pretty
@item show print pretty
Показать, какой формат @value{GDBN} использует для вывода структур.

@kindex set print sevenbit-strings
@item set print sevenbit-strings on
Осуществлять вывод, используя только семибитные знаки; если этот
параметр установлен, @value{GDBN} отображает любые восьмибитные знаки (в
строках или знаковых значениях), используя запись @code{\}@var{nnn}.
Эта установка очень удобна, если вы работаете на английском (@sc{ascii})
и используете старший бит знаков как маркер или ``мета''-бит.

@item set print sevenbit-strings off
Выводить восьмибитные знаки полностью.  Это позволяет
использовать большее количество международных наборов знаков;
устанавливается по умолчанию.

@kindex show print sevenbit-strings
@item show print sevenbit-strings
Показать, выводит @value{GDBN} только семибитные литеры или нет.

@kindex set print union
@item set print union on
Велит @value{GDBN} выводить объединения, содержащиеся в структурах.
Устанавливается по умолчанию.

@item set print union off
Указывает @value{GDBN} не выводить объединения, содержащиеся в структурах.

@kindex show print union
@item show print union
Запросить @value{GDBN}, будет ли он выводить объединения, содержащиеся
в структурах.

Например, пусть даны описания

@smallexample
typedef enum @{Tree, Bug@} Species;
typedef enum @{Big_tree, Acorn, Seedling@} Tree_forms;
typedef enum @{Caterpillar, Cocoon, Butterfly@}
              Bug_forms;

struct thing @{
  Species it;
  union @{
    Tree_forms tree;
    Bug_forms bug;
  @} form;
@};

struct thing foo = @{Tree, @{Acorn@}@};
@end smallexample

@noindent
с установленным @code{set print union on}, команда @samp{p foo} выведет

@smallexample
$1 = @{it = Tree, form = @{tree = Acorn, bug = Cocoon@}@}
@end smallexample

@noindent
а с установленным @code{set print union off}, эта же команда выведет

@smallexample
$1 = @{it = Tree, form = @{...@}@}
@end smallexample
@end table

@need 1000
@noindent
Следующие установки представляют интерес при отладке программ на Си++:

@table @code
@cindex восстановление
@kindex set print demangle
@item set print demangle
@itemx set print demangle on
Печатать идентификаторы Си++ в их изначальной, а не в закодированной
(``искаженной'') форме, передаваемой ассемблеру и компоновщику для
сборки с контролем типа.  Установлено по умолчанию.

@kindex show print demangle
@item show print demangle
Показать, в искаженной или восстановленной форме выводятся
идентификаторы Си++.

@kindex set print asm-demangle
@item set print asm-demangle
@itemx set print asm-demangle on
Выводить идентификаторы Си++ в их исходной форме, а не в
искаженной, даже при выводе ассемблерного кода, например при
дисассемблировании инструкций.  По умолчанию отключено.

@c ??? mangle ты тремя разными словами переводишь -- искажать,
@c шифровать (в начале было) и кодировать.  надо одно выбрать.

@kindex show print asm-demangle
@item show print asm-demangle
Показать, в закодированной или восстановленной форме выводятся
имена Си++ при выводе кода ассемблера.

@kindex set demangle-style
@cindex стиль декодирования символов Си++
@item set demangle-style @var{стиль}
Выбрать одну из нескольких схем кодирования, используемых
различными компиляторами для представления имен Си++.  Параметр
@var{стиль} может быть следующим:

@table @code
@item auto
Позволить @value{GDBN} выбрать стиль декодирования посредством
изучения вашей программы.

@item gnu
Декодирование основывается на алгоритме кодирования компилятора
@sc{gnu} Си++ (@code{g++}).  Устанавливается по умолчанию.

@item hp
Декодирование основывается на алгоритме кодирования HP ANSI Си++ (@code{aCC}).

@item lucid
Декодирование основывается на алгоритме кодирования компилятора
Lucid Си++ (@code{lcc}).

@item arm
Декодировать, используя алгоритм из @cite{C++ Annotated Reference
Manual}.
@strong{Предупреждение:} одной этой установки недостаточно, чтобы производить
отладку исполняемых программ, сгенерированных @code{cfront}.
Чтобы реализовать это, @value{GDBN} требует дальнейших усовершенствований.

@end table
Если вы опустите @var{стиль}, то увидите список возможных форматов.

@kindex show demangle-style
@item show demangle-style
Отобразить текущий стиль кодирования, используемый для
декодирования символов Си++.

@kindex set print object
@item set print object
@itemx set print object on
При отображении указателя на объект, идентифицировать @emph{фактический}
(производный), а не @emph{объявленный} тип объекта, используя
таблицу виртуальных функций.

@item set print object off
Отображать только объявленный тип объекта, не ссылаясь на таблицу
виртуальных функций.  Устанавливается по умолчанию.

@kindex show print object
@item show print object
Показать, какой из типов объекта выводится.

@kindex set print static-members
@item set print static-members
@itemx set print static-members on
Выводить статические члены при отображении объекта Си++.  Установлено по
умолчанию.

@item set print static-members off
Не выводить статические члены при отображении объекта Си++.

@kindex show print static-members
@item show print static-members
Показать, выводятся статические члены Си++ или нет.

@kindex set print vtbl
@item set print vtbl
@itemx set print vtbl on
Осуществлять структурный вывод таблиц виртуальных функций Си++.  По умолчанию
отключено.  (Команды @code{vtbl} не работают для программ,
скомпилированных компилятором HP ANSI Си++ (@code{aCC}).)

@item set print vtbl off
Не производить структурного вывода таблиц виртуальных функций Си++.

@kindex show print vtbl
@item show print vtbl
Показать, производится структурный вывод таблиц виртуальных
функций Си++ или нет.
@end table

@node История значений
@section История значений

@cindex история значений
Значения, выведенные командой @code{print}, сохраняются в @dfn{истории
значений} @value{GDBN}.  Это позволяет вам обращаться к ним в других
выражениях.  Значения сохраняются, пока таблица символов не будет заново
считана или уничтожена (например, командами @code{file} или
@code{symbol-file}).  При изменении таблицы символов история значений
уничтожается, так как значения могут содержать указатели на типы,
определенные в таблице символов.

@cindex @code{$}
@cindex @code{$$}
@cindex номера в истории
Выведенным значениям присваиваются @dfn{номера в истории}, по которым вы
можете на них ссылаться.  Эти номера являются последовательными целыми
числами, начинающимися с единицы.  Команда @code{print}
показывает номер в истории, присвоенный значению, выводя перед ним
@samp{$@var{номер} = }, где @var{номер} --- это номер в истории.

Для обращения к какому-либо предшествующему значению, используйте
@samp{$}, за которым следует номер в истории.  Способ, которым
@code{print} маркирует вывод, продуман так, чтобы напоминать вам об
этом.  Просто @code{$} ссылается на самое последнее значение в истории,
а @code{$$} --- на предпоследнее.  @code{$$@var{n}} ссылается на @var{n}-е
с конца значение; @code{$$2} --- значение, находящееся перед @code{$$},
@code{$$1} эквивалентно @code{$$}, а @code{$$0} эквивалентно @code{$}.

Предположим, например, вы только что вывели указатель на структуру и
хотите посмотреть ее содержимое.  Для этого достаточно ввести

@example
p *$
@end example

Если у вас есть цепочка структур, где компонента @code{next} указывает на
следующую, вы можете вывести содержимое следующей структуры так:

@example
p *$.next
@end example

@noindent
Вы можете выводить последовательные звенья в цепочке повторяя эту
команду.  Это можно сделать простым нажатием @key{RET}.

Обратите внимание на то, что в историю записываются значения, а не
выражения.  Если значение @code{x} равно 4, и вы наберете:

@example
print x
set x=5
@end example

@noindent
то значение, записанное в историю значений командой @code{print}, будет
по-прежнему равно 4, хотя значение @code{x} изменилось.

@table @code
@kindex show values
@item show values
Вывести из истории последние десять значений с их номерами.  Это похоже
на команду @samp{p@ $$9}, повторенную десять раз, за исключением того,
что @code{show values} не изменяет историю.

@item show values @var{n}
Вывести десять значений из истории, расположенных вокруг элемента
с номером @var{n}.

@item show values +
Вывести десять значений из истории, следующих сразу после
последнего выведенного значения.  Если доступных значений больше
нет, @code{show values +} не выводит ничего.
@end table

Нажатие @key{RET} для повтора @code{show values @var{n}} действует точно
так же, как @samp{show values +}.

@node Вспомогательные переменные
@section Вспомогательные переменные

@cindex вспомогательные переменные
@value{GDBN} предоставляет @dfn{вспомогательные переменные}, которые вы
можете в нем использовать, чтобы сохранить значение и обратиться к
нему позже.  Эти переменные существуют только в @value{GDBN}; они не
являются частью вашей программы, и установка вспомогательной переменной
не оказывает непосредственного влияния на ее дальшейшее выполнение.
Поэтому вы можете пользоваться ими совершенно свободно.

Имена вспомогательных переменных начинаются с @samp{$}.  Любое имя с приставкой
@samp{$} может использоваться для вспомогательной переменной, если
только оно не является предопределенным машинно-зависимым именем регистра,
(@pxref{Регистры, ,Регистры}).  (Ссылки на историю значений,
напротив, есть @emph{числа}, которым предшествует @samp{$}.
@xref{История значений, История значений}.)

Вы можете сохранить значение во вспомогательной переменной с помощью
выражения присваивания, как если бы вы устанавливали переменную в
вашей программе.  Например:

@example
set $foo = *object_ptr
@end example

@noindent
сохранит в @code{$foo} значение объекта, на который указывает
@code{object_ptr}.

Первое использование вспомогательной переменной создает ее, но
значением переменной будет @code{void}, пока вы не присвоите ей новое.
С помощью другого присваивания вы можете в любое время
изменить значение.

Вспомогательные переменные не имеют фиксированного типа.  Вы можете
присваивать вспомогательной переменной значение любого типа, включая
структуры и массивы, даже если у этой переменной уже было значение
другого типа.  Будучи использованной в выражении, вспомогательная
переменная имеет тип своего текущего значения.

@table @code
@kindex show convenience
@item show convenience
Вывести список используемых вспомогательных переменных с их значениями.
Сокращается как @code{show conv}.
@end table

Один из способов использования вспомогательных переменных --- в качестве
увеличивающегося счетчика или продвигающегося указателя.  Например,
чтобы напечатать поле из последовательных элементов массива структур:

@example
set $i = 0
print bar[$i++]->contents
@end example

@noindent
Повторяйте эту команду нажатием @key{RET}.

Некоторые вспомогательные переменные создаются @value{GDBN} автоматически,
и им присваиваются значения, которые вероятно могут оказаться полезными.

@table @code
@vindex $_@r{, вспомогательная переменная}
@item $_
Переменная @code{$_} устанавливается автоматически командой @code{x} в
последний исследованный адрес (@pxref{Память, ,Исследование памяти}).
Другие команды, которые устанавливают адрес по умолчанию для
исследования командой @code{x}, также присваивают @code{$_} упомянутый
адрес; эти команды включают @code{info line} и @code{info breakpoint}.
Переменная @code{$_} имеет тип @code{void *}, если только она не
установлена командой @code{x}; в этом случае она является указателем на
тип переменной @code{$__}.

@vindex $__@r{, вспомогательная переменная}
@item $__
Переменная @code{$__} устанавливается автоматически командой @code{x} в
значение, находящееся по последнему исследованному адресу.  Ее тип
выбирается соответствующим формату, в котором это значение было
выведено.

@item $_exitcode
@vindex $_exitcode@r{, вспомогательная переменная}
Переменной @code{$_exitcode} автоматически присваивается код завершения,
когда отлаживаемая программа завершается.
@end table

В системах HP-UX, если вы ссылаетесь на функцию или переменную, чье имя
начинается со знака доллара, @value{GDBN} сначала производит поиск
пользовательского или системного имени, перед поиском вспомогательной
переменной.

@node Регистры
@section Регистры

@cindex регистры
В выражениях, вы можете обращаться к содержимому машинных регистров,
обозначая их как переменные с именами, начинающимся с @samp{$}.  Имена
регистров различаются от машины к машине; для вывода имен регистров,
используемых на вашей машине, воспользуйтесь командой @code{info registers}.

@table @code
@kindex info registers
@item info registers
Вывести имена и содержимое всех регистров, кроме
регистров с плавающей точкой (в выбранном кадре стека).

@kindex info all-registers
@cindex регистры с плавающей точкой
@item info all-registers
Вывести имена и содержимое всех регистров, включая регистры с плавающей
точкой.

@item info registers @var{имя-рег} @dots{}
Выводит @dfn{относительное} значение каждого из указанных в @var{имя-рег}
регистров.  Как подробно обсуждается ниже, значения
регистров обычно относятся к выбранному кадру стека.  @var{Имя-рег}
может быть любым допустимым на вашей машине именем регистра, с @samp{$}
в начале имени или без.
@end table

@value{GDBN} распознает четыре ``стандартных'' имени регистров, которые
доступны (в выражениях) на большинстве машин --- если только они не
конфликтуют с каноническим для архитектуры обозначением регистров.
Названия регистров @code{$pc} и @code{$sp} используются для регистра
счетчика программы и указателя вершины стека.  @code{$fp} используется
как имя регистра, содержащего указатель на текущий кадр стека, а
@code{$ps} --- как имя регистра, содержащего состояние процессора.
Например, вы можете вывести счетчик программы в шестнадцатеричной записи
с помощью

@example
p/x $pc
@end example

@noindent
или вывести следующую исполняемую инструкцию, используя

@example
x/i $pc
@end example

@noindent
или увеличить указатель вершины стека на четыре@footnote{На машинах, где
стек растет вниз в памяти (в наши дни, на большинстве машин), это способ
удалить одно слово из стека.  Это подразумевает, что выбран самый
внутренний кадр; когда выбраны другие кадры стека, установка
@code{$sp} не разрешена.  Используйте @code{return} для извлечения
целого кадра из стека, вне зависимости от архитектуры машины; смотрите
@ref{Возврат, ,Возврат из функции}.} с помощью

@example
set $sp += 4
@end example

Когда возможно, эти четыре стандартных имени регистров доступны на вашей
машине, даже если она имеет другую каноническую мнемонику,
если не возникает конфликта.  Команда @code{info registers}
показывает канонические имена.  В SPARC, например, @code{info registers}
отображает регистр состояния процессора как @code{$psr}, но вы также можете
называть его @code{$ps}; а на машинах, базирующихся на платформе x86,
@code{$ps} является синонимом для регистра @sc{eflags}.

Когда регистр изучается таким образом, @value{GDBN} всегда рассматривает
содержимое обычного регистра как целое.  Некоторые машины имеют
специальные регистры, которые могут содержать только значение с
плавающей точкой; их значения трактуются как величины с плавающей
точкой.  Не существует способа сослаться на содержимое обычного
регистра как на величину с плавающей точкой (хотя вы можете распечатать
его значение командой @emph{print} как величину с плавающей точкой,
используя @samp{print/f $@var{имя-рег}}).

Некоторые регистры имеют различные ``необработанные'' и ``виртуальные''
форматы данных.  Это означает, что формат данных, в котором
операционная система сохраняет содержимое регистра, не совпадает с
тем, который обычно воспринимается вашей программой.  Например, регистры
сопроцессора с плавающей точкой 68881 всегда сохраняются в
``расширенном'' (необработанном) формате, но все программы на Си работают с
``двойным'' (виртуальным) форматом.  В подобных случаях, @value{GDBN} обычно
работает только с виртуальным форматом (форматом, имеющим смысл в вашей
программе), но команда @code{info registers} выводит данные в обоих
форматах.

Обычно значения регистров относятся к выбранному кадру стека
(@pxref{Выбор, ,Выбор кадра}).  Это значит, что вы получаете
значение, которое содержалось бы в регистре, если бы произошел выход
из всех внутренних кадров стека, и их сохраненные регистры были бы
восстановлены.  Для того, чтобы увидеть истинное содержимое аппаратных
регистров, вы должны выбрать самый внутренний кадр (с помощью
@samp{frame 0}).

Однако, @value{GDBN}, исходя из машинного кода, сгенерированного вашим
компилятором, должен установить, где сохранены регистры.  Если
некоторые регистры не сохранены, или если @value{GDBN} не в состоянии найти
сохраненные регистры, выбранный кадр стека не имеет значения.

@node Вычисления с плавающей точкой
@section Аппаратные средства поддержки вычислений с плавающей точкой
@cindex плавающая точка

В зависимости от конфигурации, @value{GDBN} может выдать вам больше информации
о состоянии аппаратных средств поддержки вычислений с плавающей
точкой.

@table @code
@kindex info float
@item info float
Отобразить аппаратно-зависимую информацию о модуле поддержки
вычислений с плавающей точкой.  Ее точное содержание и размещение
зависит от микросхемы поддержки вычислений с плавающей точкой.  В
настоящее время, @samp{info float} поддерживается на машинах ARM и x86.
@end table

@node Языки
@chapter Использование @value{GDBN} с различными языками программирования
@cindex языки программирования

Хотя языки программирования обычно имеют общие аспекты, их выражения редко
выглядят одинаково.  Например, в ANSI Си, разыменование указателя
@code{p} осуществляется операцией @code{*p}, а в Модуле-2 это
выполняется как @code{p^}.  Представление (и отображение) значений также
может быть различным.  Шестнадцатеричные числа в Си отображаются как
@samp{0x1ae}, в то время как в Модуле-2 они отображаются как @samp{1AEH}.

@cindex рабочий язык
В @value{GDBN} встроена специальная информация о некоторых языках, которая
позволяет описывать действия, подобные упомянутым, на языке
вашей программы, и позволяет @value{GDBN} выводить значения в виде,
принятом в языке, на котором написана ваша программа.  Язык, которым вы
пользуетесь для построения выражений, называется @dfn{рабочим языком}.

@menu
* Переход от одного языка к другому::
                                Переход от одного языка к другому
* Отображение языка::           Отображение языка
* Проверка::                    Проверки диапазона и соответствия типов
* Поддержка::                   Поддерживаемые языки
@end menu

@node Переход от одного языка к другому
@section Переход от одного языка к другому

Существует два способа управления рабочим языком: либо @value{GDBN}
устанавливает его автоматически, либо вы можете сделать это
самостоятельно.  Для этих целей вы можете воспользоваться командой @code{set
language}.  По умолчанию, при старте @value{GDBN} устанавливает язык
автоматически.  Рабочий язык используется, чтобы определить, как
интерпретируются вводимые вами выражения, как выводятся значения, и так
далее.

В дополнение к рабочему языку, каждый исходный файл, с
которым работает @value{GDBN}, имеет свой собственный рабочий язык.  Для
некоторых форматов объектных файлов компилятор может указывать, на
каком языке написан конкретный исходный файл.  Однако, чаще всего
@value{GDBN} распознает язык по имени файла.  Язык исходного файла
определяет, будут ли восстанавливаться имена Си++; таким образом,
@code{backtrace} может показывать каждый кадр в соответствии с
исходным языком.  Не существует способа установить язык исходного файла
из @value{GDBN}, но вы можете установить язык, ассоциированный с
расширением файла.  @xref{Отображение языка, ,Отображение языка
программирования}.

Наиболее часто эта проблема возникает, когда вы используете программу,
такую как @code{cfront} или @code{f2c}, которая создает текст на Си, но
написана на другом языке.  В этом случае нужно сделать, чтобы программа
использовала директивы @code{#line} в выводе текста Си; тогда
@value{GDBN} будет знать правильный язык исходного текста первоначальной
программы, и выведет этот исходный код, а не сгенерированный код Си.

@menu
* Имена файлов::                Расширения имен файлов и языки
* Установка рабочего языка::    Установки рабочего языка вручную
* Автоматическое::              Распознавание @value{GDBN} исходного языка
@end menu

@node Имена файлов
@subsection Соответствие расширений файлов и языков

Если имя исходного файла заканчивается одним из следующих расширений, то
@value{GDBN} воспринимает это как указание на обозначенный язык.

@table @file

@item .c
Исходный файл Си

@item .C
@itemx .cc
@itemx .cp
@itemx .cpp
@itemx .cxx
@itemx .c++
Исходный файл Си++

@item .f
@itemx .F
Исходный файл Фортрана

@item .ch
@itemx .c186
@itemx .c286
Исходный файл CHILL

@item .mod
Исходный файл Модулы-2

@item .s
@itemx .S
Исходный файл Ассемблера.  В действительности, воспринимается почти
также, как Си, но @value{GDBN} не пропускает вводные части функций при
пошаговом выполнении.
@end table

В дополнение к этому, вы можете установить язык, ассоциированный с
расширением имени файла.  @xref{Отображение языка, ,Отображение языка
программирования}.

@node Установка рабочего языка
@subsection Установка рабочего языка

Если вы позволяете @value{GDBN} устанавливать язык автоматически,
выражения в сеансе отладки и в вашей программе интерпретируются одинаково.

@kindex set language
По желанию, вы можете установить язык сами.  Для этого
воспользуйтесь командой @samp{set language @var{язык}}, где
@var{язык} --- название языка, например, @code{c} или @code{modula-2}.
Чтобы получить перечень поддерживаемых языков, наберите @samp{set language}.

Установка языка вручную запрещает @value{GDBN} автоматически переключать
рабочий язык.  Это может привести к неприятным последствиям, если вы
попытаетесь отладить программу, когда рабочий язык не
совпадает с исходным языком, а выражение допустимо в обоих
языках, но означает разные вещи.  Например, если текущий исходный
файл написан на Си, а в @value{GDBN} выбрана Модула-2, команда

@example
print a = b + c
@end example

@noindent
может не привести к ожидаемому результату.  В Си это означает
сложить @code{b} и @code{c} и поместить результат в @code{a}.
Выведенным результатом будет значение @code{a}.  В Модуле-2 это
означает сравнение @code{a} с результатом @code{b+c}, выдающее значение
типа @code{BOOLEAN}.

@node Автоматическое
@subsection Распознавание @value{GDBN} исходного языка

Для автоматической установки рабочего языка, используйте
@samp{set language local} или @samp{set language auto}.  Тогда
@value{GDBN} будет определять рабочий язык автоматически.  То есть при
остановке вашей программы в кадре стека (обычно, в точке останова),
@value{GDBN} устанавливает рабочий язык в тот, который записан для
функции в этом кадре.  Если язык для кадра неизвестен (то есть, если
функция или блок, соответствующие кадру, были определены в исходном
файле, не имевшем распознаваемого расширения), текущий рабочий язык не
изменяется, а @value{GDBN} выдает предупреждающее сообщение.

Для большинства программ, которые написаны целиком на одном языке,
автоматическая установка языка может показаться ненужной.
Однако, в основной программе, написанной на одном исходном языке,
могут использоваться программные модули и библиотеки, написанные на
другом исходном языке.  Использование в этом случае @samp{set language
auto} освобождает вас от установки рабочего языка вручную.

@node Отображение языка
@section Отображение языка программирования

Следующие команды помогают вам определить, какой язык
является рабочим, а также на каком языке были написаны исходные файлы.

@kindex show language
@kindex info frame@r{, показать исходный язык}
@kindex info source@r{, показать исходный язык}
@table @code
@item show language
Отобразить текущий рабочий язык.  Это тот язык, который вы можете
использовать в командах типа @code{print} для построения и вычисления
выражений, в которые могут входить переменные вашей программы.

@item info frame
Отобразить исходный язык для данного кадра стека.  Этот язык
становится рабочим, если используется идентификатор из этого кадра.
@xref{Информация о кадре, Информация о кадре стека}, для дополнительной
информации.

@item info source
Отобразить исходный язык данного исходного файла.
@xref{Символы, ,Исследование таблицы символов}, для получения
дополнительной информации.
@end table

При необычных обстоятельствах, у вас могут быть исходные файлы с
расширениями, не входящими в стандартный список.  Вы можете явно
установить расширение, ассоциированное с языком:

@kindex set extension-language
@kindex info extensions
@table @code
@item set extension-language @var{.расш} @var{язык}
Установить соответствие исходных файлов с расширением @var{.расш} с
исходным языком @var{язык}.

@item info extensions
Перечислить все расширения имен файлов и соответствующие им языки.
@end table

@node Проверка
@section Проверка диапазона и принадлежности типу

@quotation
@emph{Предупреждение:} В этот выпуск включены команды @value{GDBN} для
проверки диапазона и соответствия типов, но они пока не оказывают
никакого действия.  Этот раздел описывает их предполагаемые возможности.
@end quotation

Некоторые языки обеспечивают защиту от достаточно общих ошибок
с помощью набора проверок времени компиляции и времени выполнения.  Это
включает проверку типов аргументов функций и операторов и обеспечивает
проверку математического переполнения во время выполнения.  Проверки
такого рода помогают убедиться в корректности программы после ее
компиляции путем устранения несоответствия типов, и предоставляя
активную проверку ошибок выхода за пределы диапазона во время
выполнения.

По вашему желанию, @value{GDBN} может проводить подобные проверки.  Хотя
@value{GDBN} не проверяет операторы вашей программы, он может, например, проверять
выражения, введенные непосредственно в @value{GDBN} для вычисления
командой @code{print}.  Как и в случае рабочего языка,
@value{GDBN} может также автоматически решить, выполнять проверку или нет,
основываясь на исходном языке вашей программы.  @xref{Поддержка,
,Поддерживаемые языки}, для информации об установках по умолчанию для
поддерживаемых языков.

@menu
* Проверка типов::              Обзор проверки типов
* Проверка диапазона::          Обзор проверки диапазона
@end menu

@cindex проверка типов
@cindex типы, проверка
@node Проверка типов
@subsection Краткий обзор проверки соответствия типов

Некоторые языки, такие как Модула-2, должны иметь жесткое соответствие
типов, то есть аргументы операторов и функций должны иметь правильный тип, в
противном случае возникает ошибка.  Описанные здесь проверки
предотвращают ошибки несоответствия типов, которые могут вызвать
ошибки времени выполнения.  Например,

@smallexample
1 + 2 @result{} 3
@exdent но
@error{} 1 + 2.3
@end smallexample

Во втором примере ошибка, потому что @code{CARDINAL} 1 не совместим по
типу с @code{REAL} 2.3.

Для выражений, используемых вами в командах @value{GDBN}, вы можете
указать @value{GDBN} не производить проверку; или же рассматривать любое
несоответствие как ошибку и прекращать обработку выражения; или только
выводить предупреждение в случае возникновения несоответствия, но
вычислять выражение в любом случае.  В последнем случае, @value{GDBN}
вычисляет выражения, подобные второму примеру, но также выводит
предупреждающее сообщение.

Даже если вы отключили проверку типов, @value{GDBN} может прекратить
обработку выражения по другим причинам, связанным с типами.  Например,
@value{GDBN} не знает, как сложить @code{int} и @code{struct foo}.  Такие
типы ошибок не имеют ничего общего с используемым языком и
обычно возникают из выражений, подобных описанному выше, которые нет смысла
вычислять.

Каждый язык определяет степень строгости контроля типов.  Например, как
Модула-2, так и Си требуют, чтобы аргументы арифметических операций были
числами.  В Си, перечисляемые типы и указатели могут быть представлены в
виде чисел, так что они допустимы в качестве аргументов математических
операторов.  @xref{Поддержка, ,Поддерживаемые языки}, для более
подробного обсуждения конкретных языков.

@value{GDBN} предоставляет некоторые дополнительные команды для контроля
проверки типов:

@kindex set check@r{, тип}
@kindex set check type
@kindex show check type
@table @code
@item set check type auto
Включить или отключить контроль типов, в зависимости от
текущего рабочего языка.  @xref{Поддержка, ,Поддерживаемые языки}, для
установок по умолчанию для каждого языка.

@item set check type on
@itemx set check type off
Включить или отключить контроль типов, пренебрегая установкой
по умолчанию для текущего рабочего языка.  Вывести предупреждающее
сообщение, если установка не соответствует используемой по умолчанию.
Если возникает несоответствие типов во время вычисления
выражения при включенном контроле типов, @value{GDBN} выводит
сообщение и прерывает вычисление выражения.

@item set check type warn
При возникновении несоответствия типов вывести предупреждающее
сообщение, но попытаться вычислить выражение.  Вычисление выражения все
же может быть невозможным по другим причинам.  Например, @value{GDBN} не
может складывать числа со структурами.

@item show type
Показать текущую установку проверки типов, а также была ли она установлена
@value{GDBN} автоматически.
@end table

@cindex проверка диапазона
@cindex диапазон, проверка
@node Проверка диапазона
@subsection Краткий обзор проверки диапазона

В некоторых языках (например, в Модуле-2), выход за границы диапазона типа
считается ошибкой; эти ошибки отслеживаются с помощью контроля времени
выполнения.  Эти проверки диапазона служат для того, чтобы избежать
переполнения при вычислениях и не допустить превышения индексами
элементов массива границ индексации.

В выражениях, используемых вами в командах @value{GDBN}, вы можете указать
@value{GDBN} обрабатывать ошибки диапазона одним из трех способов:
игнорировать их, всегда рассматривать как ошибки и прерывать
обработку выражения, или выводить предупреждение и продолжать вычисление
выражения.

Ошибки диапазона могут возникать при числовом переполнении, при
превышении границы индексации массива или при использовании константы, не
принадлежащей ни одному типу.  Однако, некоторые языки не
считают переполнение ошибкой.  Во многих реализациях Си
математическое переполнение вызывает ``циклический переход'' к меньшему
значению.  Например, если @var{m} --- наибольшее целое значение, а
@var{s} --- наименьшее, то

@example
@var{m} + 1 @result{} @var{s}
@end example

Это также является специфичным для конкретных языков, а в некоторых
случаях --- для отдельного компилятора или машины.
Для дальнейших сведений по отдельным языкам, @xref{Поддержка,
,Поддерживаемые языки}.

@value{GDBN} обеспечивает некоторые дополнительные команды для контроля
проверки диапазона:

@kindex set check@r{, диапазон}
@kindex set check range
@kindex show check range
@table @code
@item set check range auto
Включить или отключить контроль диапазона, в зависимости от
текущего рабочего языка.  @xref{Поддержка, ,Поддерживаемые языки},
для получения информации об установках по умолчанию для каждого языка.

@item set check range on
@itemx set check range off
Включить или отключить контроль типов, пренебрегая установкой
по умолчанию для текущего рабочего языка.
Если установка не соответствует используемой по умолчанию, выводится
предупреждающее сообщение.  Если происходит ошибка диапазона и контроль
включен, выводится сообщение и вычисление выражения прерывается.

@item set check range warn
При выявлении ошибки диапазона @value{GDBN} выведет предупреждающее
сообщение, но попытается вычислить выражение.  Тем не менее,
вычисление выражения может быть невозможным по другим причинам,
таким как обращение к памяти, которой процесс не владеет (типичный
пример для многих систем Unix).

@item show range
Показать текущую установку проверки диапазона, и была ли она установлена
@value{GDBN} автоматически.
@end table

@node Поддержка
@section Поддерживаемые языки

@value{GDBN} поддерживает Си, Си++, Фортран, Java, Chill, Ассемблер и
Модулу-2.  Некоторые возможности @value{GDBN} могут быть задействованы в
выражениях независимо от используемого языка: операторы @value{GDBN}
@code{@@} и @code{::} и конструкция @samp{@{тип@}адрес}
(@pxref{Выражения, ,Выражения}) могут быть использованы в конструкциях
любого поддерживаемого языка.

Следующие разделы подробно описывают, до какой степени каждый из
исходных языков поддерживается @value{GDBN}.  Эти разделы не задумывались как
учебники или руководства по языкам; они лишь служат справочным
руководством по тому, что допускает анализатор выражений
@value{GDBN}, и как должны выглядеть входные и выходные форматы в
различных языках.  Существует много хороших книг по каждому из этих
языков; пожалуйста, загляните в них, если вам нужен учебник или
справочник по языку.

@menu
* Си::          Си и Си++
* Модула-2::    Модула-2
* Chill::       Chill
@end menu

@node Си
@subsection Си и Си++

@cindex Си и Си++
@cindex выражения в Си и Си++

Поскольку Си и Си++ тесно связаны, многие возможности @value{GDBN}
применимы к ним обоим.  Когда это имеет место, мы обсуждаем эти языки
вместе.

@cindex Си@t{++}
@cindex @code{g++}, компилятор @sc{gnu} Си@t{++}
@cindex @sc{gnu} Си++
Средства отладки Си++ обеспечиваются совместно компилятором Си++
и @value{GDBN}.  Следовательно, для эффективной отладки программы на
Си++, вам следует пользоваться одним из поддерживаемых компиляторов,
например @sc{gnu} @code{g++}, или компилятором HP ANSI Си++
(@code{aCC}).

При использовании @sc{gnu} Си++, для получения наилучших результатов
используйте формат отладочной информации stabs.  Вы можете выбрать его
явно с помощью ключа командной строки @samp{-gstabs} или @samp{-gstabs+}.  Смотрите
@ref{Отладочные ключи,,Ключи для отладки вашей программы или @sc{gnu}
CC, gcc.info, Использование @sc{gnu} CC}, для дополнительной информации.

@menu
* Операторы Си::                Операторы Си и Си++
* Константы Си::                Константы Си и Си++
* Выражения Си++::              Выражения Си++
* Значения Си по умолчанию::    Значения по умолчанию Си и Си++
* Проверки в Си::               Проверки диапазона и типов Си и Си++
* Отладка Си::                  @value{GDBN} и Си
* Отладка Си++::                Возможности @value{GDBN} для Си++
@end menu

@node Операторы Си
@subsubsection Операторы Си и Си++

@cindex операторы Си и Си++

Операторы должны быть определены на значениях определенных типов.
Например, @code{+} определен на числах, но не на структурах.
Операторы часто определяются на группах типов.

Для целей Си и Си++, имеют место следующие определения:

@itemize @bullet

@item
@emph{Целые типы} включают @code{int} с любыми спецификаторами
класса памяти; @code{char}; @code{enum}; и, для Си++, @code{bool}.

@item
@emph{Типы с плавающей точкой} включают @code{float}, @code{double} и
@code{long double} (если поддерживается целевой платформой).

@item
@emph{Типы указателей} включают все типы, определенные как
@code{(@var{тип} *)}.

@item
@emph{Скалярные типы} включают все вышеперечисленные типы.

@end itemize

@noindent
Поддерживаются следующие операторы, перечисленные здесь в порядке
возрастания приоритета:

@table @code
@item ,
Запятая, или оператор последовательного выполнения.  Выражения,
разделенные в списке запятыми, вычисляются слева направо;
результатом всего выражения является результат, полученный последним.

@item =
Присваивание.  Значение выражения присваивания --- присвоенное значение.
Определено на скалярных типах.

@item @var{опер}=
Используется в выражениях в форме @w{@code{@var{a} @var{опер}= @var{b}}}
и преобразовывается в @w{@code{@var{a} = @var{a опер b}}}.
@w{@code{@var{опер}=}} и @code{=} имеют одинаковый приоритет.
@var{опер} может быть одним из операторов @code{|}, @code{^}, @code{&},
@code{<<}, @code{>>}, @code{+}, @code{-}, @code{*},
@code{/}, @code{%}.

@item ?:
Тернарный оператор.  @code{@var{a} ? @var{b} : @var{c}} истолковывается
так: если @var{a}, то @var{b}, иначе @var{c}.  @var{a}
должно быть целого типа.

@item ||
Логическое @sc{или}.  Определено на целых типах.

@item &&
Логическое @sc{и}.  Определено на целых типах.

@item |
Побитовое @sc{или}.  Определено на целых типах.

@item ^
Побитовое исключающее @sc{или}.  Определено на целых типах.

@item &
Побитовое @sc{и}.  Определено на целых типах.

@item ==@r{, }!=
Равенство и неравенство.  Определено на скалярных типах.  Значение
этих выражений отлично от нуля для истины и 0 для лжи.

@item <@r{, }>@r{, }<=@r{, }>=
Меньше чем, больше чем, меньше или равно, больше или равно.  Определено
на скалярных типах.  Значение этих выражений равно 0 для лжи и отлично от нуля
для истины.

@item <<@r{, }>>
Левый сдвиг и правый сдвиг.  Определено на целых типах.

@item @@
Оператор @value{GDBN} создания ``искусственного массива''
(@pxref{Выражения, ,Выражения}).

@item +@r{, }-
Сложение и вычитание.  Определено на целочисленных типах, типах с
плавающей точкой и указателях.

@item *@r{, }/@r{, }%
Умножение, деление и остаток.  Умножение и деление определены на
целочисленных типах и типах с плавающей точкой.  Остаток определен
на целочисленных типах.

@item ++@r{, }--
Инкремент и декремент.  При появлении перед переменной,
операция выполняется прежде, чем переменная используется в
выражении; при появлении после переменной,
значение переменной используется до выполнения операции.

@item *
Разыменование указателя.  Определено для указателей.  Имеет тот
же приоритет, что и @code{++}.

@item &
Оператор получения адреса.  Определен на переменных.  Имеет тот же
приоритет, что и @code{++}.

Для отладки Си++, @value{GDBN} реализует использование @samp{&}
независимо от того, что позволяет сам язык Си++: вы можете использовать
@samp{&(&@var{ссылка})} (или просто  @samp{&&@var{ссылка}}),
чтобы исследовать адрес, по которому хранится
переменная-ссылка Си++ (объявленная с помощью @samp{&@var{ссылка}}).

@item -
Унарный минус.  Определен на целочисленных типах и типах с
плавающей точкой.  Имеет тот же приоритет, что и @code{++}.

@item !
Логическое отрицание.  Определено на целочисленных типах.  Имеет тот
же приоритет, что и @code{++}.

@item ~
Оператор побитового дополнения.  Определен на целочисленных
типах. Имеет тот же приоритет, что и @code{++}.

@item .@r{, }->
Элемент структуры и указатель на элемент структуры.  Для удобства,
@value{GDBN} считает их эквивалентными, определяя, следует ли
разыменовывать указатель, основываясь на сохраненной информации о типах.
Определен на данных структуры (@code{struct}) и объединения (@code{union}).

@item .*@r{, }->*
Разыменовывание указателя на элемент.

@item []
Индексация массива.  @code{@var{a}[@var{i}]} определяется как
@code{*(@var{a}+@var{i})}.  Имеет тот же приоритет, что и @code{->}.

@item ()
Список параметров функции.  Имеет тот же приоритет, что и @code{->}.

@item ::
Оператор Си++ определения области видимости.  Определен на типах
@code{struct}, @code{union} и @code{class}.

@item ::
Двойное двоеточие также представляет оператор @value{GDBN} области
видимости (@pxref{Выражения, ,Выражения}).  Имеет тот же приоритет, что
и @code{::}, описанный выше.
@end table

Если оператор переопределен в пользовательском коде, @value{GDBN} обычно
пытается выполнить переопределенную версию, а не использовать
предопределенное значение оператора.

@c@menu
@c* Константы Си::
@c@end menu

@node Константы Си
@subsubsection Константы Си и Си++

@cindex константы Си и Си++

@value{GDBN} позволяет вам выражать константы Си и Си++ следующими способами:

@itemize @bullet
@item
Целочисленные константы --- это последовательности цифр.  Восьмеричные
константы начинаются с @samp{0} (с нуля), а шестнадцатеричные константы
--- с @samp{0x} или @samp{0X}.  Константы также могут заканчиваться
буквой @samp{l}, указывая, что значение константы должно рассматриваться
как длинное (@code{long}).

@item
Константы с плавающей точкой --- это последовательность цифр, за которой
следует десятичная точка, другая последовательность цифр, и, возможно,
порядок.  Порядок указывается в форме
@samp{@w{e@r{[[}+@r{]|}-@r{]}@var{nnn}}}, где @var{nnn} --- другая
последовательность цифр.  Для положительных порядков @samp{+} является
необязательным.  Константа с плавающей точкой может также
заканчиваться буквой @samp{f} или @samp{F}, это указывает на то, что
константа должна рассматриваться как @code{float} (в отличие от
@code{double} по умолчанию), или буквой @samp{l} или @samp{L}, что
указывает на константу типа @code{long double}.

@item
Перечисляемые константы состоят из перечисляемых идентификаторов, или
их целочисленных эквивалентов.

@item
Знаковые константы --- это одиночный знак, заключенный в одиночные
кавычки (@code{'}), или число --- порядковое значение соответствующего
знака (обычно его значение @sc{ascii}).  Внутри кавычек, одиночный
знак может быть представлен либо буквой, либо @dfn{экранирующей
последовательностью}, которая имеет форму @samp{\@var{nnn}}, где
@var{nnn} является восьмеричным представлением порядкового значения
знака; или форму @samp{\@var{x}}, где @samp{@var{x}} --- специальный
предопределенный знак, например, @samp{\n} для знака новой строки.

@item
Строковые константы --- последовательность знаковых констант (без
одиночных кавычек), заключенная в двойные кавычки (@code{"}).  Туда
могут входить любые допустимые знаковые константы (как описано выше).
Двойным кавычкам внутри строки должна предшествовать обратная косая
черта, так что @samp{"a\"b'c"}, например, является строкой из пяти
знаков.

@item
Константы-указатели представляют собой целочисленные значения.  Вы можете также
записывать указатели на константы, используя оператор Cи @samp{&}.

@item
Константы-массивы --- заключенные в фигурные скобки (@samp{@{} и
@samp{@}}) списки элементов, разделенные запятыми.  Например,
@samp{@{1,2,3@}} является массивом с тремя целочисленными элементами,
@samp{@{@{1,2@}, @{3,4@}, @{5,6@}@}} является массивом размерности три
на два, а @samp{@{&"hi", &"there", &"fred"@}} является трехэлементным
массивом указателей.
@end itemize

@c@menu
@c* Выражения Си++::
@c* Значения Си по умолчанию::
@c* Проверки в Си::
@c* Отладка Си::
@c@end menu

@node Выражения Си++
@subsubsection Выражения Си++

@cindex выражения в Си++
Обработчик выражений @value{GDBN} может интерпретировать большинство
выражений Си++.

@cindex поддержка Си++, без @sc{coff}
@cindex @sc{coff} и Си++
@cindex Си++ и объектные форматы
@cindex объектные форматы и Си++
@cindex a.out и Си++
@cindex @sc{ecoff} и Си++
@cindex @sc{xcoff} и Си++
@cindex @sc{elf}/stabs и Си++
@cindex @sc{elf}/@sc{dwarf} и Си++
@quotation
@emph{Предупреждение:} @value{GDBN} может отлаживать программы на Си++,
только если вы используете подходящий компилятор.  Обычно
отладка Си++ зависит от использования дополнительной отладочной информации в
таблице символов и, таким образом, требует специальной поддержки.
В частности, если ваш компилятор генерирует a.out, MIPS @sc{ecoff},
RS/6000 @sc{xcoff} или @sc{elf} с расширениями stabs к таблице
символов, все эти средства доступны.  (С @sc{gnu} CC вы можете
использовать ключ @samp{-gstabs}, чтобы явно запросить расширения
отладки stabs).  С другой стороны, если формат объектного
кода --- стандартный @sc{coff} или @sc{dwarf} в @sc{elf}, значительная часть
поддержки Си++ в @value{GDBN} @emph{не} работает.
@end quotation

@enumerate

@cindex функции-члены
@item
Допускаются вызовы функций-членов; вы можете использовать выражения типа

@example
count = aml->GetOriginal(x, y)
@end example

@vindex this@r{, внутри функций-членов Си@t{++}}
@cindex пространство имен в Си++
@item
Пока функция-член активна (в выбранном кадре стека), вашим выражениям
доступно то же пространство имен, что и функции-члену; то есть
@value{GDBN} допускает неявные ссылки на указатель
экземпляра класса @code{this} по тем же правилам, что и Си++.

@cindex вызов перегруженных функций
@cindex перегруженные функции, вызов
@cindex преобразование типов в Си++
@item
Вы можете вызывать перегруженные функции; @value{GDBN} производит вызов
функции с правильным определением, но с некоторыми ограничениями.
@value{GDBN} не совершает преобразования, для выполнения которых требуются
преобразования типов, определенные пользователем, вызовы конструкторов
или конкретизации не существующих в программе шаблонов.  Он также не
может обрабатывать списки с неопределенным числом аргументов
или аргументы со значениями по умолчанию.

Он производит преобразования и расширения целочисленных типов,
расширения типов с плавающей точкой, арифметические преобразования,
преобразования указателей, преобразования класса объекта в базовые
классы и стандартные преобразования, например функции или массива к
указателю; это требует точного совпадения числа аргументов функции.

Разрешение перегруженных имен производится всегда, если не
указано @code{set overload-resolution off}.  @xref{Отладка Си++,
,Возможности @value{GDBN} для Си++}.

Вы должны указать @code{set overload-resolution off}, чтобы задать
функцию явно при вызове перегруженной функции, как в примере

@smallexample
p 'foo(char,int)'('x', 13)
@end smallexample

Возможности @value{GDBN} для завершения команд могут упростить это;
смотрите @ref{Завершение, ,Завершение команд}.

@cindex объявление ссылок
@item
@value{GDBN} понимает переменные, объявленные как ссылки Си++; вы можете
использовать их в выражениях, точно как вы делаете в исходном тексте
Си++ --- они автоматически разыменовываются.

В списке параметров, показываемом @value{GDBN} при отображении кадра
стека, значения переменных-ссылок не отображаются (в отличие от
других переменных); это позволяет избежать неудобств из-за того, что ссылки
часто используются для больших структур.  @emph{Адрес}
переменной-ссылки всегда выводится, если только вы не установили
@samp{set print address off}.

@item
@value{GDBN} поддерживает оператор Си++ определения области видимости имени
@code{::} --- ваши выражения могут использовать его так же, как в вашей
программе.  Так как одна область видимости может быть определена
внутри другой, вы можете при необходимости неоднократно использовать
@code{::}, например, в выражении типа
@samp{@var{обл1}::@var{обл2}::@var{имя}}.  @value{GDBN} также
позволяет определить область видимости имени путем ссылки на исходный
файл, при отладке как Си, так и Си++ (@pxref{Переменные, ,Переменные
программы}).
@end enumerate

Кроме того, при использовании с компилятором HP Си++, @value{GDBN}
правильно поддерживает вызов виртуальных функций, вывод виртуальных баз
объектов, вызов функций в базовом подобъекте, приведение объектов и
выполнение операторов, определенных пользователем.
@c ??? мне кажется, что base в данном случае -- это что-то насчет
@c родительского объекта в иерархии классов.  их так и принято
@c базами называть?

@node Значения Си по умолчанию
@subsubsection Значения Си и Си++ по умолчанию

@cindex значения Си и Си++ по умолчанию

Если вы разрешаете @value{GDBN} устанавливать проверки диапазона
и принадлежности типу автоматически, обе они по умолчанию
@emph{отключены}, если рабочий язык изменяется на Си или Си++.  Это
происходит независимо от того, выбираете рабочий язык вы или
@value{GDBN}.

Если вы разрешаете @value{GDBN} устанавливать язык автоматически, он распознает
исходные файлы, чьи имена заканчиваются расширением @file{.c},
@file{.C} или @file{.cc} и так далее, и когда @value{GDBN} начинает
обработку кода, скомпилированного из одного из этих файлов, он
устанавливает рабочий язык в Си или Си++.
@xref{Автоматическое, ,Распознавание @value{GDBN}
рабочего языка}, для более подробного обсуждения.

@node Проверки в Си
@subsubsection Проверки диапазона и принадлежности типу в Си и Си++

@cindex проверки в Си и Си++

Когда @value{GDBN} производит разбор выражений Си или Си++, по умолчанию
проверки соответствия типов не проводятся.  Однако, если вы их включите,
@value{GDBN} считает типы двух переменных эквивалентными, если:

@itemize @bullet
@item
Обе переменные структурированы и имеют один и тот же тег структуры,
объединения или перечисления.

@item
Имена типов обеих переменных совпадают или были объявлены
эквивалентными через @code{typedef}.
@end itemize

Проверка диапазона, если она включена, выполняется для
математических операций.  Индексы массивов не проверяются, так как они
часто применяются для индексирования указателей, которые
сами по себе массивами не являются.

@node Отладка Си
@subsubsection @value{GDBN} и Си

Команды @code{set print union} и @code{show print union} применимы к типу
@code{union}.  При установке в @samp{on}, любые объединения, находящиеся внутри
структуры или класса, также выводятся.  В противном случае, они
отображаются как @samp{@{...@}}.

Оператор @code{@@} помогает при отладке динамических массивов,
сформированных с помощью указателей и функции выделения памяти.
@xref{Выражения, ,Выражения}.

@c@menu
@c* Отладка Си++::
@c@end menu

@node Отладка Си++
@subsubsection Возможности @value{GDBN} для Си++

@cindex команды для Си++

Некоторые команды @value{GDBN} особенно полезны при использовании с
Си++, а некоторые разработаны специально для него.  Ниже приведено их
краткое описание:

@table @code
@cindex останов в перегруженных функциях
@item @r{меню точки останова}
Когда вы хотите установить точку останова в перегруженной
функции, меню точки останова @value{GDBN} помогает вам указать, какое
определение функции вам нужно.  @xref{Меню точки останова,,Меню точки
останова}.

@cindex перегрузка в Си++
@item rbreak @var{рег-выр}
Установка точек останова при помощи регулярных выражений
полезна при использовании перегруженных функций,
не являющихся членами специальных классов.  @xref{Установка точек
останова, ,Установка точек останова}.

@cindex обработка исключений Си++
@item catch throw
@itemx catch catch
Отлаживайте обработку исключений Си++ с помощью этих команд.
@xref{Установка точек перехвата, ,Установка точек перехвата}.

@cindex наследование
@item ptype @var{имя-типа}
Вывести отношения наследования вместе с другой информацией для типа
@var{имя-типа}.  @xref{Символы, ,Исследование таблицы символов}.

@cindex отображение символов Си++
@item set print demangle
@itemx show print demangle
@itemx set print asm-demangle
@itemx show print asm-demangle
Управляет отображением символов Си++ в их исходной форме, как при выводе
кода в виде исходного текста Си++, так и при выводе результата
дисассемблирования.
@xref{Параметры вывода, ,Параметры вывода}.

@item set print object
@itemx show print object
Выбрать, выводить производные (реальные) или описанные типы объектов.
@xref{Параметры вывода, ,Параметры вывода}.

@item set print vtbl
@itemx show print vtbl
Управляет форматом вывода таблиц виртуальных функций.
@xref{Параметры вывода, ,Параметры вывода}.
(Команды @code{vtbl} не работают для программ, скомпилированных
компилятором HP ANSI Си++ (@code{aCC}).)

@kindex set overload-resolution
@cindex перегруженные функции, разрешение перегруженных имен
@item set overload-resolution on
Включить разрешение перегруженных символов при вычислении выражений
Си++.  Значение по умолчанию @code{on}.  Для перегруженных функций,
@value{GDBN} вычисляет аргументы и ищет функции, чьи сигнатуры
удовлетворяют типам аргументов, используя стандартные правила
преобразования Си++ (смотрите @ref{Выражения Си++, ,Выражения Си++}, для
дополнительной информации).  Если @value{GDBN} не может найти такие
функции, он выводит сообщение.

@item set overload-resolution off
Отключить разрешение перегруженных символов при вычислении выражений
Си++.  Для перегруженных функций, не являющихся функциями-членами
класса, @value{GDBN} выбирает функцию с указанным именем, которую
он первой находит в таблице символов, вне зависимости от того, правильного
типа ее аргументы или нет.  Для перегруженных функций, являющихся
функциями-членами класса, @value{GDBN} ищет функцию, чья сигнатура
@emph{точно} совпадает с типами аргументов.

@item @r{Перегруженные имена символов}
Вы можете указать конкретное определение перегруженного символа,
используя ту же запись, что и для объявления таких символов в
Си++: введите @code{@var{символ}(@var{типы})} вместо просто
@var{символ}.  Вы также можете воспользоваться средствами завершения
слова командной строки @value{GDBN}, чтобы вывести список возможных
вариантов, или чтобы завершить набор за вас.
@xref{Завершение,, Завершение команд}, для подробного обсуждения, как это
сделать.
@end table

@node Модула-2
@subsection Модула-2

@cindex Модула-2, поддержка @value{GDBN}

Расширения, сделанные в @value{GDBN} для поддержки Модулы-2,
поддерживаются только для программ, скомпилированных
компилятором Модулы-2 @sc{gnu} (который сейчас разрабатывается).
Другие компиляторы Модулы-2 в настоящее время не
поддерживаются, и попытка отладки исполняемых программ, полученных
ими, скорее всего приведет к ошибке при считывании @value{GDBN} таблицы
символов этой программы.

@cindex выражения в Модуле-2
@menu
* Операторы Модулы-2::           Встроенные операторы
* Встроенные функции/процедуры:: Встроенные функции и процедуры
* Константы Модулы-2::           Константы Модулы-2
* Установки по умолчанию М-2::   Установки по умолчанию для Модулы-2
* Отклонения::                   Отклонения от стандарта Модулы-2
* Проверки Модулы-2::            Проверки диапазона и типа в Модулы-2
* Область видимости в Модуле-2:: Операторы определения области видимости
                                 @code{::} и @code{.}
* GDB и Модула-2::               @value{GDBN} и Модула-2
@end menu

@node Операторы Модулы-2
@subsubsection Операторы Модулы-2
@cindex операторы Модулы-2

Операторы должны быть определены на значениях определенных типов.
Например, @code{+} определен на числах, но не на структурах.
Операторы часто определяются на группах типов.  Для целей Модулы-2,
имеют место следующие определения:

@itemize @bullet

@item
@emph{Целые типы} состоят из @code{INTEGER}, @code{CARDINAL}
и их поддиапазонов.

@item
@emph{Знаковые типы} состоят из @code{CHAR} и его поддиапазонов.

@item
@emph{Типы с плавающей точкой} состоят из @code{REAL}.

@item
@emph{Типы-указатели} состоят из всего, объявленного как @code{POINTER TO
@var{тип}}.

@item
@emph{Скалярные типы} включают все вышеперечисленное.

@item
@emph{Типы-множества} состоят из типов @code{SET} и @code{BITSET}.

@item
@emph{Булевый тип} состоит из @code{BOOLEAN}.
@end itemize

@noindent
Поддерживаются следующие операторы; они представлены в порядке
возрастания приоритета:

@table @code
@item ,
Разделитель аргументов функции или индексов массива.

@item :=
Присваивание.  Значением @code{@var{перем} := @var{знач}} является
@var{знач}.

@item <@r{, }>
Меньше чем, больше чем для целочисленных типов, типов с
плавающей точкой и перечислимых типов.

@item <=@r{, }>=
Меньше или равно, больше или равно.  Определено на
целочисленных типах, типах с плавающей точкой и перечислимых типах.
Включение для множеств.  Такой же приоритет, как у @code{<}.

@item =@r{, }<>@r{, }#
Равенство и два способа выражения неравенства; допустимо на
скалярных типах.  Такой же приоритет, как у @code{<}.  В сценариях
@value{GDBN}, для неравенства допустимо только @code{<>}, так как
@code{#} конфликтует со знаком комментария.

@item IN
Установка принадлежности.  Определено на множествах и
типах их элементов.  Такой же приоритет, как у @code{<}.

@item OR
Дизъюнкция (логическое ИЛИ).  Определена на булевых типах.

@item AND@r{, }&
Конъюнкция (логическое И).  Определена на булевых типах.

@item @@
Оператор ``искусственного массива'' @value{GDBN} (@pxref{Выражения,
,Выражения}).

@item +@r{, }-
Сложение и вычитание на целочисленных типах и типах с плавающей
точкой или объединение и разность на множественных типах.

@item *
Умножение на целочисленных типах и типах с плавающей точкой или
пересечение на типах-множествах.

@item /
Деление на типах с плавающей точкой.  Симметрическая разность
множеств на типах-множествах.  Такой же приоритет, как у @code{*}.

@item DIV@r{, }MOD
Целочисленное деление и остаток.  Определены на целочисленных
типах.  Такой же приоритет, как у @code{*}.

@item -
Отрицание.  Определено на данных типов @code{INTEGER} и @code{REAL}.

@item ^
Разыменовывание указателя.  Определено на типах-указателях.

@item NOT
Булево отрицание.  Определено на булевых типах.  Такой же приоритет, как
у @code{^}.

@item .
Селектор полей @code{RECORD}.  Определен для данных типа @code{RECORD}.
Такое же приоритет, как у @code{^}.

@item []
Индексация массива.  Определена для данных типа @code{ARRAY}.  Такой же
приоритет, как у @code{^}.

@item ()
Список параметров процедуры.  Определен на объектах @code{PROCEDURE}.
Такой же приоритет, как у @code{^}.

@item ::@r{, }.
Операторы @value{GDBN} и Модулы-2 определения области видимости.
@end table

@quotation
@emph{Предупреждение:} Множества и операции над ними еще не
поддерживаются, так что @value{GDBN} трактует использование оператора
@code{IN} или операторов @code{+}, @code{-}, @code{*}, @code{/},
@code{=}, , @code{<>}, @code{#}, @code{<=}, и @code{>=} на
множествах как ошибку.
@end quotation


@node Встроенные функции/процедуры
@subsubsection Встроенные функции и процедуры
@cindex встроенные функции Модулы-2

Модула-2 также делает доступными несколько встроенных процедур и
функций.  При их описании используются следующие метапеременные:

@table @var

@item a
представляет переменную типа @code{ARRAY}.

@item c
представляет константу или переменную типа @code{CHAR}.

@item i
представляет переменную или константу целого типа.

@item m
представляет идентификатор, принадлежащий множеству.  Обычно
используется в одной функции с метапеременной @var{s}.  Тип @var{s}
должен быть @code{SET OF @var{метатип}} (где @var{метатип} --- тип @var{m}).

@item n
представляет переменную или константу целого типа или
типа с плавающей точкой.

@item r
представляет переменную или константу типа с плавающей точкой.

@item t
представляет тип.

@item v
представляет переменную.

@item x
представляет переменную или константу одного из нескольких типов.
Смотрите пояснение к функции для дополнительной информации.
@end table

Ниже описаны все встроенные процедуры Модулы-2, возвращающие результат.

@table @code
@item ABS(@var{n})
Возвращает абсолютное значение @var{n}.

@item CAP(@var{c})
Если @var{c} --- строчная буква, процедура возвращает ее эквивалент
в верхнем регистре, иначе возвращает сам аргумент.

@item CHR(@var{i})
Возвращает знак, порядковое значение которого есть @var{i}.

@item DEC(@var{v})
Уменьшает значение переменной @var{v} на единицу.  Возвращает новое значение.

@item DEC(@var{v},@var{i})
Уменьшает значение переменной @var{v} на @var{i}.  Возвращает новое значение.

@item EXCL(@var{m},@var{s})
Удаляет элемент @var{m} из множества @var{s}.  Возвращает новое множество.

@item FLOAT(@var{i})
Возвращает эквивалент целого числа @var{i} в формате с плавающей точкой.

@item HIGH(@var{a})
Возвращает индекс последнего элемента @var{a}.

@item INC(@var{v})
Увеличивает значение переменной @var{v} на единицу.  Возвращает новое
значение.

@item INC(@var{v},@var{i})
Увеличивает значение переменной @var{v} на @var{i}.  Возвращает новое
значение.

@item INCL(@var{m},@var{s})
Добавляет элемент @var{m} в множество @var{s}, если его там еще нет.
Возвращает новое множество.

@item MAX(@var{t})
Возвращает максимальное значение типа @var{t}.

@item MIN(@var{t})
Возвращает минимальное значение типа @var{t}.

@item ODD(@var{i})
Возвращает булево значение TRUE, если число @var{i} нечетно.

@item ORD(@var{x})
Возвращает порядковое значение своего аргумента.  Например, порядковое
значение знака --- его @sc{ascii}-значение (на машинах, поддерживающих
набор знаков @sc{ascii}).  @var{x} должна принадлежать упорядоченному
типу, что включает целочисленные, знаковый и перечислимый типы.

@item SIZE(@var{x})
Возвращает размер аргумента.  @var{x} может быть переменной или типом.

@item TRUNC(@var{r})
Возвращает целую часть @var{r}.

@item VAL(@var{t},@var{i})
Возвращает элемент типа @var{t}, порядковое значение которого есть @var{i}.
@end table

@quotation
@emph{Предупреждение:} Множества и операции над ними еще не
поддерживаются, так что @value{GDBN} рассматривает использование
процедур @code{INCL} и @code{EXCL} как ошибку.
@end quotation

@cindex константы Модулы-2
@node Константы Модулы-2
@subsubsection Константы

@value{GDBN} позволяет вам выражать константы Модулы-2 следующими способами:

@itemize @bullet

@item
Целые константы являются просто последовательностью цифр.
При использовании в выражении, константа интерпретируется так, чтобы быть
совместимой по типу с остальной частью выражения.  Шестнадцатеричные
целые числа определяются окончанием @samp{H}, а восьмеричные ---
окончанием @samp{B}.

@item
Константы с плавающей точкой задаются как последовательность цифр,
за которой следует десятичная точка и другая последовательность цифр.
Необязательный порядок может быть задан в форме
@samp{E@r{[}+@r{|}-@r{]}@var{nnn}}, где
@samp{@r{[}+@r{|}-@r{]}@var{nnn}} и есть желаемый порядок.  Все цифры
константы с плавающей точкой должны быть десятичными (по основанию 10).

@item
Знаковые константы состоят из одиночных знаков, заключенных в пару
одинаковых кавычек: либо одиночных (@code{'}), либо двойных (@code{"}).
Они также могут быть заданы своим порядковым значением (обычно
@sc{ascii}-значением), за которым следует @samp{C}.

@item
Строковые константы состоят из последовательности знаков, окруженных
парой одинаковых кавычек: либо одиночных (@code{'}), либо двойных
(@code{"}).  Также допускаются экранирующие последовательности в
стиле Си.  @xref{Константы Си, ,Константы Си и Си++}, для краткого
объяснения экранирующих последовательностей.

@item
Перечислимые константы состоят из перечислимого идентификатора.

@item
Булевы константы состоят из идентификаторов @code{TRUE} и @code{FALSE}.

@item
Константы-указатели состоят только из целочисленных значений.

@item
Константы-множества пока не поддерживаются.
@end itemize

@node Установки по умолчанию М-2
@subsubsection Установки по умолчанию Модулы-2
@cindex установки по умолчанию Модулы-2

Если проверка диапазона или принадлежности типу устанавливается
@value{GDBN} автоматически, то по умолчанию обе они устанавливаются в
@code{on}, если рабочим языком становится Модула-2.  Это происходит
независимо от того, кто выбрал рабочий язык --- вы или @value{GDBN}.

Если вы разрешаете @value{GDBN} выбирать язык автоматически, то при анализе
кода, скомпилированного из файла, чье имя оканчивается на @file{.mod},
@value{GDBN} установит рабочим языком Модулу-2.  @xref{Автоматическое,
,Распознавание @value{GDBN} исходного языка}, для
дополнительной информации.

@node Отклонения
@subsubsection Отклонения от стандарта Модулы-2
@cindex Модула-2, отклонения от стандарта

Для упрощения отладки программ на Модуле-2 было сделано несколько
изменений.  В основном, это сделано путем ослабления строгости контроля типов:

@itemize @bullet
@item
В отличие от стандарта Модулы-2, константы-указатели могут быть
сформированы целыми числами.  Это позволяет вам изменять
переменные-указатели в процессе отладки.  (В стандарте Модулы-2,
реальный адрес, содержащийся в переменной-указателе, скрыт от
вас; его можно изменить лишь прямым присваиванием значения другой
переменной-указателя или выражения, возвращающего указатель.)

@item
Для представления непечатаемых знаков можно использовать в строках и
знаковых константах экранирующие последовательности Си.  @value{GDBN}
выводит строки со встроенными экранирующими последовательностями.
Одиночные непечатаемые знаки выводятся с помощью формата
@samp{CHR(@var{nnn})}.

@item
Оператор присваивания (@code{:=}) возвращает значение своего правого аргумента.

@item
Все встроенные процедуры как изменяют, так @emph{и} возвращают свой аргумент.
@end itemize

@node Проверки Модулы-2
@subsubsection Проверки диапазона и принадлежности типу Модулы-2
@cindex проверки Модулы-2

@quotation
@emph{Предупреждение:} в этом выпуске, @value{GDBN} еще не выполняет проверки
диапазона и принадлежности типу.
@end quotation

@value{GDBN} считает две переменные Модулы-2 эквивалентными по типу,
если:

@itemize @bullet
@item
Их типы были объявлены эквивалентными посредством оператора @code{TYPE
@var{t1} = @var{t2}}

@item
Они были объявлены на одной и той же строке.  (Примечание:  Это верно
для компилятора @sc{gnu} Модула-2, но это может не выполняться для других
компиляторов.)
@end itemize

Пока проверка соответствия типов включена, любая попытка
скомбинировать переменные неэквивалентных типов является ошибкой.

Проверка диапазона выполняется во всех математических операциях,
присваиваниях, при индексации массивов и во всех встроенных функциях
и процедурах.

@node Область видимости в Модуле-2
@subsubsection Операторы определения области видимости @code{::} и @code{.}
@cindex область видимости
@cindex @code{.}, оператор области видимости Модулы-2
@cindex двойное двоеточие как оператор области видимости
@ifinfo
@vindex двоеточие-двоеточие@r{, в Модуле-2}
@end ifinfo
@iftex
@vindex ::@r{, в Модуле-2}
@end iftex

Существует несколько тонких различий между операторами области видимости
Мо@-ду@-лы-2 (@code{.}) и @value{GDBN} (@code{::}).  Оба имеют похожий синтаксис:

@example

@var{модуль} . @var{идент}
@var{область} :: @var{идент}
@end example

@noindent
где @var{область} --- имя модуля или процедуры, @var{модуль} --- имя модуля,
а @var{идент} --- любой идентификатор, описанный в пределах вашей программы,
за исключением другого модуля.

Использование оператора @code{::} заставляет @value{GDBN} искать
идентификатор @var{идент} в @var{области}.  Если он в ней
не найден, @value{GDBN} ищет его во всех областях,
содержащих @var{область}.

Использование оператора @code{.} заставляет @value{GDBN} искать
идентификатор @var{идент}, который был импортирован из модуля определения
@var{модуль}, в текущей области видимости.  В этом операторе cчитается
ошибкой, если идентификатор @var{идент} не был
импортирован из модуля определения @var{модуль}, или если @var{идент} не
является в нем идентификатором.

@node GDB и Модула-2
@subsubsection @value{GDBN} и Модула-2

Некоторые команды @value{GDBN} имеют мало смысла при отладке программ на
Модуле-2.  Пять подкоманд из команд @code{set print} и @code{show
print} применимы исключительно к Си и Си++: @samp{vtbl}, @samp{demangle},
@samp{asm-demangle}, @samp{object} и @samp{union}.  Первые четыре
применимы к Си++, а последняя к типу Си @code{union}, который не имеет
прямого аналога в Модуле-2.

Оператор @code{@@} (@pxref{Выражения, ,Выражения}), хоть и доступен при
использовании любого языка, бесполезен при работе с Модулой-2.  Его цель
состоит в том, чтобы помочь при отладке @dfn{динамических массивов}, которые
не могут быть созданы в Модуле-2 в отличие от Си или Си++.  Однако,
конструкция @samp{@{@var{тип}@}@var{адр-выр}} все же полезна, так как
адрес может быть определен целочисленной константой.

@cindex @code{#} в Модуле-2
В сценариях @value{GDBN}, оператор неравенства Модулы-2 @code{#}
интерпретируется как начало комментария.  Используйте вместо него @code{<>}.

@node Chill
@subsection Chill

Расширения, сделанные в @value{GDBN} для поддержки Chill, работают
только с программами, созданными компилятором @sc{gnu} Chill.
Другие компиляторы Chill в настоящее время не поддерживаются, и попытка
отладить программы, полученные с их помощью, скорее всего приведет к
ошибке в тот момент, когда @value{GDBN} будет считывать таблицу символов
выполняемого файла.

Этот раздел охватывает темы, связанные с Chill, и возможности
@value{GDBN} для их поддержки.

@menu
* Как отображаются режимы::     Как отображаются режимы
* Местоположения::              Местоположения и доступ к ним
* Значения и операции с ними::  Значения и операции с ними
* Проверка диапазона и типов в Chill::
* Установки по умолчанию Chill::
@end menu

@node Как отображаются режимы
@subsubsection Как отображаются режимы

Поддержка @value{GDBN} типов данных (режимов) Chill непосредственно
связана с возможностями компилятора @sc{gnu} Chill и, следовательно,
слегка отличается от стандартной спецификации языка.  Вот
предоставляемые режимы:

@table @code
@item @r{@emph{Дискретные режимы:}}
@itemize @bullet
@item
@emph{Целочисленные режимы}, которые предопределены как @code{BYTE,
UBYTE, INT, UINT, LONG, ULONG},
@item
@emph{Булевский режим}, который предопределен как @code{BOOL},
@item
@emph{Знаковый режим}, который предопределен как @code{CHAR},
@item
@emph{Режим-множество}, который отображается ключевым словом
@code{SET}.
@smallexample
(@value{GDBP}) ptype x
type = SET (karli = 10, susi = 20, fritzi = 100)
@end smallexample
Если тип является ненумерованным множеством, значения элементов
множества опускаются.
@item
@emph{Режим-диапазон}, который отображается как
@smallexample
@code{тип = <базовый-режим>(<нижняя граница> : <верхняя граница>)}
@end smallexample
где @code{<нижняя граница>, <верхняя граница>} может быть любым
дискретным буквенным выражением (например, имена элементов множества).
@end itemize

@item @r{@emph{Режим powerset:}}
Режим Powerset отображается ключевым словом @code{POWERSET}, за
которым следует режим элемента.
@c ???????? member mode?
@smallexample
(@value{GDBP}) ptype x
type = POWERSET SET (egon, hugo, otto)
@end smallexample

@item @r{@emph{Режимы-ссылки:}}
@itemize @bullet
@item
@emph{Режим привязанной ссылки}, который отображается ключевым словом
@code{REF}, за которым следует название режима, к которому ссылка
привязана.
@item
@emph{Режим свободной ссылки}, который отображается ключевым словом
@code{PTR}.
@end itemize

@item @r{@emph{Процедурный режим}}
Процедурный режим отображается в виде @code{тип = PROC(<список параметров>)
<возвращаемый режим> EXCEPTIONS (<список исключений>)}.  @code{<список
па@-ра@-мет@-ров>} представляет собой список режимов параметров.
@code{<возвращаемый режим>} указывает режим результата процедуры, если
она возвращает результат.  @code{<список исключений>} перечисляет все
возможные исключения, которые могут быть возбуждены процедурой.

@ignore
@item @r{@emph{Режим instance}}
@c ?????????? instance mode?
Режим instance представляется структурой, которая имеет статический тип,
и, следовательно, не представляет реального интереса.
@end ignore

@item @r{@emph{Синхронизационные режимы:}}
@itemize @bullet
@item
@emph{Режим события}, который отображается как
@smallexample
@code{EVENT (<длина события>)}
@end smallexample
где @code{<длина события>} является необязательной.
@item
@emph{Буферный режим}, который отображается как
@smallexample
@code{BUFFER (<длина буфера>)<режим элементов буфера>}
@end smallexample
где @code{(<длина буфера>)} является необязательной.
@end itemize

@item @r{@emph{Режимы времени:}}
@itemize @bullet
@item
@emph{Режим длительности}, который предопределен как @code{DURATION}
@item
@emph{Режим абсолютного времени}, который предопределен как @code{TIME}
@end itemize

@item @r{@emph{Вещественные режимы:}}
Вещественные режимы предопределены как @code{REAL} и @code{LONG_REAL}.

@item @r{@emph{Строковые режимы:}}
@itemize @bullet
@item
@emph{Режим строки знаков}, который отображается как
@smallexample
@code{CHARS(<длина строки>)}
@end smallexample
за которым следует ключевое слово @code{VARYING}, если строковый режим
является изменяющимся режимом
@c ????????? varying mode
@item
@emph{Режим строки битов}, который отображается как
@smallexample
@code{BOOLS(<длина строки>)}
@end smallexample

@end itemize

@item @r{@emph{Режим массива:}}
Режим массива отображается ключевым словом @code{ARRAY(<диапазон>)},
за которым следует режим элементов (который, в свою очередь, может быть
режимом массива).
@smallexample
(@value{GDBP}) ptype x
type = ARRAY (1:42)
          ARRAY (1:20)
             SET (karli = 10, susi = 20, fritzi = 100)
@end smallexample

@item @r{@emph{Структурный режим}}
Структурный режим отображается ключевым словом @code{STRUCT(<список
полей>)}.  @code{<список полей>} состоит из имен и режимов полей
структуры.  Структуры с вариантами имеют ключевое слово @code{CASE
<поле> OF <варианты поля> ESAC} в их списке полей.  Так как текущая
версия компилятора @sc{gnu} Chill не реализует обработку тегов (нет
проверок времени выполнения вариантных полей и, следовательно, нет
отладочной информации), вывод всегда содержит все вариантные поля.
@smallexample
(@value{GDBP}) ptype str
type = STRUCT (
    as x,
    bs x,
    CASE bs OF
    (karli):
        cs a
    (ott):
        ds x
    ESAC
)
@end smallexample
@end table

@node Местоположения
@subsubsection Местоположения и доступ к ним

Местоположением в Chill является объект, который может содержать
значения.

Доступ к значению местоположения обычно производится посредством
(описанного) имени местоположения.  Вывод удовлетворяет спецификации
значений в программах на Chill.  То, как значения задаются, является темой
следующего раздела, смотрите @ref{Значения и операции с ними}.

Псевдоместоположение @code{RESULT} (или @code{result}) может
использоваться для отображения или изменения результата процедуры,
активной в настоящий момент:

@smallexample
set result := EXPR
@end smallexample

@noindent
Это делает то же самое, что и действие Chill @code{RESULT EXPR} (которое
в @value{GDBN} недоступно).

Значения местоположений режима ссылок выводятся, в случае режима
свободной ссылки, посредством
@code{PTR(<шестнадцатеричное значение>)}, и с помощью @code{(REF <режим ссылки>) (<шестнадцатеричное
значение>)} в случае привязанной ссылки.  @code{<шестнадцатеричное
значение>} представляет адрес, на который указывает ссылка.  Для доступа
к значению местоположения, указываемого ссылкой, используйте оператор
разыменовывания @samp{->}.

Значения местоположений процедурного режима отображаются как
@smallexample
@code{@{ PROC
(<режимы аргументов> ) <возвращаемый режим> @} <адрес> <имя
местоположения процедуры>}
@end smallexample
@code{<режимы аргументов>} --- это список
режимов, в соответствии со спецификацией параметров процедуры, а
@code{<адрес>} указывает адрес точки входа.

Подструктуры значений строковых режимов, режимов массивов или структур
(например, срезы массивов, поля  структурных местоположений) доступны при
использовании определенных операторов, которые описаны в следующем
разделе, смотрите @ref{Значения и операции с ними}.

Значение местоположения может быть интерпретировано как имеющее другой
режим посредством преобразования местоположений.  Это преобразование
режимов записывается как @code{<имя режима>(<местоположение>)}.
Пользователь должен учесть, что размеры режимов должны быть равными, в
противном случае возникает ошибка.  Более того, не производится никаких
проверок диапазона местоположения по сравнению с режимом назначения, и,
следовательно, результат может быть достаточно обескураживающим.

@smallexample
(@value{GDBP}) print int (s(3 up 4)) XXX TO be filled in !! XXX
@end smallexample

@node Значения и операции с ними
@subsubsection Значения и операции с ними

Значения используются для изменения местоположений, для более подробного
изучения сложных структур и для отфильтровывания значимой информации из
большого объема данных.  Определено несколько операций
(зависящих от режима), которые позволяют проводить подобные изучения.
Эти операции применимы не только к значениям-константам, но также и к
местоположениям, что может оказаться достаточно полезным при отладке
сложных структур.  Во время разбора командной строки (например, вычисляя
выражение), @value{GDBN} рассматривает имена местоположений как значения
этих местоположений.

Этот раздел описывает, как должны задаваться значения, и какие операции
допустимо использовать с этими значениями.

@table @code
@item Буквенные значения
Буквенные значения определяются также, как в программах
@sc{gnu} Chill.  Для подробной спецификации, смотрите главу 1.5
Руководства по реализации @sc{gnu} Chill.

@item Значения-наборы
Набор может быть задан как @code{<имя режима>[<набор>]}, где @code{<имя
режима>} может быть опущено, если режим набора определяется однозначно.
Эта однозначность определяется из контекста вычисляемого выражения.
@code{<набор>} может быть одним из:

@itemize @bullet
@item @emph{Набор powerset}
@item @emph{Набор массивов}
@item @emph{Набор структур}
@end itemize

Наборы-powerset, наборы массивов и наборы структур определяются так же,
как в программах на Chill.

@item Значение элемента строки
Значение элемента строки задается как
@smallexample
@code{<строковое значение>(<индекс>)}
@end smallexample
где @code{<индекс>} является целочисленным
выражением.  Это дает знаковое значение, которое эквивалентно знаку,
указываемому в строке индексом @code{<индекс>}.

@item Значение среза строки
Значение среза строки задается как @code{<значение строки>(<спецификация
среза>)}, где @code{<спецификация среза>} может быть либо диапазоном
целых выражений, либо задаваться в виде @code{<начальное выражение> up
<размер>}.  @code{<размер>} обозначает число элементов, которое содержит
срез.  Полученная величина является строкой, которая является частью
указанной строки.

@item Значения элементов массива
Значение элемента массива указывается в виде @code{<величина
массива>(<выр>)} и дает величину элемента массива с режимом как у
указанного массива.

@item Значение среза массива
Срез массива задается как @code{<значение массива>(<спецификация
среза>)}, где @code{<спецификация среза>} может быть диапазоном,
определенным либо выражениями, либо как @code{<начальное выр> up
<размер>}.  @code{<размер>} обозначает число элементов массива, которое
содержит срез.  Получаемое значение есть массив, который является
частью указанного.

@item Значение поля структуры
Значение поля структуры получается как @code{<значение структуры>.<имя
поля>}, где @code{<имя поля>} указывает имя поля, заданное в определении
режима структуры.  Режим полученного значения соответствует этому
определению режима в определении структуры.

@item Значения вызова процедуры
Значение вызова процедуры получается из значения, возвращенного
процедурой@footnote{Если, например, вызов процедуры используется в
выражении, то эта процедура вызывается со всеми своими побочными
эффектами.  При неаккуратном использовании это может привести к
путанице.}.

Значения местоположений режима длительности представляются буквами
@code{ULONG}.

Значения местоположений режима-времени выводятся как
@smallexample
@code{TIME(<сек>:<нсек>)}.
@end smallexample

@c ?????????????
@item Значение безаргументного оператора
Значение безаргументного оператора получается из значения экземпляра для
текущего активного процесса.

@item Значения выражений
Значение, доставляемое выражением, является результатом вычисления
указанного выражения.  В случае ошибки (несовместимость режимов и тому
подобное), вычисление выражения прерывается с соответствующим сообщением об
ошибке.  Выражение может быть заключено в скобки, что приводит к
вычислению этого выражения до любого другого, использующего результат
выражения в скобках.  @value{GDBN} поддерживает следующие операторы:

@table @code
@item @code{OR, ORIF, XOR}
@itemx @code{AND, ANDIF}
@itemx @code{NOT}
Логические операторы, определенные на операндах булевого режима.

@item @code{=, /=}
Операторы равенства и неравенства, определенные на всех режимах.

@item @code{>, >=}
@itemx @code{<, <=}
Операторы отношения, заданные на предопределенных режимах.

@item @code{+, -}
@itemx @code{*, /, MOD, REM}
Арифметические операторы, заданные на предопределенных режимах.

@item @code{-}
Оператор изменения знака.

@item @code{//}
Оператор соединения строк.

@item @code{()}
Оператор повторения строки.

@item @code{->}
Оператор ссылки местоположения, который может быть использован
либо для получения адреса местоположения (@code{->loc}), или для
разыменовывания ссылки местоположения (@code{loc->}).

@item @code{OR, XOR}
@itemx @code{AND}
@itemx @code{NOT}
Операторы режимов powerset и строки битов.

@item @code{>, >=}
@itemx @code{<, <=}
Операторы включения режима powerset.

@item @code{IN}
Оператор принадлежности.
@end table
@end table

@node Проверка диапазона и типов в Chill
@subsubsection Проверка диапазона и типов в Chill

@value{GDBN} считает два режима переменных Chill эквивалентными, если их
размеры равны.  Это правило применяется рекурсивно для
более сложных типов данных.  Это означает, что сложные режимы
считаются эквивалентными, если режимы всех элементов (которые тоже могут
быть сложными, например, массивами, структурами, и так далее) имеют
одинаковый размер.

Проверка диапазона производится для всех математических операций,
присваиваний, границ индексов массива и всех встроенных процедур.

Строгие проверки типов включаются с помощью команды @value{GDBN}
@code{set check strong}.  Это навязывает строгую проверку диапазона и
принадлежности типу для всех действий, где используются конструкции
Chill (выражения, встроенные функции и так далее), в соответствии с
семантикой, определенной в спецификации языка z.200.

Все проверки могут быть отключены командой @value{GDBN} @code{set check
off}.

@node Установки по умолчанию Chill
@subsubsection Установки по умолчанию Chill

Если проверки типа и диапазона установлены @value{GDBN} автоматически,
обе они по умолчанию включены, когда рабочий язык переключается на
Chill.  Это происходит независимо от того, вы выбрали рабочий язык или
@value{GDBN}.

Если вы разрешите @value{GDBN} устанавливать рабочий язык автоматически,
то при попадании в код, скомпилированный из файла, чье имя заканчивается
на @file{.ch}, он переключает рабочий язык на Chill.  @xref{Автоматическое,
,Распознавание @value{GDBN} исходного языка}, для
дополнительной информации.

@node Символы
@chapter Исследование таблицы символов

Команды, описанные в этой главе, позволяют вам получить информацию
о символах (именах переменных, функций и типов), определенных в вашей
программе.  Эта информация присуща тексту вашей программы и не изменяется при
ее выполнении.  @value{GDBN} находит эту информацию в таблице символов
вашей программы, в файле, определенном при его вызове (@pxref{Параметры
файлов, ,Выбор файлов}), или посредством одной из команд управления
файлами (@pxref{Файлы, ,Команды для задания файлов}).

@cindex имена символов
@cindex имена в кавычках
Иногда вам может потребоваться сослаться на символы, содержащие
необычные знаки, которые @value{GDBN} обычно трактует как разделители
слов.  Наиболее часто это встречается при ссылках на статические
переменные в других исходных файлах (@pxref{Переменные, ,Переменные
программы}).  Имена файлов записаны в объектных файлах как отладочные
символы, но @value{GDBN} обычно производит разбор типичного имени файла, например
@file{foo.c}, как три слова: @samp{foo} @code{.} @code{c}.  Чтобы @value{GDBN}
идентифицировал @samp{foo.c} как одно слово, заключите его в одинарные
кавычки; например,

@example
p 'foo.c'::x
@end example

@noindent
ищет значение @code{x} в области видимости файла @file{foo.c}.

@table @code
@kindex info address
@item info address @var{символ}
Описывает, где хранятся данные для @var{символа}.  Для регистровой
переменной сообщается, в каком регистре она содержится.  Для
нерегистровой локальной переменной печатается смещение в
кадре стека, по которому переменная всегда хранится.

Заметьте отличие от команды @samp{print &@var{символ}}, которая вообще
не работает для регистровых переменных, а для локальной
переменной из стека печатает точный адрес текущего экземпляра переменной.

@kindex whatis
@item whatis @var{выраж}
Напечатать тип данных выражения @var{выраж}.  На самом деле @var{выраж} не
вычисляется, и присутствующие в нем побочные операции (такие как присваивания
или вызовы функций) не выполняются.  @xref{Выражения, ,Выражения}.

@item whatis
Вывести тип данных @code{$}, последней записи в истории значений.

@kindex ptype
@item ptype @var{имя-типа}
Вывести описание типа данных @var{имя-типа}.  @var{Имя-типа} может быть именем
типа или, для кода Си, может иметь форму @samp{class @var{имя-класса}},
@samp{struct @var{тег-структуры}}, @samp{union @var{тег-объединения}}
или @samp{enum @var{тег-перечисления}}.

@item ptype @var{выраж}
@itemx ptype
Вывести описание типа выражения @var{выраж}.  @code{ptype} отличается от
@code{whatis} тем, что выводится детальное описание, а не только имя
типа.

Например, для такого описания переменной:

@example
struct complex @{double real; double imag;@} v;
@end example

@noindent
эти две команды выведут следующее:

@example
@group
(@value{GDBP}) whatis v
type = struct complex
(@value{GDBP}) ptype v
type = struct complex @{
    double real;
    double imag;
@}
@end group
@end example

@noindent
Как и @code{whatis}, использование @code{ptype} без параметра относится
к типу @code{$}, последней записи в истории значений.

@kindex info types
@item info types @var{рег-выр}
@itemx info types
Вывести краткое описание всех типов, имена которых соответствуют
регулярному выражению
@var{рег-выр} (или всех типов вашей программы, если вы используете эту
команду без параметра).  Каждое полное имя типа сопоставляется так, как
если бы оно было полной строкой; таким образом, @samp{i type value}
выдает информацию обо всех типах в вашей программе, чьи имена
включают строку @code{value}, а @samp{i type ^value$} выдает информацию
только о типах с полным именем @code{value}.

Эта команда отличается от @code{ptype} следующим: во-первых, как и
@code{whatis}, она не выводит детального описания; во-вторых, она
перечисляет все исходные файлы, где определен тип.

@kindex info source
@item info source
Показать имя текущего исходного файла --- то есть исходного файла для функции,
содержащей текущую точку выполнения, и язык, на котором она написана.

@kindex info sources
@item info sources
Вывести имена всех исходных файлов вашей программы, для которых
имеется отладочная информация, организуя их в два списка: файлы с
уже прочитанными символами, и файлы, символы которых будут
прочитаны, когда потребуется.

@kindex info functions
@item info functions
Вывести имена и типы данных всех определенных функций.

@item info functions @var{рег-выр}
Вывести имена и типы данных всех определенных функций, чьи имена
удовлетворяют регулярному выражению @var{рег-выр}.  Так, @samp{info
fun step} находит все функции, имена которых содержат @code{step};
@samp{info fun ^step} находит функции с именами, начинающимися со @code{step}.

@kindex info variables
@item info variables
Напечатать имена и типы данных всех переменных, объявленных вне функций
(то есть исключая локальные переменные).

@item info variables @var{рег-выр}
Вывести имена и типы данных всех переменных (кpоме локальных), имена
которых удовлетворяют регулярному выражению @var{рег-выр}.

@cindex повторная загрузка символов
Некоторые системы допускают замещение отдельных объектных файлов,
составляющих вашу программу, без ее остановки и перезапуска.
Например, в VxWorks вы можете просто перекомпилировать дефектный
объектный файл и продолжить выполнение.  Если вы работаете в одной из
таких систем, вы можете позволить @value{GDBN} перезагрузить символы для
автоматически пересобранных модулей:

@table @code
@kindex set symbol-reloading
@item set symbol-reloading on
Заменить определения символов для соответствующего исходного
файла, когда объектный файл с определенным именем снова доступен.

@item set symbol-reloading off
Не заменять определения символов при встрече объектного файла с таким же
именем более одного раза.  Это состояние по умолчанию; если вы не
работаете в системе, допускающей автоматическое пересобирание модулей,
вы должны оставить @code{symbol-reloading} в состоянии @code{off}, так как
иначе @value{GDBN} может уничтожить символы пpи сборке больших программ,
которые могут содеpжать несколько модулей с одинаковым именем (из разных
каталогов или библиотек).

@kindex show symbol-reloading
@item show symbol-reloading
Показать текущую установку @code{on} или @code{off}.
@end table

@kindex set opaque-type-resolution
@item set opaque-type-resolution on
Велит @value{GDBN} производить разрешение неоднозначных типов.  Неоднозначным
является тип, описанный как указатель на @code{struct}, @code{class}
или @code{union} --- например, @code{struct MyType *} --- то есть,
используется в одном исходном файле, хотя полное описание @code{struct
MyType} находится в другом исходном файле.  По умолчанию установлено в
@code{on}.

Изменения в установке этой подкоманды не вступят в силу, пока не будут
загружены символы для какого-нибудь файла.

@item set opaque-type-resolution off
Указывает @value{GDBN} не производить разрешение неоднозначных типов.  В
этом случае, тип выводится следующим образом:
@smallexample
@{<no data fields>@}
@end smallexample

@kindex show opaque-type-resolution
@item show opaque-type-resolution
Показать, производится разрешение неоднозначных типов или нет.

@kindex maint print symbols
@cindex дамп символов
@kindex maint print psymbols
@cindex частичный дамп символов
@item maint print symbols @var{имя-файла}
@itemx maint print psymbols @var{имя-файла}
@itemx maint print msymbols @var{имя-файла}
Записать дамп данных отладочных символов в файл @var{имя-файла}.  Эти
команды используются для отладки кода @value{GDBN}, осуществляющего
чтение символов.  Включаются только символы с отладочными данными.  Если вы
используете @samp{maint print symbols}, @value{GDBN} включает все символы, для
которых уже собрана полная информация: то есть @var{имя-файла} отражает
символы только для тех файлов, символы которых @value{GDBN} уже
прочитал.  Вы можете использовать команду @code{info sources}, чтобы
определить, какие это файлы.  Если же вы используете @samp{maint print
psymbols}, дамп показывает информацию о тех символах, о которых
@value{GDBN} имеет лишь частичную информацию, то есть символы определены
в файлах, которые @value{GDBN} только просмотрел, но не прочитал
полностью.  Наконец, @samp{maint print msymbols}, выводит только
минимальную информацию о символах, требуемую для каждого
объектного файла, из которых @value{GDBN} пpочитал какие-либо символы.
@xref{Файлы, ,Команды для задания файлов}, где обсуждается, как
@value{GDBN} считывает символы (в описании @code{symbol-file}).
@end table

@node Изменения
@chapter Изменение выполнения

Если вы думаете, что нашли ошибку в своей программе, вы можете захотеть
выяснить наверняка, приведет ли исправление кажущейся ошибки к
правильным результатам в остальной части программы.  Вы можете получить
ответ экспериментируя, используя средства @value{GDBN} для изменения
выполнения программы.

Например, вы можете сохранить новые значения в переменных или
ячейках памяти, подать своей программе сигнал, перезапустить ее
с другого адреса или даже преждевременно вернуться из функции.

@menu
* Присваивание::                Присваивание значения переменной
* Переходы::                    Продолжение выполнения с другого адреса
* Подача сигналов::             Подача сигнала вашей программе
* Возврат::                     Возврат из функции
* Вызовы::                      Вызовы функций вашей программы
* Внесение изменений::          Внесение изменений в вашу программу
@end menu

@node Присваивание
@section Присваивание значений переменным

@cindex присваивание
@cindex установка значений переменных
Для изменения значения переменной, вычислите выражение присваивания.
@xref{Выражения, ,Выражения}.  Например,

@example
print x=4
@end example

@noindent
сохраняет значение 4 в переменной @code{x} и затем выводит значение данного
выражения (которое равно 4).  @xref{Языки, ,Использование @value{GDBN} с
различными языками программирования}, для получения большей информации
об операторах в поддерживаемых языках.

@kindex set variable
@cindex переменные, присваивание значений
Если вы не хотите видеть значение присваивания, используйте команду
@code{set} вместо @code{print}.  Команда @code{set} аналогична команде
@code{print} за исключением того, что значение выражения не выводится и не
заносится в историю значений (@pxref{История значений, ,История
значений}).  Выражение вычисляется только ради его действия.

Если начало строки параметров команды @code{set} выглядит идентично
подкоманде @code{set}, используйте вместо нее команду @code{set
variable}.  Эта команда аналогична @code{set}, но не имеет подкоманд.
Например, если в вашей программе есть переменная @code{width}, то вы получите
ошибку, если попытаетесь установить новое значение просто с помощью
@samp{set width=13}, потому что @value{GDBN} имеет команду
@code{set width}:

@example
(@value{GDBP}) whatis width
type = double
(@value{GDBP}) p width
$4 = 13
(@value{GDBP}) set width=47
Invalid syntax in expression.
@end example

@noindent
Недопустимое выражение, это, конечно, @samp{=47}.  Для того, чтобы
действительно установить переменную программы @code{width}, используйте

@example
(@value{GDBP}) set var width=47
@end example

Так как команда @code{set} имеет много подкоманд, которые могут
конфликтовать с именами переменных в программе, то хорошей практикой
является использование команды @code{set variable} вместо просто
@code{set}.  Например, если ваша программа имеет переменную @code{g}, у
вас возникнут проблемы, если вы попытаетесь установить новое значение
с помощью @samp{set g=4}, потому что @value{GDBN} имеет команду
@code{set gnutarget}, которая сокращается как @code{set g}:

@example
@group
(@value{GDBP}) whatis g
type = double
(@value{GDBP}) p g
$1 = 1
(@value{GDBP}) set g=4
(@value{GDBP}) p g
$2 = 1
(@value{GDBP}) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/smith/cc_progs/a.out
"/home/smith/cc_progs/a.out": can't open to read symbols:
                                 Invalid bfd target.
(@value{GDBP}) show g
The current BFD target is "=4".
@end group
@end example

@noindent
Переменная программы @code{g} не изменилась, и вы незаметно установили
@code{gnutarget} в неверное значение.  Для установки значения переменной
@code{g}, используйте

@example
(@value{GDBP}) set var g=4
@end example

@value{GDBN} допускает больше неявных преобразований в присваиваниях,
чем Си; вы можете свободно сохранить целое значение в
переменной-указателе и наоборот, преобразовать любую структуру к любой
другой, которая имеет ту же длину или короче.

Для сохранения значений в произвольных местах
памяти, используйте конструкцию @samp{@{@dots{}@}} для создания
значения определенного типа по определенному адресу памяти
(@pxref{Выражения, ,Выражения}).  Например, @code{@{int@}0x83040}
ссылается на ячейку памяти @code{0x83040} как на целое (что
предполагает соответствующий размер и представление в памяти), и

@example
set @{int@}0x83040 = 4
@end example

@noindent
записывает в эту ячейку памяти значение 4.

@node Переходы
@section Продолжение исполнения с другого адреса

Обычно, когда вы продолжаете выполнение программы, вы делаете это
с того места, где она остановилась, командой @code{continue}.  Вместо
этого, вы можете продолжить выполнение с любого выбранного адреса
при помощи следующих команд:

@table @code
@kindex jump
@item jump @var{указ-стр}
Возобновить выполнение со строки @var{указ-стр}.  Если там есть точка
останова, выполнение немедленно прекращается.  @xref{Вывод строк, ,Вывод строк
исходного текста}, для описания различных форм @var{указ-стр}.
Использование команды @code{tbreak} вместе с @code{jump} является
обычной практикой.  @xref{Установка точек останова, ,Установка точек
останова}.

Команда @code{jump} не изменяет ни текущий кадр стека, ни
указатель стека, ни содержимое каких-либо ячеек памяти или регистров, кроме
счетчика программы.  Если строка @var{указ-стр} находится вне
выполняющейся в настоящее время функции,
результаты могут быть странными, если эти
функции используют аргументы или локальные переменные разных типов.  По
этой причине, команда @code{jump} запрашивает подтверждение, если
указанная строка не находится в функции, выполняющейся в настоящее
время.  Однако, даже странные результаты предсказуемы, если вы хорошо
знакомы с машинным кодом вашей программы.

@item jump *@var{адрес}
Возобновить выполнение с инструкции, находящейся по адресу @var{адрес}.
@end table

На многих системах вы можете достичь такого же результата, как и с командой
@code{jump}, сохранив новое значение в регистр @code{$pc}.  Отличие
заключается в том, что это не начинает выполнение вашей программы, а лишь
изменяет адрес, с которого @emph{будет} выполняться программа,
когда вы продолжите выполнение.  Например,

@example
set $pc = 0x485
@end example

@noindent
выполняет следующую команду @code{continue} или команду пошагового
выполнения с адреса @code{0x485}, а не с того адреса, где ваша программа
остановилась.  @xref{Продолжение и пошаговое выполнение, ,Продолжение и
выполнение по шагам}.

Наиболее общий случай использования команды @code{jump} состоит в
возврате к выполнению уже пройденной части программы, возможно с большим
количеством установленных точек останова, чтобы исследовать выполнение
более детально.

@node Подача сигналов
@section Подача сигнала вашей программе

@table @code
@kindex signal
@item signal @var{сигнал}
Возобновить выполнение с места остановки вашей программы, но немедленно
подать ей сигнал @var{сигнал}.  @var{Сигнал} может быть именем или номером
сигнала.  Например, во многих системах @code{signal 2} и @code{signal
SIGINT} --- два способа подать сигнал прерывания.

Наоборот, если @var{сигнал} является нулем, выполнение продолжается без
подачи сигнала.  Это полезно, если ваша программа остановилась из-за
сигнала и в обычном случае увидит его при возобновлении выполнения командой
@code{continue}; @samp{signal 0} продолжит выполнение без сигнала.

@code{signal} не повторяется, когда вы нажимаете @key{RET} второй раз
после выполнения команды.
@end table

Вызов команды @code{signal} отличается от вызова утилиты @code{kill} из
оболочки.  Подача сигнала посредством @code{kill} заставляет
@value{GDBN} решать, что делать с сигналом, в зависимости от таблиц
обработки сигналов (@pxref{Сигналы}).  Команда @code{signal} передает
сигнал непосредственно вашей программе.


@node Возврат
@section Возврат из функции

@table @code
@cindex возврат из функции
@kindex return
@item return
@itemx return @var{выражение}
Вы можете отменить выполнение вызова функции с помощью команды @code{return}.
Если вы задаете параметр @var{выражение}, его значение используется
в качестве возвращаемого значения.
@end table

Когда вы используете @code{return}, @value{GDBN} уничтожает выбранный
кадр стека (и все кадры внутри него).  Вы можете считать это
преждевременным возвратом из уничтоженного кадра.  Если вы хотите
указать возвращаемое значение, задайте его в качестве аргумента к
@code{return}.

Это выталкивает выбранный кадр стека (@pxref{Выбор, ,Выбор кадра стека})
и все другие кадры внутри него, оставляя самым внутренним кадр, из
которого произошел вызов.  Этот кадр становится выбранным.  Указанное
значение сохраняется в регистрах, используемых для возвращаемых функцией
значений.

Команда @code{return} не возобновляет выполнение; она оставляет
программу остановленной в том состоянии, в котором бы она была сразу
после возврата из функции.  Напротив, команда @code{finish}
(@pxref{Продолжение и пошаговое выполнение, ,Продолжение и
выполнение по шагам}) возобновляет выполнение до естественного возврата из
выбранного кадра стека.

@node Вызовы
@section Вызов функций программы

@cindex вызов функций
@kindex call
@table @code
@item call @var{выраж}
Вычислить выражение @var{выраж} без отображения пустых (@code{void})
возвращенных значений.
@end table

Вы можете использовать этот вариант команды @code{print}, если хотите
выполнить функцию из вашей программы, не засоряя вывод пустыми возвращенными
значениями.  Если результат не пустой, он выводится и
сохраняется в истории значений.

Для A29K, устанавливаемая пользователем переменная
@code{call_scratch_address} задает положение рабочей области, которая
будет использоваться, когда @value{GDBN} вызывает функцию на целевой машине.
Это необходимо, так как обычный метод размещения рабочей области в стеке
не работает в системах с раздельными областями команд и данных.

@node Внесение изменений
@section Внесение изменений в программу

@cindex внесение изменений в двоичные файлы
@cindex запись в выполняемые файлы
@cindex запись в файлы дампа

По умолчанию, @value{GDBN} открывает файл, содержащий исполняемый код вашей
программы (или файл дампа памяти), в режиме только для чтения.  Это
предотвращает случайные изменения машинного кода; но это также предотвращает
и преднамеренное исправление двоичного файла вашей программы.

Если вы хотите иметь возможность исправлять двоичный код, вы можете
указать это явно с помощью команды @code{set write}.  Например, вы
можете захотеть установить внутренние флаги отладки или даже сделать
аварийные исправления.

@table @code
@kindex set write
@item set write on
@itemx set write off
Если вы установите @samp{set write on}, @value{GDBN} открывает исполняемые
файлы и файлы дампов памяти в режиме для чтения и записи; если вы
укажете @samp{set write off} (устанавливается по умолчанию), @value{GDBN}
открывает их в режиме только для чтения.

Если вы уже загрузили файл, то после установки @code{set write} вам
необходимо загрузить его снова (используя команды @code{exec-file} или
@code{core-file}), чтобы новые установки вступили в силу.

@item show write
@kindex show write
Показать, открыты исполняемые файлы и файлы дампов памяти для
записи или нет.
@end table

@node Файлы GDB
@chapter Файлы @value{GDBN}

@value{GDBN} должен знать имя файла программы, которая будет
отлаживаться, чтобы прочитать его таблицу символов и чтобы запустить его.
Для отладки дампа памяти от предыдущего выполнения, вы также
должны сообщить @value{GDBN} имя этого файла.

@menu
* Файлы::                       Команды для задания файлов
* Ошибки с символами::          Ошибки чтения файлов с символами
@end menu

@node Файлы
@section Команды для задания файлов

@cindex таблица символов
@cindex файл дампа памяти

Вы можете указать имена исполняемого файла и файла дампа памяти.
Обычно это делается во время вызова @value{GDBN}, используя
параметры с командами запуска @value{GDBN} (@pxref{Вызов, ,Вход и выход из
@value{GDBN}}).

Иногда во время сеанса @value{GDBN} необходимо перейти к другому файлу.
Или вы можете запустить @value{GDBN}, забыв указать файл, который
хотите использовать.  В таких ситуациях полезны команды @value{GDBN} для
задания новых файлов.

@table @code
@cindex выполняемый файл
@kindex file
@item file @var{имя-файла}
Использовать @var{имя-файла} в качестве программы для отладки.  Из нее
читаются символы и содержание неизменяемой памяти.
Также она является программой, которая выполняется при
использовании команды @code{run}.  Если вы не укажете каталог, и файл
не будет найден в рабочем каталоге @value{GDBN}, он использует переменную
среды @code{PATH} в качестве списка каталогов для поиска, точно так
же, как это делает оболочка, когда ищет программу для выполнения.
Используя команду @code{path}, вы можете изменить значение этой
переменной как для @value{GDBN}, так и для вашей программы.

В системах с отображаемыми в память файлами, информация из таблицы
символов для @var{имя-файла} может храниться во вспомогательном файле
@file{@var{имя-файла}.syms}.  Если это так, @value{GDBN} осуществляет
отображение таблицы символов из @file{@var{имя-файла}.syms}, запускаясь
намного быстрее.  Смотрите описания ключей файлов @samp{-mapped} и
@samp{-readnow} (доступных с командной строки и в командах
@code{file}, @code{symbol-file} или @code{add-symbol-file}, описанных
ниже), для получения большей информации.

@item file
@code{file} без параметров велит @value{GDBN} уничтожить любую имеющуюся
информацию как об исполняемом файле, так и о таблице символов.

@kindex exec-file
@item exec-file @r{[} @var{имя-файла} @r{]}
Указывает, что программа, которая должна быть выполнена (но не
таблица символов), находится в @var{имя-файла}.  Если необходимо,
@value{GDBN} ищет вашу программу с помощью переменной среды
@code{PATH}.  Отсутствие @var{имя-файла} означает, что необходимо
уничтожить информацию о выполняемом файле.

@kindex symbol-file
@item symbol-file @r{[} @var{имя-файла} @r{]}
Читать информацию таблицы символов из файла @var{имя-файла}.  При
необходимости производится поиск с помощью переменной среды
@code{PATH}.  Для получения таблицы символов и исполняемой программы из
одного и того же файла, используйте команду @code{file}.

@code{symbol-file} без параметров сбрасывает информацию @value{GDBN} о
таблице символов вашей программы.

Команда @code{symbol-file} велит @value{GDBN} забыть содержимое своих
вспомогательных переменных, историю значений и все точки останова и выражения
автоматического отображения, так как они могут содержать указатели
на внутренние данные, хранящие символы и типы данных, которые
являются частью данных старой таблицы символов, уничтоженной внутри
@value{GDBN}.

@code{symbol-file} не повторяется, если вы снова нажимаете @key{RET}
после первого выполнения.

Когда @value{GDBN} сконфигурирован для определенной среды, он распознает
отладочную информацию в том формате, который обычно генерируется
для этой среды; вы можете использовать или компилятор @sc{gnu}, или другие
компиляторы, которые придерживаются местных соглашений.  Наилучшие
результаты обычно достигаются с помощью компилятора @sc{gnu};
например, используя @code{@value{GCC}}, вы можете создавать отладочную
информацию для оптимизированного кода.

Для большинства типов объектных файлов, за исключением старых систем
SVR3, использующих COFF, команда @code{symbol-file} обычно не считывает
таблицу символов сразу целиком.  Вместо этого, она быстро сканирует
ее для определения, какие исходные файлы и символы в ней
присутствуют.  Детали читаются позже, по одному исходному файлу за раз,
по мере необходимости.

Такая стратегия чтения в две стадии используется для того, чтобы
@value{GDBN} вызывался быстрее.  За исключением редких пауз, чтение
деталей таблицы символов для конкретного исходного файла в большинстве
случаев практически незаметно.  (Команда @code{set verbose}
позволяет при желании превратить эти паузы в сообщения.
@xref{Сообщения/предупреждения, ,Необязательные предупреждения и сообщения}.)

Мы еще не реализовали двухступенчатую стратегию чтения для COFF.  Когда
таблица символов сохранена в формате COFF, @code{symbol-file} считывает данные
таблицы символов сразу полностью.  Заметьте, что ``stabs-in-COFF'' все
же реализует двухступенчатую стратегию, так как отладочная информация
реально хранится в формате stabs.

@kindex readnow
@cindex немедленное чтение символов
@cindex символы, немедленное чтение
@kindex mapped
@cindex файлы символов, отображаемые в память
@cindex сохранение таблицы символов
@item symbol-file @var{имя-файла} @r{[} -readnow @r{]} @r{[} -mapped @r{]}
@itemx file @var{имя-файла} @r{[} -readnow @r{]} @r{[} -mapped @r{]}
Если вы хотите быть уверены, что у @value{GDBN} есть вся таблица
символов целиком, вы можете отменить двухступенчатую стратегию чтения
таблицы символов, используя параметр @samp{-readnow} с любой
командой, загружающей информацию таблицы символов.

Если на вашей системе можно отображать файлы в память через
системный вызов @code{mmap}, вы можете использовать другой параметр,
@samp{-mapped}, чтобы @value{GDBN} записывал символы для вашей программы
в файл многократного использования.  Последующие сеансы отладки
@value{GDBN} отображают информацию о символах из этого вспомогательного
файла (если программа не изменилась), вместо того, чтобы
тратить время на чтение таблицы символов из исполняемой программы.
Использование параметра @samp{-mapped} производит такой же эффект, как
вызов @value{GDBN} с ключом командной строки @samp{-mapped}.

Вы можете использовать оба параметра вместе, чтобы быть уверенным,
что вспомогательный файл символов содержит всю информацию о символах
вашей программы.

Вспомогательный файл символов для программы @var{прог} называется
@samp{@var{прог}.syms}.  Если этот файл существует (и создан позже,
чем соответствующая исполняемая программа), @value{GDBN} всегда пытается
использовать его при отладке @var{прог}; не требуется никаких
специальных ключей или команд.

Файл @file{.syms} является специфичным для рабочей машины, на которой вы
вызываете @value{GDBN}.  Он содержит точный образ внутренней таблицы
символов @value{GDBN}.  Он не может быть использован одновременно на
разных рабочих платформах.

@kindex core
@kindex core-file
@item core-file @r{[} @var{имя-файла} @r{]}
Определяет местонахождение файла дампа памяти, который будет использован
как ``содержимое памяти''.  Обычно файлы дампов памяти содержат только
некоторые части адресного пространства процесса, создавшего их;
@value{GDBN} может обращаться к исполняемому файлу за другими частями.

@code{core-file} без параметра указывает, что файл дампа памяти
использоваться не должен.

Обратите внимание, что файл дампа памяти игнорируется, если в данное
время ваша программа выполняется под управлением @value{GDBN}.  Так что
если вы выполняли программу и желаете вместо этого отладить файл
дампа, вы должны убить подпроцесс, в котором выполняется ваша программа.
Для этого используйте команду @code{kill} (@pxref{Уничтожение процесса, ,Уничтожение дочернего процесса}).

@kindex add-symbol-file
@cindex динамическая сборка
@item add-symbol-file @var{имя-файла} @var{адрес}
@itemx add-symbol-file @var{имя-файла} @var{адрес} @r{[} -readnow @r{]} @r{[} -mapped @r{]}
@itemx add-symbol-file @var{имя-файла} @r{-s}@var{раздел} @var{адрес}
Команда @code{add-symbol-file} считывает дополнительную информацию
таблицы символов из файла @var{имя-файла}.  Вы должны использовать эту
команду, если файл @var{имя-файла} был динамически загружен (другими
средствами) в выполняющуюся программу.  @var{Адрес} должен быть адресом
памяти, по которому был загружен файл; @value{GDBN} сам его определить
не может.  Вы можете указать дополнительно произвольное количество пар
@samp{@r{-s} @var{раздел} @var{адрес}}, чтобы явно указать имя раздела и
базовый адрес для него.  Вы можете указать произвольный @var{адрес} как
выражение.

Таблица символов из файла @var{имя-файла} добавляется к таблице,
изначально считанной по команде @code{symbol-file}.  Вы можете
использовать команду @code{add-symbol-file} произвольное число раз;
прочитанные таким образом символьные данные добавляются к старым.  Чтобы
уничтожить все старые данные, используйте команду @code{symbol-file} без
аргументов.

Команда @code{add-symbol-file} не повторяется, если вы нажимаете
@key{RET} после ее использования.

Чтобы изменить способ обработки @value{GDBN} таблицы символов для
@var{имя-файла}, вы можете использовать параметры @samp{-mapped} и
@samp{-readnow} так же, как и с командой @code{symbol-file}.

@kindex add-shared-symbol-file
@item add-shared-symbol-file
Команда @code{add-shared-symbol-file} может быть использована только для
Motorola 88k в операционной системе Harris CXUX.  @value{GDBN}
ищет разделяемые библиотеки автоматически, однако, если он не находит
ваших, вы можете выполнить @code{add-shared-symbol-file}.  Эта команда
не имеет аргументов.

@kindex section
@item section
Команда @code{section} изменяет базовый адрес раздела @var{раздел}
выполняемого файла на @var{адрес}.  Это может быть использовано, если
выполняемый файл не содержит адресов разделов (что имеет место для
формата a.out), или когда адреса, указанные в самом файле, неверны.
Каждый раздел должен изменяться отдельно.  Команда @code{info files},
описанная ниже, перечисляет все разделы и их адреса.

@kindex info files
@kindex info target
@item info files
@itemx info target
Команды @code{info files} и @code{info target} являются синонимами; они обе
выводят текущую цель (@pxref{Отладочные цели, ,Определение отладочной
цели}), включая имена выполняемого файла и файла дампа памяти, используемых
@value{GDBN}, и файлов, из которых были загружены символы.  Команда
@code{help target} выводит все возможные цели, а не только текущую.

@end table

Все команды для задания файлов допускают в качестве аргументов как
абсолютные, так и относительные имена файлов.  @value{GDBN} всегда
преобразовывает имя файла к абсолютному и запоминает его в таком виде.

@cindex разделяемые библиотеки
@value{GDBN} поддерживает разделяемые библиотеки на HP-UX, SunOS, SVr4,
Irix 5 и IBM RS/6000.

Когда вы даете команду @code{run}, или когда исследуете
файл дампа памяти, @value{GDBN} автоматически загружает определения
символов из разделяемых библиотек.  (Однако, если вы не отлаживаете файл дампа,
@value{GDBN} не понимает ссылки на функции из разделяемой библиотеки до
того, как вы выполните команду @code{run}.)

На HP-UX, если программа загружает разделяемую библиотеку явно,
@value{GDBN} автоматически загружает символы в момент вызова
@code{shl_load}.

@table @code
@kindex info sharedlibrary
@kindex info share
@item info share
@itemx info sharedlibrary
Вывести имена разделяемых библиотек, загруженных в данный момент.

@kindex sharedlibrary
@kindex share
@item sharedlibrary @var{рег-выр}
@itemx share @var{рег-выр}
Загрузить символы разделяемых библиотек для файлов,
удовлетворяющих регулярному выражению Unix.  Также как и для
автоматически загруженных файлов, это загружает только разделяемые
библиотеки, требуемые вашей программой для файла дампа памяти или после
ввода @code{run}.  Если @var{рег-выр} опущено, загружаются все разделяемые
библиотеки, требуемые вашей программой.
@end table

В системах HP-UX, @value{GDBN} сам определяет загрузку разделяемой
библиотеки и автоматически считывает символы из нее до некоторого
изначально установленного порогового значения, которое вы можете при
желании изменить.

После этого порогового значения символы из разделяемых библиотек должны
загружаться явно.  Для загрузки этих символов используйте команду
@code{sharedlibrary @var{имя-файла}}.  Базовый адрес разделяемой
библиотеки определяется @value{GDBN} автоматически и вы не
должны его задавать.

Для отображения или установки порогового значения используйте следующие
команды:

@table @code
@kindex set auto-solib-add
@item set auto-solib-add @var{порог}
Устанавливает размер порога автоматической загрузки в мегабайтах.  Если
@var{порог} ненулевой, символы из всех библиотек разделяемых объектов
будут загружаться автоматически, когда программа начинает выполнение, или
когда динамический компоновщик информирует @value{GDBN} о том, что
была загружена новая библиотека, до тех пор, пока таблица символов программы и
библиотек не превысит этот порог.  В противном случае, символы должны
загружаться вручную, при помощи команды @code{sharedlibrary}.  По
умолчанию порог равен 100 мегабайтам.

@kindex show auto-solib-add
@item show auto-solib-add
Отобразить величину текущего порога автоматической загрузки в мегабайтах.
@end table

@node Ошибки с символами
@section Ошибки чтения файлов с символами

При чтении файла символов, @value{GDBN} иногда сталкивается с такими
проблемами, как типы символов, которые он не распознает, или известные
ошибки вывода компилятора.  По умолчанию, @value{GDBN} не сообщает вам о таких
проблемах, так как они сравнительно общие и прежде всего представляют
интерес для людей, занимающихся отладкой компиляторов.  Если вам интересна
информация о плохо составленных таблицах символов, вы можете запросить
@value{GDBN} печатать только одно сообщение по каждому типу проблем,
независимо от того, сколько раз проблема появляется; или вы можете
попросить @value{GDBN} напечатать больше сообщений, чтобы увидеть, сколько раз
проблема встречалась, командой @code{set complaints}
(@pxref{Сообщения/предупреждения, ,Необязательные предупреждения и
сообщения}).

Печатаемые сообщения и их значения, включают:

@table @code
@item inner block not inside outer block in @var{символ}

Информация о символах показывает, где области символов начинаются и
заканчиваются (например, в начале функции или блока операторов).  Эта
ошибка указывает на то, что внутренний блок видимости не содержится
целиком во внешнем.

@value{GDBN} обходит эту проблему, рассматривая внутренний блок так, как если
бы он имел такую же область видимости, что и внешний.  Если внешний блок
не является функцией, то  @var{символ} в данном сообщении может быть
показан как ``@code{(don't known)}''.

@item block at @var{адрес} out of order

Символьная информация для блоков символьных областей должна
появляться в порядке увеличения адресов.  Данная ошибка указывает, что это
не так.

@value{GDBN} не решает этой проблемы, и у него возникают трудности при
определении местоположения символов в исходном файле, символы которого
он считывает.  (Вы часто можете определить имя поврежденного исходного
файла, указав @code{set verbose on}.  @xref{Сообщения/предупреждения,
,Необязательные предупреждения и сообщения}.)

@item bad block start address patched

Символьная информация для блоков символьных областей имеет меньший
начальный адрес, чем у предшествующей строки исходного текста.
Известно, что это происходит в компиляторе Си SunOS 4.1.1 (и более
ранних версиях).

@value{GDBN} обходит проблему, обрабатывая блок символьной области как
начинающийся с предыдущей исходной строки.

@item bad string table offset in symbol @var{n}

@cindex foo
Символ с номером @var{n} содержит указатель на таблицу строк, который
превосходит размер таблицы.

@value{GDBN} обходит проблему, считая, что символ имеет имя @code{foo},
что может вызвать другие проблемы, если много символов
заканчиваются этим именем.

@item unknown symbol type @code{0x@var{nn}}

Символьная информация содержит новые типы данных, которые @value{GDBN} еще
не знает, как считывать.  @code{0x@var{nn}} --- это тип символа неверно
истолкованной информации, в шестнадцатеричном виде.

@value{GDBN} обходит ошибку, игнорируя эту символьную информацию.  Это
обычно позволяет вам отлаживать программу, хотя некоторые
символы и недоступны.  Если вы столкнетесь с такой проблемой и
захотите ее отладить, вы можете отладить @code{@value{GDBP}} с помощью
него же, установив точку останова на @code{complain}, затем дойти до
функции @code{read_dbx_symtab} и исследовать @code{*bufp}, чтобы
увидеть символ.

@item stub type has NULL name

@value{GDBN} не может найти полное определение для структуры или класса.

@item const/volatile indicator missing (ok if using g++ v1.x), got@dots{}
В символьной информации для функции-члена Си++ пропущена
некоторая информация, которую последние версии компилятора должны
для нее выводить.

@item info mismatch between compiler and debugger

@value{GDBN} не может разобрать спецификации типа, выведенной компилятором.

@end table

@node Отладочные цели
@chapter Определение отладочной цели

@cindex отладочная цель
@kindex target

@dfn{Цель} --- это среда выполнения, занятая вашей программой.

Часто @value{GDBN} выполняется в той же рабочей среде, что и ваша
программа; в этом случае отладочная цель задается неявно в момент
использования команд @code{file} или @code{core}.  Когда вам нужна
большая гибкость --- например, выполнение @value{GDBN} на другой машине, или
управление автономной системой через последовательный порт или системой
реального времени через соединение TCP/IP --- вы можете использовать
команду @code{target} для определения цели одного из типов,
сконфигурированных для @value{GDBN} (@pxref{Команды для целей, ,Команды
для управления целями}).

@menu
* Активные цели::               Активные цели
* Команды для целей::           Команды для управления целями
* Порядок байтов::              Выбор целевого порядка байтов
* Удаленная отладка::           Удаленная отладка
* Отображение объектов ядра::    Отображение объектов ядра

@end menu

@node Активные цели
@section Активные цели

@cindex наложение целей
@cindex активные цели
@cindex множественные цели

Существует три класса целей: процессы, файлы дампов памяти и
выполняемые файлы.  @value{GDBN} может обрабатывать одновременно до трех
активных целей, по одной в каждом классе.  Это позволяет вам (например)
запустить процесс и проверять его действия, не прерывая вашу работу над
файлом дампа.

Например, если вы выполняете @samp{gdb a.out}, то исполняемый файл
@code{a.out} является единственной активной целью.  Если вы назначите также
файл дампа --- возможно, от предыдущего выполнения, завершившегося ошибкой
и создавшего дамп, ---
тогда @value{GDBN} имеет две активные цели и использует их вместе,
просматривая сначала файл дампа, а затем исполняемый файл, для выполнения
запросов к адресам памяти.  (Обычно эти два класса целей дополняют друг
друга, так как файлы дампа памяти содержат только память программы,
доступную для чтения и записи
(переменные и тому подобное), и машинное состояние, в то время как исполняемые
файлы содержат только текст программы и инициализированные данные.)

Когда вы вводите @code{run}, ваш исполняемый файл становится также активным
целевым процессом.  Когда целевой процесс активен, все команды @value{GDBN},
запрашивающие адреса памяти, относятся к этой цели; адреса в активной
цели файла дампа или выполняемого файла неизвестны, пока активен
целевой процесс.

Используйте команды @code{core-file} и @code{exec-file} для выбора новой
цели файла дампа памяти или выполняемого файла (@pxref{Файлы, ,Команды
для задания файлов}).  Для определения в качестве цели
процесса, который уже выполняется, используйте команду @code{attach}
(@pxref{Присоединение, ,Отладка запущенного ранее процесса}).

@node Команды для целей
@section Команды для управления целями

@table @code
@item target @var{тип} @var{параметры}
Соединяет рабочую среду @value{GDBN} с целевой машиной или процессом.
Целью обычно является протокол для взаимодействия со средствами отладки.
Параметр @var{тип} используется, чтобы определить тип или протокол
целевой машины.

Дальнейшие @var{параметры} интерпретируются целевым
протоколом, но обычно включают такие вещи, как имена
устройств или имена рабочих машин, с которыми осуществляется
связь, номера процессов и скорости в бодах.

Команда @code{target} не повторяется при повторном нажатии @key{RET} после
ее выполнения.

@kindex help target
@item help target
Отображает имена всех доступных целей.  Чтобы отобразить выбранные в
данный момент цели, используйте либо @code{info target}, либо @code{info
files} (@pxref{Файлы, ,Команды для задания файлов}).

@item help target @var{имя}
Описывает определенную цель, включая любые параметры, необходимые для ее
выбора.

@kindex set gnutarget
@item set gnutarget @var{арг}
@value{GDBN} использует свою собственную библиотеку BFD@footnote{от
`Binary File Descriptor' (библиотека описания двоичных файлов).
@i{(Прим.@: переводчика)}} для чтения ваших
файлов.  @value{GDBN} знает, читает ли он @dfn{выполняемый файл},
@dfn{файл дампа памяти} или @dfn{объектный (.o)} файл; однако вы можете
определить формат файла командой @code{set gnutarget}.  В отличие от
большинства команд @code{target}, в команде @code{gnutarget} слово @code{target}
относится к программе, а не к машине.

@quotation
@emph{Предупреждение:} Для определения формата файла посредством @code{set
gnutarget}, вы должны знать фактическое имя BFD.
@end quotation

@noindent
@xref{Файлы, , Команды для задания файлов}.

@kindex show gnutarget
@item show gnutarget
Используйте команду @code{show gnutarget} для отображения, какого
формата файлы @code{gnutarget} установлен считывать.  Если вы не
установили @code{gnutarget}, @value{GDBN} определит формат для каждого файла
автоматически, и @code{show gnutarget} выведет @samp{The current BFD target
is "auto"}.
@end table

Ниже приведены некоторые наиболее распространенные цели (доступные или нет, в
зависимоси от конфигурации @value{GDBN}):

@table @code
@kindex target exec
@item target exec @var{программа}
Выполняемый файл.  @samp{target exec @var{программа}} --- это то же
самое, что и @samp{exec-file @var{программа}}.

@kindex target core
@item target core @var{имя-файла}
Файл дампа памяти.  @samp{target core @var{имя-файла}} --- это то же
самое, что и @samp{core-file @var{имя-файла}}.

@kindex target remote
@item target remote @var{устр}
Удаленная последовательная цель является уникальным для @value{GDBN}
протоколом.  Параметр @var{устр} определяет, какое последовательное
устройство использовать для соединения (например, @file{/dev/ttya}).
@xref{Удаленная отладка, ,Удаленная отладка}.  @code{target remote}
поддерживает команду @code{load}.  Это полезно, только если вы можете
получить заглушку для целевой системы каким-нибудь другим
способом и можете разместить ее в памяти, где она не будет
затерта загрузкой.

@kindex target sim
@item target sim
Встроенный эмулятор ЦП.  @value{GDBN} включает эмуляторы для большинства
архитектур.  Вообще,
@example
        target sim
        load
        run
@end example
@noindent
работает; однако, вы не можете предполагать, что доступны какое-то
отображение памяти, драйверы устройств или даже элементарные функции
ввода-вывода, хотя некоторые эмуляторы действительно предоставляют это.  Для
информации о деталях эмуляторов для конкретного процессора, смотрите
соответствующий @ref{Встроенные процессоры, ,Встроенные
процессоры}.

@end table

Некоторые конфигурации могут также включать такие цели:

@table @code

@kindex target nrom
@item target nrom @var{устр}
Эмулятор NetROM ROM.  Эта цель поддерживает только загрузку.

@end table

Для различных конфигураций @value{GDBN} доступны различные цели; ваша
конфигурация может иметь больше или меньше целей.

Многие удаленные цели требуют, чтобы вы загрузили код выполняемого
файла после того как успешно установили соединение.

@table @code

@kindex load @var{имя-файла}
@item load @var{имя-файла}
В зависимости от того, какие возможности удаленной отладки
сконфигурированы в @value{GDBN}, может быть доступна команда
@code{load}.  Если она существует, ее задачей является сделать
@var{имя-файла} (выполняемый файл) доступным для отладки на удаленной
системе --- например, путем загрузки или динамической сборки.
@code{load} также записывает таблицу символов @var{имя-файла} в
@value{GDBN}, как команда @code{add-symbol-file}.

Если ваш @value{GDBN} не имеет команды @code{load}, попытка выполнить ее
выдает сообщение об ошибке ``@code{You can't do that when your
target is @dots{}}''.

Файл загружается по адресу, указанному в выполняемом файле.  Для
некоторых форматов объектных файлов вы можете задать адрес загрузки при
сборке программы; для других форматов, таких как a.out, формат
объектного файла задает фиксированный адрес.

@code{load} не повторяется, если вы нажимаете @key{RET} снова после ее
использования.
@end table

@node Порядок байтов
@section Выбор целевого порядка байтов

@cindex выбор целевого порядка байтов
@cindex целевой порядок байтов

@c ????????? big-endian и little-endian
Некоторые типы процессоров, такие как MIPS, PowerPC и Hitachi SH,
предоставляют возможность выполнения либо с порядком байтов от старшего,
либо с порядком байтов от младшего.  Обычно выполняемый файл или
таблица символов содержат информацию для определения используемого порядка
байтов, и вам не нужно об этом заботиться.  Однако, иногда вам все же
может пригодиться вручную изменить порядок байтов процессора,
определенный @value{GDBN}.

@table @code
@kindex set endian big
@item set endian big
Велит @value{GDBN} считать, что целевой порядок байтов от старшего.

@kindex set endian little
@item set endian little
Велит @value{GDBN} считать, что целевой порядок байтов от младшего.

@kindex set endian auto
@item set endian auto
Велит @value{GDBN} использовать порядок байтов, указанный в выполняемом
файле.

@item show endian
Отображает текущую установку @value{GDBN} для целевого порядка байтов.

@end table

Заметьте, что эти команды управляют только интерпретацией символьных
данных в рабочей системе, и они совершенно не оказывают действия на
целевую систему.

@node Удаленная отладка
@section Удаленная отладка
@cindex удаленная отладка

Если вы пытаетесь отлаживать программу, выполняющуюся на машине,
которая не может запустить @value{GDBN} обычным способом, часто бывает полезна
удаленная отладка.  Например, вы можете использовать удаленную
отладку для ядра операционной системы или для малой системы, которая не
имеет достаточно мощной операционной системы общего назначения для
вызова отладчика со всеми возможностями.

Некоторые конфигурации @value{GDBN} имеют специальный последовательный или
TCP/IP-интерфейсы для того, чтобы это работало с конкретными отладочными
целями.  Кроме того, @value{GDBN} распространяется с общим
последовательным протоколом (уникальным для @value{GDBN}, но не для
конкретной целевой системы), который вы можете использовать, если пишете
удаленные заглушки --- код, выполняемый в удаленной системе для связи с
@value{GDBN}.

В вашей конфигурации @value{GDBN} могут быть доступны другие удаленные
цели; используете @code{help target}, чтобы получить их список.

@menu
* Удаленный::                   Удаленный последовательный протокол @value{GDBN}
@end menu

@node Удаленный
@subsection Удаленный последовательный протокол @value{GDBN}

@cindex удаленная последовательная отладка, обзор
Для отладки программы, выполняемой на другой машине (отладочной
@dfn{целевой} машине), вы сперва должны создать все обычные
предпосылки для самостоятельного выполнения программы.  Например, для
программы на Си вам нужны:

@enumerate
@item
Процедура запуска для установки среды выполнения Си; она обычно
имеет имя типа @file{crt0}.  Процедура запуска может быть
обеспечена аппаратными средствами, или вы должны
написать свою собственную.

@item
Библиотека подпрограмм Си для поддержки вызовов подпрограмм вашей
программы, особенно для управления вводом и выводом.

@item
Способ установки вашей программы на другую машину --- например,
программа загрузки.  Такие программы часто предоставляются поставщиками
аппаратных средств, но вам может потребоваться написать вашу
собственную, пользуясь документацией к аппаратному обеспечению.
@end enumerate

Следующим шагом будет принятие мер по использованию вашей
программой последовательного порта для связи с машиной, где
выполняется @value{GDBN} (@dfn{рабочей} машиной).  В общих чертах, схема
выглядит следующим образом:

@table @emph
@item На рабочей машине
@value{GDBN} уже понимает, как использовать этот протокол; после установки
всего остального, вы можете просто использовать
команду @samp{target remote} (@pxref{Отладочные цели,,Определение отладочной
цели}).

@item На целевой машине
вы должны скомпоновать вместе с вашей программой несколько подпрограмм
специального назначения, которые реализуют удаленный последовательный
протокол @value{GDBN}.  Файл, содержащий эти подпрограммы, называется
@dfn{отладочной заглушкой}.

На некоторых удаленных целях, вы можете использовать вспомогательную
программу @code{gdbserver} вместо компоновки заглушки вместе с вашей
программой.  @xref{Сервер,,Использование программы @code{gdbserver}},
для детального изучения.
@end table

Отладочная заглушка специфична для архитектуры удаленной машины;
например, используйте @file{sparc-stub.c} для отладки программ на
машинах @sc{sparc}.

@cindex список удаленных последовательных заглушек
Следующие работающие удаленные заглушки распространяются вместе с @value{GDBN}:

@table @code

@item i386-stub.c
@cindex @file{i386-stub.c}
@cindex Intel
@cindex i386
Для Intel 386 и совместимых архитектур.

@item m68k-stub.c
@cindex @file{m68k-stub.c}
@cindex Motorola 680x0
@cindex m680x0
Для архитектур Motorola 680x0.

@item sh-stub.c
@cindex @file{sh-stub.c}
@cindex Hitachi
@cindex SH
Для архитектур Hitachi SH.

@item sparc-stub.c
@cindex @file{sparc-stub.c}
@cindex Sparc
Для архитектур @sc{sparc}.

@item sparcl-stub.c
@cindex @file{sparcl-stub.c}
@cindex Fujitsu
@cindex SparcLite
Для архитектур Fujitsu @sc{spacrlite}.

@end table

Файл @file{README} в поставке @value{GDBN} может содержать другие
недавно добавленные заглушки.

@menu
* Содержимое заглушки::   Что заглушка может сделать для вас
* Начальная загрузка::    Что вы должны сделать для заглушки
* Сеанс отладки::         Собираем все вместе
* Протокол::              Определение протокола связи
* Сервер::                Использование программы `gdbserver'
* NetWare::               Использование программы `gdbserve.nlm'
@end menu

@node Содержимое заглушки
@subsubsection Что заглушка может сделать для вас

@cindex удаленная последовательная заглушка
Отладочная заглушка для вашей архитектуры содержит следующие
три подпрограммы:

@table @code
@item set_debug_traps
@kindex set_debug_traps
@cindex удаленная последовательная заглушка, инициализация
Когда ваша программа останавливается, эта подпрограмма организует
выполнение @code{handle_exception}.  Вы должны явно вызвать эту
подпрограмму в начале вашей программы.

@item handle_exception
@kindex handle_exception
@cindex удаленная последовательная заглушка, главная подпрограмма
Это главная рабочая лошадка, но ваша программа никогда не вызывает ее
явно --- установочный код организует запуск @code{handle_exception}, когда
вызывается ловушка.

@code{handle_exception} получает управление, когда ваша программа
останавливается во время выполнения (например, в точке останова), и
организует связь с @value{GDBN} на рабочей машине.  Именно здесь
реализуется протокол связи; @code{handle_exception} действует как
представитель @value{GDBN} на целевой машине.  Сперва она посылает
суммарную информацию о состоянии вашей программы, затем продолжает
выполняться, извлекая и передавая любую информацию, требующуюся
@value{GDBN}, пока вы не выполните команду @value{GDBN}, возобновляющую
выполнение вашей программы; в этом месте @code{handle_exception}
возвращает управление вашему коду на целевой машине.

@item breakpoint
@cindex подпрограмма @code{breakpoint}, удаленная
Используйте эту вспомогательную подпрограмму для установки в вашей
программе точек останова.  В зависимости от конкретной ситуации, это
может быть единственным способом для @value{GDBN} получить управление.
Например, если ваша целевая машина имеет некую клавишу прерывания, вам
не нужно вызывать эту подпрограмму; нажатие клавиши прерывания передаст
управление @code{handle_exception} --- в действительности, @value{GDBN}.
На некоторых машинах простое получение знаков на последовательный порт
может также вызвать ловушку; опять, в этой ситуации вам не нужно вызывать
@code{breakpoint} из вашей программы --- простое выполнение @samp{target
remote} из рабочего сеанса @value{GDBN} передаст управление.

Вызывайте @code{breakpoint}, если ни одно из этих предположений не верно,
или вы просто хотите быть уверенным, что ваша программа остановится в
предопределенной точке от начала вашего сеанса отладки.
@end table

@node Начальная загрузка
@subsubsection Что вы должны сделать для заглушки

@cindex удаленная заглушка, подпрограммы поддержки
Отладочные заглушки, поставляемые с @value{GDBN}, ориентированы на
микропроцессоры определенной архитектуры, но они не имеют информации
об остальной части вашей целевой отладочной машины.

В первую очередь, вам нужно сообщить заглушке, как связаться с
последовательным портом.

@table @code
@item int getDebugChar()
@kindex getDebugChar
Напишите эту подпрограмму для чтения одного знака из
последовательного порта.  Она может быть идентична @code{getchar} для
вашей целевой системы; разные имена используются, чтобы позволить
вам их различать, если вы этого хотите.

@item void putDebugChar(int)
@kindex putDebugChar
Напишите эту подпрограмму для записи одного знака в
последовательный порт.  Она может быть идентична @code{putchar} для
вашей целевой системы; разные имена используются, чтобы позволить
вам их различать, если вы этого хотите.
@end table

@cindex control C и удаленная отладка
@cindex прерывание удаленных целей
Если вы хотите, чтобы @value{GDBN} мог остановить вашу программу во
время ее выполнения, вам нужно использовать управляемый прерываниями
последовательный драйвер и настроить его для остановки при получении
@code{^C} (@samp{\003}, знак control-C).  Это тот знак, который
@value{GDBN} использует для указания удаленной системе остановиться.

Указание отладочной цели вернуть @value{GDBN} правильный статус,
вероятно, потребует изменений в стандартной заглушке; один быстрый и
неаккуратный способ состоит в выполнении лишь инструкции точки останова
(``неаккуратность'' состоит в том, что @value{GDBN} выдает
@code{SIGTRAP} вместо @code{SIGINT}).

Вот другие процедуры, которые вы должны обеспечить:

@table @code
@item void exceptionHandler (int @var{номер-исключения}, void *@var{адрес-исключения})
@kindex exceptionHandler
Напишите эту функцию для установки @var{адреса-исключения} в таблицы
обработки исключительных ситуаций.  Вам нужно сделать это, потому
что у заглушки нет способа узнать, как устроены таблицы обработки
исключений в вашей целевой системе (например, процессорная
таблица может находиться в @sc{пзу} и содержать элементы, указывающие на
таблицу в @sc{озу}).  @var{Номер-исключения} --- это номер исключительной
ситуации, которая должна быть изменена; его значение зависит от
архитектуры (например, различные номера могут представлять
деление на ноль, доступ с нарушением выравнивания и так далее).  Когда
это исключение возникает, управление должно быть передано
непосредственно @var{адресу-исключения}, и процессорное
состояние (стек, регистры и так далее) должно быть таким же, как
во время возникновения процессорного исключения.  Так что если вы хотите
использовать инструкцию перехода для достижения @var{адреса-исключения},
это должен быть простой переход, не переход к подпрограмме.

Для 386, @var{адрес-исключения} должен быть установлен как обработчик
@c ??????? interrupt gate
@c ??? надо у народа спросить как этот затвор называется -- ост
затвора вызова
прерывания, чтобы во время его выполнения остальные прерывания маскировались.
Он должен иметь уровень полномочий 0 (наибольшие полномочия).  Заглушки
@sc{sparc} и 68k могут маскировать прерывания самостоятельно без помощи
@code{exceptionHandler}.

@item void flush_i_cache()
@kindex flush_i_cache
Только для @sc{sparc} и @sc{sparclite}.  Напишите эту подпрограмму для
очистки кеша инструкций на вашей целевой машине, если он есть.
Если кеша инструкций нет, эта подпрограмма может ничего не делать.

На целевых машинах, имеющих кеш инструкций, @value{GDBN} требует эту
функцию, чтобы удостовериться, что состояние вашей программы
стабильно.
@end table

@noindent
Вы должны также удостовериться, что доступна такая библиотечная процедура:

@table @code
@item void *memset(void *, int, int)
@kindex memset
Это стандартная библиотечная функция @code{memset}, которая
устанавливает область памяти в заданное значение.  Если у вас есть
одна из свободных версий @code{libc.a}, @code{memset} может быть найдена
там; иначе вы должны или получить ее от изготовителя аппаратного
обеспечения, или написать свою собственную.
@end table

Если вы не используете компилятор @sc{gnu} Си, вам также могут
понадобиться другие стандартные библиотечные подпрограммы; это
меняется от одной заглушки к другой, но в общем, заглушки
часто используют различные общие библиотечные подпрограммы, которые
@code{@value{GCC}} генерирует как встроенный код.


@node Сеанс отладки
@subsubsection Собираем все вместе

@cindex обзор удаленной последовательной отладки
Вкратце, когда ваша программа готова к отладке, вы должны проделать
следующие шаги.

@enumerate
@item
Убедитесь, что вы определили поддерживающие процедуры низкого уровня
(@pxref{Начальная загрузка,,Что вы должны сделать для заглушки}):
@display
@code{getDebugChar}, @code{putDebugChar},
@code{flush_i_cache}, @code{memset}, @code{exceptionHandler}.
@end display

@item
Вставьте следующие строки в начале вашей программы:

@example
set_debug_traps();
breakpoint();
@end example

@item
Для заглушки 680x0, вы должны предоставить переменную
@code{exceptionHook}.  Обычно вы используете просто

@example
void (*exceptionHook)() = 0;
@end example

@noindent
если до вызова @code{set_debug_traps} вы установили ее для
указания на функцию в вашей программе.  Эта функция вызывается, когда
@value{GDBN} продолжает выполнение после останова на ловушке (например,
ошибка шины).
Функция, указанная @code{exceptionHook}, вызывается с одним
параметром типа @code{int}, который является номером исключения.

@item
Откомпилируйте и скомпонуйте вместе: вашу программу, отладочную
заглушку @value{GDBN} для вашей целевой архитектуры и
подпрограммы поддержки.

@item
Убедитесь, что у вас есть последовательное соединение между вашей целевой
и рабочей машинами, и идентифицируйте последовательный порт на
рабочей машине.

@item
Загрузите вашу программу на целевую машину (или поместите ее туда
любыми средствами, предоставляемыми производителем) и запустите ее.

@item
Для начала удаленной отладки, запустите @value{GDBN} на рабочей машине
и укажите в качестве выполняемого файла программу, которая выполняется
на удаленной машине.  Это сообщает @value{GDBN}, как найти символы и
содержание неизменяемых областей вашей программы.

@item
@cindex последовательная линия, @code{target remote}
Установите связь, используя команду @code{target remote}.  Ее
аргументы определяют, как взаимодействовать с целевой машиной --- либо
через устройство, подключенное к последовательной линии,
либо через порт TCP (обычно подключенный к терминальному серверу, который,
в свою очередь, имеет последовательную линию до цели).  Например,
чтобы использовать последовательную линию, присоединенную к устройству
@file{/dev/ttyb}, выполните:

@example
target remote /dev/ttyb
@end example

@cindex TCP-порт, @code{target remote}
Чтобы использовать TCP-соединение, используйте аргумент в форме
@code{@var{машина}:порт}.  Например, для соединения с портом 2828 на
терминальном сервере @code{manyfarms}:

@example
target remote manyfarms:2828
@end example
@end enumerate

Теперь вы можете использовать все обычные команды для исследования и изменения
данных, пошагового выполнения и продолжения исполнения удаленной
программы.

Для возобновления выполнения удаленной программы и прекращения ее
отладки, используйте команду @code{detach}.

@cindex прерывание удаленной программы
@cindex удаленные программы, прерывание
Всякий раз, когда @value{GDBN} ожидает удаленную программу, если вы вводите
знак прерывания (часто @kbd{C-C}), @value{GDBN} пытается остановить
программу.  Это может привести или не привести к успеху, частично в
зависимости от аппаратных средств и последовательных драйверов, которые
использует удаленная система.  Если вы снова введете знак прерывания,
@value{GDBN} выведет такое приглашение:

@example
Interrupted while waiting for the program.
Give up (and stop debugging it)?  (y or n)
@end example

Если вы введете @kbd{y}, @value{GDBN} прекратит сеанс удаленной отладки.
(Если вы позже решите попытаться снова, вы можете вновь
использовать @code{target remote}, чтобы соединиться еще раз.)  Если вы
введете @kbd{n}, @value{GDBN} вернется к ожиданию.

@node Протокол
@subsubsection Коммуникационный протокол

@cindex отладочная заглушка, пример
@cindex удаленная заглушка, пример
@cindex пример заглушки, удаленная отладка
Файлы заглушек, поставляемые с @value{GDBN}, реализуют коммуникационный
протокол со стороны целевой машины, а со стороны @value{GDBN} он
реализуется в исходном файле @value{GDBN} @file{remote.c}.  Обычно вы
можете просто позволить этим программам взаимодействовать и
не вдаваться в детали.  (Если вы разрабатываете свой собственный файл
заглушки, вы также можете игнорировать детали: начните с одного из
существующих файлов заглушки.  @file{sparc-stub.c} организован наилучшим
образом, и потому его легче всего читать.)

Однако, бывают случаи, когда вам необходимо кое-что знать о
протоколе --- например, если существует только один последовательный порт
на вашей целевой машине, вы можете захотеть, чтобы ваша программа делала
что-нибудь особенное, если она распознает предназначенный для @value{GDBN}
пакет.

В следующих примерах, @samp{<-} и @samp{->} используются для обозначения
переданных и полученных данных соответственно.

@cindex протокол, удаленный последовательный @value{GDBN}
@cindex последовательный протокол, удаленный @value{GDBN}
@cindex удаленный последовательный протокол
Все команды и ответы @value{GDBN} (не подтверждения)
посылаются в виде @var{пакета}.  @var{Пакет} представлен знаком @samp{$},
реальными @var{данными-пакета} и завершающим знаком @samp{#}, за которым
следуют две цифры @var{контрольной-суммы}:

@example
@code{$}@var{данные-пакета}@code{#}@var{контрольная-сумма}
@end example
@noindent

@cindex контрольная сумма, для удаленного @value{GDBN}
@noindent
Двузначная @var{контрольная-сумма} вычисляется как сумма по модулю 256
всех знаков между начальным @samp{$} и конечным @samp{#} (восьмибитная
беззнаковая контрольная сумма).

Разработчикам следует учесть, что до @value{GDBN} версии 5.0
спецификация протокола также включала необязательный двузначный
@var{ид-последов}:

@example
@code{$}@var{ид-последов}@code{:}@var{данные-пакета}@code{#}@var{контрольная-сумма}
@end example

@cindex идентификатор последовательности, для удаленного @value{GDBN}
@noindent
Этот @var{ид-последов} добавлялся к подтверждению.
@value{GDBN} никогда не генерировал @var{ид-последов}.
Заглушки, занимающиеся обработкой пакетов, добавленные в @value{GDBN}
начиная с версии 5.0, не должны принимать пакеты с
@var{ид-последов}.

@cindex подтверждение, для удаленного @value{GDBN}
Когда или рабочая, или целевая машина получает пакет, первым ожидаемым
ответом является подтверждение: или @samp{+} (для указания, что пакет
получен корректно), или @samp{-} (чтобы запросить повторную передачу):

@example
<- @code{$}@var{данные-пакета}@code{#}@var{контрольная-сумма}
-> @code{+}
@end example
@noindent

Рабочая машина (@value{GDBN}) посылает @var{команды}, а целевая (отладочная
заглушка, включенная в вашу программу) посылает @var{ответ}.  В случае
@var{команд} пошагового выполнения и продолжения, ответ посылается
только тогда, когда операция закончена (цель снова остановлена).

@var{Данные-пакета} состоят из последовательности знаков, за исключением
@samp{#} и @samp{$} (для дополнительных исключений, смотрите пакет
@samp{X}).

Поля внутри пакета должны разделяться при помощи @samp{,}, @samp{;} или
@samp{:}.  Если не оговорено противное, все числа представлены в
шестнадцатеричном виде без начальных нулей.

Разработчикам следует учесть, что до @value{GDBN} версии 5.0, знак
@samp{:} не мог появляться третьим знаком в пакете (так как
потенциально это могло привести к конфликту с
@var{ид-последов}).

@var{данные} ответа могут быть для экономии закодированы
методом длины серий.  @samp{*} означает, что следующий знак является
@sc{ascii}-кодом, который обозначает количество повторений знака,
предшествующего @samp{*}.  Кодировкой является @code{n+29}, что дает печатный
знак для @code{n >=3} (когда кодировка переменной длины начинает давать
@c ??? так кодировка "переменной длины" или "длины серий"?
преимущество).  Печатные знаки @samp{$}, @samp{#}, @samp{+}, @samp{-}
или знаки с номерами, большими 126, использоваться не должны.

Некоторые удаленные системы использовали другой механизм кодировки с
переменной длиной, иногда называемый cisco-кодировкой.  За @samp{*}
следуют две шестнадцатеричные цифры, обозначающие размер пакета.

Итак:
@example
"@code{0* }"
@end example
@noindent
означает то же, что и "0000".

При ошибке, ответ, возвращаемый для некоторых пакетов, включает
двузначный номер ошибки.  Этот номер определен смутно.

Для любой @var{команды}, не поддерживаемой заглушкой, должен быть
возвращен пустой ответ (@samp{$#00}).  Таким образом, протокол можно
расширять.  По этому ответу новые версии @value{GDBN} могут определить,
поддерживается тот или иной пакет.

От заглушки требуется поддержка @var{команд} @samp{g}, @samp{G},
@samp{m}, @samp{M}, @samp{c} и @samp{s}.  Все остальные @var{команды}
являются необязательными.

Вот полный список всех определенных на данный момент @var{команд} и
соответствующих им ответов @var{данные}:
@page
@multitable @columnfractions .30 .30 .40
@item Пакет
@tab Запрос
@tab Описание

@item расширенные операции
@tab @code{!}
@tab
Использовать расширенный удаленный протокол.  Имеет постоянное
действие --- требует установки только один раз.  Расширенный удаленный
протокол поддерживает пакеты @samp{R}.
@item
@tab ответ @samp{}
@tab
Заглушки, поддерживающие расширенный удаленный протокол, возвращают
@samp{}, что, к сожалению, совпадает с ответом, возвращаемым заглушками,
которые не поддерживают расширения протокола.

@item последний сигнал
@tab @code{?}
@tab
Указывает причину, по которой цель остановилась.  Ответ такой же, как
для пошагового выполнения и продолжения.
@item
@tab ответ
@tab смотрите ниже


@item зарезервировано
@tab @code{a}
@tab Зарезервировано для использования в будущем

@item установить аргументы программы @strong{(зарезервировано)}
@tab @code{A}@var{длина-арг}@code{,}@var{число-арг}@code{,}@var{арг}@code{,@dots{}}
@tab
@item
@tab
@tab
В программу передается инициализированный массив @samp{argv[]}.
@var{Длина-арг} задает число байт в закодированном в шестнадцатеричный
вид потоке байт @var{арг}.  Смотрите @file{gdbserver} для
дополнительной информации.
@item
@tab ответ @code{OK}
@item
@tab ответ @code{E}@var{NN}

@item установить скорость @strong{(не рекомендовано)}
@tab @code{b}@var{бод}
@tab
Установить скорость последовательной линии в @var{бод}.
@c JTC: @emph{Когда
@c изменяется состояние транспортного уровня?  Когда оно получено, или
@c после передачи ACK.  В любом случае, возникают проблемы, если пакет
@c команды или подтверждения потерян.}  Stan: @emph{Если люди
@c действиительно хотели добавить что-то типа этого, и оно у них сначала
@c заработало, они должны были изменить ser-unix.c .....}
@c ??????????   ^^^^^^^^^^^ абзац

@item установить точку останова @strong{(не рекомендовано)}
@tab @code{B}@var{адрес},@var{режим}
@tab
Установить (@var{режим} @samp{S}) или удалить (@var{режим} @samp{C})
точку останова по адресу @var{адрес}.  @emph{Это было замещено пакетами
@samp{Z} и @samp{z}.}

@item продолжить
@tab @code{c}@var{адрес}
@tab
@var{Адрес} --- это адрес для возобновления выполнения.  Если он
опущен, возобновить с текущего адреса.
@item
@tab ответ
@tab смотрите ниже

@item продолжить с сигналом
@tab @code{C}@var{сиг}@code{;}@var{адрес}
@tab
Продолжить с сигналом @var{сиг} (шестнадцатеричный номер сигнала).  Если
`@code{;}@var{адрес}' опущено, выполнение возобновляется с прежнего
адреса.
@item
@tab ответ
@tab смотрите ниже

@item переключить режим отладки @strong{(не рекомендовано)}
@tab @code{d}
@tab
переключить флаг отладки.

@item отсоединиться
@tab @code{D}
@tab
Отсоединить @value{GDBN} от удаленной системы.  Посылается удаленной
системе перед тем, как @value{GDBN} отсоединится.
@item
@tab ответ @emph{нет ответа}
@tab
@value{GDBN} не ждет никакого ответа после посылки этого пакета.

@item зарезервировано
@tab @code{e}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{E}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{f}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{F}
@tab Зарезервировано для использования в будущем

@item чтение регистров
@tab @code{g}
@tab Чтение регистров общего назначения.
@item
@tab ответ @var{XX...}
@tab
Каждый байт данных регистра описывается двумя шестнадцатеричными
цифрами.  Они передаются с целевым порядком байтов.  Размер каждого
регистра и его позиция внутри @var{пакета} @samp{g} определяются
внутренними макросами @value{GDBN} @var{REGISTER_RAW_SIZE} и
@var{REGISTER_NAME}.  Спецификация нескольких стандартных пакетов
@samp{g} приведена ниже.
@item
@tab @code{E}@var{NN}
@tab в случае ошибки.

@item запись в регистры
@tab @code{G}@var{XX...}
@tab
Смотрите @samp{g} для описания данных @var{XX...} .
@item
@tab ответ @code{OK}
@tab в случае успеха
@item
@tab ответ @code{E}@var{NN}
@tab в случае ошибки

@item зарезервировано
@tab @code{h}
@tab Зарезервировано для использования в будущем

@item выбрать нить
@tab @code{H}@var{c}@var{t...}
@tab
Установить нить для последующих операций (@samp{m}, @samp{M}, @samp{g},
@samp{G} и других).  @var{c} = @samp{c} для нитей, используемых при
пошаговом выполнении и продолжении; @var{t...} может быть -1 для всех
нитей.  @var{c} = @samp{g} для нитей, используемых в других операциях.
Если ноль --- выбрать любую нить.
@item
@tab ответ @code{OK}
@tab в случае успеха
@item
@tab ответ @code{E}@var{NN}
@tab в случае ошибки

@item пошаговое выполнение по тактовому циклу @strong{(черновик)}
@tab @code{i}@var{адрес}@code{,}@var{nnn}
@tab
Выполнить один тактовый цикл на удаленной машине.  Если
`@code{,}@var{nnn}' указано, выполнить @var{nnn} циклов.  Если
указан @var{адрес}, пошаговое выполнение по одному тактовому циклу
начинается этого адреса.

@item сигнал, затем выполнение по тактовым циклам @strong{(зарезервировано)}
@tab @code{I}
@tab
Смотрите @samp{i} и @samp{S}, там аналогичный синтаксис и семантика.

@item зарезервировано
@tab @code{j}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{J}
@tab Зарезервировано для использования в будущем

@item убить
@tab @code{k}
@tab
FIXME: @emph{Нет описания, как действовать в случае, если был выбран
контекст определенной нити (то есть @samp{k} убивает только эту нить?)}.

@item зарезервировано
@tab @code{l}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{L}
@tab Зарезервировано для использования в будущем

@item чтение памяти
@tab @code{m}@var{адрес}@code{,}@var{длина}
@tab
Прочитать @var{длину} байт памяти, начиная с адреса @var{адрес}.  Ни
@value{GDBN}, ни заглушка не предполагают, что передача области памяти
происходит по адресам, выровненным по границе слова.  FIXME: @emph{Нужен
механизм передачи области памяти, выровненной по границе слова.}
@item
@tab ответ @var{XX...}
@tab
@var{XX...} представляет собой содержимое памяти.  Может содержать
меньше запрошенного числа байт, если удалось прочитать только часть
данных.  Ни @value{GDBN}, ни заглушка не предполагают, что передача
области памяти происходит по адресам, выровненным по границе слова.
FIXME: @emph{Нужен механизм передачи области памяти, выровненной по
границе слова.}
@item
@tab ответ @code{E}@var{NN}
@tab @var{NN} представляет номер ошибки

@item запись в память
@tab @code{M}@var{адрес},@var{длина}@code{:}@var{XX...}
@tab
Записать @var{длину} байт памяти, начиная с адреса @var{адрес}.
@var{XX...} --- это данные.
@item
@tab ответ @code{OK}
@tab при успехе
@item
@tab ответ @code{E}@var{NN}
@tab
при ошибке (это включает случай, когда была записана только часть
данных).

@item зарезервировано
@tab @code{n}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{N}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{o}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{O}
@tab Зарезервировано для использования в будущем

@item чтение регистров @strong{(зарезервировано)}
@tab @code{p}@var{n...}
@tab
Смотрите запись регистров.
@item
@tab возврат @var{r....}
@tab Значение регистра в целевом порядке байт, закодированное в
шестнадцатеричном виде.

@item запись регистров
@tab @code{P}@var{n...}@code{=}@var{r...}
@tab
Записать в регистр @var{n...} значение @var{r...}, которое содержит две
шестнадцатеричные цифры для каждого байта в регистре (целевой порядок
байтов).
@item
@tab ответ @code{OK}
@tab в случае успеха
@item
@tab ответ @code{E}@var{NN}
@tab при ошибке

@item общий запрос
@tab @code{q}@var{запрос}
@tab
Запросить информацию о @var{запросе}.  Вообще, запросы
@value{GDBN} начинаются с заглавной буквы.  Специальные запросы от
производителей должны использовать приставку компании (из маленьких
букв).  Например: @samp{qfsf.var}.  За @var{запросом} может следовать
необязательный список, разделенный @samp{,} или @samp{;}.  Заглушки
должны проверять, что они производят сравнение с полным именем
@var{запроса}.
@item
@tab ответ @code{XX...}
@tab Данные от запроса, закодированные шестнадцатеричными цифрами.
Ответ не может быть пустым.
@item
@tab ответ @code{E}@var{NN}
@tab ответ при ошибке
@item
@tab ответ @samp{}
@tab Указывает на нераспознанный @var{запрос}.

@item общая установка
@tab @code{Q}@var{перем}@code{=}@var{знач}
@tab
Установить значение @var{перем} в @var{знач}.  Смотрите @samp{q} для
обсуждения соглашений, касающихся имен.

@item сброс @strong{(не рекомендовано)}
@tab @code{r}
@tab
Установка всей системы в исходное состояние.

@item удаленная перезагрузка
@tab @code{R}@var{XX}
@tab
Перезапустить удаленный сервер.  @var{XX} не имеет ясного определения,
хотя оно нужно.  FIXME: @emph{Нужен пример взаимодействия,
объясняющий как эти пакеты используются в расширенном удаленном режиме}.

@item пошаговое выполнение
@tab @code{s}@var{адрес}
@tab
@var{Адрес} --- это адрес для возобновления выполнения.  Если @var{адрес}
опущен, возобновить выполнение с того же адреса.
@item
@tab ответ
@tab смотрите ниже

@item пошаговое выполнение с сигналом
@tab @code{S}@var{сиг}@code{;}@var{адрес}
@tab
Как @code{C}, но разница такая же, как между @code{step} и
@code{continue}.
@item
@tab ответ
@tab смотрите ниже

@item поиск
@tab @code{t}@var{адрес}@code{:}@var{PP}@code{,}@var{MM}
@tab
Поиск совпадения с шаблоном @var{PP} и маской @var{MM} в обратном
направлении, начиная с @var{адреса}.  @var{PP} и @var{MM} --- 4 байта.
В @var{адресе} должно быть не менее трех цифр.

@item жива ли нить
@tab @code{T}@var{XX}
@tab Определить, жива ли нить @var{XX}.
@item
@tab ответ @code{OK}
@tab нить все еще жива
@item
@tab ответ @code{E}@var{NN}
@tab нить мертва

@item зарезервировано
@tab @code{u}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{U}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{v}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{V}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{w}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{W}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{x}
@tab Зарезервировано для использования в будущем

@item запись в память (двоичная)
@tab @code{X}@var{адрес}@code{,}@var{длина}@var{:}@var{XX...}
@tab
@var{Адрес} --- это адрес, @var{длина} --- это число байт, @var{XX...} --- это
двоичные данные.  Знаки @code{$}, @code{#} и @code{0x7d} экранируются
с помощью @code{0x7d}.
@item
@tab ответ @code{OK}
@tab в случае успеха
@item
@tab ответ @code{E}@var{NN}
@tab в случае ошибки

@item зарезервировано
@tab @code{y}
@tab Зарезервировано для использования в будущем

@item зарезервировано
@tab @code{Y}
@tab Зарезервировано для использования в будущем

@item удалить точку останова или наблюдения @strong{(черновик)}
@tab @code{z}@var{t}@code{,}@var{адрес}@code{,}@var{длина}
@tab
Смотрите @samp{Z}.

@item поместить точку останова или наблюдения @strong{(черновик)}
@tab @code{Z}@var{t}@code{,}@var{адрес}@code{,}@var{длина}
@tab
@var{t} представляет тип: @samp{0} в случае программной точки останова,
@samp{1} --- аппаратная точка останова, @samp{2} --- точка наблюдения за
записью, @samp{3} --- точка наблюдения за чтением, @samp{4} --- точка
наблюдения за доступом; @var{адрес} --- это адрес; @var{длина} задается в
байтах.  Для программной точки останова, @var{длина} задает размер
инструкции, на которую надо поместить заплату.  Для аппаратных точек
останова и наблюдения, @var{длина} указывает размер области памяти
для наблюдения.  Чтобы избежать потенциальных проблем с повторными
пакетами, операции должны быть реализованы идемпотентным образом.
@item
@tab ответ @code{E}@var{NN}
@tab в случае ошибки
@item
@tab ответ @code{OK}
@tab в случае успеха
@item
@tab @samp{}
@tab Если не поддерживается.

@item зарезервировано
@tab <другое>
@tab Зарезервировано для использования в будущем

@end multitable

Пакеты @samp{C}, @samp{c}, @samp{S}, @samp{s} и @samp{?} могут получить
в качестве ответа все нижеперечисленное.  В случае пакетов @samp{C},
@samp{c}, @samp{S} и @samp{s}, этот ответ возвращается только тогда,
когда цель останавливается.  Ниже, точное значение @samp{номера сигнала}
определено нечетко.  Вообще, используется одно из соглашений
UNIX о номерах сигналов.

@multitable @columnfractions .4 .6

@item @code{S}@var{AA}
@tab @var{AA} --- это номер сигнала

@item @code{T}@var{AA}@var{n...}@code{:}@var{r...}@code{;}@var{n...}@code{:}@var{r...}@code{;}@var{n...}@code{:}@var{r...}@code{;}
@tab
@var{AA} = две шестнадцатеричные цифры номера сигнала; @var{n...} =
(шестнадцатеричный) номер регистра, @var{r...} = содержимое регистра в
целевом порядке байт, размер определяется @code{REGISTER_RAW_SIZE};
@var{n...} = @samp{thread}, @var{r...} = идентификатор процесса нити, это
шестнадцатеричное целое; @var{n...} = другая строка, не начинающаяся с
шестнадцатеричной цифры.  @value{GDBN} должен игнорировать эту пару
@var{n...}, @var{r...} и переходить к следующей.  Таким образом мы можем
расширять протокол.

@item @code{W}@var{AA}
@tab
Процесс завершается с кодом выхода @var{AA}.  Это применимо только к
определенным типам целей.

@item @code{X}@var{AA}
@tab
Процесс завершается с сигналом @var{AA}.

@item @code{N}@var{AA}@code{;}@var{t...}@code{;}@var{d...}@code{;}@var{b...} @strong{(устарело)}
@tab
@var{AA} = номер сигнала; @var{t...} = адрес символа "_start";
@var{d...} = база раздела данных; @var{b...} = база раздела bss.
@emph{Примечание: используется только целями Cisco Systems.  Разница
между этим ответом и запросом "qOffsets" заключается в том, что пакет
'N' может прибыть самопроизвольно, тогда как запрос 'qOffsets'
инициируется рабочим отладчиком.}

@item @code{O}@var{XX...}
@tab
@var{XX...} --- шестнадцатеричное представление @sc{ascii}-данных.  Это
может произойти в любой момент, пока программа выполняется и отладчик
должен продолжать ждать 'W', 'T' и тому подобное.

@end multitable

Следующие пакеты для установок и запросов уже были определены.

@multitable @columnfractions .2 .2 .6

@item текущая нить
@tab @code{q}@code{C}
@tab Возвратить идентификатор текущей нити.
@item
@tab ответ @code{QC}@var{идент-проц}
@tab
Где @var{идент-проц} --- 16-битный идентификатор процесса, представленный
шестнадцатеричными цифрами.
@item
@tab ответ *
@tab Любой другой ответ подразумевает старый идентификатор процесса.

@item идентификаторы всех нитей
@tab @code{q}@code{fThreadInfo}
@item
@tab @code{q}@code{sThreadInfo}
@tab
Получить список идентификаторов активных нитей от целевой ОС.  Так как
число активных нитей может оказаться слишком большим и не поместиться в
пакет ответа, этот запрос работает итерациями: для получения полного
списка нитей может потребоваться более
одной последовательности запрос/ответ.  Первым запросом последовательности будет
@code{qf}@code{ThreadInfo}; последующими запросами последовательности
будут запросы @code{qs}@code{ThreadInfo}.
@item
@tab
@tab Замечание: замещает запрос @code{qL} (смотрите ниже).
@item
@tab ответ @code{m}@var{<ид>}
@tab Идентификатор одной нити
@item
@tab ответ @code{m}@var{<ид>},@var{<ид>...}
@tab список идентификаторов нитей, разделенных запятыми
@item
@tab ответ @code{l}
@tab (буква 'l' в нижнем регистре) обозначает конец списка.
@item
@tab
@tab
В ответ на каждый запрос, цель будет отвечать списком из разделенных
запятыми идентификаторов нитей, в шестнадцатеричном представлении, с
порядком байт от старшего.  @value{GDBN} будет отвечать на каждый ответ
запросом других идентификаторов (используя форму @code{qs} запроса),
пока цель не ответит @code{l} (буква 'l' в нижнем регистре, от
английского слова @code{'last'}).

@item дополнительная информация о нити
@tab @code{q}@code{ThreadExtraInfo}@code{,}@var{ид}
@tab
@item
@tab
@tab
Здесь @var{ид} является идентификатором нити в шестнадцатеричном
представлении, в порядке байт от старшего.  Получает печатаемое описание
строки атрибутов нити от целевой ОС.  Эта строка может содержать
все что угодно, что целевая ОС сочтет интересным для
@value{GDBN} сообщить пользователю о нити.  Эта строка выводится в
отображении @value{GDBN} @samp{info threads}.  Примерами возможной
дополнительной информации являются "Runnable" или "Blocked on Mutex".
@item
@tab ответ @var{XX...}
@tab
Где @var{XX...} --- @sc{ascii}-данные в шестнадцатеричном представлении,
содержащие печатную строку с дополнительной информацией об атрибутах
нити.

@item запрос @var{список} или @var{список-нитей} @strong{(не рекомендовано)}
@tab @code{q}@code{L}@var{нач-флаг}@var{число-нитей}@var{след-нить}
@tab
@item
@tab
@tab
Получить информацию о нити от операционной системы, где происходит
выполнение.  Здесь: @var{нач-флаг} (одна шестнадцатеричная цифра) есть
единица, что указывает на первый запрос, или ноль, что определяет
последующий запрос; @var{число-нитей} (две шестнадцатеричные
цифры) --- максимальное число нитей, которое может содержать пакет ответа;
и @var{след-нить} (восемь шестнадцатеричных цифр), для последующих
запросов (@var{нач-флаг} равен нулю), возвращается в ответ как
@var{арг-нить}.
@item
@tab
@tab Замечание: этот запрос был замещен запросом
@code{q}@code{fThreadInfo} (смотрите выше).
@item
@tab ответ @code{q}@code{M}@var{число}@var{конец}@var{арг-нить}@var{нить...}
@tab
@item
@tab
@tab
Здесь: @var{число} (две шестнадцатеричные цифры) --- число возвращаемых
нитей; @var{конец} (одна шестнадцатеричная цифра), есть ноль, который
определяет, что есть еще нити, и единица, определяющая, что
больше нитей нет; @var{арг-нить} (восемь шестнадцатеричных цифр)
представляет собой @var{след-нить} из пакета запроса;
@var{нить...} --- это последовательность идентификаторов нитей от цели.
@var{Идент-нити} (восемь шестнадцатеричных цифр).  Смотрите
@code{remote.c:parse_threadlist_response()}.

@item вычислить CRC блока памяти
@tab @code{q}@code{CRC:}@var{адрес}@code{,}@var{длина}
@tab
@item
@tab ответ @code{E}@var{NN}
@tab Ошибка (например, ошибка доступа к памяти)
@item
@tab ответ @code{C}@var{CRC32}
@tab Лишняя 32-битная циклическая проверка указанной области памяти.

@item запросить смещения разделов
@tab @code{q}@code{Offsets}
@tab
Получить смещения разделов, которые целевая машина использовала при
повторном размещении загруженного образа.  @emph{Замечание: если
смещение @code{Bss} включено в ответ, @value{GDBN} это игнорирует и
вместо этого применяет  к разделу @code{Bss} смещение @code{Data}.}
@item
@tab ответ @code{Text=}@var{xxx}@code{;Data=}@var{yyy}@code{;Bss=}@var{zzz}

@item запросить информацию о нити
@tab @code{q}@code{P}@var{режим}@var{идент-нити}
@tab
@item
@tab
@tab
Возвращает информацию об @var{идент-нити}.  Здесь: @var{режим} является
32-битным режимом в шестнадцатеричном представлении;
@var{идент-нити} --- 64-битный идентификатор нити в шестнадцатеричном
представлении.
@item
@tab ответ *
@tab
Смотрите @code{remote.c:remote_unpack_thread_info_response()}.

@item удаленная команда
@tab @code{q}@code{Rcmd,}@var{КОМАН@-ДА}
@tab
@item
@tab
@tab
@var{КОМАНДА} (в шестнадцатеричном представлении) передается для
выполнения локальному интерпретатору.  Неверные команды должны
сообщаться при помощи выходной строки.  Перед конечным результирующим
пакетом, целевая машина может также ответить некоторым количеством
промежуточных @code{O}@var{ВЫВОД} пакетов вывода на консоль.
@emph{Разработчики должны учесть, что предоставление доступа к
интерпретатору заглушки может иметь последствия для безопасности}.
@item
@tab ответ @code{OK}
@tab
Ответ на команду без вывода.
@item
@tab ответ @var{ВЫВОД}
@tab
Ответ на команду со строкой вывода @var{ВЫВОД}, в шестнадцатеричном
представлении.
@item
@tab ответ @code{E}@var{NN}
@tab
Указывает на неправильно сформированный запрос.

@item
@tab reply @samp{}
@tab
Когда @samp{q}@samp{Rcmd} не распознана.

@end multitable

Следующие пакеты @samp{g}/@samp{G} были определены раньше.  Ниже,
некоторые 32-битные регистры передаются в виде 64 бит.  Эти регистры
должны быть расширены нулем/знаком (как?), чтобы заполнять выделенное
место.  Байты регистра передаются в целевом порядке байтов.  Две части в
байте регистра передаются от более значимого к менее значимому.

@multitable @columnfractions .5 .5

@item MIPS32
@tab
Все регистры передаются как 32-битные величины в таком порядке: 32 общего
назначения; sr; lo; hi; bad; cause; pc; 32 регистра с плавающей точкой;
fsr; fir; fp.

@item MIPS64
@tab
Все регистры передаются как 64-битные величины (включая такие 32-битные
регистры, как @code{sr}).  Порядок такой же, как для @code{MIPS32}.

@end multitable

Вот пример последовательности для перезапускаемой цели.  Заметьте, что
перезапуск не получает никакого непосредственного вывода:

@example
<- @code{R00}
-> @code{+}
@emph{target restarts}
<- @code{?}
-> @code{+}
-> @code{T001:1234123412341234}
<- @code{+}
@end example

Пример последовательности при при пошаговом выполнении цели по одной
инструкции:

@example
<- @code{G1445...}
-> @code{+}
<- @code{s}
-> @code{+}
@emph{time passes}
-> @code{T001:1234123412341234}
<- @code{+}
<- @code{g}
-> @code{+}
-> @code{1455...}
<- @code{+}
@end example

@node Сервер
@subsubsection Использование программы @code{gdbserver}

@kindex gdbserver
@cindex удаленное соединение без заглушек
@code{gdbserver} является управляющей программой для Unix-подобных
систем, которая позволяет вам установить соединение вашей программы с
удаленным @value{GDBN} посредством @code{target remote}, но без
компоновки с обычной отладочной заглушкой.

@code{gdbserver} не является полной заменой отладочных заглушек, потому что
требует по существу тех же средств операционной системы, что и сам
@value{GDBN}.  Фактически, система, на которой может выполняться
@code{gdbserver} для соединения с удаленным @value{GDBN}, может также
выполнять @value{GDBN} локально!  Тем не менее, @code{gdbserver} иногда
полезен, так как по размеру эта программа гораздо меньше, чем
@value{GDBN}.  @code{gdbserver} также легче переносить, чем
весь @value{GDBN}, так что вы сможете быстрее начать работать в новой системе,
используя его.  Наконец, если вы разрабатываете программы для
систем реального времени, вы можете обнаружить, что накладные расходы,
связанные с операциями реального времени, делают более удобным
проведение всей возможной разработки на другой системе, например, с помощью
кросс-компиляции.  Вы можете использовать @code{gdbserver}, чтобы
реализовать аналогичный выбор для отладки.

@value{GDBN} и @code{gdbserver} общаются или через последовательную
линию, или через TCP-соединение, используя стандартный удаленный
последовательный протокол @value{GDBN}.

@table @emph
@item На целевой машине
вам необходимо иметь копию программы, которую вы хотите отладить.
@code{gdbserver} не нуждается в таблице символов вашей программы, так
что вы можете ее исключить, если необходимо сэкономить
пространство.  Всю обработку символов осуществляет @value{GDBN} на
рабочей машине.

Чтобы использовать сервер, вы должны сообщить ему, как взаимодействовать с
@value{GDBN}, имя вашей программы и ее аргументы.  Синтаксис следующий:

@smallexample
target> gdbserver @var{comm} @var{программа} [ @var{арг} @dots{} ]
@end smallexample

@var{comm} --- это или имя устройства (для использования последовательной линии),
или имя рабочей машины и номер порта TCP.  Например, для
отладки Emacs с параметром @samp{foo.txt} и взаимодействия с
@value{GDBN} через последовательный порт @file{/dev/com1}:

@smallexample
target> gdbserver /dev/com1 emacs foo.txt
@end smallexample

@code{gdbserver} пассивно ждет рабочего @value{GDBN} для связи с ним.

При использовании TCP-соединения вместо последовательной линии:

@smallexample
target> gdbserver host:2345 emacs foo.txt
@end smallexample

Единственное отличие от предыдущего примера состоит в первом параметре,
определяющем, что вы связываетесь с рабочим @value{GDBN} через TCP.
Параметр @samp{host:2345} означает, что @code{gdbserver} должен ожидать
TCP-соединение от машины @samp{host} к локальному порту TCP 2345. (В
настоящее время часть @samp{host} игнорируется.)  Вы можете выбрать
любой номер порта, какой захотите, если при этом он не конфликтует с
какими-либо портами TCP, уже использующимися на целевой системе
(например, @code{23} зарезервирован для @code{telnet}).@footnote{Если вы
выберете номер порта, который конфликтует с другим сервисом,
@code{gdbserver} печатает сообщение об ошибке и завершает работу.}  Вы
должны использовать тот же номер порта с командой рабочего @value{GDBN}
@code{target remote}.

@item На рабочей машине @value{GDBN}
вам нужна копия вашей программы с символьными данными, так как
@value{GDBN} нужна информация о символах и отладочная информация.
Запустите @value{GDBN} как обычно, используя имя локальной копии вашей
программы в качестве первого аргумента.  (Вам также может понадобиться
ключ @w{@samp{--baud}}, если последовательная линия работает на скорости,
отличной от 9600@dmn{бит/сек}.)  После этого, используйте @code{target remote},
чтобы установить связь с @code{gdbserver}.  Ее параметры --- либо
имя устройства (обычно последовательного устройства, такого как
@file{/dev/ttyb}), либо дескриптор порта TCP в форме
@code{@var{машина}:@var{порт}}.  Например:

@smallexample
(@value{GDBP}) target remote /dev/ttyb
@end smallexample

@noindent
взаимодействует с сервером через последовательную линию @file{/dev/ttyb}, а

@smallexample
(@value{GDBP}) target remote the-target:2345
@end smallexample

@noindent
взаимодействует через TCP-соединение с портом 2345 на рабочей машине
@w{@file{the-target}}.  Для TCP-соединения, вы должны запустить
@code{gdbserver} до использования команды @code{target remote}.  Иначе
вы можете получить ошибку, текст которой зависит от рабочей системы, но
обычно он выглядит примерно так: @samp{Connection refused}.
@end table

@node NetWare
@subsubsection Использование программы @code{gdbserve.nlm}

@kindex gdbserve.nlm
@code{gdbserve.nlm} --- это управляющая программа для систем NetWare,
которая позволяет вам установить соединение вашей программы с
удаленным @value{GDBN} посредством @code{target remote}.

@value{GDBN} и @code{gdbserve.nlm} общаются через последовательную линию,
используя стандартный удаленный последовательный протокол @value{GDBN}.

@table @emph
@item На целевой машине
вам необходимо иметь копию программы, которую вы хотите отладить.
@code{gdbserve.nlm} не нуждается в таблице символов вашей программы,
так что вы можете ее исключить, если необходимо сэкономить пространство.
@value{GDBN} осуществляет всю обработку символов на рабочей машине.

Чтобы использовать сервер, вы должны сообщить ему, как взаимодействовать с
@value{GDBN}, имя вашей программы и ее аргументы.  Синтаксис следующий:

@smallexample
load gdbserve [ BOARD=@var{плата} ] [ PORT=@var{порт} ]
              [ BAUD=@var{бод} ] @var{программа} [ @var{арг} @dots{} ]
@end smallexample

@var{Плата} и @var{порт} определяют последовательную линию; @var{бод}
определяет скорость в бодах, используемую соединением.  Значения
@var{порт} и @var{node} по умолчанию равны 0, @var{бод} по умолчанию
9600@dmn{бит/сек}.

Например, для отладки Emacs с параметром @samp{foo.txt} и взаимодействия
с @value{GDBN} через последовательный порт номер 2 на плате 1, используя
соединение 19200@dmn{бит/сек}:

@smallexample
load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt
@end smallexample

@item На рабочей машине @value{GDBN}
вам нужна копия вашей программы с символьными данными, так как
@value{GDBN} требуется символьная и отладочная информация.  Запустите
@value{GDBN} как обычно, используя имя локальной копии вашей программы в
качестве первого параметра.  (Вам также может понадобиться ключ
@w{@samp{--baud}}, если последовательная линия работает на скорости,
отличной от 9600@dmn{бит/сек}.)  После этого, используйте @code{target
remote} для установки связи с @code{gdbserve.nlm}.  Ее
аргумент --- имя устройства (обычно последовательного устройства,
такого как @file{/dev/ttyb}).  Например:

@smallexample
(@value{GDBP}) target remote /dev/ttyb
@end smallexample

@noindent
соединение с сервером через последовательную линию @file{/dev/ttyb}.
@end table

@node Отображение объектов ядра
@section Отображение объектов ядра

@cindex отображение объектов ядра
@cindex объект ядра

Некоторые цели поддерживают отображение объектов ядра.  При помощи этих
возможностей, @value{GDBN} взаимодействует непосредственно с
операционной системой и может выводить информацию об объектах уровня
операционной системы, например, о блокировках
и других объектах синхронизации.  Какие именно объекты могут быть
отображены, определяется в зависимости от конкретной ОС.

Используйте команду @code{set os}, чтобы установить тип операционной
системы.  Это говорит @value{GDBN}, какой модуль отображения объектов
ядра инициализировать:

@example
(@value{GDBP}) set os cisco
@end example

Если команда @code{set os} выполнится успешно, @value{GDBN} выведет
некоторую информацию об операционной системе и создаст новую команду
@code{info}, которая может быть использована для посылки запросов на
целевую машину.  Название команды @code{info} выбирается в зависимости
от операционной системы:

@example
(@value{GDBP}) info cisco
List of Cisco Kernel Objects
Object     Description
any        Any and all objects
@end example

Дальнейшие подкоманды могут использоваться для запросов о конкретных
объектах, информация о которых есть в ядре.

В настоящее время не существует другого способа определить,
поддерживается та или иная операционная система, кроме как попробовать.


@node Конфигурации
@chapter Информация о конфигурации

В то время как почти все команды @value{GDBN} доступны для всех чистых
и кросс-версий отладчика, существуют некоторые исключения.  Эта глава
описывает вещи, доступные только в определенных конфигурациях.

Существует три основные категории конфигураций: чистые конфигурации, где
рабочая и целевая машины совпадают, конфигурации для встроенных
операционных систем, которые обычно совпадают для нескольких различных
архитектур процессоров, и отдельные встроенные процессоры, которые
сильно отличаются друг от друга.

@menu
* Чистая::
* Встроенная ОС::
* Встроенные процессоры::
* Архитектуры::
@end menu

@node Чистая
@section Чистая конфигурация

Этот раздел описывает детали, специфичные для определенных чистых
конфигураций.

@menu
* HP-UX::                       HP-UX
* Информация о процессах SVR4:: Информация о процессах SVR4
@end menu

@node HP-UX
@subsection HP-UX

В системах HP-UX, если вы ссылаетесь на функцию или переменную, имя которой
начинается со знака доллара, @value{GDBN} сперва ищет имя пользователя
или системы, до поиска вспомогательной переменной.

@node Информация о процессах SVR4
@subsection Информация о процессах SVR4

@kindex /proc
@cindex образ процесса

Многие версии SVR4 предоставляют средства, называемые
@samp{/proc}, которые могут быть использованы для исследования образа
выполняемого процесса, задействуя подпрограммы файловой системы.  Если
@value{GDBN} сконфигурирован для операционной системы, поддерживающей
эти средства, команда @code{info proc} доступна для получения отчета
по некоторым видам информации о процессе, выполняющем вашу программу.
@code{info proc} работает только на системах SVR4, которые включают код
@code{procfs}.  Среди этих систем: OSF/1 (Digital Unix), Solaris,
Irix и Unixware, но не HP-UX или Linux, к примеру.
@c /// на Линуксе вроде есть прокфс -- ост

@table @code
@kindex info proc
@item info proc
Выдает доступную суммарную информацию о процессе.

@kindex info proc mappings
@item info proc mappings
Сообщает диапазоны адресов, доступных в программе, с информацией, может ли
ваша программа читать, записывать или исполнять каждый из диапазонов.

@kindex info proc times
@item info proc times
Время запуска, время пользовательского и системного ЦП для вашей
программы и ее потомков.

@kindex info proc id
@item info proc id
Сообщает информацию об идентификаторах процессов, относящихся к вашей
программе: ее собственный идентификатор, идентификатор ее родителя,
группы процесса и сеанса.

@kindex info proc status
@item info proc status
Общая информация о состоянии процесса.  Если процесс остановлен, то этот
отчет включает причину останова и любые полученные сигналы.

@item info proc all
Показывает всю вышеперечисленную информацию о процессе.
@end table

@node Встроенная ОС
@section Встроенные операционные системы

Этот раздел описывает конфигурации, задействующие отладку встроенных
операционных систем, которые доступны для нескольких различных архитектур.

@menu
* VxWorks::                     Использование @value{GDBN} с VxWorks
@end menu

@value{GDBN} включает возможность отлаживать программы, выполняющиеся в
различных операционных системах реального времени.

@node VxWorks
@subsection Использование @value{GDBN} с VxWorks

@cindex VxWorks

@table @code

@kindex target vxworks
@item target vxworks @var{имя-машины}
Система VxWorks, присоединенная посредством TCP/IP.  Аргумент
@var{имя-машины} есть имя или IP-адрес машины целевой системы.

@end table

На VxWorks, @code{load} компонует @var{имя-файла} динамически на текущей
целевой системе и добавляет ее символьную информацию в @value{GDBN}.

@value{GDBN} позволяет разработчикам запускать и отлаживать с Unix-машин
задачи, выполняющиеся на сетевых целях VxWorks.  Уже выполняющиеся
задачи, запущенные из оболочки VxWorks, также могут быть отлажены.
@value{GDBN} использует код, который может выполняться как на машине
Unix, так и на целевой машине VxWorks.  Программа @code{@value{GDBP}}
устанавливается и выполняется на Unix-машине.  (Она может быть
установлена под именем @code{vxgdb}, чтобы отличать ее от @value{GDBN}
для отладки программ на рабочей машине.)

@table @code
@item VxWorks-timeout @var{арг}
@kindex vxworks-timeout
Сейчас все цели, базирующиеся на VxWorks, поддерживают параметр
@code{vxworks-timeout}.  Этот параметр устанавливается пользователем, и
@var{арг} представляют число секунд, в течение которых @value{GDBN}
ожидает ответы
на вызовы удаленных процедур.  Вы можете использовать это, если ваша
целевая машина VxWorks является медленным программным эмулятором или
находится далеко на другом конце медленного сетевого соединения.
@end table

Следующая информация о соединении к VxWorks была свежей, когда
это руководство было написано; более новые выпуски VxWorks могут
использовать обновленные процедуры.

@kindex INCLUDE_RDB
Для использования @value{GDBN} с VxWorks, вы должны пересобрать ваше
ядро VxWorks, чтобы включить подпрограммы интерфейса удаленной отладки в
библиотеку VxWorks @file{rdb.a}.  Чтобы это сделать, определите
@code{INCLUDE_RDB} в конфигурационном файле VxWorks @file{configAll.h} и
пересоберите ядро VxWorks.  Получившееся ядро содержит @file{rdb.a} и
порождает задачу отладки исходного кода @code{tRdbTask}, когда VxWorks
загружается.  Для большей информации по конфигурированию и сборке
VxWorks, смотрите руководство изготовителя.

Когда вы включили @file{rdb.a} в образ вашей системы VxWorks и так
установили ваши пути поиска выполняемых файлов, чтобы можно было найти
@value{GDBN}, вы готовы к вызову отладчика.  Из вашей рабочей
Unix-машины, выполните @code{@value{GDBP}} (или @code{vxgdb}, в
зависимости от вашей установки).

@value{GDBN} появляется и показывает приглашение:

@example
(vxgdb)
@end example

@menu
* Соединение к VxWorks::        Соединение к VxWorks
* Загрузка на VxWorks::         Загрузка на VxWorks
* Присоединение к VxWorks::     Запуск задач
@end menu

@node Соединение к VxWorks
@subsubsection Соединение к VxWorks

Команда @value{GDBN} @code{target} позволяет вам соединяться с целевой
машиной VxWorks в сети.  Для соединения с целью по имени ``@code{tt}''
введите:

@example
(vxgdb) target vxworks tt
@end example

@need 750
@value{GDBN} покажет сообщения, аналогичные этим:

@smallexample
Attaching remote machine across net... 
Connected to tt.
@end smallexample

@need 1000
Затем @value{GDBN} пытается считать таблицы символов всех объектных
модулей, загруженных на целевой машине VxWorks с того момента, как она
была включена.  @value{GDBN} находит эти файлы путем поиска в
каталогах, перечисленных в путях поиска команд (@pxref{Среда, ,Рабочая
среда вашей программы}); если ему не удается найти объектный файл, он
выводит подобное сообщение:

@example
prog.o: No such file or directory.
@end example

Если это происходит, добавьте соответствующий каталог к путям поиска с
помощью команды @value{GDBN} @code{path} и выполните команду
@code{target} снова.

@node Загрузка на VxWorks
@subsubsection Загрузка на VxWorks

@cindex загрузка на VxWorks
Если вы соединились с целевой машиной VxWorks и хотите отладить объект,
который еще не был загружен, вы можете использовать команду @value{GDBN}
@code{load}, чтобы загрузить файл из Unix в VxWorks.  Объектный файл,
заданный в качестве аргумента к @code{load}, в действительности
открывается дважды: сначала целевой машиной VxWorks, чтобы загрузить код,
а затем @value{GDBN}, чтобы считать таблицу символов.  Это может
привести к проблемам, если текущие рабочие каталоги в этих системах
различаются.  Если обе системы монтируют по NFS одни и те же
файловые системы, вы можете избежать этих проблем, используя абсолютные
пути.  В противном случае, проще всего установить рабочий каталог на
обеих системах в тот, в котором расположен объектный файл, и затем
ссылаться на него по имени, без пути.  Например, программа
@file{prog.o} может находиться в @file{@var{vxpath}/vw/demo/rdb} на
VxWorks и в @file{@var{hostpath}/vw/demo/rdb} на рабочей машине.  Для
загрузки этой программы, введите в VxWorks следующее:

@example
-> cd "@var{vxpath}/vw/demo/rdb"
@end example

@noindent
Затем, в @value{GDBN}, введите:

@example
(vxgdb) cd @var{hostpath}/vw/demo/rdb
(vxgdb) load prog.o
@end example

@value{GDBN} отобразит ответ, аналогичный этому:

@smallexample
Reading symbol data from wherever/vw/demo/rdb/prog.o... done.
@end smallexample

Вы также можете использовать команду @code{load}, чтобы заново загрузить
объектный модуль после редактирования и повторной компиляции соответствующего
исходного файла.  Заметьте, что при этом @value{GDBN} удаляет все
определенные точки останова, автоматические отображения, вспомогательные
переменные и очищает историю значений.  (Это необходимо для того, чтобы
сохранить целостность структур данных отладчика, которые ссылаются
на таблицу символов целевой системы.)

@node Присоединение к VxWorks
@subsubsection Запуск задач

@cindex запуск задач VxWorks
Вы также можете присоединиться к существующей задаче, используя команду
@code{attach} следующим образом:

@example
(vxgdb) attach @var{задача}
@end example

@noindent
где @var{задача} является шестнадцатеричным идентификатором задачи
VxWorks.  Когда вы присоединяетесь к задаче, она может выполняться либо
быть приостановленной.  Выполняющаяся задача приостанавливается в момент
присоединения.

@node Встроенные процессоры
@section Встроенные процессоры

Этот раздел описывает детали, специфичные для определенных встроенных
конфигураций.

@menu
* Встроенный A29K::             Встроенный AMD A29K
* ARM::                         ARM
* H8/300::                      Hitachi H8/300
* H8/500::                      Hitachi H8/500
* i960::                        Intel i960
* M32R/D::                      Mitsubushi M32R/D
* M68K::                        Motorola M68K
* M88K::                        Motorola M88K
* Встроенный MIPS::             Встроенный MIPS
* PowerPC::                     PowerPC
* PA::                          Встроенный HP PA
* SH::                          Hitachi SH
* Sparclet::                    Tsqware Spacrlet
* Sparclite::                   Fujitsu Sparclite
* ST2000::                      Tandem ST2000
* Z8000::                       Zilog Z8000
@end menu

@node Встроенный A29K
@subsection Встроенный AMD A29K

@menu
* A29K UDI::
* A29K EB29K::
* Коммуникации (EB29K)::        Установка связи
* gdb-EB29K::                   Кросс-отладка EB29K
* Удаленный журнал::            Удаленный журнал
@end menu

@table @code

@kindex target adapt
@item target adapt @var{устр}
Монитор Adapt для A29K.

@kindex target amd-eb
@item target amd-eb @var{устр} @var{скорость} @var{прог}
@cindex AMD EB29K
Удаленная PC-резидентная плата AMD EB29K, присоединенная по
последовательным линиям.  @var{Устр} является последовательным
устройством, так же, как для @code{target remote}; @var{скорость}
позволяет вам указать скорость линии; а @var{прог} является именем
программы, которая будет отлаживаться, так, как оно появляется в ДОС на ПК.
@xref{A29K EB29K, ,Протокол EBMON для AMD29K}.

@end table

@node A29K UDI
@subsubsection A29K UDI

@cindex UDI
@cindex AMD29K через UDI

Для отладки процессоров семейства a29k, @value{GDBN} поддерживает
протокол AMD UDI (``Universal Debugger
Interface''@footnote{Универсальный отладочный интерфейс.  @i{(Прим.@:
переводчика)}}).  Для использования
этой конфигурации с целями AMD, на которых выполняется монитор MiniMON,
вам нужна программа @code{MONTIP}, доступная бесплатно у AMD.  Вы можете
также использовать @value{GDBN} с программой @code{ISSTIP},
UDI-совместимым эмулятором a29k, также доступным у AMD.

@table @code
@item target udi @var{кл-слово}
@kindex udi
Выбрать интерфейс UDI к удаленной плате a29k или эмулятору.  Здесь
@var{кл-слово} является элементом в конфигурационном файле AMD
@file{udi_soc}.  Этот файл содержит в качестве элементов ключевые слова,
которые определяют параметры, используемые при соединении к целям a29k.
Если файл @file{udi_soc} не находится в вашем рабочем каталоге, вы
должны установить путь к нему в переменной среды @samp{UDICONF}.
@end table

@node A29K EB29K
@subsubsection Протокол EBMON для AMD29K

@cindex плата EB29K
@cindex запуск программ 29K

AMD распространяет плату разработки 29K, предназначенную для помещения в
ПК, вместе с программой монитора @code{EBMON}, работающей в ДОС.  Коротко эта
система разработки называется ``EB29K''.  Чтобы использовать
@value{GDBN} из Unix-системы для выполнения программ на плате EB29K, вы
должны сперва соединить последовательным кабелем ПК (в котором
установлена плата EB29K) и последовательный порт на Unix-системе.  Далее
мы предполагаем, что вы соединили кабелем порт ПК @file{COM1} и
@file{/dev/ttya} на Unix-системе.

@node Коммуникации (EB29K)
@subsubsection Установка связи

Следующим шагом нужно установить параметры порта ПК, сделав в ДОС что-то
вроде этого:

@example
C:\> MODE com1:9600,n,8,1,none
@end example

@noindent
Этот пример, выполненный в системе MS DOS 4.0, устанавливает порт ПК в
9600@dmn{бит/сек}, без проверки четности, восьмибитные данные, один
стоп-бит и отсутствие действия для ``повтора''; вы должны использовать
те же параметры связи при установке соединения со стороны Unix.

Чтобы передать управление с ПК стороне Unix, введите следующее в консоли
ДОС:

@example
C:\> CTTY com1
@end example

@noindent
(Позже, если вы хотите вернуть управление консоли ДОС, вы можете
использовать команду @code{CTTY con} --- но вы должны послать ее через
устройство, имевшее управление, в нашем примере через последовательную
линию @file{COM1}.)

На Unix-машине, для связи с ПК используйте коммуникационную программу,
такую как @code{tip} или @code{cu}.  Например

@example
cu -s 9600 -l /dev/ttya
@end example

@noindent
Показанные ключи для @code{cu} определяют, соответственно, скорость
линии и последовательный порт.  Если вместо этого вы используете
@code{tip}, ваша командная строка может выглядеть следующим образом:

@example
tip -9600 /dev/ttya
@end example

@noindent
Ваша система может требовать другого имени в том месте, где мы
показываем @file{/dev/ttya} в качестве аргумента к @code{tip}.
Параметры связи, включая используемый порт, ассоциированы с аргументом к
@code{tip} в файле описаний ``remote'' --- обычно это @file{/etc/remote}.

@kindex EBMON
Используя соединение @code{tip} или @code{cu}, измените рабочий каталог
ДОС в тот, который содержит копию вашей программы 29K, затем запустите
на ПК программу @code{EBMON} (управляющая программа EB29K, поставляемая
AMD с вашей платой).  Вы должны увидеть начальный вывод @code{EBMON},
аналогичный следующему, заканчивающийся приглашением @code{EBMON}
@samp{#}:

@example
C:\> G:

G:\> CD \usr\joe\work29k

G:\USR\JOE\WORK29K> EBMON
Am29000 PC Coprocessor Board Monitor, version 3.0-18
Copyright 1990 Advanced Micro Devices, Inc.
Written by Gibbons and Associates, Inc.

Enter '?' or 'H' for help

PC Coprocessor Type   = EB29K
I/O Base              = 0x208
Memory Base           = 0xd0000

Data Memory Size      = 2048KB
Available I-RAM Range = 0x8000 to 0x1fffff
Available D-RAM Range = 0x80002000 to 0x801fffff

PageSize              = 0x400
Register Stack Size   = 0x800
Memory Stack Size     = 0x1800

CPU PRL               = 0x3
Am29027 Available     = No
Byte Write Available  = Yes

# ~.
@end example

Затем выйдите из программы @code{cu} или @code{tip} (в этом примере это
сделано при помощи ввода @code{~.} в приглашении @code{EBMON}).
@code{EBMON} продолжает работать, готовый к тому, что @value{GDBN}
перехватит управление.

Для этого примера, мы предположили, что существует соединение PC/NFS,
которое устанавливает файловую систему Unix-машины как ``диск
@file{G:}'' на ПК.  Это является, вероятно, самым удобным способом
удостовериться, что одна и та же программа 29K находится и на ПК, и в
Unix-системе.  Если у вас нет PC/NFS или чего-нибудь аналогичного,
соединяющего две системы, вы должны прибегнуть к другому
способу передачи программы 29K из Unix на ПК --- возможно переписать ее на
дискету.  @value{GDBN} @emph{не} загружает программы по последовательной
линии.

@node gdb-EB29K
@subsubsection Кросс-отладка EB29K

Наконец, перейдите в каталог, содержащий образ вашей программы 29K в
Unix-системе, и запустите @value{GDBN}, указав имя программы в качестве
аргумента:

@example
cd /usr/joe/work29k
@value{GDBP} myfoo
@end example

@need 500
Теперь вы можете использовать команду @code{target}:

@example
target amd-eb /dev/ttya 9600 MYFOO
@c FIXME: test above 'target amd-eb' as spelled, with caps!  caps are meant to
@c emphasize that this is the name as seen by DOS (since I think DOS is
@c single-minded about case of letters).  ---doc@cygnus.com, 25feb91
@end example

@noindent
В этом примере мы предполагали, что ваша программа находится в файле
@file{myfoo}.  Заметьте, что имя файла, заданное в качестве последнего
аргумента к @code{target amd-eb}, должно быть таким, каким его видит
ДОС.  В нашем примере, это просто @code{MYFOO}, но вообще оно может
включать путь ДОС, и, в зависимости от механизма передачи, может быть
не похоже на имя на Unix-машине.

В этом месте вы можете установить желаемые точки останова; когда вы
будете готовы увидеть вашу программу выполняющейся на плате 29K,
используйте команду @value{GDBN} @code{run}.

Чтобы остановить отладку удаленной программы, используйте команду
@value{GDBN} @code{detach}.

Чтобы возвратить управление консоли ПК, используйте @code{tip} или
@code{cu} снова, после завершения вашего сеанса @value{GDBN}, чтобы
присоединиться к @code{EBMON}.  Затем вы можете ввести команду @code{q},
чтобы завершить работу @code{EBMON}, возвращая управление командному
интерпретатору ДОС.  Введите @kbd{CTTY con}, чтобы возвратить командный
ввод основной консоли ДОС, и введите @kbd{~.}, чтобы покинуть @code{tip}
или @code{cu}.

@node Удаленный журнал
@subsubsection Удаленный журнал
@cindex @file{eb.log}, журнальный файл для EB29K
@cindex журнальный файл для EB29K

Команда @code{target amd-eb} создает в текущем рабочем каталоге файл
@file{eb.log}, чтобы помочь отладить проблемы с соединением.
@file{eb.log} записывает весь вывод @file{EBMON}, включая эхо
посланных ему команд.  Выполнение @samp{tail -f} для этого файла в другом
окне часто помогает понять проблемы с @code{EBMON} или неожиданные
события на стороне ПК.

@node ARM
@subsection ARM

@table @code

@kindex target rdi
@item target rdi @var{устр}
Монитор ARM Angel, через интерфейс библиотеки RDI к протоколу ADP.  Вы
можете использовать эту цель для взаимодействия как с платами, на
которых выполняется монитор Angel, так и с устройством отладки
EmbeddedICE JTAG.

@kindex target rdp
@item target rdp @var{устр}
Монитор ARM Demon.

@end table

@node H8/300
@subsection Hitachi H8/300

@table @code

@kindex target hms@r{, с H8/300}
@item target hms @var{устр}
Плата Hitachi SH, H8/300 или H8/500, присоединенная через
последовательную линию к вашей машине.  Используйте специальные команды
@code{device} и @code{speed} для управления последовательной линией и
используемой скоростью связи.

@kindex target e7000@r{, с H8/300}
@item target e7000 @var{устр}
Эмулятор E7000 для Hitachi H8 и SH.

@kindex target sh3@r{, с H8/300}
@kindex target sh3e@r{, с H8/300}
@item target sh3 @var{устр}
@itemx target sh3e @var{устр}
Целевые системы Hitachi SH-3 и SH-3E.

@end table

@cindex загрузка на H8/300 или H8/500
@cindex H8/300 или H8/500, загрузка на
@cindex загрузка на Hitachi SH
@cindex Hitachi SH, загрузка на
Когда вы выбираете удаленную отладку для платы Hitachi SH, H8/300 или
H8/500, команда @code{load} загружает вашу программу на плату Hitachi, а
также открывает ее как текущую выполняемую цель для @value{GDBN} на
вашей машине (как команда @code{file}).

Для общения с Hitachi SH, H8/300 или H8/500, @value{GDBN}
необходимо знать следующие вещи:

@enumerate
@item
Что вы хотите использовать: @samp{target hms}, удаленный отладочный
интерфейс для микропроцессоров Hitachi, или @samp{target e7000},
встроенный эмулятор для Hitachi SH и Hitachi 300H.  (@samp{target hms}
используется по умолчанию, если @value{GDBN} сконфигурирован специально
для Hitachi SH, H8/300 или H8/500.)

@item
Какое последовательное устройство соединяет вашу машину с платой Hitachi
(по умолчанию используется первое последовательное устройство, доступное
на вашей машине).

@item
Какую скорость использовать для этого последовательного устройства.
@end enumerate

@menu
* Платы Hitachi::            Соединение с платами Hitachi.
* Hitachi ICE::              Использование встроенного эмулятора E7000.
* Специально для Hitachi::   Специальные команды @value{GDBN} для Hitachi.
@end menu

@node Платы Hitachi
@subsubsection Соединение с платами Hitachi

@c only for Unix hosts
@kindex device
@cindex последовательное устройство, микропроцессоры Hitachi
Используйте специальную команду @value{GDBN} @samp{device @var{порт}},
если вам нужно явно установить последовательное устройство.  По
умолчанию используется первый @var{порт}, доступный на вашей машине.
Это необходимо только на Unix-машинах, где это обычно что-то типа
@file{/dev/ttya}.

@kindex speed
@cindex скорость последовательной линии, микропроцессоры Hitachi
@value{GDBN} имеет другую специальную команду для установки скорости
связи: @samp{speed @var{bps}}.  Эта команда также используется только на
Unix-машинах; в ДОС, устанавливайте скорость линии как обычно извне
@value{GDBN} командой @code{mode} (например,
@w{@kbd{mode com2:9600,n,8,1,p}} для соединения 9600@dmn{бит/сек}.

Команды @samp{device} и @samp{speed} доступны для отладки программ
микропроцессора Hitachi, только если вы используете рабочую среду Unix.
Если вы используете ДОС, для взаимодействия с платой разработки через
последовательный порт ПК @value{GDBN} полагается на вспомогательную
резидентную программу @code{asynctsr}.  Вы также должны использовать
команду ДОС @code{mode}, чтобы подготовить порт со стороны ДОС.

Следующий пример сеанса иллюстрирует шаги, необходимые для запуска
программы на H8/300 под управлением @value{GDBN}.  В нем используется
программа H8/300 под названием @file{t.x}.  Для Hitachi SH и H8/500
процедура та же самая.

Сперва подсоедините вашу плату разработки.  В этом примере, мы
используем плату, присоединенную к порту @code{COM2}.  Если вы
используете другой последовательный порт, подставьте его имя в аргументе
команды @code{mode}.  Когда вы вызываете @code{asynctsr},
вспомогательную программу связи, используемую отладчиком, вы передаете
ей только числовую часть имени последовательного порта; например, ниже
@samp{asynctsr 2} запускает @code{asynctsr} для @code{COM2}.

@example
C:\H8300\TEST> asynctsr 2
C:\H8300\TEST> mode com2:9600,n,8,1,p

Resident portion of MODE loaded

COM2: 9600, n, 8, 1, p

@end example

@quotation
@emph{Предупреждение:} Мы обнаружили ошибку в PC-NFS, которая
конфликтует с @code{asynctsr}.  Если вы также используете PC-NFS на
вашей ДОС-машине, вам может потребоваться отключить его или даже
загрузить машину без него, чтобы использовать @code{asynctsr} для
управления отладочной платой.
@end quotation

@kindex target hms@r{ и последовательный протокол}
Теперь, когда связь установлена, и плата разработки присоединена, вы
можете запустить @value{GDBN}.  Вызовите @code{@value{GDBP}} с именем
вашей программы в качестве аргумента.  @value{GDBN} выводит
обычное приглашение: @samp{(@value{GDBP})}.  Используйте две специальные
команды для начала сеанса отладки: @samp{target hms} для задания
кросс-отладки для платы Hitachi и команду @code{load} для загрузки вашей
программы на нее.  @code{load} выводит имена разделов программы и
@samp{*} для каждых двух килобайт загруженных данных.  (Если вы хотите
обновить данные @value{GDBN} для символов или для выполняемого файла без
загрузки, используйте команды @value{GDBN} @code{file} или
@code{symbol-file}.  Для описания этих команд, равно как и самой команды
@code{load}, см. @ref{Файлы,,Команды для задания файлов}.)

@smallexample
(eg-C:\H8300\TEST) @value{GDBP} t.x
@value{GDBN} is free software and you are welcome to distribute copies
 of it under certain conditions; type "show copying" to see
 the conditions.
There is absolutely no warranty for @value{GDBN}; type "show warranty"
for details.
@value{GDBN} @value{GDBVN}, Copyright 1992 Free Software Foundation, Inc...
(@value{GDBP}) target hms
Connected to remote H8/300 HMS system.
(@value{GDBP}) load t.x
.text   : 0x8000 .. 0xabde ***********
.data   : 0xabde .. 0xad30 *
.stack  : 0xf000 .. 0xf014 *
@end smallexample

Теперь вы готовы выполнять или отлаживать вашу программу.  С этого
момента вы можете использовать все обычные команды @value{GDBN}.  Команда
@code{break} устанавливает точки останова; @code{run} запускает вашу
программу; @code{print} или @code{x} отображает данные; команда
@code{continue} возобновляет выполнение после остановки в точке
останова.  Вы можете использовать команду @code{help} в любой момент,
чтобы узнать больше о командах @value{GDBN}.

Помните, однако, что возможности @emph{операционной системы} недоступны
на вашей плате разработки; например, если ваша программа зависает, вы
не можете послать сигнал прерывания --- но можете нажать кнопку @sc{reset}!

Используйте кнопку @sc{reset} на вашей плате разработки
@itemize @bullet
@item
чтобы прервать вашу программу (не используйте @kbd{ctl-C} на машине с
ДОС --- у нее нет способа передать сигнал прерывания на плату разработки); и

@item
для возврата к приглашению @value{GDBN} после того, как ваша программа
нормально завершается.  Протокол связи не предусматривает другого способа
для @value{GDBN} определить, что ваша программа завершилась.
@end itemize

В любом случае, @value{GDBN} видит результат нажатия @sc{reset} на плате
разработки как ``нормальное завершение'' вашей программы.

@node Hitachi ICE
@subsubsection Использование встроенного эмулятора E7000

@kindex target e7000@r{, c Hitachi ICE}
Вы можете использовать встроенный эмулятор E7000 для разработки кода либо
для Hitachi SH, либо для H8/300H.  Используйте одну из этих форм команды
@samp{target e7000} для соединения @value{GDBN} с вашей E7000:

@table @code
@item target e7000 @var{порт} @var{скорость}
Используйте эту форму, если ваша E7000 присоединена к последовательному
порту.  Аргумент @var{порт} идентифицирует, какой последовательный порт
использовать (например, @samp{com2}).  Третий аргумент является
скоростью линии в битах в секунду (например, @samp{9600}).

@item target e7000 @var{имя-узла}
Если ваша E7000 установлена как узел сети TCP/IP, вы можете просто
указать его имя; @value{GDBN} использует для соединения @code{telnet}.
@end table

@node Специально для Hitachi
@subsubsection Специальные команды @value{GDBN} для Hitachi

Некоторые команды @value{GDBN} доступны только для H8/300:

@table @code

@kindex set machine
@kindex show machine
@item set machine h8300
@itemx set machine h8300h
Настраивайте @value{GDBN} на один из двух вариантов архитектур H8/300 с
помощью @samp{set machine}.  Вы можете использовать @samp{show machine},
чтобы проверить, какой из вариантов действует в данный момент.

@end table

@node H8/500
@subsection H8/500

@table @code

@kindex set memory @var{мод}
@cindex модели памяти, H8/500
@item set memory @var{мод}
@itemx show memory
Укажите, какую модель памяти H8/500 (@var{мод}) вы используете с помощью
@samp{set memory}; проверяйте, какая модель используется при помощи
@samp{show memory}.  Допустимыми значениями для @var{мод} являются
@code{small}, @code{big}, @code{medium} и @code{compact}.

@end table

@node i960
@subsection Intel i960

@table @code

@kindex target mon960
@item target mon960 @var{устр}
Монитор MON960 для Intel i960.

@kindex target nindy
@item target nindy @var{имя-устр}
Плата Intel 960, управляемая Nindy Monitor.  @var{Имя-устр} является
именем последовательного устройства, которое должно использоваться для
соединения, например @file{/dev/ttya}.

@end table

@cindex Nindy
@cindex i960
@dfn{Nindy} --- это программа ROM Monitor для целевых систем Intel 960.
Когда @value{GDBN} сконфигурирован для управления удаленным Intel 960 с
использованием Nindy, вы можете указать ему, как присоединиться к 960
несколькими способами:

@itemize @bullet
@item
Указав последовательный порт, версию протокола Nindy и скорость связи
через ключи командной строки;

@item
Ответив на запрос при старте;

@item
Используя команду @code{target} в любом месте вашего сеанса
@value{GDBN}.  @xref{Команды для целей, ,Команды для управления целями}.

@end itemize

@cindex загрузка на Nindy-960
С интерфейсом Nindy к плате Intel 960, команда @code{load} загружает
@var{имя-файла} на 960, а также добавляет его символьные данные в
@value{GDBN}.

@menu
* Вызов Nindy::                 Вызов Nindy
* Параметры Nindy::             Параметры для Nindy
* Сброс Nindy::                 Команда сброса Nindy
@end menu

@node Вызов Nindy
@subsubsection Вызов Nindy

Если вы просто запустите @code{@value{GDBP}} без использования ключей
командной строки, у вас запросят, какой последовательный порт
использовать, @emph{до} того, как вы получите обычное приглашение
@value{GDBN}:

@example
Attach /dev/ttyNN -- specify NN, or "quit" to quit:
@end example

@noindent
Ответьте на запрос с любым суффиксом (после @samp{/dev/tty}),
определяющим последовательный порт, который вы хотите использовать.  Вы
можете, по своему выбору, просто начать работу без соединения с
Nindy, ответив на приглашение пустой строкой.  Если вы сделаете это и позже
захотите присоединиться к Nindy, используйте @code{target}
(@pxref{Команды для целей, ,Команды для управления целями}).

@node Параметры Nindy
@subsubsection Параметры для Nindy

Вот параметры вызова для начала вашего сеанса @value{GDBN} с подключенной
платой Nindy-960:

@table @code
@item -r @var{порт}
Задайте имя порта последовательного интерфейса, который должен
использоваться для соединения с целевой системой.  Этот ключ доступен,
только когда @value{GDBN} сконфигурирован для целевой архитектуры Intel
960.  Вы можете определить @var{порт} любым из следующих способов:
полный путь (например, @samp{-r /dev/ttya}), имя устройства в
@file{/dev} (например, @samp{-r ttya}) или просто уникальный суффикс для
определенного @code{tty} (например, @samp{-r a}).

@item -O
(Заглавная буква ``O'', не ноль.)  Определяет, что @value{GDBN}
должен использовать ``старый'' протокол монитора Nindy для
соединения с целевой системой.  Этот ключ доступен, только когда
@value{GDBN} сконфигурирован для целевой архитектуры Intel 960.

@quotation
@emph{Предупреждение:} если вы определите @samp{-O}, но в
действительности попытаетесь связаться с системой, которая
ожидает более нового протокола, соединение не будет установлено, как
будто не соответствуют скорости.  @value{GDBN} неоднократно пытается
соединиться снова на нескольких различных скоростях линии.  Вы можете
остановить этот процесс посредством прерывания.
@end quotation

@item -brk
Определяет, что @value{GDBN} должен сперва послать целевой системе
сигнал @code{BREAK}, пытаясь сбросить ее, перед соединением с целью
Nindy.

@quotation
@emph{Предупреждение:} Многие целевые системы не имеют требуемых
для этого аппаратных средств; это работает только на некоторых платах.
@end quotation
@end table

Стандартный ключ @samp{-b} управляет скоростью линии, используемой на
последовательном порту.

@node Сброс Nindy
@subsubsection Команда сброса Nindy

@table @code
@item reset
@kindex reset
Для целей Nindy, эта команда посылает ``break'' удаленной целевой
системе; она полезна, только если целевая система была оборудована
схемой для выполнения аппаратного сброса (или других действий,
представляющих интерес) при обнаружении прерывания.
@end table

@node M32R/D
@subsection Mitsubishi M32R/D

@table @code

@kindex target m32r
@item target m32r @var{устр}
Монитор ROM Mitsubishi M32R/D.

@end table

@node M68K
@subsection M68k

Конфигурация Motorola m68k включает поддержку ColdFire и команду
@code{target} для следующих мониторов ROM.

@table @code

@kindex target abug
@item target abug @var{устр}
Монитор ABug ROM для M68K.

@kindex target cpu32bug
@item target cpu32bug @var{устр}
Монитор CPU32BUG, выполняющийся на плате CPU32 (M68K).

@kindex target dbug
@item target dbug @var{устр}
Монитор dBUG ROM для Motorola ColdFire.

@kindex target est
@item target est @var{устр}
Монитор EST-300 ICE, выполняющийся на плате CPU32 (M68K).

@kindex target rom68k
@item target rom68k @var{устр}
Монитор ROM 68K, выполняющийся на плате M68K IDP.

@end table

Если @value{GDBN} сконфигурирован с @code{m68*-ericsson-*}, то вместо
этого у него будет только одна специальная команда @code{target}:

@table @code

@kindex target es1800
@item target es1800 @var{устр}
Эмулятор ES-1800 для M68K.

@end table

@c [context?]

@table @code

@kindex target rombug
@item target rombug @var{устр}
Монитор ROMBUG ROM для OS/9000.

@end table

@node M88K
@subsection M88K

@table @code

@kindex target bug
@item target bug @var{устр}
Монитор BUG, выполняющийся на плате MVME187 (m88k).

@end table

@node Встроенный MIPS
@subsection Встроенный MIPS

@cindex MIPS
@value{GDBN} может использовать удаленный отладочный протокол MIPS для
взаимодействия с платой MIPS, присоединенной к последовательной линии.
Эта возможность доступна, если вы сконфигурировали @value{GDBN} с
@samp{--target=mips-idt-ecoff}.

@need 1000
Используйте эти команды @value{GDBN} для определения соединения с вашей
целевой платой:

@table @code
@item target mips @var{порт}
@kindex target mips @var{порт}
Для выполнения программы на плате, выполните @code{@value{GDBP}}, задав
имя программы в качестве аргумента.  Для соединения с платой,
используйте команду @samp{target mips @var{порт}}, где @var{порт} --- имя
последовательного порта, присоединенного к плате.  Если программа еще не
была загружена на плату, вы можете использовать команду @code{load},
чтобы это сделать.  Затем вы можете использовать все обычные команды
@value{GDBN}.

Например, эта последовательность команд устанавливает соединение к
целевой плате через последовательный порт, загружает и начинает
выполнение из отладчика программы с именем @var{prog}:

@example
host$ @value{GDBP} @var{prog}
@value{GDBN} is free software and @dots{}
(@value{GDBP}) target mips /dev/ttyb
(@value{GDBP}) load @var{prog}
(@value{GDBP}) run
@end example

@item target mips @var{имя-машины}:@var{номер-порта}
В некоторых рабочих конфигурациях @value{GDBN}, вы можете задать
TCP-соединение (например, к последовательной линии, управляемой
терминальным концентратором) вместо последовательного порта, используя
синтаксис @samp{@var{имя-машины}:@var{номер-порта}}.

@item target pmon @var{порт}
@kindex target pmon @var{порт}
Монитор ROM PMON.

@item target ddb @var{порт}
@kindex target ddb @var{порт}
NEC DDB-разновидность PMON для Vr4300.

@item target lsi @var{порт}
@kindex target lsi @var{порт}
LSI-разновидность PMON.

@kindex target r3900
@item target r3900 @var{устр}
Densan DVE-R3900 монитор ROM для Toshiba R3900 Mips.

@kindex target array
@item target array @var{устр}
Плата контроллера RAID Array Tech LSI33K.

@end table

@noindent
@value{GDBN} также поддерживает следующие специальные команды для целей
MIPS:

@table @code
@item set processor @var{арг}
@itemx show processor
@kindex set processor @var{арг}
@kindex show processor
Используйте команду @code{set processor} для установки типа процессора
MIPS, когда вы хотите обратиться к регистрам, уникальным для данного
типа процессора.  Например, @code{set processor @var{r3041}} велит
@value{GDBN} использовать регистры ЦП, соответствующие микросхеме
3041.  Используйте команду @code{show processor}, чтобы узнать, какой
процессор MIPS используется @value{GDBN}.  Используйте команду
@code{info reg} чтобы узнать, какие регистры использует @value{GDBN}.

@item set mipsfpu double
@itemx set mipsfpu single
@itemx set mipsfpu none
@itemx show mipsfpu
@kindex set mipsfpu
@kindex show mipsfpu
@cindex плавающая точка, удаленный MIPS
Если ваша целевая плата не поддерживает сопроцессор MIPS для вычислений
с плавающей точкой, вы должны использовать команду @samp{set mipsfpu
none} (если вам это нужно, вы можете поместить эту команду в ваш
файл инициализации @value{GDBN}).
Это говорит @value{GDBN}, как найти значения
функций, которые возвращают величины с плавающей точкой.  Это также
позволяет @value{GDBN} избежать сохранения регистров с плавающей точкой
при вызове функций на плате.  Если вы используете сопроцессор поддержки
вычислений с плавающей точкой с поддержкой только одинарной точности,
как на процессоре @sc{r4650}, используйте команду @samp{set mipsfpu
single}.  По умолчанию используется сопроцессор поддержки вычислений с
плавающей точкой двойной точности; этот режим может быть выбран с
помощью @samp{set mipsfpu double}.

В предыдущих версиях, единственным выбором была двойная точность или
отсутствие поддержки вычислений с плавающей точкой, так что @samp{set
mipsfpu on} выберет режим двойной точности, а @samp{set mipsfpu off}
отключит эту поддержку.

Как обычно, вы можете запросить значение переменной @code{mipsfpu} при
помощи @samp{show mipsfpu}.

@item set remotedebug @var{n}
@itemx show remotedebug
@kindex set remotedebug@r{, протокол MIPS}
@kindex show remotedebug@r{, протокол MIPS}
@cindex @code{remotedebug}, протокол MIPS
@cindex протокол MIPS @code{remotedebug}
Вы можете увидеть некоторую отладочную информацию о связи с
платой, установив переменную @code{remotedebug}.  Если вы установите ее
в @code{1} при помощи @samp{set remotedebug 1}, будет отображаться
каждый пакет.  Если вы установите ее в @code{2}, то будет отображаться
каждый знак.  В любой момент вы можете проверить текущее значение
переменной командой @samp{show remotedebug}.

@item set timeout @var{секунды}
@itemx set retransmit-timeout @var{секунды}
@itemx show timeout
@itemx show retransmit-timeout
@cindex @code{timeout}, протокол MIPS
@cindex @code{retransmit-timeout}, протокол MIPS
@kindex set timeout
@kindex show timeout
@kindex set retransmit-timeout
@kindex show retransmit-timeout
Вы можете управлять временем ожидания пакета, используемым в удаленном
протоколе MIPS, при помощи команды @code{set timeout @var{секунды}}.
Значение по умолчанию --- 5 секунд.  Аналогично, вы можете управлять
временем ожидания, используемым при ожидании подтверждения пакета с
помощью команды @code{set retransmit-timeout @var{секунды}}.  По
умолчанию 3 секунды.  Вы можете узнать обе эти величины с помощью
@code{show timeout} и @code{show retransmit-timeout}.  (Эти команды
доступны, @emph{только} если @value{GDBN} сконфигурирован для цели
@samp{--target=mips-idt-ecoff}.)

Время ожидания, установленное при помощи @code{set timeout}, не играет
роли, когда @value{GDBN} ожидает остановки вашей программы.  В этом
случае @value{GDBN} ждет бесконечно, потому что у него нет способа
узнать, сколько программа будет выполняться, пока не остановится.
@end table

@node PowerPC
@subsection PowerPC

@table @code

@kindex target dink32
@item target dink32 @var{устр}
Монитор ROM DINK32.

@kindex target ppcbug
@item target ppcbug @var{устр}
@kindex target ppcbug1
@item target ppcbug1 @var{устр}
Монитор ROM PPCBUG для PowerPC.

@kindex target sds
@item target sds @var{устр}
Монитор SDS, выполняющийся на плате PowerPC (такой как Motorola ADS).

@end table

@node PA
@subsection Встроенный HP PA

@table @code

@kindex target op50n
@item target op50n @var{устр}
Монитор OP50N, выполняющийся на плате OKI HPPA.

@kindex target w89k
@item target w89k @var{устр}
Монитор W89K, выполняющийся на плате Winbond HPPA.

@end table

@node SH
@subsection Hitachi SH

@table @code

@kindex target hms@r{, с Hitachi SH}
@item target hms @var{устр}
Плата Hitachi SH, присоединенная через последовательную линию к вашей
рабочей машине.  Используйте специальные команды @code{device} и
@code{speed} для управления последовательной линией и используемой
скоростью связи.

@kindex target e7000@r{, с Hitachi SH}
@item target e7000 @var{устр}
Эмулятор E7000 для Hitachi SH.

@kindex target sh3@r{, с SH}
@kindex target sh3e@r{, с SH}
@item target sh3 @var{устр}
@item target sh3e @var{устр}
Целевые системы Hitachi SH-3 и SH-3E.

@end table

@node Sparclet
@subsection Tsqware Sparclet

@cindex Sparclet

@value{GDBN} позволяет разработчикам отлаживать с Unix-машины задачи,
выполняющиеся на целевых системах Sparclet.  @value{GDBN} использует код,
который выполняется как на Unix-машине, так и на цели Sparclet.  Программа
@code{@value{GDBP}} устанавливается и работает на Unix-машине.

@table @code
@item remotetimeout @var{арг}
@kindex remotetimeout
@value{GDBN} поддерживает параметр @code{remotetimeout}.  Он
устанавливается пользователем, а @var{арг} представляет число секунд, в
течение которых @value{GDBN} ожидает ответы.
@end table

@cindex компиляция, на Sparclet
При компиляции для отладки, используйте ключи @samp{-g} для получения
отладочной информации и @samp{-Ttext} для того, чтобы разместить
программу в том месте, в каком вы хотите загрузить ее на целевую
машину.  Вы также можете добавить ключ @samp{-n} или @samp{-N},
чтобы уменьшить размеры разделов.  Например:

@example
sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N
@end example

Чтобы проверить, что адреса в действительности являются теми, которые вы
подразумевали, можно использовать @code{objdump}:

@example
sparclet-aout-objdump --headers --syms prog
@end example

@cindex выполнение, на Sparclet
После того, как вы установили путь поиска выполняемых файлов, в котором
присутствует @value{GDBN}, вы готовы запустить отладчик.  С вашей
рабочей машины Unix выполните @code{@value{GDBP}} (или
@code{sparclet-aout-gdb}, в зависимости от вашей установки).

@value{GDBN} запустится и покажет приглашение:

@example
(gdbslet)
@end example

@menu
* Файл Sparclet::                Установка файла для отладки
* Соединение к Sparclet::        Соединение к Sparclet
* Загрузка на Sparclet::         Загрузка на Sparclet
* Выполнение Sparclet::          Выполнение и отладка
@end menu

@node Файл Sparclet
@subsubsection Установка файла для отладки

Команда @value{GDBN} @code{file} позволяет вам выбрать программу для
отладки.

@example
(gdbslet) file prog
@end example

@need 1000
Затем @value{GDBN} пытается прочитать таблицу символов программы
@file{prog}.  Он находит файл путем поиска в каталогах, перечисленных в
пути поиска команд.  Если файл был скомпилирован с отладочной
информацией (ключ @samp{-g}), то также будет произведен поиск исходных
файлов.  @value{GDBN} находит исходные файлы, производя поиск в
каталогах, перечисленных в пути поиска каталогов (@pxref{Среда, ,Рабочая
среда вашей программы}).  Если ему не удается найти файл, он выводит
сообщение, подобное этому:

@example
prog: No such file or directory.
@end example

Когда это случается, добавьте соответствующие каталоги в пути поиска с
помощью команд @value{GDBN} @code{path} и @code{dir} и выполните
команду @code{target} снова.

@node Соединение к Sparclet
@subsubsection Соединение к Sparclet

Команда @value{GDBN} @code{target} позволяет вам установить
соединение с целевой машиной Sparclet.  Для соединения с
последовательным портом ``@code{ttya}'', введите:

@example
(gdbslet) target sparclet /dev/ttya
Remote target sparclet connected to /dev/ttya
main () at ../prog.c:3
@end example

@need 750
@value{GDBN} выведет сообщение, подобное этому:

@example
Connected to ttya.
@end example

@node Загрузка на Sparclet
@subsubsection Загрузка на Sparclet

@cindex загрузка на Sparclet
Когда вы установили соединение к цели Sparclet, вы можете использовать
команду @value{GDBN} @code{load} для загрузки файла с рабочей машины на
целевую.  Имя файла и смещение загрузки должно быть задано команде
@code{load} в качестве аргумента.  Поскольку это файл в формате a.out, программа
должна быть загружена по начальному адресу.  Чтобы определить, чему
равна эта величина, вы можете использовать @code{objdump}.  Смещение
загрузки --- это смещение, которое добавляется к VMA (Virtual Memory
Address@footnote{Виртуальный адрес памяти  @i{(Прим.@: переводчика)}})
каждого раздела файла.
Например, если программа @file{prog} была скомпонована с адресом текста
0x1201000, сегментом данных по адресу 0x12010160 и сегментом стека по
адресу 0x12010170, введите в @value{GDBN}:

@example
(gdbslet) load prog 0x12010000
Loading section .text, size 0xdb0 vma 0x12010000
@end example

Если код загружается по адресу, отличному от того, по которому программа
была скомпонована, вам может потребоваться использовать команды
@code{section} и @code{add-symbol-file}, чтобы сообщить @value{GDBN},
куда отобразить таблицу символов.

@node Выполнение Sparclet
@subsubsection Выполнение и отладка

@cindex выполнение и отладка программ Sparclet
Теперь вы можете начать отлаживать задачу, используя команды
@value{GDBN} для управления выполнением, @code{b}, @code{step},
@code{run} и так далее.  Все такие команды перечислены в этом
руководстве.

@example
(gdbslet) b main
Breakpoint 1 at 0x12010000: file prog.c, line 3.
(gdbslet) run
Starting program: prog
Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
3        char *symarg = 0;
(gdbslet) step
4        char *execarg = "hello!";
(gdbslet)
@end example

@node Sparclite
@subsection Fujitsu Sparclite

@table @code

@kindex target sparclite
@item target sparclite @var{устр}
Платы Fujitsu sparclite, используемые только с целью загрузки.  Чтобы
отлаживать программу, вы должны использовать дополнительную команду.
Например, @code{target remote @var{устр}}, используя стандартный удаленный
протокол @value{GDBN}.

@end table

@node ST2000
@subsection Tandem ST2000

@value{GDBN} может быть использован с телефонным коммутатором Tandem
ST2000, поддерживающим протокол Tandem STDBUG.

Чтобы узнать, как соединить ST2000 с рабочей машиной, смотрите
руководство производителя.  После того как ST2000 физически подключен,
вы можете выполнить:

@example
target st2000 @var{устр} @var{скорость}
@end example

@noindent
чтобы установить его как вашу отладочную среду.  @var{Устр} --- это обычно
имя последовательного устройства, такое как @file{/dev/ttya},
соединенного с ST2000 через последовательную линию.  Вместо этого, вы
можете указать @var{устр} как TCP-соединение (например, к
последовательной линии, присоединенной через терминальный концентратор),
используя синтаксис @code{@var{имя-машины}:@var{номер-порта}}.

Команды @code{load} и @code{attach} @emph{не} определены для этой цели;
вы должны загрузить вашу программу на ST2000 так же, как вы это обычно
делаете для автономных действий.  @value{GDBN} читает отладочную
информацию (например, символы) из отдельной, отладочной версии
программы, которая доступна на вашем рабочем компьютере.

@cindex вспомогательные команды ST2000
Следующие вспомогательные команды @value{GDBN} доступны для облегчения
работы в среде ST2000:

@table @code
@item st2000 @var{команда}
@kindex st2000 @var{ком}
@cindex команды STDBUG (ST2000)
@cindex команды для STDBUG (ST2000)
Послать @var{команду} монитору STDBUG.  Доступные команды описаны в
руководстве производителя.

@item connect
@cindex соединение (с STDBUG)
Соединяет управляющий терминал с командным монитором STDBUG.  Когда вы
закончили взаимодействие с STDBUG, ввод одной из двух
последовательностей знаков возвратит вас назад к приглашению
@value{GDBN}: @kbd{@key{RET}~.} (Return, за которым следует тильда и
точка) или @kbd{@key{RET}~@key{C-d}} (Return, за которым следует тильда
и control-D).
@end table

@node Z8000
@subsection Zilog Z8000

@cindex Z8000
@cindex имитатор, Z8000
@cindex Zilog Z8000, имитатор

Будучи сконфигурированным для отладки целей Zilog Z8000, @value{GDBN}
включает симулятор Z8000.        

Для семейства Z8000, @samp{target sim} имитирует либо Z8002
(несегментированный вариант архитектуры Z8000), либо Z8001
(сегментированный вариант).  Имитатор распознает подходящую архитектуру
изучая объектный код.

@table @code
@item target sim @var{арг}
@kindex sim
@kindex target sim@r{, с Z8000}
Отладка программ на имитируемом ЦП.  Если имитатор поддерживает
параметры установки, укажите их в @var{арг}.
@end table

@noindent
После определения этой цели, вы можете отлаживать программы для
имитированного ЦП таким же образом, как программы для вашего рабочего
компьютера; используйте команду @code{file} для загрузки образа новой
программы, команду @code{run} для запуска вашей программы и так далее.

Помимо того, что доступны все обычные машинные регистры
(@pxref{Регистры, ,Регистры}), имитатор Z8000 предоставляет три
специально названных регистра с дополнительной информацией:

@table @code

@item cycles
Считает тактовые импульсы в имитаторе.

@item insts
Считает инструкции, выполненные в имитаторе.

@item time
Время выполнения в шестидесятых долях секунды.

@end table

Вы можете ссылаться на эти значения в выражениях @value{GDBN} с помощью
обычных соглашений; например, @w{@samp{b fputc if $cycles>5000}}
устанавливает условную точку останова, которая срабатывает только после
как минимум 5000 имитированных тактовых импульсов.

@node Архитектуры
@section Архитектуры

Этот раздел описывает свойства архитектур, которые воздействуют на все
применения @value{GDBN} с данной архитектурой, как при чистой отладке,
так и при кросс-отладке.

@menu
* A29K::
* Alpha::
* MIPS::
@end menu

@node A29K
@subsection A29K

@table @code

@kindex set rstack_high_address
@cindex стек регистров, AMD 29K
@cindex AMD29K, стек регистров
@item set rstack_high_address @var{адрес}
В процессорах семейства AMD 29000, регистры сохраняются в отдельном
@dfn{стеке регистров}.  Для отладчика не существует способа
определить размер этого стека.  Обычно @value{GDBN} просто
подразумевает, что стек ``достаточно большой''.  Это может привести к
тому, что @value{GDBN} попытается обратиться несуществующей области
памяти.  В случае необходимости, вы можете решить эту проблему, указав
конечный адрес стека регистров с помощью команды @code{set
rstack_high_address}.  Аргумент должен быть адресом, который вы,
вероятно, захотите начать с @samp{0x}, чтобы задать его в
шестнадцатеричном виде.

@kindex show rstack_high_address
@item show rstack_high_address
Отобразить текущее ограничение на стек регистров для процессоров
семейства AMD 29000.

@end table

@node Alpha
@subsection Alpha

Смотрите следующий раздел.

@node MIPS
@subsection MIPS

@cindex стек на Alpha
@cindex стек на MIPS
@cindex Alpha, стек
@cindex MIPS, стек
Компьютеры, базирующиеся на архитектурах Alpha и MIPS, используют
необычный кадр стека, который иногда требует от @value{GDBN} поиска в
объектном коде в обратном направлении, чтобы найти начало функции.

@cindex время ответа, отладка MIPS
Чтобы сократить время ответа (особенно для встроенных приложений, где
@value{GDBN} может быть ограничен медленной последовательной линией для
этого поиска), вы можете захотеть ограничить область поиска, используя
одну из этих команд:

@table @code
@cindex @code{heuristic-fence-post} (Alpha, MIPS)
@item set heuristic-fence-post @var{предел}
Ограничить @value{GDBN} для исследования не более @var{предела} байт при
поиске начала функции.  Значение @var{0} (по умолчанию) означает
неограниченный поиск.  Однако, исключая @var{0}, чем больше предел, тем
больше байт @code{heuristic-fence-post} должен просмотреть, и,
следовательно, тем дольше он будет выполняться.

@item show heuristic-fence-post
Отобразить текущее значение данного предела.
@end table

@noindent
Эти команды доступны, @emph{только} когда @value{GDBN} сконфигурирован
для отладки программ на процессорах Alpha или MIPS.


@node Управление GDB
@chapter Управление @value{GDBN}

Вы можете изменять способы взаимодействия @value{GDBN} с вами, используя
команду @code{set}.  Для команд, управляющих способами отображения
данных @value{GDBN}, смотрите @ref{Параметры вывода, ,Параметры вывода}.
Другие установки описаны здесь.

@menu
* Приглашение::                 Приглашение
* Редактирование::              Редактирование команд
* История::                     История команд
* Размер экрана::               Размер экрана
* Числа::                       Числа
* Сообщения/предупреждения::    Необязательные предупреждения и сообщения
* Отладочный вывод::            Необязательные сообщения о внутренних событиях
@end menu

@node Приглашение
@section Приглашение

@cindex приглашение

@value{GDBN} демонстрирует свою готовность считать команду выводя строку,
называемую @dfn{приглашением}.  Обычно это @samp{(@value{GDBP})}.  Вы
можете изменить строку приглашения командой @code{set prompt}.
Например, при отладке @value{GDBN} с помощью @value{GDBN}, полезно
изменить приглашение в одном из сеансов так, чтобы вы всегда могли
понять, с каким из них вы общаетесь.

@emph{Замечание:}  @code{set prompt} не добавляет пробелы после установленного
вами приглашения.  Это позволяет устанавливать приглашение,
заканчивающееся пробелом или нет.

@table @code
@kindex set prompt
@item set prompt @var{новое-пригл}
Указывает @value{GDBN}, что с этого момента надо использовать в качестве
строки приглашения @var{новое-пригл}.

@kindex show prompt
@item show prompt
Печатает строку в форме: @samp{Gdb's prompt is: @var{ваше-пригл}}
@end table

@node Редактирование
@section Редактирование команд
@cindex readline
@cindex редактирование командной строки

@value{GDBN} читает входные команды через интерфейс @dfn{readline}.  Эта
библиотека @sc{gnu} обеспечивает единообразное поведение для программ,
которые предоставляют пользователю интерфейс командной строки.
Преимуществами являются стили редактирования командной строки @sc{gnu}
Emacs или @dfn{vi}, @code{csh}-подобная подстановка истории
и сохранение и повторное использование истории команд между сеансами отладки.

Вы можете управлять поведением редактирования командной строки в
@value{GDBN} командой @code{set}.

@table @code
@kindex set editing
@cindex редактирование
@item set editing
@itemx set editing on
Включает редактирование командной строки (включено по умолчанию).

@item set editing off
Отключает редактирование командной строки.

@kindex show editing
@item show editing
Показывает, включено редактирование командной строки или нет.
@end table

@node История
@section История команд

@value{GDBN} может отслеживать команды, которые вы вводите во время сеансов
отладки, чтобы вы могли точно знать, что происходило.  Используйте
следующие команды для управления возможностями истории команд @value{GDBN}.

@table @code
@cindex подстановка истории
@cindex файл истории
@kindex set history filename
@kindex GDBHISTFILE
@item set history filename @var{имя-файла}
Устанавливает имя файла истории команд @value{GDBN} в @var{имя-файла}.
Это файл, откуда @value{GDBN} читает исходный список истории команд, и
куда он записывает историю команд при выходе из данного сеанса.  Вы
можете обращаться к этому списку через раскрывание истории или с помощью
символов редактирования истории команд, перечисленных ниже.  По
умолчанию, этот файл есть значение переменной среды @code{GDBHISTFILE}
или, если эта переменная не установлена, @file{./.gdb_history}
(@file{./_gdb_history} в MS-DOS).

@cindex сохранение истории
@kindex set history save
@item set history save
@itemx set history save on
Записать историю команд в файл, имя которого может быть определено
командой @code{set history filename}.  По умолчанию, эта возможность
отключена.

@item set history save off
Прекратить запись истории команд в файл.

@cindex размер истории
@kindex set history size
@item set history size @var{размер}
Установить число команд, которые @value{GDBN} хранит в своем списке
истории.  Значение по умолчанию берется из переменной среды
@code{HISTSIZE} или приравнивается 256, если эта переменная не установлена.
@end table

@cindex раскрывание истории
Раскрывание истории назначает специальное значение знаку @kbd{!}.
@ifset have-readline-appendices
@xref{Указатели событий}.
@end ifset

Так как @kbd{!} является также оператором логического отрицания в Си,
раскрывание истории по умолчанию отключено.  Если вы решите включить
раскрывание истории командой @code{set history expansion on}, вы должны
будете снабдить @kbd{!} (когда он используется как логическое отрицание в
выражении) последующим пробелом или символом табуляции, чтобы предохранить
его от раскрывания.  Средства истории Readline не делают попытки подстановки
на строках @kbd{!=} и @kbd{!(}, даже когда раскрывание истории включено.

Вот команды управления раскрыванием истории:

@table @code
@kindex set history expansion
@item set history expansion on
@itemx set history expansion
Включить раскрывание истории.  Раскрывание по умолчанию отключено.

@item set history expansion off
Отключить раскрывание истории.

Библиотека Readline поставляется вместе с более полной
документацией по возможностям редактирования и раскрывания истории.
Пользователи, незнакомые с @sc{gnu} Emacs или @code{vi}, могут почитать ее.
@ifset have-readline-appendices
@xref{Редактирование командной строки}.
@end ifset

@kindex show history
@item show history
@itemx show history filename
@itemx show history save
@itemx show history size
@itemx show history expansion
Эти команды отображают состояние параметров истории @value{GDBN}.
Просто @code{show history} показывает все четыре состояния.
@end table

@table @code
@kindex shows
@item show commands
Отобразить последние десять команд в истории.

@item show commands @var{n}
Вывести десять команд, расположенных вокруг команды с номером @var{n}.

@item show commands +
Вывести десять команд, расположенных сразу после последних выведенных.
@end table

@node Размер экрана
@section Размер экрана
@cindex размер экрана
@cindex паузы при выводе

Определенные команды @value{GDBN} могут выводить большое количество информации
на экран.  Чтобы помочь вам всю ее прочитать, @value{GDBN} приостанавливает вывод и
запрашивает ввод в конце каждой страницы вывода.  Нажмите @key{RET}, когда вы
хотите продолжить вывод, или @kbd{q} для уничтожения оставшегося вывода.
Также, установка ширины экрана определяет, когда переносить строки
вывода.  В зависимости от того, что выводится, @value{GDBN} пытается
разбить строку в удобочитаемом месте, вместо того чтобы просто
продолжить ее на следующую строчку.

Обычно @value{GDBN} узнает размер экрана из программы драйвера
терминала.  Например, в Unix @value{GDBN} использует базу данных
termcap, вместе со значением переменной среды @code{TERM} и
установками @code{stty rows} и @code{stty cols}.  Если это неправильно,
вы можете заменить эти установки командами @code{set height} и
@code{set width}:

@table @code
@kindex set height
@kindex set width
@kindex show wight
@kindex show width
@item set height @var{lpp}
@itemx show height
@itemx set width @var{cpl}
@itemx show width
Эти команды @code{set} определяют высоту экрана в @var{lpp} строк и ширину
в @var{cpl} знаков.  Соответствующие команды @code{show} отображают
текущие установки.

Если вы определите высоту в ноль строк, @value{GDBN} не будет
останавливаться при выводе, независимо от того, насколько он длинный.
Это полезно, если вывод осуществляется в файл или буфер редактора.

Аналогично, вы можете определить @samp{set width 0}, чтобы запретить
@value{GDBN} переносить строки вывода.
@end table

@node Числа
@section Числа
@cindex представление чисел
@cindex ввод чисел

Вы всегда можете вводить в @value{GDBN} числа в восьмеричной,
десятичной или шестнадцатеричной системе в соответствии c обычными
соглашениями: восьмеричные числа начинаются с @samp{0}, десятичные числа
оканчиваются на @samp{.}, а шестнадцатеричные числа начинаются с
@samp{0x}.  Числа, которые не начинаются ни c одного из этих знаков, по
умолчанию считаются десятичными; аналогично, отображение чисел по
умолчанию --- если не определен никакой конкретный формат --- осуществляется
по основанию 10.  Командой @code{set radix} вы можете изменять
основание, устанавливаемое по умолчанию для ввода и вывода.

@table @code
@kindex set input-radix
@item set input-radix @var{основание}
Установить основание по умолчанию для числового ввода.
Поддерживаемые варианты для @var{основания} --- 8, 10 или 16.  Само
@var{основание} должно быть определено либо недвусмысленно, либо с
использованием текущего основания системы счисления по умолчанию;
например, любая из команд

@smallexample
set radix 012
set radix 10.
set radix 0xa
@end smallexample

@noindent
устанавливает десятичное основание.  С другой стороны, @samp{set radix
10} оставляет основание системы счисления без изменений независимо от
того, каким оно было.

@kindex show output-radix
@item set output-radix @var{основание}
Установить основание по умолчанию для числового вывода.
Поддерживаемые варианты для @var{основания} --- 8, 10 или 16.  Само
@var{основание} должно быть определено либо недвусмысленно, либо с
использованием текущего основания системы счисления по умолчанию.

@kindex show input-radix
@item show input-radix
Отобразить текущее основание по умолчанию для числового ввода.

@kindex show output-radix
@item show output-radix
Отобразить текущее основание по умолчанию для числового вывода.
@end table

@node Сообщения/предупреждения
@section Необязательные предупреждения и сообщения

По умолчанию, @value{GDBN} ничего не сообщает о своей внутренней
деятельности.  Если вы работаете на медленной машине, то вы можете захотеть
использовать команду @code{set verbose}.  Она велит @value{GDBN}
сообщать вам, когда он выполняет длинную внутреннюю операцию, чтобы вы
не думали, что он завис.

В настоящее время @code{set verbose} управляет только
сообщениями о чтении таблиц символов исходного файла; смотрите
@ref{Файлы, ,Команды для задания файлов}, описание @code{symbol-file}.

@table @code
@kindex set verbose
@item set verbose on
Разрешает @value{GDBN} выводить некоторые информационные сообщения.

@item set verbose off
Отключает вывод некоторых информационных сообщений.

@kindex show verbose
@item show verbose
Сообщает, установлено @code{set verbose} в @code{on} или @code{off}.
@end table

По умолчанию, если @value{GDBN} сталкивается с ошибками в таблице символов
объектного файла, он не сообщает об этом; но если вы отлаживаете
компилятор, эта информация может вам пригодиться  (@pxref{Ошибки с
символами, ,Ошибки чтения файлов с символами}).

@table @code

@kindex set complaints
@item set complaints @var{предел}
Позволяет @value{GDBN} выводить @var{предел} сообщений о каждом типе
необычных символов прежде, чем перестать сообщать о проблеме.  Установите
@var{предел} в ноль для подавления всех сообщений, или очень большим,
чтобы предотвратить подавление сообщений.

@kindex show complaints
@item show complaints
Выводит ограничение @value{GDBN} на вывод сообщений о символах.

@end table

По умолчанию @value{GDBN} осмотрителен и задает, как иногда кажется,
множество глупых вопросов, чтобы подтвердить некоторые команды.
Например, если вы пытаетесь выполнить программу, которая уже
выполняется:

@example
(@value{GDBP}) run
The program being debugged has been started already.
Start it from the beginning? (y or n)
@end example

Если вы неуклонно желаете сами разбираться с последствиями ваших собственных
команд, вы можете отключить эту ``возможность'':

@table @code

@kindex set confirm
@cindex подтверждение
@cindex глупые вопросы
@item set confirm off
Отключает запросы подтверждений.

@item set confirm on
Включает запросы подтверждений (по умолчанию).

@kindex show confirm
@item show confirm
Показывает, выводятся ли запросы подтверждений.

@end table

@node Отладочный вывод
@section Необязательные сообщения о внутренних событиях
@table @code
@kindex set debug arch
@item set debug arch
Включает и отключает вывод отладочной информации gdbarch.  По умолчанию
отключено.
@kindex show debug arch
@item show debug arch
Отображает текущее состояние вывода отладочной информации gdbarch.
@kindex set debug event
@item set debug event
Включает и отключает вывод отладочной информации о событиях
@value{GDBN}.  По умолчанию отключено.
@kindex show debug event
@item show debug event
Отображает текущее состояние вывода отладочной информации о событиях
@value{GDBN}.
@kindex set debug expression
@item set debug expression
Включает и отключает вывод отладочной информации о выражениях
@value{GDBN}.  По умолчанию отключено.
@kindex show debug expression
@item show debug expression
Отображает текущее состояние вывода отладочной информации о выражениях
@value{GDBN}.
@kindex set debug overload
@item set debug overload
Включает и выключает вывод @value{GDBN} отладочной информации о
перегруженных символах Си++.  Это включает такую информацию, как
упорядочивание функций и тому подобное.  По умолчанию отключено.
@kindex show debug overload
@item show debug overload
Отображает текущее состояние вывода @value{GDBN} отладочной информации о
перегруженных символах Си++.
@kindex set debug remote
@cindex пакеты, отчет на стандартный вывод
@cindex последовательные соединения, отладка
@item set debug remote
Включает и выключает вывод отчета о всех пакетах, посланных вперед и
назад по последовательной линии удаленной машине.  Информация печатается
в стандартный выходной поток @value{GDBN}.  По умолчанию отключено.
@kindex show debug remote
@item show debug remote
Выводит состояние вывода удаленных пакетов.
@kindex set debug serial
@item set debug serial
Включает и выключает вывод @value{GDBN} отладочной информации о
последовательном соединении.  По умолчанию отключено.
@kindex show debug serial
@item show debug serial
Отображает текущее состояние вывода @value{GDBN} отладочной информации о
последовательном соединении.
@kindex set debug target
@item set debug target
Включает и выключает вывод @value{GDBN} отладочной информации о цели.
Сюда входит информация о том, что происходит на уровне цели
@value{GDBN}.  По умолчанию отключено.
@kindex show debug target
@item show debug target
Отображает текущее состояние вывода @value{GDBN} отладочной информации о
цели.
@kindex set debug varobj
@item set debug varobj
Включает и отключает вывод @value{GDBN} отладочной информации о
переменных объектах.  По умолчанию отключено.
@kindex show debug varobj
@item show debug varobj
Отображает текущее состояние вывода @value{GDBN} отладочной информации о
переменных объектах.
@end table

@node Последовательности
@chapter Фиксированные последовательности команд

Кроме команд точки останова (@pxref{Команды останова, ,Команды
точки останова}), @value{GDBN} предоставляет два способа сохранить
последовательности команд для выполнения целиком:
определяемые пользователем команды и командные файлы.

@menu
* Определяемые пользователем команды::
                                Определяемые пользователем команды
* Ловушки::                     Определяемые пользователем команды-ловушки
* Командные файлы::             Командные файлы
* Вывод::                       Команды для управления выводом
@end menu

@node Определяемые пользователем команды
@section Команды, определяемые пользователем

@cindex определяемые пользователем команды
@dfn{Команда, определяемая пользователем} --- это последовательность команд
@value{GDBN}, которой вы назначаете имя как новой команде.  Это
осуществляется командой @code{define}.  Пользовательские команды могут иметь
до 10 параметров, разделенных пробелами.  Внутри команды пользователя,
доступ к параметрам производится посредством @var{$arg0@dots{}$arg9}.
Вот простой пример:

@smallexample
define adder
  print $arg0 + $arg1 + $arg2
@end smallexample

@noindent
Для выполнения команды используйте:

@smallexample
adder 1 2 3
@end smallexample

@noindent
Этот пример определяет команду @code{adder}, которая печатает сумму трех
своих параметров.  Обратите внимание, параметры являются текстовыми
подстановками, так что они могут ссылаться на переменные, использовать
сложные выражения или даже выполнять вызовы подчиненных функций.

@table @code

@kindex define
@item define @var{имя-команды}
Определить команду с именем @var{имя-команды}.  Если команда
с таким именем уже имеется, у вас запрашивается подтверждение на ее
переопределение.

Определение команды состоит из других командных строк @value{GDBN},
которые задаются после команды @code{define}.  Конец этих команд
отмечается строкой, содержащей @code{end}.

@kindex if
@kindex else
@item if
Имеет один аргумент --- вычисляемое выражение.  Команда сопровождается
последовательностью команд, которые выполняются, если выражение истинно
(отлично от нуля).  Затем может следовать необязательная строка
@code{else}, сопровождаемая последовательностью команд, которые
выполняются только при ложном значении данного выражения.  Конец списка
отмечается строкой, содержащей @code{end}.

@kindex while
@item while
Синтаксис подобен @code{if}: команда имеет один параметр, который
является вычисляемым выражением и должен сопровождаться командами,
по одной в строке, которые завершаются @code{end}.  Выполнение команд
повторяется, пока выражение истинно.

@kindex document
@item document @var{имя-команды}
Документирует определенную пользователем команду @var{имя-команды},
чтобы к ней можно было обращаться посредством @code{help}.  Команда
@var{имя-команды} должна быть определена ранее.  Эта команда
считывает строки документации точно так же, как @code{define}
считывает строки определения команды, до строки @code{end}.  После
завершения команды @code{document}, написанная вами документация будет
отображаться командой @code{help} для команды @var{имя-команды}.

Вы можете использовать команду @code{document} неоднократно, чтобы
изменить документацию команды.  Переопределение команды посредством
@code{define} не изменяет документации.

@kindex help user-defined
@item help user-defined
Перечислить все определенные пользователем команды, вместе с первой
строкой документации (если она есть).

@kindex show user
@item show user
@itemx show user @var{имя-команды}
Вывести команды @value{GDBN}, использовавшиеся для определения
@var{имя-команды} (но не ее документацию).  Если @var{имя-команды} не
задано, вывести содержимое всех определенных пользователем команд.

@end table

При выполнении команд, определенных пользователем, команды
определения не печатаются.  Ошибка в любой из них останавливает
выполнение всей определенной пользователем команды.

При использовании в интерактивном режиме, команды, обычно запрашивающие
подтверждение, выполняются без запроса, если они используется внутри
определенной пользователем команды.  Многие команды @value{GDBN},
которые обычно печатают сообщения о своих действиях, опускают
их при использовании в команде, определенной пользователем.

@node Ловушки
@section Определяемые пользователем команды-ловушки
@cindex команды-ловушки
@cindex ловушки для команд
@cindex ловушки, до команды

@kindex hook
@kindex hook-
Вы можете определять @dfn{ловушки}, которые являются специальным
видом определяемых пользователем команд.  Всякий раз, когда вы выполняете
команду @samp{foo}, перед ней выполняется определенная пользователем команда
@samp{hook-foo} (без параметров), если она существует.

@cindex ловушки, после команды
@kindex hookpost
@kindex hookpost-
Также может быть определена ловушка, которая вызывается после
выполненной вами команды.  Когда вы выполняете команду @samp{foo}, после
нее вызывается (без аргументов) определенная пользователем команда
@samp{hookpost-foo}, если она существует.  Ловушки, срабатывающие после
выполнения команды, могут существовать одновременно с ловушками,
вызываемыми до выполнения той же команды.

Ловушка может вызывать ту же команду, которую она ловит.  Если
это происходит, ловушка заново не вызывается.  Тем самым избегаются
бесконечные циклы.

@kindex stop@r{, псевдокоманда}
Кроме того, существует псевдокоманда @samp{stop}.  Определение
(@samp{hook-stop}) велит выполняться связанным с ней командам при каждом
останове вашей программы: перед выполнением команд точек останова, перед
выводом на экран сообщений или кадров стека.

Например, чтобы игнорировать сигналы @code{SIGALRM} во время выполнения
в пошаговом режиме, но обрабатывать их при нормальном выполнении, вы
можете определить:

@example
define hook-stop
handle SIGALRM nopass
end

define hook-run
handle SIGALRM pass
end

define hook-continue
handle SIGLARM pass
end
@end example

В качестве другого примера, чтобы поймать начало и конец команды
@code{echo} и добавить дополнительный текст до и после сообщения, вы
можете определить:

@example
define hook-echo
echo <<<---
end

define hookpost-echo
echo --->>>\n
end

(@value{GDBP}) echo Hello World
<<<---Hello World--->>>
(@value{GDBP})

@end example

Вы можете определить ловушку для любой однословной команды
@value{GDBN}, но не для синонимов команды; вам следует определить
ловушку для базового имени команды, например, @code{backtrace}, но не
@code{bt}.  Если во время выполнения вашей ловушки возникает ошибка,
выполнение команд @value{GDBN} останавливается, и
он выдает приглашение (до того, как введенная вами
команда начнет выполняться).

Если вы попытаетесь определить ловушку, не соответствующую никакой
известной команде, вы получите предупреждение от команды @code{define}.

@node Командные файлы
@section Командные файлы

@cindex командные файлы
Командный файл для @value{GDBN} --- это файл, состоящий из строк с
командами @value{GDBN}.  Такие файлы могут также включать комментарии
(строки, начинающиеся с @kbd{#}).  Пустая строка в командном файле
ничего не делает; она не означает повторение последней команды, как это
было бы при вводе с терминала.

@cindex файл инициализации
@cindex @file{.gdbinit}
@cindex @file{gdb.ini}
Когда вы вызываете @value{GDBN}, он автоматически выполняет команды из
своих @dfn{файлов инициализации}.  Это файлы, называющиеся
@file{.gdbinit} в Unix и @file{gdb.ini} в DOS/Windows.  Во время старта,
@value{GDBN} делает следующее:

@enumerate
@item
считывает файл инициализации (если он существует) в вашем
домашнем каталоге@footnote{В системах DOS/Windows, домашним каталогом
считается тот, на который указывает переменная среды @code{HOME}.}.

@item
Обрабатывает ключи и операнды командной строки.

@item
Считывает файл инициализации (если он существует) в текущем рабочем
каталоге.

@item
Считывает командные файлы, заданные с помощью ключа @samp{-x}.
@end enumerate

Файл инициализации в вашем домашнем каталоге может
устанавливать параметры (такие как @samp{set complaints}), которые влияют на
последующую обработку ключей и операндов командной строки.  Файлы
инициализации не выполняются, если вы используете ключ @samp{-nx}
@pxref{Параметры режима, ,Выбор режимов}.
@c ??? /// тут pxref не к месту, она в скобках применяется -- ост

@cindex имя файла инициализации
В некоторых конфигурациях @value{GDBN}, файлу инициализации присваивается
другое имя (обычно это среды, где специализированная форма @value{GDBN} должна
сосуществовать с другими формами, следовательно должно быть отличное
имя для файла инициализации специализированной версии).  Следующие
среды используют специальные имена файлов инициализации:

@cindex @file{.vxgdbinit}
@itemize @bullet
@item
VxWorks (ОС реального времени Wind River Systems): @file{.vxgdbinit}

@cindex @file{.os68gdbinit}
@item
OS68K (ОС реального времени Enea Data Systems): @file{.os68gdbinit}

@cindex @file{.esgdbinit}
@item
ES-1800 (эмулятор Ericsson Telecom AB M68000): @file{.esgdbinit}
@end itemize

Вы также можете запросить выполнение командного файла с помощью команды
@code{source}:

@table @code
@kindex source
@item source @var{имя-файла}
Выполнить командный файл @var{имя-файла}.
@end table

Строки командного файла выполняются последовательно, при этом они
не выводятся.  Ошибка в любой команде завершает выполнение всего
командного файла.

Команды, запрашивающие подтверждение в интерактивном режиме, при
выполнении в командном файле выполняются без запросов.  Многие
команды @value{GDBN}, обычно выводящие сообщения о своих действиях,
опускают эти сообщения при вызове из командных файлов.

@node Вывод
@section Команды для управляемого вывода

Во время выполнения командного файла или определенной пользователем
команды нормальный вывод @value{GDBN} подавляется; единственный появляющийся
вывод --- тот, который производится явно командами из определения.  В этом
разделе описываются три команды, полезные для получения именно такого
вывода, который вы хотите.

@table @code
@kindex echo
@item echo @var{текст}
Напечатать @var{текст}.  Непечатные знаки могут быть включены в
@var{текст} при помощи экранирующих последовательностей Си, таких как
@samp{\n} для перехода на новую строку.  @strong{Переход на новую строку
не печатается, если вы его не укажете.}  В дополнение к стандартным
экранирующим последовательностям Си, обратная косая черта, за
которой следует пробел, обозначает пробел.  Это полезно для
отображения строки с пробелами в начале или конце, поскольку в противном
случае начальные и конечные пробелы удаляются из всех аргументов.  Чтобы
напечатать @samp{@w{ }and foo =@w{ }}, используйте команду
@samp{echo \@w{ }and foo = \@w{ }}.

Обратная косая черта в конце @var{текста} может использоваться, как и в
Си, для продолжения команды на последующие строки.  Например,

@example
echo Вот пример текста,\n\
который занимает\n\
несколько строк.\n
@end example

производит такой же вывод как

@example
echo Вот пример текста,\n
echo который занимает\n
echo несколько строк.\n
@end example

@kindex output
@item output @var{выражение}
Напечатать значение @var{выражения} и ничего кроме него: никаких новых
строк, никаких @samp{$@var{nn} = }.  Значение также не заносится в
историю значений.  @xref{Выражения, ,Выражения}, для дополнительной
информации о выражениях.

@item output/@var{формат} @var{выражение}
Вывести значение @var{выражения} в формате @var{формат}.  Вы можете
использовать те же форматы, что и для @code{print}.  @xref{Форматы
вывода,,Форматы вывода}, для получения большей информации.

@kindex printf
@item printf @var{строка}, @var{выражения}@dots{}
Напечатать значения @var{выражений}, причем формат вывода задает @var{строка}.
@var{Выражения} разделяются запятыми и могут быть либо числами, либо
указателями.  Их значения печатаются так, как определяет @var{строка},
в точности, как если бы ваша программа выполняла подпрограмму Си

@example
printf (@var{строка}, @var{выражения}@dots{});
@end example

Например, вы можете напечатать два шестнадцатеричных значения:

@smallexample
printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo
@end smallexample

Единственые экранирующие последовательности с обратной косой чертой,
которые вы можете использовать в строке формата --- простые
последовательности, состоящие из обратной косой черты, за которой
следует буква.
@end table

@node Emacs
@chapter Использование @value{GDBN} под управлением @sc{gnu} Emacs

@cindex Emacs
@cindex @sc{gnu} Emacs
Специальный интерфейс позволяет вам использовать @sc{gnu} Emacs для
просмотра (и редактирования) исходных файлов программы, которую вы
отлаживаете с помощью @value{GDBN}.

Чтобы использовать этот интерфейс, используйте команду @kbd{M-x gdb} в
Emacs.  В качестве аргумента задайте выполняемый файл, который вы хотите
отладить.  Эта команда вызывает @value{GDBN} как подпроцесс Emacs с
вводом и выводом через заново созданный буфер.

Под управлением Emacs, @value{GDBN} используется точно так же, как обычно,
за исключением двух моментов:

@itemize @bullet
@item
Весь ``терминальный'' ввод и вывод происходит через буфер Emacs.
@end itemize

Это относится как к командам @value{GDBN} и их выводу, так и к вводу и
выводу, производимыми отлаживаемой программой.

Это полезно, потому что вы можете копировать текст предыдущих команд и
вводить их снова; вы даже можете использовать таким образом части
вывода.

Все средства режима оболочки Emacs доступны для взаимодействия с
вашей программой.  В частности, вы можете посылать сигналы обычным путем
--- например, @kbd{C-c C-c} для прерывания, @kbd{C-c C-z} для остановки.

@itemize @bullet
@item
@value{GDBN} отображает исходный код через Emacs.
@end itemize

Каждый раз, когда @value{GDBN} отображает кадр стека, Emacs
автоматически находит исходный файл для него и помещает стрелку
(@samp{=>}) с левого края текущей строки.  Emacs использует отдельный
буфер для отображения исходного текста и разделяет экран, чтобы
отобразить как сеанс @value{GDBN}, так и исходный текст.

Тем не менее, явные команды @value{GDBN} @code{list} и @code{search}
производят вывод как обычно, но у вас, скорее всего, не будет причин
использовать их из Emacs.

@quotation
@emph{Предупреждение:} Если каталог, в котором находится ваша программа, не
является текущим, Emacs легко может ошибиться при определении
местонахождения исходных файлов; в этом случае вспомогательный буфер с
исходным текстом не появляется.  @value{GDBN} может искать программы, используя
переменную среды @code{PATH}, так что сеансы ввода и вывода
происходят нормально; но Emacs не получает достаточно информации
от @value{GDBN}, чтобы найти исходные файлы в такой ситуации.  Чтобы
избежать этой проблемы, либо запускайте режим @value{GDBN} из каталога,
где находится ваша программа, либо укажите абсолютное имя файла, когда будет
запрошен параметр для @kbd{M-x gdb}.

Подобная путаница может возникнуть, если вы используете команду
@value{GDBN} @code{file}, чтобы переключиться к отладке программы,
находящейся в каком-нибудь другом месте, из существующего буфера
@value{GDBN} в Emacs.
@end quotation

По умолчанию, @kbd{M-x gdb} вызывает программу с именем @file{gdb}.  Если вам
нужно вызвать @value{GDBN} под другим именем (например, если вы храните
несколько конфигураций под различными именами), вы можете установить переменную
Emacs @code{gdb-command-name}; например, установка

@example
(setq gdb-command-name "mygdb")
@end example

@noindent
(которой предшествует @kbd{M-:} или @kbd{ESC :}, или если она введена в буфер
@code{*scratch*} или в вашем файле @file{.emacs}), заставит Emacs вызвать
программу ``@code{mygdb}''.

В буфере ввода-вывода @value{GDBN}, вы можете использовать следующие
специальные команды Emacs в дополнение к стандартным командам режима
оболочки:

@table @kbd
@item C-h m
Описывает возможности режима @value{GDBN} Emacs.

@item M-s
Выполнить до другой строки исходного текста, подобно команде @value{GDBN}
@code{step}; также обновляет окно отображения для показа текущего файла и
положения в нем.

@item M-n
Выполнить до следующей строки исходного текста в этой функции,
пропуская все вызовы функций, подобно команде @value{GDBN} @code{next}.
Затем обновить окно отображения, чтобы показать текущий файл и положение
в нем.

@item M-i
Выполнить одну инструкцию, подобно команде @value{GDBN} @code{stepi};
обновляет окно отображения.

@item M-x gdb-nexti
Выполнить до следующей инструкции, используя команду @value{GDBN}
@code{nexti}; обновляет окно отображения.

@item C-c C-f
Выполнить до выхода из выбранного кадра стека, подобно команде
@value{GDBN} @code{finish}.

@item M-c
Продолжить выполнение вашей программы, подобно команде @value{GDBN}
@code{continue}.

@emph{Предупреждение:} В Emacs версии 19, эта команда вызывается
посредством @kbd{C-c C-p}.

@item M-u
Подняться вверх по стеку на число кадров, заданное числовым параметром,
подобно команде @value{GDBN} @code{up}
(@pxref{Аргументы, , Числовые аргументы, Emacs, Руководство по @sc{gnu}
Emacs}).

@emph{Предупреждение:} В Emacs версии 19, эта команда вызывается
посредством @kbd{C-c C-u}.

@item M-d
Спуститься вниз по стеку на число кадров, заданное числовым параметром,
аналогично команде @value{GDBN} @code{down}.

@emph{Предупреждение:} В Emacs версии 19, эта команда вызывается
посредством @kbd{C-c C-d}.

@item C-x &
Прочитать число в позиции курсора и вставить его в конец буфера
ввода-вывода @value{GDBN}.  Например, если вы хотите дисассемблировать код
по адресу, отображенному ранее, наберите @kbd{disassemble}; затем
переместите курсор на изображение адреса и задайте аргумент для
@code{disassemble}, набрав @kbd{C-x &}.

Вы можете и дальше настраивать это, определяя элементы списка
@code{gdb-print-command}; если он определен, вы можете форматировать или
как-либо иначе обрабатывать числа, задаваемые @kbd{C-x &}, перед их вставкой
в буфер.  Числовой аргумент к @kbd{C-x &} показывает, что вам нужно
специальное форматирование, а также действует как индекс для выбора
элемента из списка.  Если элемент списка является строкой, то вставляемое
число форматируется с использованием функции Emacs @code{format}; в
противном случае, число передается как параметр соответствующему
элементу списка.
@end table

В любом исходном файле, команда Emacs @kbd{C-x SPC} (@code{gdb-break})
велит @value{GDBN} установить точку останова на строке исходного текста,
в которой находится точка.

Если вы случайно удалите буфер отображения исходного текста, его можно легко
вернуть обратно, введя команду @code{f} в буфере @value{GDBN}, чтобы запросить
отображение кадра; когда выполнение происходит под управлением Emacs,
это при необходимости создает исходный буфер заново, чтобы показать вам
текущий кадр.

Исходные файлы, отображаемые в Emacs, находятся в обычных буферах
Emacs, которые получают доступ к исходным файлам обычным способом.  При
желании вы можете редактировать файлы в этих буферах; но помните,
что @value{GDBN} взаимодействует с Emacs в терминах номеров строк.
Если вы добавите или удалите строки из текста, известные @value{GDBN}
номера строк больше не будут соответствовать коду.

@include annotate.texi
@include gdbmi.texinfo

@node Ошибки в GDB
@chapter Отчеты об ошибках в @value{GDBN}
@cindex ошибки в @value{GDBN}
@cindex отчеты об ошибках в @value{GDBN}

Ваши отчеты об ошибках играют существенную роль в обеспечении
надежности @value{GDBN}.

Сообщение об ошибке может помочь вам найти решение вашей проблемы, а
может и не помочь.  Но в любом случае, основная функция отчета об
ошибке --- помочь всему обществу сделать следующую версию @value{GDBN}
лучше.  Отчеты об ошибках --- это ваш вклад в поддержку @value{GDBN}.

Чтобы отчет об ошибке сделал свое дело, вы должны включить в него
информацию, которая даст нам возможность ее устранить.

@menu
* Критерий ошибки::             Вы нашли ошибку?
* Отчеты об ошибках::           Как составлять отчеты об ошибках
@end menu

@node Критерий ошибки
@section Вы нашли ошибку?
@cindex критерий ошибки

Если вы не уверены, нашли ли вы ошибку, вот несколько руководящих
принципов:

@itemize @bullet
@cindex фатальный сигнал
@cindex сбой отладчика
@item
Если отладчик получает фатальный сигнал, то это ошибка в
@value{GDBN}, независимо от ввода.  В надежных отладчиках сбоев не бывает.

@cindex ошибка при правильных входных данных
@item
Если @value{GDBN} выводит сообщение об ошибке для допустимого
ввода --- это ошибка.  (Заметьте, что если вы выполняете кросс-отладку,
проблема может возникать где-то в соединении к цели.)

@cindex недопустимые входные данные
@item
Если @value{GDBN} не выводит сообщение об ошибке для недопустимого ввода,
это ошибка.  Однако вы должны обратить внимание, что если по вашему
мнению что-то является ``недопустимым вводом'', по нашему мнению это может быть
``расширением'' или ``поддержкой традиционной практики''.

@item
Если вы опытный пользователь средств отладки, ваши предложения по
улучшению @value{GDBN} приветствуются в любом случае.
@end itemize

@node Отчеты об ошибках
@section Как составлять отчеты об ошибках
@cindex отчеты об ошибках
@cindex ошибки в @value{GDBN}, отчеты

Некоторые компании и частные лица предлагают поддержку для программных
продуктов @sc{gnu}.  Если вы получили @value{GDBN} из организации
поддержки, мы рекомендуем вам сперва связаться с ней.

Вы можете найти контактную информацию для многих организаций поддержки
и частных лиц в файле @file{etc/SERVICE} в дистрибутиве @sc{gnu} Emacs.

В любом случае, мы также рекомендуем вам послать отчет об ошибке в
@value{GDBN} по этому адресу:

@example
@email{bug-gdb@@gnu.org}
@end example

@strong{Не посылайте отчеты об ошибках в @samp{info-gdb}, или в
@samp{help-gdb}, или в какую-либо группу новостей.}  Большинство
пользователей @value{GDBN} не хотят получать отчеты об ошибках.  Те, кто
этого действительно хочет, должны получать @samp{bug-gdb}.

Список рассылки @samp{bug-gdb} имеет группу новостей @samp{gnu.gdb.bug},
которая работает как повторитель.  Список рассылки и группа новостей
содержат в точности одинаковые сообщения.  Часто люди посылают сообщения
об ошибках в группу новостей вместо отправки по электронной почте.  Это
работает, но есть одна проблема, которая может стать решающей: сообщения
в группу новостей часто не несут информации об обратном адресе
отправителя.  Таким образом, если нам потребуется запросить
дополнительную информацию, у нас может не быть возможности связаться с
вами.  По этой причине лучше посылать отчеты об ошибках в список
рассылки.

В крайнем случае посылайте отчеты об ошибках на бумаге по адресу:

@example
@sc{gnu} Debugger Bugs
Free Software Foundation Inc.
59 Temple Place - Suite 330
Boston, MA 02111-1307
USA
@end example

Основной принцип действенного составления отчетов об ошибках:
@strong{сообщайте все факты}.  Если вы не уверены, оставить факт или
исключить, оставьте его!

Часто люди опускают факты, потому что думают, что знают причины
проблемы, и полагают, что некоторые детали не имеют значения.  Например,
вы можете решить, что имя переменной, которую вы используете в примере,
не играет роли.  Возможно это так, но нельзя быть уверенным в этом.
Может быть, ошибкой является неверное обращение к памяти, которое
выбрало данные из ячеек, где хранилось это имя; возможно, если бы имя
было другим, содержимое этих ячеек ввело бы отладчик в заблуждение, и
ошибка не была бы замечена.  Относитесь к этому осторожно и приводите
конкретные, полные примеры.  Это самое простое, что вы можете сделать, и
наиболее полезное.

Помните, что цель отчета об ошибке состоит в том, чтобы
дать нам возможность установить дефект.  Может случиться, что об этой
ошибке нам уже сообщали, но не вы, но мы не можем этого знать, если отчет
об ошибке не будет полным и самодостаточным.

Иногда люди дают несколько поверхностных фактов и спрашивают, ``не
говорит ли это об ошибке?''.  Такие сообщения о дефектах бесполезны, и мы
убеждаем всех @emph{отказываться отвечать на них}, за исключением того,
чтобы побудить автора отчета послать его правильно.

Чтобы дать нам возможность устранить ошибку, вы должны включить в
сообщение следующее:

@itemize @bullet
@item
Версию @value{GDBN}.  @value{GDBN} сообщает ее при вызове без
параметров; вы можете также вывести ее в любой момент, используя
@code{show version}.

Без этого мы не будем знать, имеет ли смысл поиск ошибки в текущей
версии отладчика.

@item
Тип машины, которой вы пользуетесь, название и номер версии операционной
системы.

@item
Какой компилятор (и его версия) использовался при компиляции
@value{GDBN}.  Например, ``@value{GCC}--2.8.1''.

@item
Какой компилятор (и его версия) использовался для компиляции
отлаживаемой программы --- например ``@value{GCC}--2.8.1'' или
``HP92453-01 A.10.32.03 HP C Compiler''.  Для @value{GCC}, вы можете
использовать @code{gcc --version}, чтобы получить эту информацию; для
других компиляторов, смотрите их документацию.

@item
Параметры команды, которые вы дали компилятору для компиляции вашего
примера, с которым вы наблюдали ошибку.  Например, использовали ли вы
@samp{-O}?  Для гарантии, что вы не пропустите что-нибудь важное,
перечисляйте все.
Копии @file{Makefile} (или результата вызова @code{make}) достаточно.

Если мы должны будем угадывать аргументы, мы, возможно, сделаем это
неправильно и можем не столкнуться с ошибкой.

@item
Полный сценарий ввода и все необходимые исходные файлы, которые
воспроизведут ошибку.

@item
Описание наблюдаемого вами поведения, которое вы считаете ошибочным.
Например, ``Это приводит к фатальному сигналу''.

Конечно, если ошибка состоит в получении @value{GDBN} фатального
сигнала, то мы, конечно, заметим это.  Но если ошибкой является
некорректный вывод, мы можем не заметить этого, если это не бросается в
глаза.  Вы также можете не дать нам возможности ошибиться.

Даже если ваша проблема заключается в фатальном сигнале, вы все же
должны сообщить об этом явно.  Предположим, происходит что-то странное,
например, ваша копия @value{GDBN} рассинхронизировалась, или вы
столкнулись с ошибкой в библиотеке Си вашей системы.  (Такое бывало!)
Ваша копия может завершиться аварийно, а наша нет.  Если вы предупредите
нас об ожидаемой аварии, а в нашей системе этого не произойдет, мы будем
знать, что ошибка произошла не из-за нас.  Если вы нас не предупредите,
мы не сможем сделать никаких выводов из наших наблюдений.

@item
Если вы хотите предложить внести изменения в исходные тексты @value{GDBN},
присылайте нам контекстные изменения.  Даже если вы желаете обсудить
что-нибудь из исходных текстов, ссылайтесь по контексту, а не по
номеру строки.

Номера строк в наших исходных текстах разработки не будут
соответствовать вашим.  Ваши номера строк не дадут нам никакой полезной
информации.

@end itemize

Вот некоторые вещи, не являющиеся обязательными:

@itemize @bullet
@item
Описание контекста ошибки.

Часто люди, сталкивающиеся с ошибкой, тратят много времени на
исследования, какие изменения входного файла приведут к ее
исчезновению, а какие на нее не влияют.

Это часто занимает много времени и приносит мало пользы, потому что мы
найдем ошибку посредством выполнения одного примера под управлением
отладчика с точками останова, а не чистыми выводами из
серии примеров.  Мы рекомендуем вам сохранить это время для
чего-нибудь другого.

Конечно, если вы сможете найти более простой пример для отчета
@emph{вместо} первоначального, это будет удобнее для нас.
Выделение ошибок в выводе будет проще, выполнение под управлением
отладчика будет занимать меньше времени, и так далее.

Однако, это упрощение не является жизненно важным; если вы не
хотите делать этого, сообщайте об ошибке в любом случае и посылайте нам
весь тестовый материал, который вы использовали.

@item
Заплата для ошибки.

Заплата для исправления ошибки действительно поможет нам, если это
хорошая заплата.  Но не опускайте необходимую информацию, такую как
тестовый пример, предполагая, что заплата это все, в чем мы нуждаемся.
Мы можем обнаружить проблемы с вашей заплатой и решить устранить ошибку
другим путем, или мы можем вообще не понять смысл вашей заплаты.

Иногда для такой сложной программы, как @value{GDBN}, очень трудно
создать пример, который заставит программу следовать по определенному
пути в процессе выполнения.  Если вы не пришлете нам пример, мы не
сможем сконструировать его сами, и таким образом не сможем проверить,
что ошибка устранена.

И если мы не сможем понять, какую ошибку вы пытаетесь исправить,
или почему ваша заплата являются улучшением, мы не используем ее.
Тестовый пример поможет нам во всем разобраться.

@item
Предположения, в чем состоит ошибка, или от чего она зависит.

Такие предположения обычно неверны.  Даже мы не можем сделать
правильных предположений о такого рода вещах до запуска отладчика
и выявления фактов.
@end itemize

@include rluser.texinfo
@include inc-hist.texinfo

@node Форматирование документации
@appendix Форматирование документации

@cindex справочная карточка по @value{GDBN}
@cindex справочная карточка
Выпуск 4 @value{GDBN} содержит уже отформатированную справочную
карточку, готовую к печати с PostScript или Ghostscript, в подкаталоге
@file{gdb} главного исходного каталога@footnote{В
@file{gdb-@value{GDBVN}/gdb/refcard.ps} в версии @value{GDBVN}
выпуска.}.  Если вы можете использовать PostScript или Ghostscript с
вашим принтером, вы можете сразу распечатать справочную карточку из
@file{refcard.ps}.

Выпуск также включает исходный текст справочной карточки.  Вы можете
отформатировать ее при помощи @TeX{}, набрав:

@example
make refcard.dvi
@end example

Справочная карточка @value{GDBN} разработана для печати в режиме
@dfn{landscape} на бумаге американского размера ``letter''; то есть на листе
шириной 11 и высотой 8.5 дюймов.  Вы должны будете указать
этот формат печати в качестве ключа к вашей программе вывода @sc{dvi}.

@cindex документация
Вся документация для @value{GDBN} поставляется как часть
машинно-читаемого дистрибутива.  Документация написана в формате
Texinfo, который является системой построения документации, использующей
один исходный файл для создания как интерактивного, так и печатного
руководства.  Вы можете использовать одну из команд форматирования Info,
чтобы создать интерактивную версию документации, и @TeX{} (или
@code{texi2roff}) для создания печатной версии.

@value{GDBN} включает уже отформатированную копию интерактивной версии Info
этого руководства в подкаталоге @file{gdb}.  Основной файл Info ---
@file{gdb-@value{GDBVN}/gdb/gdb.info}, он ссылается на подчиненные файлы
@samp{gdb.info*} в том же каталоге.  В случае необходимости,
вы можете распечатать эти файлы или прочитать их в любом редакторе; но
их легче прочитать, используя подсистему @code{info} в @sc{gnu} Emacs или
автономную программу @code{info}, доступную как часть дистрибутива @sc{gnu}
Texinfo.

Если вы хотите форматировать эти Info-файлы самостоятельно, вам
нужна одна из программ форматирования Info, например
@code{texinfo-format-buffer} или @code{makeinfo}.

Если у вас установлена программа @code{makeinfo}, и вы находитесь на верхнем
уровне иерархии каталогов @value{GDBN} (@file{gdb-@value{GDBVN}} в
случае версии @value{GDBVN}), вы можете создать Info-файл, набрав:

@example
cd gdb
make gdb.info
@end example

Если вы хотите сформировать и распечатать копии этого руководства, вам
нужен @TeX{}, программа печати его выходных @sc{dvi}-файлов и файл
определений Texinfo @file{texinfo.tex}.

@TeX{} --- это программа форматирования; она не печатает файлы
непосредственно, а создает выходные файлы, называемые @sc{dvi}-файлами.
Чтобы напечатать сформатированный документ, вам нужна программа печати
@sc{dvi}-файлов.  Если в вашей системе установлен @TeX{}, в ней, скорее
всего, есть такая программа.  Какую точно команду нужно использовать
зависит от вашей системы; часто это @kbd{lpr -d}; другая программа
(для PostScript-устройств) --- это @kbd{dvips}.  Команда печати
@sc{dvi}-файлов может требовать имя файла без расширения или с
расширением @samp{.dvi}.

@TeX{} также требует файл макроопределений @file{texinfo.tex}.  Этот файл
сообщает @TeX{}, как форматировать документ, написанный в формате
Texinfo.  Сам по себе @TeX{} не может читать или форматировать
файл Texinfo.  @file{texinfo.tex} распространяется с @value{GDBN} и
размещается в каталоге @file{gdb-@var{номер-версии}/texinfo}.

Если у вас установлены @TeX{} и программа печати @sc{dvi}, вы можете
отформатировать и распечатать это руководство.  Сначала перейдите в
подкаталог @file{gdb}
главного исходного каталога (например, в @file{gdb-@value{GDBVN}/gdb}), и
наберите:

@example
make gdb.dvi
@end example

Это передаст @file{gdb.dvi} вашей программе печати @sc{dvi}.

@node Установка GDB
@appendix Установка @value{GDBN}
@cindex конфигурация @value{GDBN}
@cindex установка

@value{GDBN} поставляется вместе со сценарием @code{configure}, который
автоматизирует процесс подготовки @value{GDBN} к установке; затем вы можете
использовать @code{make} для построения программы @code{gdb}.
@iftex
@footnote{Если у вас более новая версия @value{GDBN}, чем @value{GDBVN},
просмотрите файл @file{README} в исходном каталоге; мы могли
усовершенствовать процедуру установки с момента публикации этого
руководства.}
@end iftex

Дистрибутив @value{GDBN} включает весь исходный код, который вам
понадобится для @value{GDBN}, в одном каталоге, имя которого обычно
составляется добавлением номера версии к @samp{gdb}.

Например, дистрибутив @value{GDBN} версии @value{GDBVN} находится в каталоге
@file{gdb-@value{GDBVN}}.  Этот каталог содержит:

@table @code
@item gdb-@value{GDBVN}/configure @r{(и файлы поддержки)}
сценарий для конфигурации @value{GDBN} и всех поддерживаемых библиотек

@item gdb-@value{GDBVN}/gdb
исходные тексты, специфичные для самого @value{GDBN}

@item gdb-@value{GDBVN}/bfd
исходные тексты для библиотеки описания двоичных файлов (Binary File
Descriptor)

@item gdb-@value{GDBVN}/include
включаемые файлы @sc{gnu}

@item gdb-@value{GDBVN}/libiberty
исходные тексты для библиотеки свободного программного обеспечения
@samp{-liberty}

@item gdb-@value{GDBVN}/opcodes
исходные тексты библиотеки таблиц кодов операций и дисассемблеров

@item gdb-@value{GDBVN}/readline
исходные тексты интерфейса командной строки @sc{gnu}

@item gdb-@value{GDBVN}/glob
исходные тексты подпрограммы @sc{gnu} сопоставления с образцом имени
файла

@item gdb-@value{GDBVN}/mmalloc
исходные тексты пакета @sc{gnu} для выделения памяти
@end table

Простейший способ сконфигурировать и собрать @value{GDBN} состоит в
выполнении @code{configure} из исходного каталога
@file{gdb-@var{номер-версии}}, который в этом примере есть
@file{gdb-@value{GDBVN}}.

Сперва перейдите в исходный каталог @file{gdb-@var{номер-версии}}, если вы
еще не находитесь в нем; затем запустите @code{configure}.  Передайте в
качестве аргумента идентификатор платформы, на которой будет выполняться
@value{GDBN}.

Например:

@example
cd gdb-@value{GDBVN}
./configure @var{платформа}
make
@end example

@noindent
где @var{платформа} --- идентификатор, такой как @samp{sun4} или
@samp{decstation}, задающий платформу, на которой будет выполняться
@value{GDBN}.  (Часто вы
можете опустить @var{платформу}; @code{configure} пытается определить
корректное значение, изучая вашу систему.)

Выполнение @samp{configure @var{платформа}} и затем @code{make} строит
библиотеки @file{bfd}, @file{readline}, @file{mmalloc} и
@file{libiberty}, а затем сам @code{gdb}.  Сконфигурированные исходные
файлы, а также двоичные файлы, остаются в соответствующих исходных
каталогах.

@need 750
@code{configure} является сценарием оболочки Bourne (@code{/bin/sh}); если
ваша система не распознает это автоматически, когда вы находитесь в
другой оболочке, вам может потребоваться выполнить @code{sh} явно:

@example
sh configure @var{платформа}
@end example

Если вы выполните @code{configure} из каталога, содержащего исходные
каталоги для нескольких библиотек или программ, например
@file{gdb-@value{GDBVN}} для версии @value{GDBVN}, @code{configure}
создает файлы конфигурации для всех подкаталогов низшего уровня (если вы не
велите ему не этого делать ключом @samp{--norecursion}).

Вы можете выполнить сценарий @code{configure} из любого подкаталога из
поставки @value{GDBN}, если вы хотите сконфигурировать только этот
подкаталог, но убедитесь, что указали путь к нему.

Например, для версии @value{GDBVN}, чтобы сконфигурировать только подкаталог
@code{bfd}, введите:

@example
@group
cd gdb-@value{GDBVN}/bfd
../configure @var{платформа}
@end group
@end example

Вы можете установить @code{@value{GDBP}} куда угодно; он не имеет никаких
жестко заданных путей.  Однако, вы должны удостовериться, что ваша оболочка
(определяемая переменной среды @samp{SHELL}) доступна всем для чтения.
Помните, что @value{GDBN} использует оболочку для запуска вашей
программы --- некоторые системы не позволяют @value{GDBN} отлаживать
дочерние процессы, чьи программы недоступны для чтения.

@menu
* Отдельный объектный каталог:: Компиляция @value{GDBN} в другом каталоге
* Имена конфигураций::          Определение имен рабочих и целевых машин
* Ключи configure::             Обзор ключей для configure
@end menu

@node Отдельный объектный каталог
@section Компиляция @value{GDBN} в другом каталоге

Если вы хотите запускать версии @value{GDBN} на нескольких рабочих или
целевых машинах, вам нужны различные @code{gdb}, скомпилированные для
каждой комбинации рабочей и целевой машины.  @code{configure} разработан
так, чтобы облегчить это, позволяя вам создавать каждую конфигурацию в
отдельном подкаталоге, а не в исходном каталоге.  Если ваша программа
@code{make} поддерживает возможности @samp{VPATH} (@sc{gnu} @code{make}
поддерживает), вызов @code{make} в каждом из этих каталогов строит
программу @code{gdb}, определенную там.

Чтобы построить @code{gdb} в отдельном каталоге, запустите @code{configure} с
ключом @samp{--srcdir}, для определения, где искать исходники.  (Вам также
нужно определить путь для поиска @code{configure} из вашего рабочего каталога.
Если путь к @code{configure} совпадает с параметром @samp{--srcdir},
ключ @samp{--srcdir} можно опустить; он подразумевается.)

Например, в версии @value{GDBVN}, вы можете построить @value{GDBN} в
отдельном каталоге для Sun 4 так:

@example
@group
cd gdb-@value{GDBVN}
mkdir ../gdb-sun4
cd ../gdb-sun4
../gdb-@value{GDBVN}/configure sun4
make
@end group
@end example

Когда @code{configure} строит конфигурацию, используя удаленный
каталог с исходниками, он создает дерево для двоичных файлов с той же
структурой (и используя те же имена), что и дерево каталогов с
исходными текстами.  В этом примере, вы бы нашли библиотеку Sun 4
@file{libiberty.a} в каталоге @file{gdb-sun4/libiberty}, а сам
@value{GDBN} --- в @file{gdb-sun4/gdb}.

Одна из распространенных причин построения нескольких конфигураций
@value{GDBN} в отдельных каталогах состоит в том, чтобы конфигурировать
@value{GDBN} для кросс-компиляции (где @value{GDBN} запускается на
одной машине --- @dfn{рабочей}, в то время как отлаживаемые программы
выполняются на другой машине --- @dfn{целевой}).  Вы определяете целевую
машину кросс-отладки ключом @code{configure} @samp{--target=@var{цель}}.

Когда вы выполняете @code{make} для построения программы или библиотеки,
вы должны выполнять ее из сконфигурированного каталога --- того каталога,
из которого вы вызывали @code{configure} (или из одного из его подкаталогов).

@code{Makefile}, который создает @code{configure} в каждом исходном
каталоге, также выполняется рекурсивно.  Если вы ввели
@code{make} в каталоге с исходными файлами, например в
@file{gdb-@value{GDBVN}} (или в каталоге, сконфигурированном отдельно
посредством @samp{--srcdir=@var{имя-каталога}/gdb-@value{GDBVN}}),
вы построите все требуемые библиотеки и затем @value{GDBN}.

Когда у вас имеется несколько рабочих или целевых конфигураций в
отдельных каталогах, вы можете запустить @code{make} для них параллельно
(например, если они смонтированы по NFS на каждой рабочей машине); они
не будут конфликтовать друг с другом.

@node Имена конфигураций
@section Определение имен рабочих и целевых машин

Спецификации, использованные для рабочих и целевых машин в сценарии
@code{configure}, именуются в соответствии со схемой именования,
состоящей из трех частей, но поддерживаются также некоторые короткие
предопределенные синонимы.  Полная схема именования кодирует три
фрагмента информации по следующему образцу:

@example
@var{архитектура}-@var{производитель}-@var{ОС}
@end example

Например, вы можете использовать синоним @code{sun4} как параметр
@var{платформа} или как значение @var{цель} в ключе
@code{--target=@var{цель}}.
Эквивалентное полное имя --- @samp{sparc-sun-sunos4}.

Сценарий @code{configure}, сопровождающий @value{GDBN}, не предоставляет
никаких средств для запроса вывода всех поддерживаемых имен рабочих и
целевых машин или их сокращений.  @code{configure} вызывает сценарий
оболочки Bourne @code{config.sub} для отображения сокращений в полные
имена; при желании, вы можете посмотреть сценарий или использовать его
для проверки ваших предположений о сокращениях.  Например:

@smallexample
% sh config.sub i386-linux
i386-pc-linux-gnu
% sh config.sub alpha-linux
alpha-unknown-linux-gnu
% sh config.sub hp9k700
hppa1.1-hp-hpux
% sh config.sub sun4
sparc-sun-sunos4.1.1
% sh config.sub sun3
m68k-sun-sunos4.1.1
% sh config.sub i986v
Invalid configuration `i986v': machine `i986v' not recognized
@end smallexample

@noindent
@code{config.sub} также распространяется в исходном каталоге
@value{GDBN} (@file{gdb-@value{GDBVN}}, для версии @value{GDBVN}).

@node Ключи configure
@section Ключи @code{configure}

Здесь приводится обзор ключей и параметров @code{configure}, которые
наиболее часто используются для построения @value{GDBN}.
@code{configure} также имеет несколько других ключей, не представленных
здесь.  @inforef{What Configure Does,,configure.info}, для полного
объяснения @code{configure}.

@example
configure @r{[}--help@r{]}
          @r{[}--prefix=@var{каталог}@r{]}
          @r{[}--exec-prefix=@var{каталог}@r{]}
          @r{[}--srcdir=@var{имя-каталога}@r{]}
          @r{[}--norecursion@r{]} @r{[}--rm@r{]}
          @r{[}--target=@var{цель}@r{]}
          @var{платформа}
@end example

@noindent
Если хотите, можете вводить ключи с одним @samp{-}, а не с @samp{--}; но
если вы используете @samp{--}, вы можете сокращать имена ключей.

@table @code
@item --help
Отображает краткий обзор, как вызывать @code{configure}.

@item --prefix=@var{каталог}
Конфигурировать исходник для установки программ и файлов в подкаталогах
@file{@var{каталога}}.

@item --exec-prefix=@var{каталог}
Конфигурировать исходник для установки программ в каталог
@file{@var{каталог}}.

@need 2000
@item --srcdir=@var{имя-каталога}
@strong{Предупреждение: использование этого ключа требует @sc{gnu}
@code{make} или другой программы @code{make}, реализующей возможности
@code{VPATH}.}@*
Используйте этот ключ для создания конфигураций в каталогах,
отдельных от исходного каталога @value{GDBN}.  Кроме всего прочего, вы
можете использовать его для построения (или поддержки)
нескольких конфигураций одновременно в отдельных каталогах.
@code{configure} записывает файлы, относящиеся к конфигурации, в текущий
каталог, но принимает меры, чтобы можно было использовать исходники в
каталоге @var{имя-каталога}.  @code{configure} создает каталоги внутри
рабочего каталога параллельно с исходными каталогами внутри @var{имя-каталога}.

@item --norecursion
Конфигурировать только тот уровень каталогов, где выполняется
@code{configure}; не распространять конфигурацию на подкаталоги.

@item --target=@var{цель}
Конфигурировать @value{GDBN} для кросс-отладки программ, выполняемых на
указанной @var{цели}.  Без этого ключа @value{GDBN} конфигурируется для
отладки программ, выполняемых на той же машине (@var{платформе}), что и сам
@value{GDBN}.

Нет никакого удобного способа сгенерировать список всех доступных
целей.

@item @var{платформа} @dots{}
Конфигуровать @value{GDBN} для выполнения на указанной @var{платформе}.

Нет никакого удобного способа сгенерировать список всех допустимых
платформ.
@end table

Существует также много других ключей, но обычно они требуются только для
специальных целей.

@node Алфавитный указатель
@unnumbered Алфавитный указатель

@printindex cp

@c @tex
@c % I think something like @colophon should be in texinfo.  In the
@c % meantime:
@c \long\def\colophon{\hbox to0pt{}\vfill
@c \centerline{The body of this manual is set in}
@c \centerline{\fontname\tenrm,}
@c \centerline{with headings in {\bf\fontname\tenbf}}
@c \centerline{and examples in {\tt\fontname\tentt}.}
@c \centerline{{\it\fontname\tenit\/},}
@c \centerline{{\bf\fontname\tenbf}, and}
@c \centerline{{\sl\fontname\tensl\/}}
@c \centerline{are used for emphasis.}\vfill}
@c \page\colophon
@c % Blame: doc@cygnus.com, 1991.
@c @end tex

@c TeX can handle the contents at the start but makeinfo 3.12 can not
@ifinfo
@contents
@end ifinfo
@ifhtml
@contents
@end ifhtml

@bye
