@ignore
This file documents the user interface to the GNU History library.

Copyright (C) 1988-1999 Free Software Foundation, Inc.
Authored by Brian Fox and Chet Ramey.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on
all copies.

Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
GNU Copyright statement is available to the distributee, and provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ignore

@node Интерактивное использование истории
@chapter Использование истории в интерактивном режиме

@c @ifclear BashFeatures
@c @defcodeindex bt
@c @end ifclear

@ifset BashFeatures
Эта глава описывает, как использовать библиотеку @sc{gnu} History
интерактивно, c точки зрения пользователя.  Она должна рассматриваться
как руководство пользователя.  Для информации об использовании
библиотеки @sc{gnu} History в других программах, смотрите руководство по
библиотеке @sc{gnu} Readline.
@end ifset
@ifclear BashFeatures
Эта глава описывает, как использовать библиотеку @sc{gnu} History
интерактивно, c точки зрения пользователя.  Она должна рассматриваться
как руководство пользователя.
@c  For
@c information on using the GNU History Library in your own programs,
@c @pxref{Programming with GNU History}.
@end ifclear

@ifset BashFeatures
@menu
* Возможности истории Bash::         Как Bash позволяет вам управлять
                                     историей команд.
* Встроенные команды истории Bash::  Встроенные команды Bash для управления
                                     историей команд.
* Взаимодействие с историей::        Как выглядит использование истории с
                                     точки зрения пользователя.
@end menu
@end ifset
@ifclear BashFeatures
@menu
* Взаимодействие с историей::        Как выглядит использование истории с
                                     точки зрения пользователя.
@end menu
@end ifclear

@ifset BashFeatures
@node Возможности истории Bash
@section Возможности истории Bash
@cindex история команд
@cindex список истории

Когда включен параметр @samp{-o history} к встроенной команде @code{set}
(@pxref{Встроенная команда set}), оболочка предоставляет доступ к
@dfn{истории команд}, списку команд, введенных ранее.  Значение
переменной оболочки @code{HISTSIZE} используется как число команд,
сохраняемое в списке истории.  Сохраняется текст последних
@code{HISTSIZE} команд (по умолчанию 500).
Оболочка сохраняет каждую команду в списке истории до раскрывания
параметров и переменных, но после того, как будет произведено
раскрывание истории, подверженное действию значений переменных оболочки
@code{HISTIGNORE} и @code{HISTCONTROL}.

Когда оболочка стартует,
история инициализируется из файла, указываемого переменной
@code{HISTFILE} (по умолчанию @file{~/.bash_history}).  В случае
необходимости файл, на который указывает значение @code{HISTFILE}
усекается, чтобы число строк, содержащееся
в нем, не превосходило значения переменной @code{HISTFILESIZE}.  При
выходе из интерактивного запуска оболочки, последние @code{HISTSIZE}
строк копируются из списка истории в файл, имя которого содержится в
@code{HISTFILE}.  Если установлен
параметр оболочки @code{histappend} (@pxref{Встроенные команды Bash}),
строки добавляется к файлу истории, в противном случае файл истории
перезаписывается.  Если @code{HISTFILE} не установлена, или файл истории
недоступен для записи, история не сохраняется.  После сохранения, файл
истории усекается, так чтобы он содержал не более @code{HISTFILESIZE}
строк.  Если @code{HISTFILESIZE} не установлена, усечение не
производится.

Встроенная команда @code{fc} может быть использована для вывода или
редактирования и повторного исполнения части списка истории.  Для
отображения или модификации списка истории и манипулирования файлом
истории может быть использована встроенная команда @code{history}.  При
использовании редактирования командной строки, в каждом режиме
редактирования доступны команды поиска, предоставляющие доступ к списку
истории (@pxref{Команды для истории}).

Оболочка позволяет контролировать, какие команды сохраняются в список
истории.  Чтобы оболочка сохраняла лишь подмножество введенных команд,
могут быть установлены переменные @code{HISTCONTROL} и
@code{HISTIGNORE}.  Параметр оболочки @code{cmdhist}, если он включен,
велит ей пытаться сохранить каждую строку многострочной команды в одном
элементе истории, добавляя где необходимо точки с запятой, чтобы
сохранить синтаксическую корректность.  Параметр оболочки @code{lithist}
указывает ей сохранять команды вместе с содержащимися переносами строк,
вместо точек с запятой.  Для установки этих параметров используется
встроенная команда @code{shopt}.
@xref{Встроенные команды Bash}, для описания @code{shopt}.

@node Встроенные команды истории Bash
@section Встроенные команды истории Bash
@cindex встроенные команды истории

Bash предоставляет две встроенные команды, которые управляют
списком и файлом истории.

@table @code

@item fc
btindex fc
@example
@code{fc [-e @var{имя-ред}] [-nlr] [@var{первая}] [@var{последняя}]}
@code{fc -s [@var{шабл}=@var{замена}] [@var{команда}]}
@end example

Команда исправления.  В первой форме, диапазон команд от @var{первой} до
@var{последней} выбираются из списка истории.  Как @var{первая}, так и
@var{последняя} могут быть заданы строкой (для нахождения последней
команды, начинающейся с этой строки) или числом (номером в списке
истории, причем отрицательные числа рассматриваются как смещение от
номера текущей команды).  Если @var{последняя} команда не определена,
она приравнивается @var{первой}.  Если не определена @var{первая}
команда, она приравнивается предыдущей команде при редактировании и
@minus{}16 для вывода.  Если задан ключ @option{-l}, команды выводятся
на стандартный вывод.  Ключ @option{-n} подавляет номера строк при
выводе.  Ключ @option{-r} изменяет порядок вывода на противоположный.  В
противном случае, для файла, содержащего эти команды, запускается
редактор, указанный @var{имя-ред}.  Если @var{имя-ред} не задано,
используется результат раскрывания следующих переменных:
@code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}.  Эта конструкция указывает
использовать значение переменной @code{FCEDIT}, если она установлена,
или значение переменной @code{EDITOR}, если она установлена, или, если
ни одна из этих переменных не установлена, @code{vi}.  Когда
редактирование завершено, отредактированные команды выводятся и
выполняются.

Во второй форме, @var{команда} выполняется заново после того, как каждое
вхождение @var{шабл} в выбранную команду заменяется на @var{замена}.

Полезным синонимом для использования с командой @code{fc} является
@code{r='fc -s'}, так что набор @samp{r cc} запускает последнюю команду,
начинающуюся с @code{cc}, а ввод @samp{r} повторяет последнюю команду
(@pxref{Синонимы}).

@item history
btindex history
@example
history [@var{n}]
history -c
history -d @var{смещение}
history [-anrw] [@var{имя-файла}]
history -ps @var{арг}
@end example

Без параметров --- отобразить список истории с номерами строк.  Строки,
начинающиеся с
@samp{*}, были изменены.  Аргумент @var{n} выводит только
последние @var{n} строк.  Ключи, если они указаны, имеют следующие
значения:

@table @code
@item -c
Очистить список истории.  Этот ключ может быть совмещен с другими, чтобы
полностью заменить список истории.

@item -d @var{смещение}
Удалить элемент истории в позиции @var{смещение}.  @var{Смещение} должно
быть задано так, как оно появляется при отображении истории.

@item -a
Добавить новые строки истории (строки, введенные с начала текущего
сеанса Bash) в файл истории.

@item -n
Добавить строки истории, еще не прочитанные из файла истории к списку.
Это строки, добавленные в файл после начала текущего сеанса Bash.

@item -r
Считать текущий файл истории и добавить его содержимое к списку истории.

@item -w
Записать текущую историю в файл истории.

@item -p
Произвести подстановку истории для аргументов @var{арг} и вывести
результат на стандартный вывод, не сохраняя их с списке истории.

@item -s
Добавить аргументы @var{арг} в конец списка истории в виде одного
элемента.

@end table

Когда используются любые из ключей @option{-w}, @option{-r}, @option{-a} или
@option{-n}, если @var{имя-файла} задано, оно используется как файл
истории.  Если оно не задано, используется значение переменной
@code{HISTFILE}.

@end table
@end ifset

@node Взаимодействие с историей
@section Раскрывание истории
@cindex раскрывание истории

Библиотека History обеспечивает средства раскрывания истории, подобные
предоставляемым @code{csh}.  Этот раздел описывает
синтаксис, использующийся для управления информацией истории.

Раскрывание истории вводит слова из списка истории во входной поток,
облегчая повторение команд, вставку аргументов предыдущей команды в
текущую строку ввода или быстрое устранение ошибок в предыдущей
команде. 

Раскрывание истории происходит в два этапа.  Первый заключается в
определении, какая из строк списка истории должна использоваться
в процессе замены.  На втором этапе выбираются части этой строки для включения
в текущую.  Строка, выбранная из истории, называется @dfn{событием}, а
использованные части называются @dfn{словами}.  Существуют различные
@dfn{модификаторы} для манипулирования выбранными словами.  Строка
разбивается на слова так же, как это делает Bash, так что несколько
слов, заключенных в кавычки, рассматриваются как одно слово.
Раскрывания истории вводятся появлением специального знака, по
умолчанию это @samp{!}.
@ifset BashFeatures
Только @samp{\} и @samp{'} могут использоваться для экранирования знака
раскрывания истории.
@end ifset

@ifset BashFeatures
Некоторые параметры оболочки, устанавливаемые встроенной командой
@code{shopt} (@pxref{Встроенные команды Bash}), могут использоваться для
настройки поведения раскрывания истории.  Если включен параметр
@code{histverify}, и используется Readline, подстановки истории не
передаются немедленно анализатору оболочки.  Вместо этого, раскрытая
строка загружается снова в буфер редактирования Readline для дальнейших
изменений.  Если используется Readline, и включен параметр оболочки
@code{histreedit}, неудавшееся раскрывание истории будет снова загружено
в буфер редактирования Readline для коррекции.  Ключ @option{-p}
встроенной команды @code{history} может использоваться, чтобы посмотреть,
какое раскрывание истории произойдет, прежде чем делать его.  Ключ
@option{-s} встроенной команды @code{history} может использоваться для
добавления команд в конец списка истории, не выполняя их, так что они
будут доступны для дальнейшего использования.  Это наиболее эффективно
при использовании с Readline.

Оболочка производит контроль различных знаков, используемых механизмом
раскрывания истории, с помощью переменной @code{histchars}.
@end ifset

@menu
* Указатели событий::   Как указать, какую строку истории использовать.
* Указатели слов::      Определение интересующих слов.
* Модификаторы::        Изменение результатов подстановки.
@end menu

@node Указатели событий
@subsection Указатели событий
@cindex указатели событий

Указатель событий является ссылкой на запись командной строки в
списке истории.
@cindex события истории

@table @asis

@item @code{!}
Начать подстановку истории, если только за @code{!} не следует пробел,
знак табуляции, знак конца строки, @samp{=} или @samp{(}.

@item @code{!@var{n}}
Сослаться на командную строку с номером @var{n}.

@item @code{!-@var{n}}
Сослаться на командную строку, отстоящую на @var{n} строк назад.

@item @code{!!}
Сослаться на предыдущую команду.  Это синоним для @samp{!-1}.

@item @code{!@var{строка}}
Сослаться на самую последнюю команду, начинающуюся со @var{строки}.

@item @code{!?@var{строка}[?]}
Сослаться на самую последнюю команду, содержащую @var{строку}.  @samp{?}
в конце может быть опущен, если знак новой строки следует немедленно за
@var{строкой}.

@item @code{^@var{строка1}^@var{строка2}^}
Быстрая подстановка.  Повторяет последнюю команду, заменяя @var{строку1}
на @var{строку2}.  Эквивалентно @code{!!:s/@var{строка1}/@var{строка2}/}.

@item @code{!#}
Вся командная строка, введенная до этого момента.

@end table

@node Указатели слов
@subsection Указатели слов

Указатели слов используются для выбора желаемых слов из события.
Спецификация события отделяется от указателя слова двоеточием.
Его можно опустить, если указатель слова начинается с @samp{^},
@samp{$}, @samp{*}, @samp{-} или @samp{%}.  Слова нумеруются от начала
строки, причем первому слову присваивается номер 0 (ноль).  Слова
вставляются в текущую строку, разделенные одиночными пробелами.

@need 0.75
Например, 

@table @code
@item !!
обозначает предыдущую команду.  Когда вы это вводите, предыдущая команда
повторяется один к одному.

@item !!:$
обозначает последний аргумент предыдущей команды.  Это может быть
сокращено как @code{!$}.

@item !fi:2
обозначает второй аргумент самой последней команды, начинавшейся с букв
@code{fi}.
@end table

@need 0.75
Вот указатели слов:

@table @code

@item 0 (ноль)
Нулевое слово.  Для многих приложений, это командное слово.

@item @var{n}
@var{n}-ное слово.

@item ^
Первый аргумент, то есть слово 1.

@item $
Последний аргумент.

@item %
Слово, соответствующее самому последнему поиску @samp{?@var{строка}?}.

@item @var{x}-@var{y}
Диапазон слов; @samp{0-@var{y}} сокращается как @samp{-@var{y}}.

@item *
Все слова, за исключением нулевого.  Это синоним для @samp{1-$}.  Даже
если в событии имеется только одно слово, использование @samp{*} не
является ошибкой; в этом случае возвращается пустая строка.

@item @var{x}*
Сокращение для @samp{@var{x}-$}

@item @var{x}-
Сокращает @samp{@var{x}-$} как @samp{@var{x}*}, но опускает последнее
слово.

@end table

Если указатель слова задается без указания события, в качестве события
используется предыдущая команда.

@node Модификаторы
@subsection Модификаторы

После необязательного указателя слова вы можете добавить
последовательность из одного или более следующих модификаторов,
перед каждым из которых ставится двоеточие.

@table @code

@item h
Удалить заключительную компоненту имени пути, оставляя только начальную.

@item r
Удалить заключительный суффикс, имеющий форму @samp{.@var{суффикс}},
оставляя базовое имя.

@item e
Удалить все, кроме заключительного суффикса.

@item p
Напечатать новую команду, но не выполнять ее.

@ifset BashFeatures
@item q
Заключить подмененные слова в кавычки, предотвращая дальнейшие
подстановки.

@item x
Заключать подмененные слова в кавычки, как с @samp{q}, но разбивать на
слова по пробелам, знакам табуляции и новых строк.
@end ifset

@item s/@var{старое}/@var{новое}/
Заменить первое появление @var{старое} на @var{новое} в строке
события.  На месте @samp{/} может использоваться любой разделитель.
Разделитель может быть включен в @var{старое} или @var{новое} с помощью
обратной косой черты.  Если в @var{новое} появляется знак @samp{&}, он
заменяется на @var{старое}.  Одиночная обратная косая черта
экранирует @samp{&}.  Заключительный разделитель необязателен, если он
является последним знаком во входной строке.

@item &
Повторить предыдущую подстановку.

@item g
Велит применить изменения ко всей строке события.  Используется вместе с
@samp{s}, как в @code{gs/@var{старое}/@var{новое}/}, или с @samp{&}.

@end table
