@comment %**start of header (This is for running Texinfo on a region.)
@setfilename rluser.info
@comment %**end of header (This is for running Texinfo on a region.)
@setchapternewpage odd

@ignore
This file documents the end user interface to the GNU command line
editing features.  It is to be an appendix to manuals for programs which
use these features.  There is a document entitled "readline.texinfo"
which contains both end-user and programmer documentation for the
GNU Readline Library.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Authored by Brian Fox and Chet Ramey.

Permission is granted to process this file through Tex and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on
all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
GNU Copyright statement is available to the distributee, and provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ignore

@comment If you are including this manual as an appendix, then set the
@comment variable readline-appendix.

@ifclear BashFeatures
@defcodeindex bt
@end ifclear

@node Редактирование командной строки
@chapter Редактирование командной строки

Эта глава описывает основные возможности интерфейса редактирования
командной строки @sc{gnu}.
@ifset BashFeatures
Редактирование командной строки обеспечивается библиотекой Readline,
которая используется несколькими различными программами, включая Bash.
@end ifset

@menu
* Введение и обозначения::         Обозначения, используемые в этом тексте.
* Взаимодействие с Readline::      Минимальный набор команд для редактирования
                                   командной строки.
* Файл инициализации Readline::    Настройка Readline с точки
                                   зрения пользователя
* Привязываемые команды Readline:: Описание большинства команд Readline,
                                   доступных для привязки.
* Режим vi Readline::              Короткое описание, как сделать поведение
                                   Readline похожим на редактор vi.
@ifset BashFeatures
* Программируемые завершения::       Как задать возможные завершения для
                                   конкретной команды.
* Встроенные программируемые завершения::   Встроенные команды для указания,
                                   как дополнить аргументы для определенной
                                   команды.
@end ifset
@end menu  

@node Введение и обозначения
@section Введение в редактирование строк

Следующие абзацы описывают нотацию, используемую для обозначения
нажатия клавиш.

Текст @kbd{C-k} читается как `Control-K' и описывает знак, получаемый
нажатием клавиши @key{k} при нажатой клавише Control.

Текст @kbd{M-k} читается как `Meta-K' и описывает знак, вводимый
нажатием клавиши @key{k} при нажатой клавише Meta (если у вас она
имеется).  На многих клавиатурах клавиша Meta надписана как
@key{ALT}.  На клавиатурах с двумя клавишами @key{ALT}
(обычно по разные стороны от пробела), @key{ALT} на левой стороне обычно
устанавливается для работы клавишей Meta.  Правый @key{ALT}
также может быть сконфигурирован для работы Meta, или он может быть
сконфигурирован как другой модификатор, например как клавиша Compose для
ввода букв с акцентами.

Если у вас нет клавиши Meta или @key{ALT} или другой клавиши,
работающей как Meta, идентичное нажатие клавиш можно получить
нажав @i{сначала} @key{ESC}, а затем @key{k}.  Эти процессы
называются @dfn{метафикацией} клавиши @key{k}.

Текст @kbd{M-C-k} читается как `Meta-Control-k' и описывает знак,
получаемый посредством @dfn{метафикации} @kbd{C-k}.

Кроме того, некоторые клавиши имеют собственные имена.  Именно,
@key{DEL}, @key{ESC}, @key{LFD}, @key{SPC}, @key{RET} и @key{TAB} в этом
тексте или в файле инициализации обозначают сами себя (@pxref{Файл
инициализации Readline}).
Если на вашей клавиатуре нет клавиши @key{LFD}, нажатие @kbd{C-j}
приведет к вводу желаемого знака.
Клавиша @key{RET} на некоторых клавиатурах может быть отмечена как
@key{Return} или @key{Enter}.

@node Взаимодействие с Readline
@section Взаимодействие с Readline
@cindex взаимодействие с readline

Часто во время интерактивного сеанса вы вводите длинную строку
текста и только потом замечаете, что первое слово набрано
неправильно.  Библиотека Readline дает вам набор команд для
управления текстом во время ввода, позволяя вам лишь исправить опечатку,
а не набирать заново большую часть строки.  С помощью
этих команд редактирования, вы перемещаете курсор в место,
требующее исправления, и удаляете или вставляете текст для коррекции.
Затем, когда строка полностью исправлена, вы просто нажимаете @key{RET}.
Чтобы нажать @key{RET}, вам не обязательно находиться в конце строки; вся
строка вводится независимо от расположения в ней курсора.

@menu
* Сведения первой необходимости:: Минимум, который вам необходимо
                                  знать о Readline.
* Команды перемещения Readline::  Перемещение по строке ввода.
* Команды уничтожения Readline::  Как уничтожить текст, и как его восстановить.
* Параметры команд Readline::     Задание числовых аргументов командам.
* Поиск в истории::               Поиск в предыдущих строках.
@end menu

@node Сведения первой необходимости
@subsection Сведения первой необходимости
@cindex обозначения, readline
@cindex редактирование команд
@cindex редактирование командных строк

Для того, чтобы ввести знак в строку, просто нажмите его.  Введенный знак
появляется там, где был курсор, и затем курсор перемещается на одну
позицию вправо.  Если вы неверно набрали знак, вы можете использовать
ваш знак уничтожения, чтобы вернуться и удалить неверный знак.

Иногда вы можете набрать знак ошибочно и не заметить ошибки, пока не
напечатаете несколько других знаков.  В этом случае, вы можете набрать
@kbd{C-b}, чтобы переместить курсор влево, и затем исправить вашу
ошибку.  После этого, вы можете переместить курсор вправо нажатием
@kbd{C-f}.

Когда вы добавляете текст в середину строки, знаки справа от
курсора `сдвигаются вперед', чтобы освободить место для вставляемого
текста.  Аналогично, когда вы удаляете текст за курсором, знаки
справа от него `сдвигаются назад', занимая пустое пространство,
созданное в результате удаления текста.  Ниже следует список
команд первой необходимости для редактирования вводимого текста.

@table @asis
@item @kbd{C-b}
Переместиться назад на одну позицию.
@item @kbd{C-f}
Переместиться вперед на одну позицию.
@item @key{DEL} или @key{Backspace}
Удалить знак слева от курсора.
@item @kbd{C-d}
Удалить знак под курсором.
@item @w{Ввод знаков}
Вставить знак в строку в позицию курсора.
@item @kbd{C-_} или @kbd{C-x C-u}
Отменить последнюю команду редактирования.  Вы можете отменить все,
вернувшись назад к пустой строке.
@end table

@noindent
(В зависимости от вашей конфигурации, клавиша @key{Backspace} может быть
настроена удалять знак слева от курсора, а @key{DEL} удалять знак под
курсором, как @kbd{C-d}, вместо знака, расположенного от курсора
слева.)

@node Команды перемещения Readline
@subsection Команды перемещения Readline


Приведенная выше таблица описывает только самые базовые
последовательности клавиш, которые
могут вам понадобиться для редактирования строки ввода.  Для удобства, в
дополнение к @kbd{C-b}, @kbd{C-f}, @kbd{C-d} и @key{DEL} были добавлены
многие другие команды.  Вот некоторые из них, предназначенные для более
быстрого перемещения по строке.

@table @kbd
@item C-a
Переместиться в начало строки.
@item C-e
Переместиться в конец строки.
@item M-f
Переместиться вперед на слово.  Слово состоит из букв и цифр.
@item M-b
Переместиться назад на слово.
@item C-l
Очистить экран, напечатав текущую строку заново вверху экрана.
@end table

Заметьте, что @kbd{C-f} перемещает курсор вперед на один знак, в то время
как @kbd{M-f} перемещает вперед на слово.  Это своего рода соглашение,
что при нажатии клавиши Сontrol производятся действия над знаками, а при
нажатии клавиши Meta --- над словами.

@node Команды уничтожения Readline
@subsection Команды уничтожения Readline

@cindex уничтожение текста
@cindex восстановление текста

@dfn{Уничтожение} текста означает уничтожение текста из строки, но
сохранение его для дальнейшего использования, обычно для
@dfn{восстановления} (повторной вставки) обратно в строку.  (`Вырезать'
и `вставить' являются более современными жаргонными синонимами для
`уничтожить' и `восстановить'.)

Если в описании команды сказано, что она `уничтожает' текст,
то вы можете быть уверены, что позже его можно будет получить обратно в
другом (или том же самом) месте.

Когда вы используете команду уничтожения, текст сохраняется в
@dfn{кольцевом списке уничтожений}.  Любое число последовательных уничтожений
сохраняет весь уничтоженный текст вместе, так что когда вы
восстанавливаете его назад, вы получите все.  Список уничтожений не
имеет привязки к строкам; текст, уничтоженный вами в предыдущей строке
ввода, доступен для восстановления позже, когда вы вводите другую
строку.
@cindex кольцевой список уничтожений

Вот список команд для уничтожения текста.

@table @kbd
@item C-k
Уничтожить текст от текущей позиции курсора до конца строки.

@item M-d
Уничтожить от курсора до конца текущего слова или, если курсор
находится между словами, до конца следующего слова.
Границы слов такие же, как и используемые @kbd{M-f}.

@item M-@key{DEL}
Уничтожить от курсора до начала текущего слова или, если курсор
находится между словами, до начала предыдущего слова.
Границы слов такие же, как и используемые @kbd{M-b}.

@item C-w
Уничтожить от курсора до предыдущего пробельного символа.  Это отличается от
M-@key{DEL}, так как границы слова различаются.

@end table

Вот как можно @dfn{восстановить} текст обратно в строку.  Восстановление
означает копирование последнего уничтоженного текста из буфера
уничтожений.

@table @kbd
@item C-y
Восстановить последний уничтоженный текст в буфер перед курсором.

@item M-y
Циклический сдвиг по кольцевому списку уничтожений и восстановление
новой вершины.  Вы можете использовать это, только если предыдущая команда
была @kbd{C-y} или @kbd{M-y}.
@end table

@node Параметры команд Readline
@subsection Параметры команд Readline

Вы можете передавать числовые параметры командам Readline.  Иногда
параметр действует как счетчик повторений, иногда он является
@emph{знаком минус}, если аргумент отрицателен.  Если вы передаете
отрицательный параметр команде, которая обычно действует в прямом
направлении, то она будет действовать в обратном направлении.  Например,
чтобы уничтожить текст до начала строки, вы можете набрать
@samp{@kbd{M--} @kbd{C-k}}.

Общий способ передачи числовых параметров команде состоит в
наборе Meta-цифр перед командой.  Если первая набранная `цифра' есть знак
минус (@samp{-}), тогда знак аргумента будет отрицательным.  Если вы набрали
одну мета-цифру для начала параметра, вы можете набрать оставшиеся
цифры и потом команду.  Например, чтобы передать команде @kbd{C-d}
параметр 10, вы можете набрать @samp{@kbd{M-1 0 C-d}}.

@node Поиск в истории
@subsection Поиск команд в истории

Readline предоставляет команды для поиска в истории команд
@ifset BashFeatures
(@pxref{Возможности истории Bash})
@end ifset
строк, содержащих указанную подстроку.  Существует два режима поиска:
@dfn{наращиваемый} и @dfn{ненаращиваемый}.

Наращиваемый поиск начинается до того, как пользователь закончит ввод
строки поиска.  По мере ввода очередных знаков строки поиска, Readline
отображает следующий элемент из истории, соответствующий строке,
введенной на данный момент.  Наращиваемый поиск требует ровно столько
знаков, сколько требуется для нахождения желаемого элемента истории.
Для поиска определенной строки в истории в обратном направлении, введите
@kbd{C-r}.  Ввод @kbd{C-s} производит поиск в прямом направлении.
Знаки, присутствующие в значении переменной @code{isearch-terminators},
используются для завершения наращиваемого поиска.  Если этой переменной
не было присвоено значение, знаки @key{ESC} и @kbd{C-J} будут завершать
наращиваемый поиск.  @kbd{C-g} прерывает наращиваемый поиск и
восстанавливает исходную строку.  Когда поиск завершается, элемент
истории, содержащий искомую строку, становится текущей строкой.

Для нахождения других подходящих элементов списка истории, введите
соответственно @kbd{C-r} или @kbd{C-s}.  Это произведет поиск вперед или
назад в истории до следующего элемента, соответствующего введенной
строке поиска.  Любая другая последовательность клавиш, привязанная к
команде Readline, завершит поиск и выполнит эту команду.  Например,
@key{RET} завершит поиск и примет эту строку, таким образом выполняя
команду из списка истории.

Ненаращиваемый поиск считывает строку поиска целиком, до начала поиска
соответствующих строк истории.  Строка поиска может быть введена
пользователем или являться частью содержимого текущей строки.

@node Файл инициализации Readline
@section Файл инициализации Readline
@cindex файл инициализации, readline

Хотя библиотека Readline поставляется с установленным по умолчанию набором
привязок клавиш, аналогичному Emacs, возможно использование
другого набора привязок.  Любой пользователь может настраивать
программы, которые используют Readline, помещая команды в файл
@dfn{inputrc}, обычно в своем домашнем каталоге.  Имя этого
@ifset BashFeatures
файла берется из переменной оболочки @code{INPUTRC}.  Если
@end ifset
@ifclear BashFeatures
файла берется из переменной среды @code{INPUTRC}.  Если
@end ifclear
эта переменная не установлена, по умолчанию берется файл @file{~/.inputrc}.

Когда запускается программа, использующая библиотеку Readline,
файл инициализации считывается, и устанавливаются привязки клавиш.

Кроме того, команда @kbd{C-x C-r} считывает файл инициализации заново,
так что изменения, которые вы могли cделать к этому времени, вступают в
силу.

@menu
* Синтаксис файла инициализации Readline:: Синтаксис команд файла инициализации.
* Условные конструкции инициализации::     Условные привязки клавиш в
                                           файле инициализации.
* Пример файла инициализации::             Пример файла инициализации.
@end menu

@node Синтаксис файла инициализации Readline
@subsection Синтаксис файла инициализации Readline

Существуют всего несколько конструкций, которые допускаются в файле
инициализации Readline.  Пустые строки игнорируются.  Строки,
начинающиеся с @samp{#}, являются комментариями.  Строки, начинающиеся с
@samp{$}, обозначают условные конструкции (@pxref{Условные конструкции
инициализации}).  Другие строки обозначают установку переменных и
привязки клавиш.

@table @asis
@item Установка переменных
Вы можете изменять поведение Readline во время выполнения посредством
изменения значений переменных, используя команду @code{set} в
файле инициализации.  Вот как можно изменить привязку клавиш Emacs,
используемую по умолчанию, для использования команд редактирования
строки @code{vi}:

@example
set editing-mode vi
@end example

@ifset BashFeatures
Команда @w{@code{bind -V}} перечисляет имена текущих переменных Readline
и их значения.  @xref{Bash Builtins}.
@end ifset

Основная часть поведения при выполнении изменяется с помощью следующих
переменных.

@table @code
@item bell-style
@vindex bell-style
Контролирует, что происходит, когда Readline хочет издать звук на
терминале.  Если установлено в @samp{none}, Readline никогда не издает
звук.  Если установлено в @samp{visible}, Readline использует визуальный
звонок, если есть возможность.  Если установлено в @samp{audible} (по
умолчанию), Readline пытается издать звук на терминале.

@item comment-begin
@vindex comment-begin
Строка для вставки в начало строки, когда выполняется команда
@samp{insert-comment}.  По умолчанию @code{"#"}.

@item completion-ignore-case
Если установлено в @samp{on}, Readline производит проверку совпадений
и завершение имени файла без учета регистра.
По умолчанию @samp{off}.

@item completion-query-items
@vindex completion-query-items
Количество возможных завершений, определяющее, когда у пользователя
запрашивается, хочет ли он увидеть список возможных вариантов.  Если
число возможных завершений больше этого значения, Readline спросит у
пользователя, хочет он их просмотреть или нет; в противном случае, они
просто отображаются.  По умолчанию устанавливается предел @code{100}.

@item convert-meta
@vindex convert-meta
Если установлено в @samp{on}, Readline будет преобразовывать знаки с
установленным восьмым битом в последовательность клавиш @sc{ascii},
удаляя восьмой бит и подставляя в качестве префикса знак @key{ESC}, тем
самым преобразовывая их в последовательность клавиш с Meta-префиксом.
По умолчанию @samp{on}.

@item disable-completion
@vindex disable-completion
Если установлено в @samp{on}, Readline будет препятствовать завершению
слов.  Знаки завершения будут вставляться в строку так, как если бы они
отображались в @code{self-insert}.  По умолчанию @samp{off}.

@item editing-mode
@vindex editing-mode
Переменная @code{editing-mode} контролирует, какой набор привязок клавиш
используется.  По умолчанию, Readline запускается в режиме
редактирования Emacs, где нажатия клавиш очень похожи на Emacs.  Эта
переменная может быть установлена или в @samp{emacs}, или в @samp{vi}.

@item enable-keypad
@vindex enable-keypad
Когда установлено в @samp{on}, Readline будет пытаться активизировать
малую клавиатуру приложения, когда она вызывается.  Это требуется
некоторым системам для активации клавиш со стрелками.  По умолчанию
@samp{off}.

@item expand-tilde
@vindex expand-tilde
Если установлено в @samp{on}, производится раскрывание тильды, когда
Readline осуществляет завершение слова.  По умолчанию @samp{off}.

@item horizontal-scroll-mode
@vindex horizontal-scroll-mode
Эта переменная может быть установлена в @samp{on} или @samp{off}.
Установка в @samp{on} означает, что текст в редактируемых строках будет
прокручиваться горизонтально в одной строке экрана, когда ширина строки
становится больше ширины экрана, вместо переноса на новую строку.  По
умолчанию, эта переменная установлена в @samp{off}.

@item input-meta
@vindex input-meta
@vindex meta-flag
Если установлено в @samp{on}, Readline включит восьмибитный ввод
(восьмой бит не будет удаляться из считываемых знаков) независимо от
того, поддерживает ли это терминал.  Значение по умолчанию @samp{off}.
Имя @code{meta-flag} является синонимом для этой переменной.

@item isearch-terminators
@vindex isearch-terminators
Строка из знаков, которые должны прекращать наращиваемый поиск без
последующего выполнения знака как команды (@pxref{Поиск в истории}).
Если этой переменной не присвоено значение, наращиваемый поиск
прекращают знаки @key{ESC} и @kbd{C-J}.

@item keymap
@vindex keymap
Устанавливает текущую раскладку клавиатуры Readline для привязок команд
к клавишам.  Возможные имена для @code{keymap}: @code{emacs},
@code{emacs-standard}, @code{emacs-meta}, @code{emacs-ctlx}, @code{vi},
@code{vi-command} и @code{vi-insert}.  @code{vi} эквивалентно
@code{vi-command}; @code{emacs} эквивалентно @code{emacs-standard}.
Значение по умолчанию @code{emacs}.  Значение переменной
@code{editing-mode} также влияет на раскладку по умолчанию.

@item mark-directories
Если установлено в @samp{on}, к именам каталогов после завершения
добавляется косая черта.  По умолчанию @samp{on}.

@item mark-modified-lines
@vindex mark-modified-lines
Эта переменная, будучи установлена в @samp{on}, велит Readline
отображать звездочку (@samp{*}) в начале тех строк истории, которые были
модифицированы.  По умолчанию, эта переменная установлена в @samp{off}.

@item output-meta
@vindex output-meta
Если установлено в @samp{on}, Readline будет отображать знаки с
установленным восьмым битом непосредственно, а не в виде экранирующих
последовательностей с Meta-префиксом.  По умолчанию @samp{off}.

@item print-completions-horizontally
Если установлено в @samp{on}, Readline будет отображать завершения,
отсортированные горизонтально в алфавитном порядке, а не вниз по
экрану.  По умолчанию @samp{off}.

@item show-all-if-ambiguous
@vindex show-all-if-ambiguous
Это изменяет поведение по умолчанию функций завершения.  При
установке в @samp{on}, если слово имеет более одного возможного
завершения, они будут выводиться немедленно, вместо подачи сигнала.  По
умолчанию @samp{off}.

@item visible-stats
@vindex visible-stats
Если установлено в @samp{on},
при выводе возможных завершений, к имени файла добавляется знак,
обозначающий тип файла.  По умолчанию @samp{off}.

@end table

@item Привязки клавиш
Синтаксис для управления привязками клавиш в файле инициализации прост.
Во-первых, вы должны найти имя команды, которую вы хотите изменить.
Следующий раздел содержит таблицы с именем команды, привязкой клавиш по
умолчанию, если таковые есть, и коротким описанием, что делает команда.

Если вы знаете имя команды, просто поместите в строке файла
инициализации название клавиши, к которой вы хотите привязать команду,
двоеточие и затем имя команды.  Название клавиши может быть выражено
различными способами, в зависимости от того, как вам удобнее.

@ifset BashFeatures
Команда @w{@code{bind -p}} отображает имена функций Readline и привязки,
в таком формате, что вы можете поместить их непосредственно в файл
инициализации.
@xref{Bash Builtins}
@end ifset

@table @asis
@item @w{@var{назв-клавиши}: @var{имя-функции} или @var{макрос}}
@var{назв-клавиши} --- это название клавиши, записанное по-английски.
Например:
@example
Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "> output"
@end example

В этом примере, @kbd{C-u} привязана к функции @code{universal-argument},
а @kbd{C-o} привязана к выполнению макрокоманды, записанной с правой
стороны (то есть, вставить текст @samp{> output} в строку).

@item @w{"@var{послед-клавиш}": @var{имя-функции} или @var{макро}}
@var{послед-клавиш} отличается от вышеупомянутого @var{назв-клавиши}
тем, что позволяет определять строки, обозначающие целую последовательность
клавиш, посредством ее заключения в двойные кавычки.
Могут быть использованы некоторые экранирующие последовательности в стиле
@sc{gnu} Emacs, как в следующем примере, но имена специальных знаков не
распознаются.

@example
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
@end example

В этом примере, @kbd{C-u} привязывается к функции
@code{universal-argument} (как это было в первом примере),
@samp{@kbd{C-x} @kbd{C-r}} привязывается к функции
@code{re-read-init-file} и @samp{@key{ESC} @kbd{[ 1 1 ~}} привязывается к
вставке текста @samp{Function Key 1}.

@end table

Следующие экранирующие последовательности в стиле @sc{gnu} Emacs доступны
при определении последовательности клавиш:

@table @code
@item @kbd{\C-}
префикс Control
@item @kbd{\M-}
префикс Meta
@item @kbd{\e}
префикс экранирующего знака
@item @kbd{\\}
обратная косая черта
@item @kbd{\"}
@key{"}, знак двойных кавычек
@item @kbd{\'}
@key{'}, одинарная кавычка или апостроф
@end table

В дополнение к экранирующим последовательностям стиля @sc{gnu} Emacs,
доступен второй набор последовательностей с обратной косой чертой:

@table @code
@item \a
тревога (звуковой сигнал)
@item \b
переместиться назад на одну позицию
@item \d
удаление
@item \f
перевод страницы
@item \n
новая строка
@item \r
возврат каретки
@item \t
горизонтальная табуляция
@item \v
вертикальная табуляция
@item \@var{nnn}
знак, восьмеричное значение кода @code{ASCII} которого есть @var{nnn}
(от одной до трех цифр)
@item \x@var{nnn}
знак, шестнадцатеричное значение кода @code{ASCII} которого есть @var{nnn}
(от одной до трех цифр)
@end table

При вводе текста макрокоманды, для обозначения ее определения должны
использоваться одиночные или двойные кавычки.  Предполагается, что текст
без кавычек является именем функции.  В теле макрокоманды, экранирующие
последовательности с обратной косой чертой раскрываются.  Обратная косая
черта будет экранировать любой другой знак в тексте макрокоманды,
включая @samp{"} и @samp{'}.  Например, следующая привязка велит
@samp{@kbd{C-x} \} вставлять одиночную @samp{\} в строку:
@example
"\C-x\\": "\\"
@end example

@end table

@node Условные конструкции инициализации
@subsection Условные конструкции инициализации

Readline реализует возможности, аналогичные по смыслу возможностям
условной компиляции препроцессора Си, позволяющие производить привязки
клавиш и установку переменных в результате тестов.  Вот четыре
директивы, используемые анализатором.

@table @code
@item $if
Конструкция @code{$if} позволяет производить привязки в зависимости от
режима редактирования, используемого терминала, или приложения,
использующего Readline.  Содержимое теста продолжается до конца строки;
для его ограничения не требуются никакие знаки.

@table @code
@item mode
Форма @code{mode=} директивы @code{$if} используется для проверки в
каком из режимов находится Readline: @code{emacs} или @code{vi}.  Это
может быть использовано, например, вместе с командой @samp{set keymap}
для установки привязок в наборы @code{emacs-standard} и
@code{emacs-ctlx}, только если Readline запускается в режиме
@code{emacs}.

@item term
Форма @code{term=} может использоваться для включения привязок клавиш,
уникальных для какого-либо терминала, возможно для привязки вывода
последовательности клавиш к функциональным клавишам терминала.  Слово,
стоящее справа от @samp{=}, сравнивается как с полным названием
терминала, так и с частью названия, идущей до первого @samp{-}.  Это
позволяет, например, опознавать как @code{sun}, так и @code{sun-cmd}.

@item application
Конструкция @var{application} используется для включения установок,
уникальных для какого-либо приложения.  Каждая программа, использующая
библиотеку Readline, устанавливает @var{application name}, и вы можете
проверить его.  Это может быть использовано для привязки
последовательностей клавиш к функциям, полезным в конкретной программе.
Например, следующая команда добавляет последовательность, которая
заключает в кавычки текущее или предыдущее слово в Bash:
@example
$if Bash
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
$endif
@end example
@end table

@item $endif
Эта команда, как показано в предыдущем примере, заканчивает команду
@code{$if}.

@item $else
Команды этой ветви директивы @code{$if} выполняются, если проверка
заканчивается неудачей.

@item $include
Эта директива принимает в качестве аргумента одно имя файла и считывает
из него команды и привязки клавиш.
@example
$include /etc/inputrc
@end example
@end table

@node Пример файла инициализации
@subsection Пример файла инициализации

Вот пример файла @var{inputrc}.  Он иллюстрирует привязки клавиш, присвоение
значений переменным и синтаксис условий.

@example
@page
# Этот файл управляет поведением редактирования строки ввода в
# программах, использующих библиотеку Gnu Readline.  Среди таких программ
# FTP, Bash и Gdb.
#
# Вы можете заново считать файл inputrc с помощью C-x C-r.
# Строки, начинающиеся с '#', являются комментариями.
#
# Сначала, включим все общесистемные привязки и переменные из
# /etc/Inputrc
$include /etc/Inputrc

#
# Установка различных привязок для режима emacs.

set editing-mode emacs 

$if mode=emacs

Meta-Control-h:	backward-kill-word	Текст после имени функции игнорируется

#
# Стрелки в режиме малой клавиатуры
#
#"\M-OD":        backward-char
#"\M-OC":        forward-char
#"\M-OA":        previous-history
#"\M-OB":        next-history
#
# Стрелки в режиме ANSI
#
"\M-[D":        backward-char
"\M-[C":        forward-char
"\M-[A":        previous-history
"\M-[B":        next-history
#
# Стрелки в восьмибитном режиме малой клавиатуры
#
#"\M-\C-OD":       backward-char
#"\M-\C-OC":       forward-char
#"\M-\C-OA":       previous-history
#"\M-\C-OB":       next-history
#
# Стрелки в восьмибитном режиме ANSI
#
#"\M-\C-[D":       backward-char
#"\M-\C-[C":       forward-char
#"\M-\C-[A":       previous-history
#"\M-\C-[B":       next-history

C-q: quoted-insert

$endif

# Привязки старого стиля.  Устанавливается по умолчанию.
TAB: complete

# Макрокоманды, удобные при взаимодействии с оболочкой
$if Bash
# редактирование пути
"\C-xp": "PATH=$@{PATH@}\e\C-e\C-a\ef\C-f"
# Подготовка к вводу слова в кавычках -- вставляет открывающуюся и
# закрывающуюся двойные кавычки и помещает курсор сразу за открывающей
"\C-x\"": "\"\"\C-b"
# вставляет обратную косую черту (testing backslash escapes in sequences
# and macros)  @c ???????????????
"\C-x\\": "\\"
# Заключает в кавычки текущее или предыдущее слово
"\C-xq": "\eb\"\ef\""
# Добавляет привязку для обновления строки
"\C-xr": redraw-current-line
# Редактирование переменной в текущей строке
"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
$endif

# использовать визуальный звонок, если он доступен
set bell-style visible

# не урезать знаки при чтении до 7 бит
set input-meta on

# позволяет ввод знаков iso-latin1 вместо их преобразования к
# последовательностям с Meta-префиксом
# prefix-meta sequences
set convert-meta off

# отображает знаки непосредственно с установленным восьмым битом, а не
# в виде знаков с Meta-префиксом
set output-meta on

# если существует более 150 возможных завершений слова, запросить
# пользователя, хочет ли он видеть их все
set completion-query-items 150

# Для FTP
$if Ftp
"\C-xg": "get \M-?"
"\C-xt": "put \M-?"
"\M-.": yank-last-arg
$endif
@end example

@node Привязываемые команды Readline
@section Привязываемые команды Readline

@menu
* Команды для перемещения::     Перемещение по строке.
* Команды для истории::         Вызов предыдущих строк.
* Команды для текста::          Команды для изменения текста.
* Команды для уничтожения::     Команды для уничтожения и восстановления.
* Числовые параметры::          Задание числовых параметров,
                                счетчиков повторений.
* Команды для завершения::      Readline вводит за вас.
* Клавиатурные макросы::        Сохранений и повторное выполнений
                                введенных символов.
* Разные команды::              Прочие разные команды.
@end menu

Этот раздел описывает команды Readline, которые могут быть привязаны к
последовательностям клавиш.
@ifset BashFeatures
Вы можете напечатать ваши привязки клавиш, выполнив @w{@code{bind -P}},
или, в более сжатом виде, пригодном для файла @var{inputrc},
@w{@code{bind -p}}.  (@xref{Bash Builtins}.)
@end ifset

@node Команды для перемещения
@subsection Команды для перемещения
@ftable @code
@item beginning-of-line (C-a)
Переместиться в начало текущей строки.

@item end-of-line (C-e)
Переместиться в конец строки.

@item forward-char (C-f)
Переместиться на один знак вперед.

@item backward-char (C-b)
Переместиться назад на один знак.

@item forward-word (M-f)
Переместиться вперед до конца следующего слова.  Слова составляются из
букв и цифр.

@item backward-word (M-b)
Переместиться назад к началу текущего или предыдущего слова.  Слова
составляются из букв и цифр.

@item clear-screen (C-l)
Очистить экран и перерисовать текущую строку, оставляя ее наверху
экрана.

@item redraw-current-line ()
Обновить текущую строку.  По умолчанию не привязана.

@end ftable

@node Команды для истории
@subsection Команды для манипуляции историей

@ftable @code
@item accept-line (Newline, Return)
@ifset BashFeatures
Ввод строки независимо от положения курсора.  Если строка
непуста, добавить ее к списку истории, в соответствии с установками
переменных @code{HISTCONTROL} и @code{HISTIGNORE}.  Если эта строка была
строкой истории, то восстановить строку истории до ее первоначального
состояния.
@end ifset
@ifclear BashFeatures
Ввод строки независимо от положения курсора.  Если строка
непуста, добавить ее к списку истории.  Если эта строка была
строкой истории, то восстановить строку истории до ее первоначального
состояния.
@end ifclear

@item previous-history (C-p)
Переместиться `вверх' по списку истории.

@item next-history (C-n)
Переместиться `вниз' по списку истории.

@item beginning-of-history (M-<)
Переместиться к первой строке истории.

@item end-of-history (M->)
Переместиться в конец истории ввода, то есть к строке, которая сейчас
редактируется.

@item reverse-search-history (C-r)
Обратный поиск начиная с текущей строки и перемещаясь по мере
необходимости `вверх' по истории.  Это наращиваемый поиск.

@item forward-search-history (C-s)
Прямой поиск начиная с текущей строки и перемещаясь по мере
необходимости `вниз' по истории.  Это наращиваемый поиск.

@item non-incremental-reverse-search-history (M-p)
Обратный поиск начиная с текущей строки и перемещаясь по мере
необходимости `вверх' по истории, используя ненаращиваемый поиск строки,
заданной пользователем.

@item non-incremental-forward-search-history (M-n)
Прямой поиск начиная с текущей строки и перемещаясь по мере
необходимости `вниз' по истории, используя ненаращиваемый поиск строки,
заданной пользователем.

@item history-search-forward ()
Прямой поиск в истории строки, состоящей из знаков между началом текущей
строки и точкой.  Это ненаращиваемый поиск.  По умолчанию эта команда не
привязана.

@item history-search-backward ()
Обратный поиск в истории строки, состоящей из знаков между началом
текущей строки и точкой.  Это ненаращиваемый поиск.  По умолчанию эта
команда не привязана.

@item yank-nth-arg (M-C-y)
Вставить первый аргумент предыдущей команды (обычно второе слово
предыдущей строки).  С аргументом @var{n}, вставляет @var{n}-ное слово
из предыдущей команды (слова в предыдущей команде начинаются со слова
0).  Отрицательный аргумент вставляет @var{n}-ное с конца слово
предыдущей команды.

@item yank-last-arg (M-., M-_)
Вставить последний аргумент предыдущей команды (последнее слово
предыдущего элемента истории).  С аргументом, ведет себя точно так же,
как @code{yank-nth-arg}.  Последовательные вызовы @code{yank-last-arg}
перемещают назад по списку истории, вставляя последний аргумент каждой
строки по очереди.

@end ftable

@node Команды для текста
@subsection Команды для изменения текста

@ftable @code
@item delete-char (C-d)
Удалить знак в позиции курсора.  Если курсор находится в
начале строки, в строке нет знаков и последний набранный знак не был
привязан к @code{delete-char}, возвращает @sc{eof}.

@item backward-delete-char (Rubout)
Удалить знак за курсором.  Числовой параметр предписывает
уничтожать знаки, а не удалять их.

@item forward-backward-delete-char ()
Удалить знак под курсором, если не находится в конце строки, в этом
случае удаляется знак за курсором.  По умолчанию, эта функция не
привязана к какой-либо клавише.

@item quoted-insert (C-q, C-v)
Добавить в строку следующий введенный знак, каким бы он ни был.  Таким
образом можно вставить последовательность клавиш, например @kbd{C-q}.

@ifclear BashFeatures
@item tab-insert (M-TAB)
Вставить знак табуляции.
@end ifclear

@item self-insert (a, b, A, 1, !, @dots{})
Эти знаки вставляют сами себя.

@item transpose-chars (C-t)
Переместить знак перед курсором вперед за знак под курсором, также перемещая
курсор вперед.  Если точка вставки находится в конце строки, то
переставить последние два знака в строке.  Отрицательные аргументы не
оказывают действия.

@item transpose-words (M-t)
Переместить слово перед точкой за слово после точки.  Также перемещает
точку за это слово.

@item upcase-word (M-u)
Перевести в верхний регистр текущее (или следующее) слово.  С
отрицательным аргументом, переводит в верхний регистр предыдущее
слово, но не перемещает курсор.

@item downcase-word (M-l)
Перевести в нижний регистр текущее (или следующее) слово.  С
отрицательным аргументом переводит в нижний регистр предыдущее слово, но
не перемещает курсор.

@item capitalize-word (M-c)
Перевести текущее (или предыдущее) слово в нижний регистр с первой
заглавной буквой.  С отрицательным аргументом, действует на предыдущее
слово, но не перемещает курсор.

@end ftable

@node Команды для уничтожения
@subsection Уничтожение и восстановление

@ftable @code

@item kill-line (C-k)
Уничтожить текст от точки до конца строки.

@item backward-kill-line (C-x Rubout)
Уничтожить назад до начала строки.

@item unix-line-discard (C-u)
Уничтожить назад от курсора до начала текущей строки.

@item kill-whole-line ()
Уничтожить все знаки в текущей строке, независимо от позиции точки.
По умолчанию эта функция не привязана.

@item kill-word (M-d)
Уничтожить от точки до конца текущего слова или, если курсор находится
между словами, до конца следующего слова.  Границы слова такие же, как
для @code{forward-word}.

@item backward-kill-word (M-DEL)
Уничтожить слово за точкой.  Границы слова такие же, как для
@code{backward-word}.

@item unix-word-rubout (C-w)
Уничтожает слово за точкой, используя в качестве границы
слова пробелы.  Уничтоженный текст сохраняется в кольцевом списке
уничтожений.

@item delete-horizontal-space ()
Удалить все пробелы и знаки табуляции вокруг точки.  По умолчанию эта
функция не привязана.

@item kill-region ()
Уничтожить текст в текущей области.  Эта функция по
умолчанию не привязана.

@item copy-region-as-kill ()
Копировать текст области в буфер уничтожения, так что он может быть сразу
восстановлен.  Эта команда по умолчанию не привязана.

@item copy-backward-word ()
Копировать слово перед точкой в буфер уничтожений.  Границы слова
такие же, как для @code{backward-word}.  Эта команда по умолчанию не
привязана.

@item copy-forward-word ()
Копировать слово, следующее за точкой, в буфер уничтожений.  Границы слова
такие же, как для @code{forward-word}.  Эта команда по умолчанию не
привязана.

@item yank (C-y)
Восстановить вершину кольцевого списка уничтожений в буфер в текущую
позицию курсора.

@item yank-pop (M-y)
Циклический сдвиг кольцевого списка уничтожений и восстановление новой
вершины.  Вы можете использовать эту команду, только если предыдущей
командой была @code{yank} или @code{yank-pop}.
@end ftable

@node Числовые параметры
@subsection Определение числовых параметров
@ftable @code

@item digit-argument (@kbd{M-0}, @kbd{M-1}, @dots{} @kbd{M--})
Добавить эту цифру к вводимому аргументу или начать новый
аргумент.  @kbd{M--} начинает отрицательный аргумент.

@item universal-argument ()
Это другой способ задать аргумент.  Если за этой командой следуют одна
или несколько цифр, возможно со знаком минус в начале, то они
определяют аргумент.  Если за командой следуют цифры, повторное
выполнение @code{universal-argument} заканчивает числовой аргумент, а в
противном случае он игнорируется.
В особом случае, если непосредственно за этой командой следует или
цифра, или знак минус, аргумент для следующей команды умножается на
четыре.  Изначально аргумент равен единице, так что выполнение этой
функции первый раз делает его равным четырем, второй раз --- шестнадцати,
и так далее.  По умолчанию эта функция не привязана к клавише.
@end ftable

@node Команды для завершения
@subsection Readline вводит за вас

@ftable @code
@item complete (@key{TAB})
Пытается завершить текст перед курсором.  Действие функции зависит от
приложения.  Обычно, если вы вводите имя файла, вы можете выполнить
завершение имени файла; если вы вводите команду, вы можете завершить
команду; если вводите символ для GDB, можете выполнить завершение имени
символа; если вы вводите переменную для Bash, можете завершить имя
переменной, и так далее.
@ifset BashFeatures
Bash пытается выполнить завершение, рассматривая текст по очереди как
переменную (если он начинается с @samp{$}), имя пользователя (если текст
начинается с @samp{~}), имя машины (если текст начинается с @samp{@@},
или как команду (включая синонимы и функции).  Если ни в одной из этих
попыток не находится соответствие, производится завершение имени файла.
@end ifset

@item possible-completions (M-?)
Перечислить возможные завершения текста перед курсором.

@item insert-completions (M-*)
Вставить все завершения текста перед точкой, которые были бы созданы
@code{possible-completions}.

@item menu-complete ()
Аналогично @code{complete}, но замещает завершаемое слово одним
совпадением из списка возможных завершений.  Повторяемое выполнение
@code{menu-complete} обходит список возможных завершений, вставляя
каждое совпадение по очереди.  В конце списка завершений издается
звуковой сигнал и восстанавливается исходный текст.  Аргумент @var{n}
перемещает на @var{n} позиций вперед в списке совпадений; отрицательный
аргумент может использоваться для перемещения по списку назад.  Эта
команда предназначается для привязки к @key{TAB}, но по умолчанию не
привязана.

@item delete-char-or-list ()
Удаляет знак в позиции курсора, если он не находится в начале или конце
строки (как @code{delete-char}).  Если курсор находится в конце строки,
поведение аналогично @code{possible-completions}.  Эта команда по
умолчанию не привязана.

@ifset BashFeatures
@item complete-filename (M-/)
Пытается выполнить завершение имени файла для текста до точки.

@item possible-filename-completions (C-x /)
Перечислить возможные завершения для текста до точки, рассматривая его
как имя файла.

@item complete-username (M-~)
Пытается завершить текст до точки, рассматривая его как имя
пользователя.

@item possible-username-completions (C-x ~)
Перечислить возможные завершения текста до точки, рассматривая его как
имя пользователя.

@item complete-variable (M-$)
Пытается завершить текст до точки, рассматривая его как переменную
оболочки.

@item possible-variable-completions (C-x $)
Перечислить возможные завершения текста до точки, рассматривая его как
переменную оболочки.

@item complete-hostname (M-@@)
Пытается завершить текст до точки, рассматривая его как имя машины.

@item possible-hostname-completions (C-x @@)
Перечислить возможные завершения текста до точки, рассматривая его как
имя машины.

@item complete-command (M-!)
Пытается завершить текст до точки, рассматривая его как имя команды.
Завершение команды ищет совпадение текста с синонимами,
зарезервированными словами, функциями оболочки, встроенными функциями
оболочки, и наконец с именами выполняемых файлов, в таком порядке.

@item possible-command-completions (C-x !)
Перечислить возможные завершения текста до точки, рассматривая его как
имя команды.

@item dynamic-complete-history (M-TAB)
Пытается завершить текст до точки, сравнивая его со строками из списка
истории в поиске возможных завершений.

@item complete-into-braces (M-@{)
Выполнить завершение имени файла и вставить список возможных
завершений, заключенный в скобки, так что список доступен оболочке
(@pxref{Раскрывание скобок}).

@end ifset
@end ftable

@node Клавиатурные макросы
@subsection Клавиатурные макросы
@ftable @code

@item start-kbd-macro (C-x ()
Начать сохранение вводимых знаков в текущий клавиатурный макрос.

@item end-kbd-macro (C-x ))
Прекратить сохранение вводимых знаков в текущий клавиатурный макрос и
запомнить его определение.

@item call-last-kbd-macro (C-x e)
Выполнить последний определенный клавиатурный макрос, выводя знаки
макроса так, как если бы он набирался на клавиатуре.

@end ftable

@node Разные команды
@subsection Некоторые другие команды
@ftable @code

@item re-read-init-file (C-x C-r)
Считать содержимое файла @var{inputrc} и подключить любые найденные там
привязки клавиш и присвоения переменных.

@item abort (C-g)
Прервать текущую команду редактирования и издать звук на терминале
(зависит от установки @code{bell-style}).

@item do-uppercase-version (M-a, M-b, M-@var{x}, @dots{})
Если метафицированный знак @var{x} находится в нижнем регистре,
выполнить команду, привязанную к соответствующему знаку в верхнем
регистре.

@item prefix-meta (@key{ESC})
Метафицировать следующий введенный вами знак.  Это для клавиатур, не
имеющих клавиши Meta.  Ввод @samp{@key{ESC} f} эквивалентен вводу
@kbd{M-f}.

@item undo (C-_, C-x C-u)
Наращиваемая отмена, запоминаемая отдельно для каждой строки.

@item revert-line (M-r)
Отменить все изменения, сделанные в этой строке.  Это аналогично
выполнению достаточного числа раз команды @code{undo}, чтобы вернуться в
начало.

@ifset BashFeatures
@item tilde-expand (M-&)
@end ifset
@ifclear BashFeatures
@item tilde-expand (M-~)
@end ifclear
Выполнить раскрывание знака тильды для текущего слова.

@item set-mark (C-@@)
Установить отметку в текущей точке.  Если задан числовой аргумент,
отметка устанавливается в указанной позиции.

@item exchange-point-and-mark (C-x C-x)
Поменять местами точку и отметку.  Текущая позиция курсора устанавливается
в сохраненную позицию, а старое положение курсора запоминается как отметка.

@item character-search (C-])
Считывается знак, и точка перемещается к следующему появлению этого
знака.  Отрицательный аргумент производит поиск вхождения знака в
обратном направлении.

@item character-search-backward (M-C-])
Считывается знак, и точка перемещается к предыдущему появлению этого
знака.  Отрицательный аргумент производит поиск последующих вхождений
знака.

@item insert-comment (M-#)
В начало текущей строки вставляется значение переменной
@code{comment-begin}, и эта строка вводится, как если бы был введен знак
новой строки.
@ifset BashFeatures
Значение @code{comment-begin} по умолчанию велит этой команде сделать
текущую строку комментарием оболочки.
@end ifset

@item dump-functions ()
Напечатать все функции и их привязки к клавишам в выходной поток
Readline.  Если задан числовой аргумент, вывод форматируется так, чтобы 
его можно было вставить в файл @var{inputrc}.  По умолчанию эта команда
не привязана.

@item dump-variables ()
Напечатать все устанавливаемые переменные и их значения в выходной поток
Readline.  Если задан числовой аргумент, вывод форматируется так, чтобы
его можно было вставить в файл @var{inputrc}.  Эта команда по умолчанию
не привязана.

@item dump-macros ()
Напечатать все последовательности клавиш Readline, привязанные к
макросам, и выводимые ими строки.  Если задан числовой аргумент, вывод
форматируется так, чтобы его можно было вставить в файл @var{inputrc}.
Эта команда по умолчанию не привязана.

@ifset BashFeatures
@item glob-expand-word (C-x *)
Слово перед точкой рассматривается как шаблон для расширения в имя пути,
и вставляется список имен совпадающих файлов, замещая слово.

@item glob-list-expansions (C-x g)
Отображается список расширений, которые были бы созданы
@code{glob-expand-word}, и строка перерисовывается.

@item display-shell-version (C-x C-v)
Отобразить информацию о версии текущего экземпляра Bash.

@item shell-expand-line (M-C-e)
Раскрыть строку так, как это делает оболочка.  Помимо раскрывания слов
оболочки, это производит раскрывание синонимов и
истории. (@pxref{Раскрывания оболочки}).

@item history-expand-line (M-^)
Произвести раскрывание истории в текущей строке.

@item magic-space ()
Произвести раскрывание истории в текущей строке и вставить пробел
(@pxref{Взаимодействие с историей}).

@item alias-expand-line ()
Произвести раскрывание синонимов в текущей строке. (@pxref{Синонимы}).

@item history-and-alias-expand-line ()
Произвести раскрывание истории и синонимов в текущей строке.

@item insert-last-argument (M-., M-_)
Синоним для @code{yank-last-arg}.

@item operate-and-get-next (C-o)
Ввести текущую строку для выполнения и извлечь следующую (по отношению к
текущей) строку из истории для редактирования.  Любые аргументы
игнорируются.

@item emacs-editing-mode (C-e)
Находясь в режиме @code{vi}, это производит переключение обратно в режим
редактирования @code{emacs}, так, как если бы была выполнена команда
@samp{set -o emacs}.

@end ifset

@end ftable

@node Режим vi Readline
@section Режим vi Readline

Хотя библиотека Readline не имеет полного набора функций редактирования
@code{vi}, она все же содержит достаточно для простого редактирования
строки.  Режим @code{vi} Readline функционирует так, как определено в
стандарте @sc{posix} 1003.2.

@ifset BashFeatures
Для интерактивного переключения между режимами редактирования
@code{emacs} и @code{vi}, используйте команды @samp{set -o emacs} и
@samp{set -o vi} (@pxref{Встроенная команда set}).
@end ifset
@ifclear BashFeatures
Для интерактивного переключения между режимами редактирования
@code{emacs} и @code{vi}, используйте команду @kbd{M-C-j}
(@code{toggle-editing-mode}).
@end ifclear
По умолчанию, Readline использует режим @code{emacs}.

Когда вы вводите строку в режиме @code{vi}, вы уже находитесь в режиме
`вставки', как если бы вы набрали @samp{i}.  Нажатие @key{ESC}
переключает вас в `командный' режим, в котором вы можете редактировать
текст строки стандартными клавишами перемещения @code{vi}, перемещаться
к предыдущим строкам истории посредством @samp{k} и к последующим
строкам посредством @samp{j}, и так далее.

@ifset BashFeatures
@node Programmable Completion
@section Programmable Completion
@cindex programmable completion

When word completion is attempted for an argument to a command for
which a completion specification (a @var{compspec}) has been defined
using the @code{complete} builtin (@pxref{Programmable Completion Builtins}),
the programmable completion facilities are invoked. 

First, the command name is identified.
If a compspec has been defined for that command, the
compspec is used to generate the list of possible completions for the word.
If the command word is a full pathname, a compspec for the full
pathname is searched for first.
If no compspec is found for the full pathname, an attempt is made to
find a compspec for the portion following the final slash.

Once a compspec has been found, it is used to generate the list of
matching words.
If a compspec is not found, the default Bash completion
described above (@pxref{Commands For Completion}) is performed.

First, the actions specified by the compspec are used.
Only matches which are prefixed by the word being completed are
returned.
When the @samp{-f} or @samp{-d} option is used for filename or
directory name completion, the shell variable @code{FIGNORE} is
used to filter the matches.
@xref{Bash Variables}, for a description of @code{FIGNORE}.

Any completions specified by a filename expansion pattern to the
@samp{-G} option are generated next.
The words generated by the pattern need not match the word being completed.
The @code{GLOBIGNORE} shell variable is not used to filter the matches,
but the @code{FIGNORE} shell variable is used.

Next, the string specified as the argument to the @samp{-W} option
is considered.
The string is first split using the characters in the @code{IFS}
special variable as delimiters.
Shell quoting is honored.
Each word is then expanded using
brace expansion, tilde expansion, parameter and variable expansion,
command substitution, arithmetic expansion, and pathname expansion,
as described above (@pxref{Shell Expansions}).
The results are split using the rules described above
(@pxref{Word Splitting}).
The results of the expansion are prefix-matched against the word being
completed, and the matching words become the possible completions.

After these matches have been generated, any shell function or command
specified with the @samp{-F} and @samp{-C} options is invoked.
When the command or function is invoked, the @code{COMP_LINE} and
@code{COMP_POINT} variables are assigned values as described above
(@pxref{Bash Variables}).
If a shell function is being invoked, the @code{COMP_WORDS} and
@code{COMP_CWORD} variables are also set.
When the function or command is invoked, the first argument is the
name of the command whose arguments are being completed, the
second argument is the word being completed, and the third argument
is the word preceding the word being completed on the current command line.
No filtering of the generated completions against the word being completed
is performed; the function or command has complete freedom in generating
the matches.

Any function specified with @samp{-F} is invoked first.
The function may use any of the shell facilities, including the
@code{compgen} builtin described below
(@pxref{Programmable Completion Builtins}), to generate the matches.
It must put the possible completions in the @code{COMPREPLY} array
variable.

Next, any command specified with the @samp{-C} option is invoked
in an environment equivalent to command substitution.
It should print a list of completions, one per line, to
the standard output.
Backslash may be used to escape a newline, if necessary.

After all of the possible completions are generated, any filter
specified with the @samp{-X} option is applied to the list.
The filter is a pattern as used for pathname expansion; a @samp{&}
in the pattern is replaced with the text of the word being completed.
A literal @samp{&} may be escaped with a backslash; the backslash
is removed before attempting a match.
Any completion that matches the pattern will be removed from the list.
A leading @samp{!} negates the pattern; in this case any completion
not matching the pattern will be removed.

Finally, any prefix and suffix specified with the @samp{-P} and @samp{-S}
options are added to each member of the completion list, and the result is
returned to the Readline completion code as the list of possible
completions.

If a compspec is found, whatever it generates is returned to the completion
code as the full set of possible completions.
The default Bash completions are not attempted, and the Readline
default of filename completion is disabled.

@node Programmable Completion Builtins
@section Programmable Completion Builtins
@cindex completion builtins

Two builtin commands are available to manipulate the programmable completion
facilities.

@table @code
@item compgen
@btindex compgen
@example
@code{compgen [@var{option}] [@var{word}]}
@end example

Generate possible completion matches for @var{word} according to
the @var{option}s, which may be any option accepted by the
@code{complete}
builtin with the exception of @samp{-p} and @samp{-r}, and write
the matches to the standard output.
When using the @samp{-F} or @samp{-C} options, the various shell variables
set by the programmable completion facilities, while available, will not
have useful values.

The matches will be generated in the same way as if the programmable
completion code had generated them directly from a completion specification
with the same flags.
If @var{word} is specified, only those completions matching @var{word}
will be displayed.

The return value is true unless an invalid option is supplied, or no
matches were generated.

@item complete
@btindex complete
@example
@code{complete [-abcdefjkvu] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
[-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
[-C @var{command}] @var{name} [@var{name} @dots{}]}
@code{complete -pr [@var{name} @dots{}]}
@end example

Specify how arguments to each @var{name} should be completed.
If the @samp{-p} option is supplied, or if no options are supplied, existing
completion specifications are printed in a way that allows them to be
reused as input.
The @samp{-r} option removes a completion specification for
each @var{name}, or, if no @var{name}s are supplied, all
completion specifications.

The process of applying these completion specifications when word completion
is attempted is described above (@pxref{Programmable Completion}).

Other options, if specified, have the following meanings.
The arguments to the @samp{-G}, @samp{-W}, and @samp{-X} options
(and, if necessary, the @samp{-P} and @samp{-S} options)
should be quoted to protect them from expansion before the
@code{complete} builtin is invoked.

@table @code
@item -A @var{action}
The @var{action} may be one of the following to generate a list of possible
completions:

@table @code
@item alias
Alias names.  May also be specified as @samp{-a}.

@item arrayvar
Array variable names.

@item binding
Readline key binding names (@pxref{Bindable Readline Commands}).

@item builtin
Names of shell builtin commands.  May also be specified as @samp{-b}.

@item command
Command names.  May also be specified as @samp{-c}.

@item directory
Directory names.  May also be specified as @samp{-d}.

@item disabled
Names of disabled shell builtins.

@item enabled
Names of enabled shell builtins.

@item export
Names of exported shell variables.  May also be specified as @samp{-e}.

@item file
File names.  May also be specified as @samp{-f}.

@item function
Names of shell functions.

@item helptopic
Help topics as accepted by the @code{help} builtin (@pxref{Bash Builtins}).

@item hostname
Hostnames, as taken from the file specified by the
@code{HOSTFILE} shell variable (@pxref{Bash Variables}).

@item job
Job names, if job control is active.  May also be specified as @samp{-j}.

@item keyword
Shell reserved words.  May also be specified as @samp{-k}.

@item running
Names of running jobs, if job control is active.

@item setopt
Valid arguments for the @samp{-o} option to the @code{set} builtin
(@pxref{The Set Builtin}).

@item shopt
Shell option names as accepted by the @code{shopt} builtin
(@pxref{Bash Builtins}).

@item signal
Signal names.

@item stopped
Names of stopped jobs, if job control is active.

@item user
User names.  May also be specified as @samp{-u}.

@item variable
Names of all shell variables.  May also be specified as @samp{-v}.
@end table

@item -G @var{globpat}
The filename expansion pattern @var{globpat} is expanded to generate
the possible completions.

@item -W @var{wordlist}
The @var{wordlist} is split using the characters in the
@code{IFS} special variable as delimiters, and each resultant word
is expanded.
The possible completions are the members of the resultant list which
match the word being completed.

@item -C @var{command}
@var{command} is executed in a subshell environment, and its output is
used as the possible completions.

@item -F @var{function}
The shell function @var{function} is executed in the current shell
environment.
When it finishes, the possible completions are retrieved from the value
of the @code{COMPREPLY} array variable.

@item -X @var{filterpat}
@var{filterpat} is a pattern as used for filename expansion.
It is applied to the list of possible completions generated by the
preceding options and arguments, and each completion matching
@var{filterpat} is removed from the list.
A leading @samp{!} in @var{filterpat} negates the pattern; in this
case, any completion not matching @var{filterpat} is removed.

@item -P @var{prefix}
@var{prefix} is added at the beginning of each possible completion
after all other options have been applied.

@item -S @var{suffix}
@var{suffix} is appended to each possible completion
after all other options have been applied.
@end table

The return value is true unless an invalid option is supplied, an option
other than @samp{-p} or @samp{-r} is supplied without a @var{name}
argument, an attempt is made to remove a completion specification for
a @var{name} for which no specification exists, or
an error occurs adding a completion specification.

@end table
@end ifset
